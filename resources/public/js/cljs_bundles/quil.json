{"quil/util.js":"// Compiled by ClojureScript 1.9.293 {:elide-asserts true}\ngoog.provide(\"quil.util\");\n/**\n * Function that does nothing.\n */\nquil.util.no_fn = (function quil$util$no_fn(){\nreturn null;\n});\n/**\n * Returns the val associated with key in mappings or key directly if it\n *   is one of the vals in mappings. Otherwise throws an exception.\n */\nquil.util.resolve_constant_key = (function quil$util$resolve_constant_key(key,mappings){\nif(cljs.core.truth_(cljs.core.get.call(null,mappings,key))){\nreturn cljs.core.get.call(null,mappings,key);\n} else {\nif(cljs.core.truth_(cljs.core.some.call(null,cljs.core.PersistentHashSet.fromArray([key], true),cljs.core.vals.call(null,mappings)))){\nreturn key;\n} else {\nthrow (new Error([cljs.core.str(\"Expecting a keyword, got: \"),cljs.core.str(key),cljs.core.str(\". Expected one of: \"),cljs.core.str(cljs.core.vec.call(null,cljs.core.sort.call(null,cljs.core.keys.call(null,mappings))))].join('')));\n\n}\n}\n});\n/**\n * Returns the length of the longest key of map m. Assumes m's keys are strings\n * and returns 0 if map is empty:\n * (length-of-longest-key {\"foo\" 1 \"barr\" 2 \"bazzz\" 3}) ;=> 5\n * (length-of-longest-key {}) ;=> 0\n */\nquil.util.length_of_longest_key = (function quil$util$length_of_longest_key(m){\nvar or__11101__auto__ = cljs.core.last.call(null,cljs.core.sort.call(null,cljs.core.map.call(null,(function (p1__5_SHARP_){\nreturn p1__5_SHARP_.length();\n}),cljs.core.keys.call(null,m))));\nif(cljs.core.truth_(or__11101__auto__)){\nreturn or__11101__auto__;\n} else {\nreturn (0);\n}\n});\n/**\n * Generates a padding string starting concatting s with len times pad:\n * (gen-padding \"\" 5 \"b\") ;=> \"bbbbb\"\n * May be called without starting string s in which case it defaults to the\n * empty string and also without pad in which case it defaults to a single space\n */\nquil.util.gen_padding = (function quil$util$gen_padding(var_args){\nvar args199 = [];\nvar len__13421__auto___202 = arguments.length;\nvar i__13422__auto___203 = (0);\nwhile(true){\nif((i__13422__auto___203 < len__13421__auto___202)){\nargs199.push((arguments[i__13422__auto___203]));\n\nvar G__204 = (i__13422__auto___203 + (1));\ni__13422__auto___203 = G__204;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__201 = args199.length;\nswitch (G__201) {\ncase (1):\nreturn quil.util.gen_padding.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.util.gen_padding.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.util.gen_padding.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args199.length)].join('')));\n\n}\n});\n\nquil.util.gen_padding.cljs$core$IFn$_invoke$arity$1 = (function (len){\nreturn quil.util.gen_padding.call(null,\"\",len,\" \");\n});\n\nquil.util.gen_padding.cljs$core$IFn$_invoke$arity$2 = (function (len,pad){\nreturn quil.util.gen_padding.call(null,\"\",len,pad);\n});\n\nquil.util.gen_padding.cljs$core$IFn$_invoke$arity$3 = (function (s,len,pad){\nif((len > (0))){\nreturn quil.util.gen_padding.call(null,[cljs.core.str(s),cljs.core.str(pad)].join(''),(len - (1)),pad);\n} else {\nreturn s;\n}\n});\n\nquil.util.gen_padding.cljs$lang$maxFixedArity = (3);\n\nquil.util.print_definition_list = (function quil$util$print_definition_list(definitions){\nvar longest_key = quil.util.length_of_longest_key.call(null,definitions);\nreturn cljs.core.dorun.call(null,cljs.core.map.call(null,((function (longest_key){\nreturn (function (p__210){\nvar vec__211 = p__210;\nvar k = cljs.core.nth.call(null,vec__211,(0),null);\nvar v = cljs.core.nth.call(null,vec__211,(1),null);\nvar len = k.length();\nvar diff = (longest_key - len);\nvar pad = quil.util.gen_padding.call(null,diff);\nreturn cljs.core.println.call(null,k,pad,\"- \",v);\n});})(longest_key))\n,definitions));\n});\nquil.util.clj_compilation_QMARK_ = (function quil$util$clj_compilation_QMARK_(){\nreturn false;\n});\nquil.util.prepare_quil_name = (function quil$util$prepare_quil_name(const_keyword){\nreturn clojure.string.replace.call(null,clojure.string.upper_case.call(null,cljs.core.name.call(null,const_keyword)),/-/,\"_\");\n});\nquil.util.prepare_quil_clj_constants = (function quil$util$prepare_quil_clj_constants(constants){\nreturn cljs.core.into.call(null,cljs.core.PersistentArrayMap.EMPTY,cljs.core.map.call(null,(function (p1__6_SHARP_){\nreturn (new cljs.core.PersistentVector(null,(2),(5),cljs.core.PersistentVector.EMPTY_NODE,[p1__6_SHARP_,cljs.core.symbol.call(null,[cljs.core.str(\"PConstants/\"),cljs.core.str(quil.util.prepare_quil_name.call(null,p1__6_SHARP_))].join(''))],null));\n}),constants));\n});\nquil.util.prepare_quil_cljs_constants = (function quil$util$prepare_quil_cljs_constants(constants){\nreturn cljs.core.into.call(null,cljs.core.PersistentArrayMap.EMPTY,cljs.core.map.call(null,(function (p1__7_SHARP_){\nreturn (new cljs.core.PersistentVector(null,(2),(5),cljs.core.PersistentVector.EMPTY_NODE,[p1__7_SHARP_,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"cljs.core\",\"aget\",\"cljs.core/aget\",(6345791),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"js\",\"Processing.prototype.PConstants\",\"js/Processing.prototype.PConstants\",(2034048972),null)),(function (){var x__13164__auto__ = quil.util.prepare_quil_name.call(null,p1__7_SHARP_);\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})()))],null));\n}),constants));\n});\nquil.util.make_quil_constant_map = (function quil$util$make_quil_constant_map(target,const_map_name,const_map){\nreturn cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"def\",\"def\",(597100991),null)),(function (){var x__13164__auto__ = const_map_name;\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})(),(function (){var x__13164__auto__ = ((cljs.core._EQ_.call(null,target,new cljs.core.Keyword(null,\"clj\",\"clj\",(-660495428))))?quil.util.prepare_quil_clj_constants.call(null,const_map):quil.util.prepare_quil_cljs_constants.call(null,const_map));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})()));\n});\nquil.util.generate_quil_constants = (function quil$util$generate_quil_constants(var_args){\nvar args__13423__auto__ = [];\nvar len__13421__auto___218 = arguments.length;\nvar i__13422__auto___219 = (0);\nwhile(true){\nif((i__13422__auto___219 < len__13421__auto___218)){\nargs__13423__auto__.push((arguments[i__13422__auto___219]));\n\nvar G__220 = (i__13422__auto___219 + (1));\ni__13422__auto___219 = G__220;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__13424__auto__ = ((((3) < args__13423__auto__.length))?(new cljs.core.IndexedSeq(args__13423__auto__.slice((3)),(0),null)):null);\nreturn quil.util.generate_quil_constants.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__13424__auto__);\n});\n\nquil.util.generate_quil_constants.cljs$core$IFn$_invoke$arity$variadic = (function (_AMPERSAND_form,_AMPERSAND_env,target,opts){\nreturn cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"do\",\"do\",(1686842252),null)),cljs.core.map.call(null,(function (p1__8_SHARP_){\nreturn quil.util.make_quil_constant_map.call(null,target,cljs.core.first.call(null,p1__8_SHARP_),cljs.core.second.call(null,p1__8_SHARP_));\n}),cljs.core.partition.call(null,(2),opts))));\n});\n\nquil.util.generate_quil_constants.cljs$lang$maxFixedArity = (3);\n\nquil.util.generate_quil_constants.cljs$lang$applyTo = (function (seq214){\nvar G__215 = cljs.core.first.call(null,seq214);\nvar seq214__$1 = cljs.core.next.call(null,seq214);\nvar G__216 = cljs.core.first.call(null,seq214__$1);\nvar seq214__$2 = cljs.core.next.call(null,seq214__$1);\nvar G__217 = cljs.core.first.call(null,seq214__$2);\nvar seq214__$3 = cljs.core.next.call(null,seq214__$2);\nreturn quil.util.generate_quil_constants.cljs$core$IFn$_invoke$arity$variadic(G__215,G__216,G__217,seq214__$3);\n});\n\n\nquil.util.generate_quil_constants.cljs$lang$macro = true;\n","clojure/string.cache.json":"[\"^ \",\"~:rename-macros\",[\"^ \"],\"~:renames\",[\"^ \"],\"~:use-macros\",[\"^ \"],\"~:excludes\",[\"~#set\",[\"~$reverse\",\"~$replace\"]],\"~:name\",\"~$clojure.string\",\"~:imports\",[\"^ \",\"~$StringBuffer\",\"~$goog.string.StringBuffer\"],\"~:requires\",[\"^ \",\"~$gstring\",\"~$goog.string\",\"^>\",\"^>\",\"^:\",\"^;\"],\"~:uses\",null,\"~:defs\",[\"^ \",\"~$ends-with?\",[\"^ \",\"~:protocol-inline\",null,\"~:meta\",[\"^ \",\"~:file\",\"/Users/MattPro/Dropbox/Sites/planck/planck-cljs/out/clojure/string.cljs\",\"~:line\",250,\"~:column\",16,\"~:end-line\",250,\"~:end-column\",26,\"~:tag\",\"~$boolean\",\"~:arglists\",[\"~#list\",[\"~$quote\",[\"^L\",[[\"~$s\",\"~$substr\"]]]]],\"~:doc\",\"True if s ends with substr.\"],\"^7\",\"~$clojure.string/ends-with?\",\"~:variadic\",false,\"^D\",\"out/clojure/string.cljs\",\"^H\",26,\"~:method-params\",[\"^L\",[[\"~$s\",\"^N\"]]],\"~:protocol-impl\",null,\"~:arglists-meta\",[\"^L\",[null,null]],\"^F\",1,\"^E\",250,\"~:ret-tag\",\"^J\",\"^G\",250,\"~:max-fixed-arity\",2,\"^I\",\"^J\",\"~:fn-var\",true,\"^K\",[\"^L\",[\"^M\",[\"^L\",[[\"~$s\",\"^N\"]]]]],\"^O\",\"True if s ends with substr.\"],\"~$seq-reverse\",[\"^ \",\"^B\",null,\"^C\",[\"^ \",\"^D\",\"/Users/MattPro/Dropbox/Sites/planck/planck-cljs/out/clojure/string.cljs\",\"^E\",14,\"^F\",8,\"^G\",14,\"^H\",19,\"~:private\",true,\"^K\",[\"^L\",[\"^M\",[\"^L\",[[\"~$coll\"]]]]]],\"^Y\",true,\"^7\",\"~$clojure.string/seq-reverse\",\"^Q\",false,\"^D\",\"out/clojure/string.cljs\",\"^H\",19,\"^R\",[\"^L\",[[\"^Z\"]]],\"^S\",null,\"^T\",[\"^L\",[null,null]],\"^F\",1,\"^E\",14,\"^G\",14,\"^V\",1,\"^W\",true,\"^K\",[\"^L\",[\"^M\",[\"^L\",[[\"^Z\"]]]]]],\"~$replace-with\",[\"^ \",\"^B\",null,\"^C\",[\"^ \",\"^D\",\"/Users/MattPro/Dropbox/Sites/planck/planck-cljs/out/clojure/string.cljs\",\"^E\",31,\"^F\",8,\"^G\",31,\"^H\",20,\"^Y\",true,\"^K\",[\"^L\",[\"^M\",[\"^L\",[[\"~$f\"]]]]]],\"^Y\",true,\"^7\",\"~$clojure.string/replace-with\",\"^Q\",false,\"^D\",\"out/clojure/string.cljs\",\"^H\",20,\"^R\",[\"^L\",[[\"~$f\"]]],\"^S\",null,\"^T\",[\"^L\",[null,null]],\"^F\",1,\"^E\",31,\"^G\",31,\"^V\",1,\"^W\",true,\"^K\",[\"^L\",[\"^M\",[\"^L\",[[\"~$f\"]]]]]],\"~$capitalize\",[\"^ \",\"^B\",null,\"^C\",[\"^ \",\"^D\",\"/Users/MattPro/Dropbox/Sites/planck/planck-cljs/out/clojure/string.cljs\",\"^E\",95,\"^F\",7,\"^G\",95,\"^H\",17,\"^K\",[\"^L\",[\"^M\",[\"^L\",[[\"~$s\"]]]]],\"^O\",\"Converts first character of the string to upper-case, all other\\n  characters to lower-case.\"],\"^7\",\"~$clojure.string/capitalize\",\"^Q\",false,\"^D\",\"out/clojure/string.cljs\",\"^H\",17,\"^R\",[\"^L\",[[\"~$s\"]]],\"^S\",null,\"^T\",[\"^L\",[null,null]],\"^F\",1,\"^E\",95,\"^G\",95,\"^V\",1,\"^W\",true,\"^K\",[\"^L\",[\"^M\",[\"^L\",[[\"~$s\"]]]]],\"^O\",\"Converts first character of the string to upper-case, all other\\n  characters to lower-case.\"],\"^5\",[\"^ \",\"^B\",null,\"^C\",[\"^ \",\"^D\",\"/Users/MattPro/Dropbox/Sites/planck/planck-cljs/out/clojure/string.cljs\",\"^E\",21,\"^F\",7,\"^G\",21,\"^H\",14,\"^K\",[\"^L\",[\"^M\",[\"^L\",[[\"~$s\"]]]]],\"^O\",\"Returns s with its characters reversed.\"],\"^7\",\"~$clojure.string/reverse\",\"^Q\",false,\"^D\",\"out/clojure/string.cljs\",\"^H\",14,\"^R\",[\"^L\",[[\"~$s\"]]],\"^S\",null,\"^T\",[\"^L\",[null,null]],\"^F\",1,\"^E\",21,\"^G\",21,\"^V\",1,\"^W\",true,\"^K\",[\"^L\",[\"^M\",[\"^L\",[[\"~$s\"]]]]],\"^O\",\"Returns s with its characters reversed.\"],\"~$join\",[\"^ \",\"^B\",null,\"^C\",[\"^ \",\"^D\",\"/Users/MattPro/Dropbox/Sites/planck/planck-cljs/out/clojure/string.cljs\",\"^E\",66,\"^F\",7,\"^G\",66,\"^H\",11,\"^K\",[\"^L\",[\"^M\",[\"^L\",[[\"^Z\"],[\"~$separator\",\"^Z\"]]]]],\"^O\",\"Returns a string of all elements in coll, as returned by (seq coll),\\n  separated by an optional separator.\",\"~:top-fn\",[\"^ \",\"^Q\",false,\"^V\",2,\"^R\",[\"^L\",[[\"^Z\"],[\"^16\",\"^Z\"]]],\"^K\",[\"^L\",[[\"^Z\"],[\"^16\",\"^Z\"]]],\"^T\",[\"^L\",[null,null]]]],\"^7\",\"~$clojure.string/join\",\"^Q\",false,\"^D\",\"out/clojure/string.cljs\",\"^H\",11,\"^17\",[\"^ \",\"^Q\",false,\"^V\",2,\"^R\",[\"^L\",[[\"^Z\"],[\"^16\",\"^Z\"]]],\"^K\",[\"^L\",[[\"^Z\"],[\"^16\",\"^Z\"]]],\"^T\",[\"^L\",[null,null]]],\"^R\",[\"^L\",[[\"^Z\"],[\"^16\",\"^Z\"]]],\"^S\",null,\"^T\",[\"^L\",[null,null]],\"^F\",1,\"^E\",66,\"^G\",66,\"^V\",2,\"^W\",true,\"^K\",[\"^L\",[[\"^Z\"],[\"^16\",\"^Z\"]]],\"^O\",\"Returns a string of all elements in coll, as returned by (seq coll),\\n  separated by an optional separator.\"],\"~$replace-first\",[\"^ \",\"^B\",null,\"^C\",[\"^ \",\"^D\",\"/Users/MattPro/Dropbox/Sites/planck/planck-cljs/out/clojure/string.cljs\",\"^E\",57,\"^F\",7,\"^G\",57,\"^H\",20,\"^K\",[\"^L\",[\"^M\",[\"^L\",[[\"~$s\",\"~$match\",\"~$replacement\"]]]]],\"^O\",\"Replaces the first instance of match with replacement in s.\\n   match/replacement can be:\\n\\n   string / string\\n   pattern / (string or function of match).\"],\"^7\",\"~$clojure.string/replace-first\",\"^Q\",false,\"^D\",\"out/clojure/string.cljs\",\"^H\",20,\"^R\",[\"^L\",[[\"~$s\",\"^1:\",\"^1;\"]]],\"^S\",null,\"^T\",[\"^L\",[null,null]],\"^F\",1,\"^E\",57,\"^G\",57,\"^V\",3,\"^W\",true,\"^K\",[\"^L\",[\"^M\",[\"^L\",[[\"~$s\",\"^1:\",\"^1;\"]]]]],\"^O\",\"Replaces the first instance of match with replacement in s.\\n   match/replacement can be:\\n\\n   string / string\\n   pattern / (string or function of match).\"],\"~$starts-with?\",[\"^ \",\"^B\",null,\"^C\",[\"^ \",\"^D\",\"/Users/MattPro/Dropbox/Sites/planck/planck-cljs/out/clojure/string.cljs\",\"^E\",245,\"^F\",16,\"^G\",245,\"^H\",28,\"^I\",\"^J\",\"^K\",[\"^L\",[\"^M\",[\"^L\",[[\"~$s\",\"^N\"]]]]],\"^O\",\"True if s starts with substr.\"],\"^7\",\"~$clojure.string/starts-with?\",\"^Q\",false,\"^D\",\"out/clojure/string.cljs\",\"^H\",28,\"^R\",[\"^L\",[[\"~$s\",\"^N\"]]],\"^S\",null,\"^T\",[\"^L\",[null,null]],\"^F\",1,\"^E\",245,\"^U\",\"^J\",\"^G\",245,\"^V\",2,\"^I\",\"^J\",\"^W\",true,\"^K\",[\"^L\",[\"^M\",[\"^L\",[[\"~$s\",\"^N\"]]]]],\"^O\",\"True if s starts with substr.\"],\"~$escape\",[\"^ \",\"^B\",null,\"^C\",[\"^ \",\"^D\",\"/Users/MattPro/Dropbox/Sites/planck/planck-cljs/out/clojure/string.cljs\",\"^E\",198,\"^F\",7,\"^G\",198,\"^H\",13,\"^K\",[\"^L\",[\"^M\",[\"^L\",[[\"~$s\",\"~$cmap\"]]]]],\"^O\",\"Return a new string, using cmap to escape each character ch\\n   from s as follows:\\n\\n   If (cmap ch) is nil, append ch to the new string.\\n   If (cmap ch) is non-nil, append (str (cmap ch)) instead.\"],\"^7\",\"~$clojure.string/escape\",\"^Q\",false,\"^D\",\"out/clojure/string.cljs\",\"^H\",13,\"^R\",[\"^L\",[[\"~$s\",\"^1@\"]]],\"^S\",null,\"^T\",[\"^L\",[null,null]],\"^F\",1,\"^E\",198,\"^G\",198,\"^V\",2,\"^W\",true,\"^K\",[\"^L\",[\"^M\",[\"^L\",[[\"~$s\",\"^1@\"]]]]],\"^O\",\"Return a new string, using cmap to escape each character ch\\n   from s as follows:\\n\\n   If (cmap ch) is nil, append ch to the new string.\\n   If (cmap ch) is non-nil, append (str (cmap ch)) instead.\"],\"~$replace-all\",[\"^ \",\"^B\",null,\"^C\",[\"^ \",\"^D\",\"/Users/MattPro/Dropbox/Sites/planck/planck-cljs/out/clojure/string.cljs\",\"^E\",27,\"^F\",8,\"^G\",27,\"^H\",19,\"^Y\",true,\"^K\",[\"^L\",[\"^M\",[\"^L\",[[\"~$s\",\"~$re\",\"^1;\"]]]]]],\"^Y\",true,\"^7\",\"~$clojure.string/replace-all\",\"^Q\",false,\"^D\",\"out/clojure/string.cljs\",\"^H\",19,\"^R\",[\"^L\",[[\"~$s\",\"^1C\",\"^1;\"]]],\"^S\",null,\"^T\",[\"^L\",[null,null]],\"^F\",1,\"^E\",27,\"^G\",27,\"^V\",3,\"^W\",true,\"^K\",[\"^L\",[\"^M\",[\"^L\",[[\"~$s\",\"^1C\",\"^1;\"]]]]]],\"~$discard-trailing-if-needed\",[\"^ \",\"^B\",null,\"^C\",[\"^ \",\"^D\",\"/Users/MattPro/Dropbox/Sites/planck/planck-cljs/out/clojure/string.cljs\",\"^E\",120,\"^F\",8,\"^G\",120,\"^H\",34,\"^Y\",true,\"^K\",[\"^L\",[\"^M\",[\"^L\",[[\"~$limit\",\"~$v\"]]]]]],\"^Y\",true,\"^7\",\"~$clojure.string/discard-trailing-if-needed\",\"^Q\",false,\"^D\",\"out/clojure/string.cljs\",\"^H\",34,\"^R\",[\"^L\",[[\"^1F\",\"~$v\"]]],\"^S\",null,\"^T\",[\"^L\",[null,null]],\"^F\",1,\"^E\",120,\"^G\",120,\"^V\",2,\"^W\",true,\"^K\",[\"^L\",[\"^M\",[\"^L\",[[\"^1F\",\"~$v\"]]]]]],\"~$last-index-of\",[\"^ \",\"^B\",null,\"^C\",[\"^ \",\"^D\",\"/Users/MattPro/Dropbox/Sites/planck/planck-cljs/out/clojure/string.cljs\",\"^E\",231,\"^F\",7,\"^G\",231,\"^H\",20,\"^K\",[\"^L\",[\"^M\",[\"^L\",[[\"~$s\",\"~$value\"],[\"~$s\",\"^1I\",\"~$from-index\"]]]]],\"^O\",\"Return last index of value (string or char) in s, optionally\\n  searching backward from from-index or nil if not found.\",\"^17\",[\"^ \",\"^Q\",false,\"^V\",3,\"^R\",[\"^L\",[[\"~$s\",\"^1I\"],[\"~$s\",\"^1I\",\"^1J\"]]],\"^K\",[\"^L\",[[\"~$s\",\"^1I\"],[\"~$s\",\"^1I\",\"^1J\"]]],\"^T\",[\"^L\",[null,null]]]],\"^7\",\"~$clojure.string/last-index-of\",\"^Q\",false,\"^D\",\"out/clojure/string.cljs\",\"^H\",20,\"^17\",[\"^ \",\"^Q\",false,\"^V\",3,\"^R\",[\"^L\",[[\"~$s\",\"^1I\"],[\"~$s\",\"^1I\",\"^1J\"]]],\"^K\",[\"^L\",[[\"~$s\",\"^1I\"],[\"~$s\",\"^1I\",\"^1J\"]]],\"^T\",[\"^L\",[null,null]]],\"^R\",[\"^L\",[[\"~$s\",\"^1I\"],[\"~$s\",\"^1I\",\"^1J\"]]],\"^S\",null,\"^T\",[\"^L\",[null,null]],\"^F\",1,\"^E\",231,\"^G\",231,\"^V\",3,\"^W\",true,\"^K\",[\"^L\",[[\"~$s\",\"^1I\"],[\"~$s\",\"^1I\",\"^1J\"]]],\"^O\",\"Return last index of value (string or char) in s, optionally\\n  searching backward from from-index or nil if not found.\"],\"~$pop-last-while-empty\",[\"^ \",\"^B\",null,\"^C\",[\"^ \",\"^D\",\"/Users/MattPro/Dropbox/Sites/planck/planck-cljs/out/clojure/string.cljs\",\"^E\",113,\"^F\",8,\"^G\",113,\"^H\",28,\"^Y\",true,\"^K\",[\"^L\",[\"^M\",[\"^L\",[[\"~$v\"]]]]]],\"^Y\",true,\"^7\",\"~$clojure.string/pop-last-while-empty\",\"^Q\",false,\"^D\",\"out/clojure/string.cljs\",\"^H\",28,\"^R\",[\"^L\",[[\"~$v\"]]],\"^S\",null,\"^T\",[\"^L\",[null,null]],\"^F\",1,\"^E\",113,\"^G\",113,\"^V\",1,\"^W\",true,\"^K\",[\"^L\",[\"^M\",[\"^L\",[[\"~$v\"]]]]]],\"~$includes?\",[\"^ \",\"^B\",null,\"^C\",[\"^ \",\"^D\",\"/Users/MattPro/Dropbox/Sites/planck/planck-cljs/out/clojure/string.cljs\",\"^E\",255,\"^F\",16,\"^G\",255,\"^H\",25,\"^I\",\"^J\",\"^K\",[\"^L\",[\"^M\",[\"^L\",[[\"~$s\",\"^N\"]]]]],\"^O\",\"True if s includes substr.\"],\"^7\",\"~$clojure.string/includes?\",\"^Q\",false,\"^D\",\"out/clojure/string.cljs\",\"^H\",25,\"^R\",[\"^L\",[[\"~$s\",\"^N\"]]],\"^S\",null,\"^T\",[\"^L\",[null,null]],\"^F\",1,\"^E\",255,\"^U\",\"^J\",\"^G\",255,\"^V\",2,\"^I\",\"^J\",\"^W\",true,\"^K\",[\"^L\",[\"^M\",[\"^L\",[[\"~$s\",\"^N\"]]]]],\"^O\",\"True if s includes substr.\"],\"^6\",[\"^ \",\"^B\",null,\"^C\",[\"^ \",\"^D\",\"/Users/MattPro/Dropbox/Sites/planck/planck-cljs/out/clojure/string.cljs\",\"^E\",39,\"^F\",7,\"^G\",39,\"^H\",14,\"^K\",[\"^L\",[\"^M\",[\"^L\",[[\"~$s\",\"^1:\",\"^1;\"]]]]],\"^O\",\"Replaces all instance of match with replacement in s.\\n   match/replacement can be:\\n\\n   string / string\\n   pattern / (string or function of match).\"],\"^7\",\"~$clojure.string/replace\",\"^Q\",false,\"^D\",\"out/clojure/string.cljs\",\"^H\",14,\"^R\",[\"^L\",[[\"~$s\",\"^1:\",\"^1;\"]]],\"^S\",null,\"^T\",[\"^L\",[null,null]],\"^F\",1,\"^E\",39,\"^G\",39,\"^V\",3,\"^W\",true,\"^K\",[\"^L\",[\"^M\",[\"^L\",[[\"~$s\",\"^1:\",\"^1;\"]]]]],\"^O\",\"Replaces all instance of match with replacement in s.\\n   match/replacement can be:\\n\\n   string / string\\n   pattern / (string or function of match).\"],\"~$split-lines\",[\"^ \",\"^B\",null,\"^C\",[\"^ \",\"^D\",\"/Users/MattPro/Dropbox/Sites/planck/planck-cljs/out/clojure/string.cljs\",\"^E\",160,\"^F\",7,\"^G\",160,\"^H\",18,\"^K\",[\"^L\",[\"^M\",[\"^L\",[[\"~$s\"]]]]],\"^O\",\"Splits s on \\n or \\r\\n.\"],\"^7\",\"~$clojure.string/split-lines\",\"^Q\",false,\"^D\",\"out/clojure/string.cljs\",\"^H\",18,\"^R\",[\"^L\",[[\"~$s\"]]],\"^S\",null,\"^T\",[\"^L\",[null,null]],\"^F\",1,\"^E\",160,\"^G\",160,\"^V\",1,\"^W\",true,\"^K\",[\"^L\",[\"^M\",[\"^L\",[[\"~$s\"]]]]],\"^O\",\"Splits s on \\n or \\r\\n.\"],\"~$lower-case\",[\"^ \",\"^B\",null,\"^C\",[\"^ \",\"^D\",\"/Users/MattPro/Dropbox/Sites/planck/planck-cljs/out/clojure/string.cljs\",\"^E\",90,\"^F\",7,\"^G\",90,\"^H\",17,\"^K\",[\"^L\",[\"^M\",[\"^L\",[[\"~$s\"]]]]],\"^O\",\"Converts string to all lower-case.\"],\"^7\",\"~$clojure.string/lower-case\",\"^Q\",false,\"^D\",\"out/clojure/string.cljs\",\"^H\",17,\"^R\",[\"^L\",[[\"~$s\"]]],\"^S\",null,\"^T\",[\"^L\",[null,null]],\"^F\",1,\"^E\",90,\"^G\",90,\"^V\",1,\"^W\",true,\"^K\",[\"^L\",[\"^M\",[\"^L\",[[\"~$s\"]]]]],\"^O\",\"Converts string to all lower-case.\"],\"~$trim-newline\",[\"^ \",\"^B\",null,\"^C\",[\"^ \",\"^D\",\"/Users/MattPro/Dropbox/Sites/planck/planck-cljs/out/clojure/string.cljs\",\"^E\",180,\"^F\",7,\"^G\",180,\"^H\",19,\"^K\",[\"^L\",[\"^M\",[\"^L\",[[\"~$s\"]]]]],\"^O\",\"Removes all trailing newline \\\\n or return \\\\r characters from\\n  string.  Similar to Perl's chomp.\"],\"^7\",\"~$clojure.string/trim-newline\",\"^Q\",false,\"^D\",\"out/clojure/string.cljs\",\"^H\",19,\"^R\",[\"^L\",[[\"~$s\"]]],\"^S\",null,\"^T\",[\"^L\",[null,null]],\"^F\",1,\"^E\",180,\"^G\",180,\"^V\",1,\"^W\",true,\"^K\",[\"^L\",[\"^M\",[\"^L\",[[\"~$s\"]]]]],\"^O\",\"Removes all trailing newline \\\\n or return \\\\r characters from\\n  string.  Similar to Perl's chomp.\"],\"~$upper-case\",[\"^ \",\"^B\",null,\"^C\",[\"^ \",\"^D\",\"/Users/MattPro/Dropbox/Sites/planck/planck-cljs/out/clojure/string.cljs\",\"^E\",85,\"^F\",7,\"^G\",85,\"^H\",17,\"^K\",[\"^L\",[\"^M\",[\"^L\",[[\"~$s\"]]]]],\"^O\",\"Converts string to all upper-case.\"],\"^7\",\"~$clojure.string/upper-case\",\"^Q\",false,\"^D\",\"out/clojure/string.cljs\",\"^H\",17,\"^R\",[\"^L\",[[\"~$s\"]]],\"^S\",null,\"^T\",[\"^L\",[null,null]],\"^F\",1,\"^E\",85,\"^G\",85,\"^V\",1,\"^W\",true,\"^K\",[\"^L\",[\"^M\",[\"^L\",[[\"~$s\"]]]]],\"^O\",\"Converts string to all upper-case.\"],\"~$split\",[\"^ \",\"^B\",null,\"^C\",[\"^ \",\"^D\",\"/Users/MattPro/Dropbox/Sites/planck/planck-cljs/out/clojure/string.cljs\",\"^E\",136,\"^F\",7,\"^G\",136,\"^H\",12,\"^K\",[\"^L\",[\"^M\",[\"^L\",[[\"~$s\",\"^1C\"],[\"~$s\",\"^1C\",\"^1F\"]]]]],\"^O\",\"Splits string on a regular expression. Optional argument limit is\\n  the maximum number of splits. Not lazy. Returns vector of the splits.\",\"^17\",[\"^ \",\"^Q\",false,\"^V\",3,\"^R\",[\"^L\",[[\"~$s\",\"^1C\"],[\"~$s\",\"^1C\",\"^1F\"]]],\"^K\",[\"^L\",[[\"~$s\",\"^1C\"],[\"~$s\",\"^1C\",\"^1F\"]]],\"^T\",[\"^L\",[null,null]]]],\"^7\",\"~$clojure.string/split\",\"^Q\",false,\"^D\",\"out/clojure/string.cljs\",\"^H\",12,\"^17\",[\"^ \",\"^Q\",false,\"^V\",3,\"^R\",[\"^L\",[[\"~$s\",\"^1C\"],[\"~$s\",\"^1C\",\"^1F\"]]],\"^K\",[\"^L\",[[\"~$s\",\"^1C\"],[\"~$s\",\"^1C\",\"^1F\"]]],\"^T\",[\"^L\",[null,null]]],\"^R\",[\"^L\",[[\"~$s\",\"^1C\"],[\"~$s\",\"^1C\",\"^1F\"]]],\"^S\",null,\"^T\",[\"^L\",[null,null]],\"^F\",1,\"^E\",136,\"^G\",136,\"^V\",3,\"^W\",true,\"^K\",[\"^L\",[[\"~$s\",\"^1C\"],[\"~$s\",\"^1C\",\"^1F\"]]],\"^O\",\"Splits string on a regular expression. Optional argument limit is\\n  the maximum number of splits. Not lazy. Returns vector of the splits.\"],\"~$trimr\",[\"^ \",\"^B\",null,\"^C\",[\"^ \",\"^D\",\"/Users/MattPro/Dropbox/Sites/planck/planck-cljs/out/clojure/string.cljs\",\"^E\",175,\"^F\",7,\"^G\",175,\"^H\",12,\"^K\",[\"^L\",[\"^M\",[\"^L\",[[\"~$s\"]]]]],\"^O\",\"Removes whitespace from the right side of string.\"],\"^7\",\"~$clojure.string/trimr\",\"^Q\",false,\"^D\",\"out/clojure/string.cljs\",\"^H\",12,\"^R\",[\"^L\",[[\"~$s\"]]],\"^S\",null,\"^T\",[\"^L\",[null,null]],\"^F\",1,\"^E\",175,\"^G\",175,\"^V\",1,\"^W\",true,\"^K\",[\"^L\",[\"^M\",[\"^L\",[[\"~$s\"]]]]],\"^O\",\"Removes whitespace from the right side of string.\"],\"~$index-of\",[\"^ \",\"^B\",null,\"^C\",[\"^ \",\"^D\",\"/Users/MattPro/Dropbox/Sites/planck/planck-cljs/out/clojure/string.cljs\",\"^E\",217,\"^F\",7,\"^G\",217,\"^H\",15,\"^K\",[\"^L\",[\"^M\",[\"^L\",[[\"~$s\",\"^1I\"],[\"~$s\",\"^1I\",\"^1J\"]]]]],\"^O\",\"Return index of value (string or char) in s, optionally searching\\n  forward from from-index or nil if not found.\",\"^17\",[\"^ \",\"^Q\",false,\"^V\",3,\"^R\",[\"^L\",[[\"~$s\",\"^1I\"],[\"~$s\",\"^1I\",\"^1J\"]]],\"^K\",[\"^L\",[[\"~$s\",\"^1I\"],[\"~$s\",\"^1I\",\"^1J\"]]],\"^T\",[\"^L\",[null,null]]]],\"^7\",\"~$clojure.string/index-of\",\"^Q\",false,\"^D\",\"out/clojure/string.cljs\",\"^H\",15,\"^17\",[\"^ \",\"^Q\",false,\"^V\",3,\"^R\",[\"^L\",[[\"~$s\",\"^1I\"],[\"~$s\",\"^1I\",\"^1J\"]]],\"^K\",[\"^L\",[[\"~$s\",\"^1I\"],[\"~$s\",\"^1I\",\"^1J\"]]],\"^T\",[\"^L\",[null,null]]],\"^R\",[\"^L\",[[\"~$s\",\"^1I\"],[\"~$s\",\"^1I\",\"^1J\"]]],\"^S\",null,\"^T\",[\"^L\",[null,null]],\"^F\",1,\"^E\",217,\"^G\",217,\"^V\",3,\"^W\",true,\"^K\",[\"^L\",[[\"~$s\",\"^1I\"],[\"~$s\",\"^1I\",\"^1J\"]]],\"^O\",\"Return index of value (string or char) in s, optionally searching\\n  forward from from-index or nil if not found.\"],\"~$trim\",[\"^ \",\"^B\",null,\"^C\",[\"^ \",\"^D\",\"/Users/MattPro/Dropbox/Sites/planck/planck-cljs/out/clojure/string.cljs\",\"^E\",165,\"^F\",7,\"^G\",165,\"^H\",11,\"^K\",[\"^L\",[\"^M\",[\"^L\",[[\"~$s\"]]]]],\"^O\",\"Removes whitespace from both ends of string.\"],\"^7\",\"~$clojure.string/trim\",\"^Q\",false,\"^D\",\"out/clojure/string.cljs\",\"^H\",11,\"^R\",[\"^L\",[[\"~$s\"]]],\"^S\",null,\"^T\",[\"^L\",[null,null]],\"^F\",1,\"^E\",165,\"^G\",165,\"^V\",1,\"^W\",true,\"^K\",[\"^L\",[\"^M\",[\"^L\",[[\"~$s\"]]]]],\"^O\",\"Removes whitespace from both ends of string.\"],\"~$triml\",[\"^ \",\"^B\",null,\"^C\",[\"^ \",\"^D\",\"/Users/MattPro/Dropbox/Sites/planck/planck-cljs/out/clojure/string.cljs\",\"^E\",170,\"^F\",7,\"^G\",170,\"^H\",12,\"^K\",[\"^L\",[\"^M\",[\"^L\",[[\"~$s\"]]]]],\"^O\",\"Removes whitespace from the left side of string.\"],\"^7\",\"~$clojure.string/triml\",\"^Q\",false,\"^D\",\"out/clojure/string.cljs\",\"^H\",12,\"^R\",[\"^L\",[[\"~$s\"]]],\"^S\",null,\"^T\",[\"^L\",[null,null]],\"^F\",1,\"^E\",170,\"^G\",170,\"^V\",1,\"^W\",true,\"^K\",[\"^L\",[\"^M\",[\"^L\",[[\"~$s\"]]]]],\"^O\",\"Removes whitespace from the left side of string.\"],\"~$blank?\",[\"^ \",\"^B\",null,\"^C\",[\"^ \",\"^D\",\"/Users/MattPro/Dropbox/Sites/planck/planck-cljs/out/clojure/string.cljs\",\"^E\",193,\"^F\",16,\"^G\",193,\"^H\",22,\"^I\",\"^J\",\"^K\",[\"^L\",[\"^M\",[\"^L\",[[\"~$s\"]]]]],\"^O\",\"True is s is nil, empty, or contains only whitespace.\"],\"^7\",\"~$clojure.string/blank?\",\"^Q\",false,\"^D\",\"out/clojure/string.cljs\",\"^H\",22,\"^R\",[\"^L\",[[\"~$s\"]]],\"^S\",null,\"^T\",[\"^L\",[null,null]],\"^F\",1,\"^E\",193,\"^U\",\"^J\",\"^G\",193,\"^V\",1,\"^I\",\"^J\",\"^W\",true,\"^K\",[\"^L\",[\"^M\",[\"^L\",[[\"~$s\"]]]]],\"^O\",\"True is s is nil, empty, or contains only whitespace.\"],\"~$re-surrogate-pair\",[\"^ \",\"^7\",\"~$clojure.string/re-surrogate-pair\",\"^D\",\"out/clojure/string.cljs\",\"^E\",18,\"^F\",1,\"^G\",18,\"^H\",33,\"^Y\",true,\"^C\",[\"^ \",\"^D\",\"/Users/MattPro/Dropbox/Sites/planck/planck-cljs/out/clojure/string.cljs\",\"^E\",18,\"^F\",16,\"^G\",18,\"^H\",33,\"^Y\",true]],\"~$split-with-empty-regex\",[\"^ \",\"^B\",null,\"^C\",[\"^ \",\"^D\",\"/Users/MattPro/Dropbox/Sites/planck/planck-cljs/out/clojure/string.cljs\",\"^E\",126,\"^F\",8,\"^G\",126,\"^H\",30,\"^Y\",true,\"^K\",[\"^L\",[\"^M\",[\"^L\",[[\"~$s\",\"^1F\"]]]]]],\"^Y\",true,\"^7\",\"~$clojure.string/split-with-empty-regex\",\"^Q\",false,\"^D\",\"out/clojure/string.cljs\",\"^H\",30,\"^R\",[\"^L\",[[\"~$s\",\"^1F\"]]],\"^S\",null,\"^T\",[\"^L\",[null,null]],\"^F\",1,\"^E\",126,\"^G\",126,\"^V\",2,\"^W\",true,\"^K\",[\"^L\",[\"^M\",[\"^L\",[[\"~$s\",\"^1F\"]]]]]]],\"~:require-macros\",null,\"~:cljs.analyzer/constants\",[\"^ \",\"~:seen\",[\"^4\",[\"~:else\"]],\"~:order\",[\"^2@\"]],\"^O\",null]","quil/util$macros.js":"// Compiled by ClojureScript 1.9.293 {:elide-asserts true}\ngoog.provide(\"quil.util$macros\");\n/**\n * Function that does nothing.\n */\nquil.util$macros.no_fn = (function quil$util$macros$no_fn(){\nreturn null;\n});\n/**\n * Returns the val associated with key in mappings or key directly if it\n *   is one of the vals in mappings. Otherwise throws an exception.\n */\nquil.util$macros.resolve_constant_key = (function quil$util$macros$resolve_constant_key(key,mappings){\nif(cljs.core.truth_(cljs.core.get.call(null,mappings,key))){\nreturn cljs.core.get.call(null,mappings,key);\n} else {\nif(cljs.core.truth_(cljs.core.some.call(null,cljs.core.PersistentHashSet.fromArray([key], true),cljs.core.vals.call(null,mappings)))){\nreturn key;\n} else {\nthrow (new Error([cljs.core.str(\"Expecting a keyword, got: \"),cljs.core.str(key),cljs.core.str(\". Expected one of: \"),cljs.core.str(cljs.core.vec.call(null,cljs.core.sort.call(null,cljs.core.keys.call(null,mappings))))].join('')));\n\n}\n}\n});\n/**\n * Returns the length of the longest key of map m. Assumes m's keys are strings\n * and returns 0 if map is empty:\n * (length-of-longest-key {\"foo\" 1 \"barr\" 2 \"bazzz\" 3}) ;=> 5\n * (length-of-longest-key {}) ;=> 0\n */\nquil.util$macros.length_of_longest_key = (function quil$util$macros$length_of_longest_key(m){\nvar or__11101__auto__ = cljs.core.last.call(null,cljs.core.sort.call(null,cljs.core.map.call(null,(function (p1__11_SHARP_){\nreturn p1__11_SHARP_.length();\n}),cljs.core.keys.call(null,m))));\nif(cljs.core.truth_(or__11101__auto__)){\nreturn or__11101__auto__;\n} else {\nreturn (0);\n}\n});\n/**\n * Generates a padding string starting concatting s with len times pad:\n * (gen-padding \"\" 5 \"b\") ;=> \"bbbbb\"\n * May be called without starting string s in which case it defaults to the\n * empty string and also without pad in which case it defaults to a single space\n */\nquil.util$macros.gen_padding = (function quil$util$macros$gen_padding(var_args){\nvar args325 = [];\nvar len__13421__auto___328 = arguments.length;\nvar i__13422__auto___329 = (0);\nwhile(true){\nif((i__13422__auto___329 < len__13421__auto___328)){\nargs325.push((arguments[i__13422__auto___329]));\n\nvar G__330 = (i__13422__auto___329 + (1));\ni__13422__auto___329 = G__330;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__327 = args325.length;\nswitch (G__327) {\ncase (1):\nreturn quil.util$macros.gen_padding.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.util$macros.gen_padding.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.util$macros.gen_padding.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args325.length)].join('')));\n\n}\n});\n\nquil.util$macros.gen_padding.cljs$core$IFn$_invoke$arity$1 = (function (len){\nreturn quil.util$macros.gen_padding.call(null,\"\",len,\" \");\n});\n\nquil.util$macros.gen_padding.cljs$core$IFn$_invoke$arity$2 = (function (len,pad){\nreturn quil.util$macros.gen_padding.call(null,\"\",len,pad);\n});\n\nquil.util$macros.gen_padding.cljs$core$IFn$_invoke$arity$3 = (function (s,len,pad){\nif((len > (0))){\nreturn quil.util$macros.gen_padding.call(null,[cljs.core.str(s),cljs.core.str(pad)].join(''),(len - (1)),pad);\n} else {\nreturn s;\n}\n});\n\nquil.util$macros.gen_padding.cljs$lang$maxFixedArity = (3);\n\nquil.util$macros.print_definition_list = (function quil$util$macros$print_definition_list(definitions){\nvar longest_key = quil.util$macros.length_of_longest_key.call(null,definitions);\nreturn cljs.core.dorun.call(null,cljs.core.map.call(null,((function (longest_key){\nreturn (function (p__336){\nvar vec__337 = p__336;\nvar k = cljs.core.nth.call(null,vec__337,(0),null);\nvar v = cljs.core.nth.call(null,vec__337,(1),null);\nvar len = k.length();\nvar diff = (longest_key - len);\nvar pad = quil.util$macros.gen_padding.call(null,diff);\nreturn cljs.core.println.call(null,k,pad,\"- \",v);\n});})(longest_key))\n,definitions));\n});\nquil.util$macros.clj_compilation_QMARK_ = (function quil$util$macros$clj_compilation_QMARK_(){\nreturn false;\n});\nquil.util$macros.prepare_quil_name = (function quil$util$macros$prepare_quil_name(const_keyword){\nreturn clojure.string.replace.call(null,clojure.string.upper_case.call(null,cljs.core.name.call(null,const_keyword)),/-/,\"_\");\n});\nquil.util$macros.prepare_quil_clj_constants = (function quil$util$macros$prepare_quil_clj_constants(constants){\nreturn cljs.core.into.call(null,cljs.core.PersistentArrayMap.EMPTY,cljs.core.map.call(null,(function (p1__12_SHARP_){\nreturn (new cljs.core.PersistentVector(null,(2),(5),cljs.core.PersistentVector.EMPTY_NODE,[p1__12_SHARP_,cljs.core.symbol.call(null,[cljs.core.str(\"PConstants/\"),cljs.core.str(quil.util$macros.prepare_quil_name.call(null,p1__12_SHARP_))].join(''))],null));\n}),constants));\n});\nquil.util$macros.prepare_quil_cljs_constants = (function quil$util$macros$prepare_quil_cljs_constants(constants){\nreturn cljs.core.into.call(null,cljs.core.PersistentArrayMap.EMPTY,cljs.core.map.call(null,(function (p1__13_SHARP_){\nreturn (new cljs.core.PersistentVector(null,(2),(5),cljs.core.PersistentVector.EMPTY_NODE,[p1__13_SHARP_,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"cljs.core\",\"aget\",\"cljs.core/aget\",(6345791),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"js\",\"Processing.prototype.PConstants\",\"js/Processing.prototype.PConstants\",(2034048972),null)),(function (){var x__13164__auto__ = quil.util$macros.prepare_quil_name.call(null,p1__13_SHARP_);\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})()))],null));\n}),constants));\n});\nquil.util$macros.make_quil_constant_map = (function quil$util$macros$make_quil_constant_map(target,const_map_name,const_map){\nreturn cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"def\",\"def\",(597100991),null)),(function (){var x__13164__auto__ = const_map_name;\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})(),(function (){var x__13164__auto__ = ((cljs.core._EQ_.call(null,target,new cljs.core.Keyword(null,\"clj\",\"clj\",(-660495428))))?quil.util$macros.prepare_quil_clj_constants.call(null,const_map):quil.util$macros.prepare_quil_cljs_constants.call(null,const_map));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})()));\n});\nquil.util$macros.generate_quil_constants = (function quil$util$macros$generate_quil_constants(var_args){\nvar args__13423__auto__ = [];\nvar len__13421__auto___344 = arguments.length;\nvar i__13422__auto___345 = (0);\nwhile(true){\nif((i__13422__auto___345 < len__13421__auto___344)){\nargs__13423__auto__.push((arguments[i__13422__auto___345]));\n\nvar G__346 = (i__13422__auto___345 + (1));\ni__13422__auto___345 = G__346;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__13424__auto__ = ((((3) < args__13423__auto__.length))?(new cljs.core.IndexedSeq(args__13423__auto__.slice((3)),(0),null)):null);\nreturn quil.util$macros.generate_quil_constants.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__13424__auto__);\n});\n\nquil.util$macros.generate_quil_constants.cljs$core$IFn$_invoke$arity$variadic = (function (_AMPERSAND_form,_AMPERSAND_env,target,opts){\nreturn cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"do\",\"do\",(1686842252),null)),cljs.core.map.call(null,(function (p1__14_SHARP_){\nreturn quil.util$macros.make_quil_constant_map.call(null,target,cljs.core.first.call(null,p1__14_SHARP_),cljs.core.second.call(null,p1__14_SHARP_));\n}),cljs.core.partition.call(null,(2),opts))));\n});\n\nquil.util$macros.generate_quil_constants.cljs$lang$maxFixedArity = (3);\n\nquil.util$macros.generate_quil_constants.cljs$lang$applyTo = (function (seq340){\nvar G__341 = cljs.core.first.call(null,seq340);\nvar seq340__$1 = cljs.core.next.call(null,seq340);\nvar G__342 = cljs.core.first.call(null,seq340__$1);\nvar seq340__$2 = cljs.core.next.call(null,seq340__$1);\nvar G__343 = cljs.core.first.call(null,seq340__$2);\nvar seq340__$3 = cljs.core.next.call(null,seq340__$2);\nreturn quil.util$macros.generate_quil_constants.cljs$core$IFn$_invoke$arity$variadic(G__341,G__342,G__343,seq340__$3);\n});\n\n\nquil.util$macros.generate_quil_constants.cljs$lang$macro = true;\n","quil/sketch$macros.cache.json":"[\"^ \",\"~:rename-macros\",[\"^ \"],\"~:renames\",[\"^ \"],\"~:use-macros\",[\"^ \"],\"~:excludes\",[\"~#set\",[]],\"~:name\",\"~$quil.sketch$macros\",\"~:imports\",null,\"~:requires\",null,\"~:uses\",null,\"~:defs\",[\"^ \",\"~$wrap-fns\",[\"^ \",\"~:protocol-inline\",null,\"~:meta\",[\"^ \",\"~:file\",\"~$quil.sketch\",\"~:line\",7,\"~:column\",7,\"~:end-line\",7,\"~:end-column\",15,\"~:arglists\",[\"~#list\",[\"~$quote\",[\"^E\",[[\"~$opts\"]]]]],\"~:doc\",\"Wrap fns allows dynamic redefinition of function such as draw, update\\n  in cljs. This is achieved by wrapping all provided functions to\\n  anonymous functions such that 'my-draw' function turns into\\n  (fn [& args] (apply my-draw args)). This adds a level of indirection\\n  so that when quil calls draw, it invokes anonymous function which in\\n  turn always calls my-draw by name and if you redefine - new version\\n  will be used. Hence we need this cryptic macro.\"],\"^5\",\"~$quil.sketch$macros/wrap-fns\",\"~:variadic\",false,\"^>\",\"quil/sketch.clj\",\"^C\",15,\"~:method-params\",[\"^E\",[[\"^G\"]]],\"~:protocol-impl\",null,\"~:arglists-meta\",[\"^E\",[null,null]],\"^A\",1,\"^@\",7,\"^B\",7,\"~:max-fixed-arity\",1,\"~:fn-var\",true,\"^D\",[\"^E\",[\"^F\",[\"^E\",[[\"^G\"]]]]],\"^H\",\"Wrap fns allows dynamic redefinition of function such as draw, update\\n  in cljs. This is achieved by wrapping all provided functions to\\n  anonymous functions such that 'my-draw' function turns into\\n  (fn [& args] (apply my-draw args)). This adds a level of indirection\\n  so that when quil calls draw, it invokes anonymous function which in\\n  turn always calls my-draw by name and if you redefine - new version\\n  will be used. Hence we need this cryptic macro.\"],\"~$defsketch\",[\"^ \",\"^<\",null,\"^=\",[\"^ \",\"^>\",\"^?\",\"^@\",22,\"^A\",11,\"^B\",22,\"^C\",20,\"~:macro\",true,\"^D\",[\"^E\",[\"^F\",[\"^E\",[[\"~$app-name\",\"~$&\",\"~$options\"]]]]],\"~:top-fn\",[\"^ \",\"^J\",true,\"^N\",3,\"^K\",[[\"^E\",[\"~$&form\",\"~$&env\",\"^R\",\"^S\"]]],\"^D\",[\"^E\",[[\"^U\",\"^V\",\"^R\",\"~$&\",\"^S\"]]],\"^M\",[\"^E\",[null]]]],\"^5\",\"~$quil.sketch$macros/defsketch\",\"^J\",true,\"^>\",\"quil/sketch.clj\",\"^C\",20,\"^T\",[\"^ \",\"^J\",true,\"^N\",3,\"^K\",[[\"^E\",[\"^U\",\"^V\",\"^R\",\"^S\"]]],\"^D\",[\"^E\",[[\"^U\",\"^V\",\"^R\",\"~$&\",\"^S\"]]],\"^M\",[\"^E\",[null]]],\"^K\",[[\"^E\",[\"^U\",\"^V\",\"^R\",\"^S\"]]],\"^L\",null,\"^M\",[\"^E\",[null]],\"^A\",1,\"^@\",22,\"^Q\",true,\"^B\",22,\"^N\",3,\"^O\",false,\"^D\",[\"^E\",[[\"^U\",\"^V\",\"^R\",\"~$&\",\"^S\"]]]],\"~$with-sketch\",[\"^ \",\"^<\",null,\"^=\",[\"^ \",\"^>\",\"^?\",\"^@\",3,\"^A\",11,\"^B\",3,\"^C\",22,\"^Q\",true,\"^D\",[\"^E\",[\"^F\",[\"^E\",[[\"~$applet\",\"~$&\",\"~$body\"]]]]],\"^T\",[\"^ \",\"^J\",true,\"^N\",3,\"^K\",[[\"^E\",[\"^U\",\"^V\",\"^Y\",\"^Z\"]]],\"^D\",[\"^E\",[[\"^U\",\"^V\",\"^Y\",\"~$&\",\"^Z\"]]],\"^M\",[\"^E\",[null]]]],\"^5\",\"~$quil.sketch$macros/with-sketch\",\"^J\",true,\"^>\",\"quil/sketch.clj\",\"^C\",22,\"^T\",[\"^ \",\"^J\",true,\"^N\",3,\"^K\",[[\"^E\",[\"^U\",\"^V\",\"^Y\",\"^Z\"]]],\"^D\",[\"^E\",[[\"^U\",\"^V\",\"^Y\",\"~$&\",\"^Z\"]]],\"^M\",[\"^E\",[null]]],\"^K\",[[\"^E\",[\"^U\",\"^V\",\"^Y\",\"^Z\"]]],\"^L\",null,\"^M\",[\"^E\",[null]],\"^A\",1,\"^@\",3,\"^Q\",true,\"^B\",3,\"^N\",3,\"^O\",false,\"^D\",[\"^E\",[[\"^U\",\"^V\",\"^Y\",\"~$&\",\"^Z\"]]]]],\"~:require-macros\",[\"^ \"],\"~:cljs.analyzer/constants\",[\"^ \",\"~:seen\",[\"^4\",[\"~$&\",\"~:features\",\"~$cljs.core/binding\",\"~$quil.sketch/*applet*\",\"~:fn\",\"~$cljs.core/=\",\"~$cljs.core/apply\",\"~$args\",\"~$p1__9__10__auto__\",\"~$cljs.core/when-not\",\"~$cljs.core/defn\",\"~$do\",\"~:export\",\"~$if\",\"~$cljs.core/fn?\",\"~:host\",\"~$fn*\",\"~$cljs.core/fn\",\"~:host-id\",\"~:no-start\",\"~$quil.sketch/add-sketch-to-init-list\",\"~$cljs.core/some\",\"~$quil.sketch/sketch\"]],\"~:order\",[\"^14\",\"^15\",\"^1?\",\"^1@\",\"^1C\",\"~$&\",\"^19\",\"^18\",\"^1A\",\"^1=\",\"^1<\",\"^1>\",\"^1H\",\"^1;\",\"^1G\",\"^1B\",\"^1:\",\"^17\",\"^1E\",\"^13\",\"^1F\",\"^16\",\"^1D\"]],\"^H\",null]","quil/sketch.js":"// Compiled by ClojureScript 1.9.293 {:elide-asserts true}\ngoog.provide(\"quil.sketch\");\nquil.sketch._STAR_applet_STAR_ = null;\nquil.sketch.current_applet = (function quil$sketch$current_applet(){\nreturn quil.sketch._STAR_applet_STAR_;\n});\nquil.sketch.rendering_modes = new cljs.core.PersistentArrayMap(null, 4, [new cljs.core.Keyword(null,\"java2d\",\"java2d\",(166099237)),(Processing.prototype.PConstants[\"JAVA2D\"]),new cljs.core.Keyword(null,\"p2d\",\"p2d\",(-2106175755)),(Processing.prototype.PConstants[\"P2D\"]),new cljs.core.Keyword(null,\"p3d\",\"p3d\",(-850380194)),(Processing.prototype.PConstants[\"P3D\"]),new cljs.core.Keyword(null,\"opengl\",\"opengl\",(-614998103)),(Processing.prototype.PConstants[\"OPENGL\"])], null);\nquil.sketch.resolve_renderer = (function quil$sketch$resolve_renderer(mode){\nreturn quil.util.resolve_constant_key.call(null,mode,quil.sketch.rendering_modes);\n});\nquil.sketch.size = (function quil$sketch$size(var_args){\nvar args347 = [];\nvar len__13421__auto___350 = arguments.length;\nvar i__13422__auto___351 = (0);\nwhile(true){\nif((i__13422__auto___351 < len__13421__auto___350)){\nargs347.push((arguments[i__13422__auto___351]));\n\nvar G__352 = (i__13422__auto___351 + (1));\ni__13422__auto___351 = G__352;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__349 = args347.length;\nswitch (G__349) {\ncase (2):\nreturn quil.sketch.size.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.sketch.size.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args347.length)].join('')));\n\n}\n});\n\nquil.sketch.size.cljs$core$IFn$_invoke$arity$2 = (function (width,height){\nreturn quil.sketch.current_applet.call(null).size((width | (0)),(height | (0)));\n});\n\nquil.sketch.size.cljs$core$IFn$_invoke$arity$3 = (function (width,height,mode){\nreturn quil.sketch.current_applet.call(null).size((width | (0)),(height | (0)),quil.util.resolve_constant_key.call(null,mode,quil.sketch.rendering_modes));\n});\n\nquil.sketch.size.cljs$lang$maxFixedArity = (3);\n\nquil.sketch.bind_handlers = (function quil$sketch$bind_handlers(prc,opts){\nvar seq__366 = cljs.core.seq.call(null,cljs.core.PersistentHashMap.fromArrays([new cljs.core.Keyword(null,\"keyPressed\",\"keyPressed\",(1791025256)),new cljs.core.Keyword(null,\"mouseOut\",\"mouseOut\",(-386669045)),new cljs.core.Keyword(null,\"mouseScrolled\",\"mouseScrolled\",(31878252)),new cljs.core.Keyword(null,\"mouseDragged\",\"mouseDragged\",(129975181)),new cljs.core.Keyword(null,\"setup\",\"setup\",(1987730512)),new cljs.core.Keyword(null,\"keyReleased\",\"keyReleased\",(541714964)),new cljs.core.Keyword(null,\"mouseClicked\",\"mouseClicked\",(1764302965)),new cljs.core.Keyword(null,\"mouseReleased\",\"mouseReleased\",(1116234838)),new cljs.core.Keyword(null,\"mousePressed\",\"mousePressed\",(1776186454)),new cljs.core.Keyword(null,\"mouseMoved\",\"mouseMoved\",(-1936954058)),new cljs.core.Keyword(null,\"mouseOver\",\"mouseOver\",(-1334461930)),new cljs.core.Keyword(null,\"keyTyped\",\"keyTyped\",(1437329399)),new cljs.core.Keyword(null,\"draw\",\"draw\",(1358331674))],[new cljs.core.Keyword(null,\"key-pressed\",\"key-pressed\",(-757100364)),new cljs.core.Keyword(null,\"mouse-exited\",\"mouse-exited\",(-483205244)),new cljs.core.Keyword(null,\"mouse-wheel\",\"mouse-wheel\",(1811662439)),new cljs.core.Keyword(null,\"mouse-dragged\",\"mouse-dragged\",(-1220073441)),new cljs.core.Keyword(null,\"setup\",\"setup\",(1987730512)),new cljs.core.Keyword(null,\"key-released\",\"key-released\",(215919828)),new cljs.core.Keyword(null,\"mouse-clicked\",\"mouse-clicked\",(-199339421)),new cljs.core.Keyword(null,\"mouse-released\",\"mouse-released\",(-664480061)),new cljs.core.Keyword(null,\"mouse-pressed\",\"mouse-pressed\",(736955536)),new cljs.core.Keyword(null,\"mouse-moved\",\"mouse-moved\",(-1918152310)),new cljs.core.Keyword(null,\"mouse-entered\",\"mouse-entered\",(811350322)),new cljs.core.Keyword(null,\"key-typed\",\"key-typed\",(-876037597)),new cljs.core.Keyword(null,\"draw\",\"draw\",(1358331674))]));\nvar chunk__367 = null;\nvar count__368 = (0);\nvar i__369 = (0);\nwhile(true){\nif((i__369 < count__368)){\nvar vec__370 = cljs.core._nth.call(null,chunk__367,i__369);\nvar processing_name = cljs.core.nth.call(null,vec__370,(0),null);\nvar quil_name = cljs.core.nth.call(null,vec__370,(1),null);\nvar temp__10400__auto___378 = opts.call(null,quil_name);\nif(cljs.core.truth_(temp__10400__auto___378)){\nvar handler_379 = temp__10400__auto___378;\n(prc[cljs.core.name.call(null,processing_name)] = ((function (seq__366,chunk__367,count__368,i__369,handler_379,temp__10400__auto___378,vec__370,processing_name,quil_name){\nreturn (function (){\nvar _STAR_applet_STAR_373 = quil.sketch._STAR_applet_STAR_;\nquil.sketch._STAR_applet_STAR_ = prc;\n\ntry{return handler_379.call(null);\n}finally {quil.sketch._STAR_applet_STAR_ = _STAR_applet_STAR_373;\n}});})(seq__366,chunk__367,count__368,i__369,handler_379,temp__10400__auto___378,vec__370,processing_name,quil_name))\n);\n} else {\n}\n\nvar G__380 = seq__366;\nvar G__381 = chunk__367;\nvar G__382 = count__368;\nvar G__383 = (i__369 + (1));\nseq__366 = G__380;\nchunk__367 = G__381;\ncount__368 = G__382;\ni__369 = G__383;\ncontinue;\n} else {\nvar temp__10400__auto__ = cljs.core.seq.call(null,seq__366);\nif(temp__10400__auto__){\nvar seq__366__$1 = temp__10400__auto__;\nif(cljs.core.chunked_seq_QMARK_.call(null,seq__366__$1)){\nvar c__13128__auto__ = cljs.core.chunk_first.call(null,seq__366__$1);\nvar G__384 = cljs.core.chunk_rest.call(null,seq__366__$1);\nvar G__385 = c__13128__auto__;\nvar G__386 = cljs.core.count.call(null,c__13128__auto__);\nvar G__387 = (0);\nseq__366 = G__384;\nchunk__367 = G__385;\ncount__368 = G__386;\ni__369 = G__387;\ncontinue;\n} else {\nvar vec__374 = cljs.core.first.call(null,seq__366__$1);\nvar processing_name = cljs.core.nth.call(null,vec__374,(0),null);\nvar quil_name = cljs.core.nth.call(null,vec__374,(1),null);\nvar temp__10400__auto___388__$1 = opts.call(null,quil_name);\nif(cljs.core.truth_(temp__10400__auto___388__$1)){\nvar handler_389 = temp__10400__auto___388__$1;\n(prc[cljs.core.name.call(null,processing_name)] = ((function (seq__366,chunk__367,count__368,i__369,handler_389,temp__10400__auto___388__$1,vec__374,processing_name,quil_name,seq__366__$1,temp__10400__auto__){\nreturn (function (){\nvar _STAR_applet_STAR_377 = quil.sketch._STAR_applet_STAR_;\nquil.sketch._STAR_applet_STAR_ = prc;\n\ntry{return handler_389.call(null);\n}finally {quil.sketch._STAR_applet_STAR_ = _STAR_applet_STAR_377;\n}});})(seq__366,chunk__367,count__368,i__369,handler_389,temp__10400__auto___388__$1,vec__374,processing_name,quil_name,seq__366__$1,temp__10400__auto__))\n);\n} else {\n}\n\nvar G__390 = cljs.core.next.call(null,seq__366__$1);\nvar G__391 = null;\nvar G__392 = (0);\nvar G__393 = (0);\nseq__366 = G__390;\nchunk__367 = G__391;\ncount__368 = G__392;\ni__369 = G__393;\ncontinue;\n}\n} else {\nreturn null;\n}\n}\nbreak;\n}\n});\nquil.sketch.make_sketch = (function quil$sketch$make_sketch(options){\nvar opts = cljs.core.merge.call(null,new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"size\",\"size\",(1098693007)),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [(500),(300)], null)], null),(function (p1__15_SHARP_){\nreturn p1__15_SHARP_.call(null,options);\n}).call(null,cljs.core.apply.call(null,cljs.core.comp,cljs.core.cons.call(null,quil.middlewares.deprecated_options.deprecated_options,new cljs.core.Keyword(null,\"middleware\",\"middleware\",(1462115504)).cljs$core$IFn$_invoke$arity$2(options,cljs.core.PersistentVector.EMPTY)))));\nvar sketch_size = (function (){var or__11101__auto__ = new cljs.core.Keyword(null,\"size\",\"size\",(1098693007)).cljs$core$IFn$_invoke$arity$1(opts);\nif(cljs.core.truth_(or__11101__auto__)){\nreturn or__11101__auto__;\n} else {\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [(200),(200)], null);\n}\n})();\nvar renderer = new cljs.core.Keyword(null,\"renderer\",\"renderer\",(336841071)).cljs$core$IFn$_invoke$arity$1(opts);\nvar features = cljs.core.set.call(null,new cljs.core.Keyword(null,\"features\",\"features\",(-1146962336)).cljs$core$IFn$_invoke$arity$1(opts));\nvar setup = ((function (opts,sketch_size,renderer,features){\nreturn (function (){\ncljs.core.apply.call(null,quil.sketch.size,cljs.core.concat.call(null,sketch_size,(cljs.core.truth_(renderer)?new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [renderer], null):cljs.core.PersistentVector.EMPTY)));\n\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"settings\",\"settings\",(1556144875)).cljs$core$IFn$_invoke$arity$1(opts))){\nnew cljs.core.Keyword(null,\"settings\",\"settings\",(1556144875)).cljs$core$IFn$_invoke$arity$1(opts).call(null);\n} else {\n}\n\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"setup\",\"setup\",(1987730512)).cljs$core$IFn$_invoke$arity$1(opts))){\nreturn new cljs.core.Keyword(null,\"setup\",\"setup\",(1987730512)).cljs$core$IFn$_invoke$arity$1(opts).call(null);\n} else {\nreturn null;\n}\n});})(opts,sketch_size,renderer,features))\n;\nvar mouse_wheel = (cljs.core.truth_(new cljs.core.Keyword(null,\"mouse-wheel\",\"mouse-wheel\",(1811662439)).cljs$core$IFn$_invoke$arity$1(opts))?((function (opts,sketch_size,renderer,features,setup){\nreturn (function (){\nreturn new cljs.core.Keyword(null,\"mouse-wheel\",\"mouse-wheel\",(1811662439)).cljs$core$IFn$_invoke$arity$1(opts).call(null,((-1) * quil.sketch._STAR_applet_STAR_.mouseScroll));\n});})(opts,sketch_size,renderer,features,setup))\n:null);\nvar opts__$1 = cljs.core.assoc.call(null,opts,new cljs.core.Keyword(null,\"setup\",\"setup\",(1987730512)),setup,new cljs.core.Keyword(null,\"mouse-wheel\",\"mouse-wheel\",(1811662439)),mouse_wheel);\nvar attach_function = ((function (opts,sketch_size,renderer,features,setup,mouse_wheel,opts__$1){\nreturn (function (prc){\nquil.sketch.bind_handlers.call(null,prc,opts__$1);\n\nprc.quil = cljs.core.atom.call(null,null);\n\nreturn prc.target_frame_rate = cljs.core.atom.call(null,(60));\n});})(opts,sketch_size,renderer,features,setup,mouse_wheel,opts__$1))\n;\nvar sketch = (new Processing.Sketch(attach_function));\nif(cljs.core.contains_QMARK_.call(null,features,new cljs.core.Keyword(null,\"global-key-events\",\"global-key-events\",(335064944)))){\n((sketch[\"options\"])[\"globalKeyEvents\"] = true);\n} else {\n}\n\nreturn sketch;\n});\nquil.sketch.destroy_previous_sketch = (function quil$sketch$destroy_previous_sketch(host_elem){\nvar temp__10400__auto__ = host_elem.processing_obj;\nif(cljs.core.truth_(temp__10400__auto__)){\nvar proc_obj = temp__10400__auto__;\nreturn proc_obj.exit();\n} else {\nreturn null;\n}\n});\nquil.sketch.sketch = (function quil$sketch$sketch(var_args){\nvar args__13423__auto__ = [];\nvar len__13421__auto___395 = arguments.length;\nvar i__13422__auto___396 = (0);\nwhile(true){\nif((i__13422__auto___396 < len__13421__auto___395)){\nargs__13423__auto__.push((arguments[i__13422__auto___396]));\n\nvar G__397 = (i__13422__auto___396 + (1));\ni__13422__auto___396 = G__397;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__13424__auto__ = ((((0) < args__13423__auto__.length))?(new cljs.core.IndexedSeq(args__13423__auto__.slice((0)),(0),null)):null);\nreturn quil.sketch.sketch.cljs$core$IFn$_invoke$arity$variadic(argseq__13424__auto__);\n});\n\nquil.sketch.sketch.cljs$core$IFn$_invoke$arity$variadic = (function (opts){\nvar opts_map = cljs.core.apply.call(null,cljs.core.hash_map,opts);\nvar host_elem = goog.dom.getElement(new cljs.core.Keyword(null,\"host\",\"host\",(-1558485167)).cljs$core$IFn$_invoke$arity$1(opts_map));\nvar renderer = (function (){var or__11101__auto__ = new cljs.core.Keyword(null,\"renderer\",\"renderer\",(336841071)).cljs$core$IFn$_invoke$arity$1(opts_map);\nif(cljs.core.truth_(or__11101__auto__)){\nreturn or__11101__auto__;\n} else {\nreturn new cljs.core.Keyword(null,\"p2d\",\"p2d\",(-2106175755));\n}\n})();\nif(cljs.core.truth_(host_elem)){\nif(cljs.core.truth_(host_elem.processing_context)){\nif(cljs.core._EQ_.call(null,renderer,host_elem.processing_context)){\n} else {\nconsole.warn(\"WARNING: Using different context on one canvas!\");\n}\n} else {\nhost_elem.processing_context = renderer;\n}\n\nquil.sketch.destroy_previous_sketch.call(null,host_elem);\n\nreturn host_elem.processing_obj = (new Processing(host_elem,quil.sketch.make_sketch.call(null,opts_map)));\n} else {\nreturn console.error(\"ERROR: Cannot create sketch. :host is not specified.\");\n}\n});\n\nquil.sketch.sketch.cljs$lang$maxFixedArity = (0);\n\nquil.sketch.sketch.cljs$lang$applyTo = (function (seq394){\nreturn quil.sketch.sketch.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq.call(null,seq394));\n});\n\nquil.sketch.sketch_init_list = cljs.core.atom.call(null,cljs.core.List.EMPTY);\nquil.sketch.empty_body_QMARK_ = (function quil$sketch$empty_body_QMARK_(){\nvar child = document.body.childNodes;\nreturn (child.length <= (1));\n});\nquil.sketch.add_canvas = (function quil$sketch$add_canvas(canvas_id){\nvar canvas = document.createElement(\"canvas\");\ncanvas.setAttribute(\"id\",canvas_id);\n\nreturn document.body.appendChild(canvas);\n});\nquil.sketch.init_sketches = (function quil$sketch$init_sketches(){\nvar add_elem_QMARK__406 = quil.sketch.empty_body_QMARK_.call(null);\nvar seq__402_407 = cljs.core.seq.call(null,cljs.core.deref.call(null,quil.sketch.sketch_init_list));\nvar chunk__403_408 = null;\nvar count__404_409 = (0);\nvar i__405_410 = (0);\nwhile(true){\nif((i__405_410 < count__404_409)){\nvar sk_411 = cljs.core._nth.call(null,chunk__403_408,i__405_410);\nif(cljs.core.truth_(add_elem_QMARK__406)){\nquil.sketch.add_canvas.call(null,new cljs.core.Keyword(null,\"host-id\",\"host-id\",(742376279)).cljs$core$IFn$_invoke$arity$1(sk_411));\n} else {\n}\n\nnew cljs.core.Keyword(null,\"fn\",\"fn\",(-1175266204)).cljs$core$IFn$_invoke$arity$1(sk_411).call(null);\n\nvar G__412 = seq__402_407;\nvar G__413 = chunk__403_408;\nvar G__414 = count__404_409;\nvar G__415 = (i__405_410 + (1));\nseq__402_407 = G__412;\nchunk__403_408 = G__413;\ncount__404_409 = G__414;\ni__405_410 = G__415;\ncontinue;\n} else {\nvar temp__10400__auto___416 = cljs.core.seq.call(null,seq__402_407);\nif(temp__10400__auto___416){\nvar seq__402_417__$1 = temp__10400__auto___416;\nif(cljs.core.chunked_seq_QMARK_.call(null,seq__402_417__$1)){\nvar c__13128__auto___418 = cljs.core.chunk_first.call(null,seq__402_417__$1);\nvar G__419 = cljs.core.chunk_rest.call(null,seq__402_417__$1);\nvar G__420 = c__13128__auto___418;\nvar G__421 = cljs.core.count.call(null,c__13128__auto___418);\nvar G__422 = (0);\nseq__402_407 = G__419;\nchunk__403_408 = G__420;\ncount__404_409 = G__421;\ni__405_410 = G__422;\ncontinue;\n} else {\nvar sk_423 = cljs.core.first.call(null,seq__402_417__$1);\nif(cljs.core.truth_(add_elem_QMARK__406)){\nquil.sketch.add_canvas.call(null,new cljs.core.Keyword(null,\"host-id\",\"host-id\",(742376279)).cljs$core$IFn$_invoke$arity$1(sk_423));\n} else {\n}\n\nnew cljs.core.Keyword(null,\"fn\",\"fn\",(-1175266204)).cljs$core$IFn$_invoke$arity$1(sk_423).call(null);\n\nvar G__424 = cljs.core.next.call(null,seq__402_417__$1);\nvar G__425 = null;\nvar G__426 = (0);\nvar G__427 = (0);\nseq__402_407 = G__424;\nchunk__403_408 = G__425;\ncount__404_409 = G__426;\ni__405_410 = G__427;\ncontinue;\n}\n} else {\n}\n}\nbreak;\n}\n\nreturn cljs.core.reset_BANG_.call(null,quil.sketch.sketch_init_list,cljs.core.PersistentVector.EMPTY);\n});\nquil.sketch.add_sketch_to_init_list = (function quil$sketch$add_sketch_to_init_list(sk){\ncljs.core.swap_BANG_.call(null,quil.sketch.sketch_init_list,cljs.core.conj,sk);\n\nif(cljs.core._EQ_.call(null,document.readyState,\"complete\")){\nreturn quil.sketch.init_sketches.call(null);\n} else {\nreturn null;\n}\n});\ngoog.events.listenOnce(window,goog.events.EventType.LOAD,quil.sketch.init_sketches);\n","quil/core$macros.js":"// Compiled by ClojureScript 1.9.293 {:elide-asserts true}\ngoog.provide(\"quil.core$macros\");\nquil.core$macros._STAR_graphics_STAR_ = null;\nquil.core$macros.no_fill_prop = \"no-fill-quil\";\n/**\n * Graphics currently used for drawing. By default it is sketch graphics,\n *   but if called inside with-graphics macro - graphics passed to the macro\n *   is returned. This method should be used if you need to call some methods\n *   that are not implemented by quil. Example:\n *   (.beginDraw (current-graphics)).\n */\nquil.core$macros.current_graphics = (function quil$core$macros$current_graphics(){\nvar or__11101__auto__ = quil.core$macros._STAR_graphics_STAR_;\nif(cljs.core.truth_(or__11101__auto__)){\nreturn or__11101__auto__;\n} else {\nreturn quil.sketch.current_applet.call(null);\n}\n});\nquil.core$macros.arc_modes = new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\"open\",\"open\",(-1763596448)),(Processing.prototype.PConstants[\"OPEN\"]),new cljs.core.Keyword(null,\"chord\",\"chord\",(-696248342)),(Processing.prototype.PConstants[\"CHORD\"]),new cljs.core.Keyword(null,\"pie\",\"pie\",(1530441672)),(Processing.prototype.PConstants[\"PIE\"])], null);\n\nquil.core$macros.shape_modes = new cljs.core.PersistentArrayMap(null, 7, [new cljs.core.Keyword(null,\"points\",\"points\",(-1486596883)),(Processing.prototype.PConstants[\"POINTS\"]),new cljs.core.Keyword(null,\"lines\",\"lines\",(-700165781)),(Processing.prototype.PConstants[\"LINES\"]),new cljs.core.Keyword(null,\"triangles\",\"triangles\",(-1525417058)),(Processing.prototype.PConstants[\"TRIANGLES\"]),new cljs.core.Keyword(null,\"triangle-fan\",\"triangle-fan\",(1743150739)),(Processing.prototype.PConstants[\"TRIANGLE_FAN\"]),new cljs.core.Keyword(null,\"triangle-strip\",\"triangle-strip\",(221845500)),(Processing.prototype.PConstants[\"TRIANGLE_STRIP\"]),new cljs.core.Keyword(null,\"quads\",\"quads\",(1347497505)),(Processing.prototype.PConstants[\"QUADS\"]),new cljs.core.Keyword(null,\"quad-strip\",\"quad-strip\",(-1297270686)),(Processing.prototype.PConstants[\"QUAD_STRIP\"])], null);\n\nquil.core$macros.blend_modes = cljs.core.PersistentHashMap.fromArrays([new cljs.core.Keyword(null,\"burn\",\"burn\",(-458179293)),new cljs.core.Keyword(null,\"screen\",\"screen\",(1990059748)),new cljs.core.Keyword(null,\"darkest\",\"darkest\",(68197253)),new cljs.core.Keyword(null,\"dodge\",\"dodge\",(-1556666427)),new cljs.core.Keyword(null,\"replace\",\"replace\",(-786587770)),new cljs.core.Keyword(null,\"overlay\",\"overlay\",(-139131598)),new cljs.core.Keyword(null,\"difference\",\"difference\",(1916101396)),new cljs.core.Keyword(null,\"exclusion\",\"exclusion\",(531897910)),new cljs.core.Keyword(null,\"hard-light\",\"hard-light\",(-37591145)),new cljs.core.Keyword(null,\"multiply\",\"multiply\",(-1036907048)),new cljs.core.Keyword(null,\"lightest\",\"lightest\",(-2043115912)),new cljs.core.Keyword(null,\"blend\",\"blend\",(249565561)),new cljs.core.Keyword(null,\"add\",\"add\",(235287739)),new cljs.core.Keyword(null,\"soft-light\",\"soft-light\",(513207899)),new cljs.core.Keyword(null,\"subtract\",\"subtract\",(2136988635))],[(Processing.prototype.PConstants[\"BURN\"]),(Processing.prototype.PConstants[\"SCREEN\"]),(Processing.prototype.PConstants[\"DARKEST\"]),(Processing.prototype.PConstants[\"DODGE\"]),(Processing.prototype.PConstants[\"REPLACE\"]),(Processing.prototype.PConstants[\"OVERLAY\"]),(Processing.prototype.PConstants[\"DIFFERENCE\"]),(Processing.prototype.PConstants[\"EXCLUSION\"]),(Processing.prototype.PConstants[\"HARD_LIGHT\"]),(Processing.prototype.PConstants[\"MULTIPLY\"]),(Processing.prototype.PConstants[\"LIGHTEST\"]),(Processing.prototype.PConstants[\"BLEND\"]),(Processing.prototype.PConstants[\"ADD\"]),(Processing.prototype.PConstants[\"SOFT_LIGHT\"]),(Processing.prototype.PConstants[\"SUBTRACT\"])]);\n\nquil.core$macros.color_modes = new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\"rgb\",\"rgb\",(1432123467)),(Processing.prototype.PConstants[\"RGB\"]),new cljs.core.Keyword(null,\"hsb\",\"hsb\",(-753472031)),(Processing.prototype.PConstants[\"HSB\"])], null);\n\nquil.core$macros.image_formats = new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\"rgb\",\"rgb\",(1432123467)),(Processing.prototype.PConstants[\"RGB\"]),new cljs.core.Keyword(null,\"argb\",\"argb\",(633844107)),(Processing.prototype.PConstants[\"ARGB\"]),new cljs.core.Keyword(null,\"alpha\",\"alpha\",(-1574982441)),(Processing.prototype.PConstants[\"ALPHA\"])], null);\n\nquil.core$macros.ellipse_modes = new cljs.core.PersistentArrayMap(null, 4, [new cljs.core.Keyword(null,\"center\",\"center\",(-748944368)),(Processing.prototype.PConstants[\"CENTER\"]),new cljs.core.Keyword(null,\"radius\",\"radius\",(-2073122258)),(Processing.prototype.PConstants[\"RADIUS\"]),new cljs.core.Keyword(null,\"corner\",\"corner\",(1296717125)),(Processing.prototype.PConstants[\"CORNER\"]),new cljs.core.Keyword(null,\"corners\",\"corners\",(-137817903)),(Processing.prototype.PConstants[\"CORNERS\"])], null);\n\nquil.core$macros.hint_options = cljs.core.PersistentHashMap.fromArrays([new cljs.core.Keyword(null,\"disable-stroke-perspective\",\"disable-stroke-perspective\",(479198433)),new cljs.core.Keyword(null,\"disable-depth-mask\",\"disable-depth-mask\",(3298562)),new cljs.core.Keyword(null,\"enable-depth-test\",\"enable-depth-test\",(1519326084)),new cljs.core.Keyword(null,\"enable-depth-sort\",\"enable-depth-sort\",(-383089627)),new cljs.core.Keyword(null,\"disable-texture-mipmaps\",\"disable-texture-mipmaps\",(1697917541)),new cljs.core.Keyword(null,\"disable-stroke-pure\",\"disable-stroke-pure\",(735493926)),new cljs.core.Keyword(null,\"disable-depth-test\",\"disable-depth-test\",(284606407)),new cljs.core.Keyword(null,\"enable-stroke-perspective\",\"enable-stroke-perspective\",(-259923319)),new cljs.core.Keyword(null,\"disable-optimized-stroke\",\"disable-optimized-stroke\",(74038544)),new cljs.core.Keyword(null,\"enable-opengl-errors\",\"enable-opengl-errors\",(89998962)),new cljs.core.Keyword(null,\"enable-stroke-pure\",\"enable-stroke-pure\",(881345587)),new cljs.core.Keyword(null,\"enable-depth-mask\",\"enable-depth-mask\",(872785875)),new cljs.core.Keyword(null,\"enable-optimized-stroke\",\"enable-optimized-stroke\",(1537575253)),new cljs.core.Keyword(null,\"disable-opengl-errors\",\"disable-opengl-errors\",(506822839)),new cljs.core.Keyword(null,\"disable-depth-sort\",\"disable-depth-sort\",(-1568352839)),new cljs.core.Keyword(null,\"enable-texture-mipmaps\",\"enable-texture-mipmaps\",(1241892671))],[(Processing.prototype.PConstants[\"DISABLE_STROKE_PERSPECTIVE\"]),(Processing.prototype.PConstants[\"DISABLE_DEPTH_MASK\"]),(Processing.prototype.PConstants[\"ENABLE_DEPTH_TEST\"]),(Processing.prototype.PConstants[\"ENABLE_DEPTH_SORT\"]),(Processing.prototype.PConstants[\"DISABLE_TEXTURE_MIPMAPS\"]),(Processing.prototype.PConstants[\"DISABLE_STROKE_PURE\"]),(Processing.prototype.PConstants[\"DISABLE_DEPTH_TEST\"]),(Processing.prototype.PConstants[\"ENABLE_STROKE_PERSPECTIVE\"]),(Processing.prototype.PConstants[\"DISABLE_OPTIMIZED_STROKE\"]),(Processing.prototype.PConstants[\"ENABLE_OPENGL_ERRORS\"]),(Processing.prototype.PConstants[\"ENABLE_STROKE_PURE\"]),(Processing.prototype.PConstants[\"ENABLE_DEPTH_MASK\"]),(Processing.prototype.PConstants[\"ENABLE_OPTIMIZED_STROKE\"]),(Processing.prototype.PConstants[\"DISABLE_OPENGL_ERRORS\"]),(Processing.prototype.PConstants[\"DISABLE_DEPTH_SORT\"]),(Processing.prototype.PConstants[\"ENABLE_TEXTURE_MIPMAPS\"])]);\n\nquil.core$macros.image_modes = new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\"corner\",\"corner\",(1296717125)),(Processing.prototype.PConstants[\"CORNER\"]),new cljs.core.Keyword(null,\"corners\",\"corners\",(-137817903)),(Processing.prototype.PConstants[\"CORNERS\"]),new cljs.core.Keyword(null,\"center\",\"center\",(-748944368)),(Processing.prototype.PConstants[\"CENTER\"])], null);\n\nquil.core$macros.rect_modes = new cljs.core.PersistentArrayMap(null, 4, [new cljs.core.Keyword(null,\"corner\",\"corner\",(1296717125)),(Processing.prototype.PConstants[\"CORNER\"]),new cljs.core.Keyword(null,\"corners\",\"corners\",(-137817903)),(Processing.prototype.PConstants[\"CORNERS\"]),new cljs.core.Keyword(null,\"center\",\"center\",(-748944368)),(Processing.prototype.PConstants[\"CENTER\"]),new cljs.core.Keyword(null,\"radius\",\"radius\",(-2073122258)),(Processing.prototype.PConstants[\"RADIUS\"])], null);\n\nquil.core$macros.p_shape_modes = new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\"corner\",\"corner\",(1296717125)),(Processing.prototype.PConstants[\"CORNER\"]),new cljs.core.Keyword(null,\"corners\",\"corners\",(-137817903)),(Processing.prototype.PConstants[\"CORNERS\"]),new cljs.core.Keyword(null,\"center\",\"center\",(-748944368)),(Processing.prototype.PConstants[\"CENTER\"])], null);\n\nquil.core$macros.stroke_cap_modes = new cljs.core.PersistentArrayMap(null, 4, [new cljs.core.Keyword(null,\"square\",\"square\",(812434677)),(Processing.prototype.PConstants[\"SQUARE\"]),new cljs.core.Keyword(null,\"round\",\"round\",(2009433328)),(Processing.prototype.PConstants[\"ROUND\"]),new cljs.core.Keyword(null,\"project\",\"project\",(1124394579)),(Processing.prototype.PConstants[\"PROJECT\"]),new cljs.core.Keyword(null,\"model\",\"model\",(331153215)),(Processing.prototype.PConstants[\"MODEL\"])], null);\n\nquil.core$macros.stroke_join_modes = new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\"miter\",\"miter\",(327727052)),(Processing.prototype.PConstants[\"MITER\"]),new cljs.core.Keyword(null,\"bevel\",\"bevel\",(2090515654)),(Processing.prototype.PConstants[\"BEVEL\"]),new cljs.core.Keyword(null,\"round\",\"round\",(2009433328)),(Processing.prototype.PConstants[\"ROUND\"])], null);\n\nquil.core$macros.horizontal_alignment_modes = new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\"left\",\"left\",(-399115937)),(Processing.prototype.PConstants[\"LEFT\"]),new cljs.core.Keyword(null,\"center\",\"center\",(-748944368)),(Processing.prototype.PConstants[\"CENTER\"]),new cljs.core.Keyword(null,\"right\",\"right\",(-452581833)),(Processing.prototype.PConstants[\"RIGHT\"])], null);\n\nquil.core$macros.vertical_alignment_modes = new cljs.core.PersistentArrayMap(null, 4, [new cljs.core.Keyword(null,\"top\",\"top\",(-1856271961)),(Processing.prototype.PConstants[\"TOP\"]),new cljs.core.Keyword(null,\"bottom\",\"bottom\",(-1550509018)),(Processing.prototype.PConstants[\"BOTTOM\"]),new cljs.core.Keyword(null,\"center\",\"center\",(-748944368)),(Processing.prototype.PConstants[\"CENTER\"]),new cljs.core.Keyword(null,\"baseline\",\"baseline\",(1151033280)),(Processing.prototype.PConstants[\"BASELINE\"])], null);\n\nquil.core$macros.text_modes = new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\"model\",\"model\",(331153215)),(Processing.prototype.PConstants[\"MODEL\"]),new cljs.core.Keyword(null,\"shape\",\"shape\",(1190694006)),(Processing.prototype.PConstants[\"SHAPE\"])], null);\n\nquil.core$macros.texture_modes = new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\"image\",\"image\",(-58725096)),(Processing.prototype.PConstants[\"IMAGE\"]),new cljs.core.Keyword(null,\"normal\",\"normal\",(-1519123858)),(Processing.prototype.PConstants[\"NORMAL\"])], null);\n\nquil.core$macros.texture_wrap_modes = new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\"clamp\",\"clamp\",(1803814940)),(Processing.prototype.PConstants[\"CLAMP\"]),new cljs.core.Keyword(null,\"repeat\",\"repeat\",(832692087)),(Processing.prototype.PConstants[\"REPEAT\"])], null);\n\nquil.core$macros.filter_modes = new cljs.core.PersistentArrayMap(null, 8, [new cljs.core.Keyword(null,\"threshold\",\"threshold\",(204221583)),(Processing.prototype.PConstants[\"THRESHOLD\"]),new cljs.core.Keyword(null,\"gray\",\"gray\",(1013268388)),(Processing.prototype.PConstants[\"GRAY\"]),new cljs.core.Keyword(null,\"invert\",\"invert\",(1553577503)),(Processing.prototype.PConstants[\"INVERT\"]),new cljs.core.Keyword(null,\"posterize\",\"posterize\",(-148251901)),(Processing.prototype.PConstants[\"POSTERIZE\"]),new cljs.core.Keyword(null,\"blur\",\"blur\",(-453500461)),(Processing.prototype.PConstants[\"BLUR\"]),new cljs.core.Keyword(null,\"opaque\",\"opaque\",(-1243552654)),(Processing.prototype.PConstants[\"OPAQUE\"]),new cljs.core.Keyword(null,\"erode\",\"erode\",(1539530618)),(Processing.prototype.PConstants[\"ERODE\"]),new cljs.core.Keyword(null,\"dilate\",\"dilate\",(1504745153)),(Processing.prototype.PConstants[\"DILATE\"])], null);\n\nquil.core$macros.cursor_modes = new cljs.core.PersistentArrayMap(null, 6, [new cljs.core.Keyword(null,\"arrow\",\"arrow\",(1071351425)),(Processing.prototype.PConstants[\"ARROW\"]),new cljs.core.Keyword(null,\"cross\",\"cross\",(194557789)),(Processing.prototype.PConstants[\"CROSS\"]),new cljs.core.Keyword(null,\"hand\",\"hand\",(791601933)),(Processing.prototype.PConstants[\"HAND\"]),new cljs.core.Keyword(null,\"move\",\"move\",(-2110884309)),(Processing.prototype.PConstants[\"MOVE\"]),new cljs.core.Keyword(null,\"text\",\"text\",(-1790561697)),(Processing.prototype.PConstants[\"TEXT\"]),new cljs.core.Keyword(null,\"wait\",\"wait\",(-260664777)),(Processing.prototype.PConstants[\"WAIT\"])], null);\nquil.core$macros.PI = Math.PI;\nquil.core$macros.HALF_PI = (quil.core$macros.PI / (2));\nquil.core$macros.THIRD_PI = (quil.core$macros.PI / (3));\nquil.core$macros.QUARTER_PI = (quil.core$macros.PI / (4));\nquil.core$macros.TWO_PI = (quil.core$macros.PI * (2));\nquil.core$macros.DEG_TO_RAD = (quil.core$macros.PI / (180));\nquil.core$macros.RAD_TO_DEG = ((180) / quil.core$macros.PI);\nquil.core$macros.KEY_CODES = cljs.core.PersistentHashMap.fromArrays([(37),(38),(39),(40),(16),(112),(17),(113),(18),(114),(115),(116),(117),(118),(119),(120),(121),(122),(123),(157)],[new cljs.core.Keyword(null,\"left\",\"left\",(-399115937)),new cljs.core.Keyword(null,\"up\",\"up\",(-269712113)),new cljs.core.Keyword(null,\"right\",\"right\",(-452581833)),new cljs.core.Keyword(null,\"down\",\"down\",(1565245570)),new cljs.core.Keyword(null,\"shift\",\"shift\",(997140064)),new cljs.core.Keyword(null,\"f1\",\"f1\",(1714532389)),new cljs.core.Keyword(null,\"control\",\"control\",(1892578036)),new cljs.core.Keyword(null,\"f2\",\"f2\",(396168596)),new cljs.core.Keyword(null,\"alt\",\"alt\",(-3214426)),new cljs.core.Keyword(null,\"f3\",\"f3\",(1954829043)),new cljs.core.Keyword(null,\"f4\",\"f4\",(990968764)),new cljs.core.Keyword(null,\"f5\",\"f5\",(1587057387)),new cljs.core.Keyword(null,\"f6\",\"f6\",(2103080604)),new cljs.core.Keyword(null,\"f7\",\"f7\",(356150168)),new cljs.core.Keyword(null,\"f8\",\"f8\",(-2141475484)),new cljs.core.Keyword(null,\"f9\",\"f9\",(704633338)),new cljs.core.Keyword(null,\"f10\",\"f10\",(627525541)),new cljs.core.Keyword(null,\"f11\",\"f11\",(-1417398799)),new cljs.core.Keyword(null,\"f12\",\"f12\",(853352790)),new cljs.core.Keyword(null,\"command\",\"command\",(-894540724))]);\n/**\n * Writes to the text area of the Processing environment's console.\n *   This is often helpful for looking at the data a program is producing.\n *   Each call to this function creates a new line of output.\n *   Individual elements can be separated with quotes (\"\") and joined with the string concatenation operator (+).\n *   Also writes the content of an array to the text area of the Processing environment.\n *   This is often helpful for looking at the data a program is producing.\n *   A new line is put between each element of the array. This function can only print 1D arrays,\n *   but can test to see if the content are null or not null for 2+ dimensional arrays.\n */\nquil.core$macros.prc_println = (function quil$core$macros$prc_println(msg){\nreturn quil.sketch.current_applet.call(null).println(msg);\n});\n/**\n * Writes to the console area of the Processing environment.\n *   This is often helpful for looking at the data a program is producing.\n *   The companion function println() works like print(), but creates a new line of text for each call to the function.\n * Individual elements can be separated with quotes (\"\") and joined with the addition operator (+). \n */\nquil.core$macros.prc_print = (function quil$core$macros$prc_print(msg){\nreturn quil.sketch.current_applet.call(null).print(msg);\n});\n/**\n * Returns sketch object by id of canvas element of sketch.\n */\nquil.core$macros.get_sketch_by_id = (function quil$core$macros$get_sketch_by_id(id){\nreturn Processing.getInstanceById(id);\n});\nquil.core$macros.with_sketch = (function quil$core$macros$with_sketch(var_args){\nvar args__13423__auto__ = [];\nvar len__13421__auto___388 = arguments.length;\nvar i__13422__auto___389 = (0);\nwhile(true){\nif((i__13422__auto___389 < len__13421__auto___388)){\nargs__13423__auto__.push((arguments[i__13422__auto___389]));\n\nvar G__390 = (i__13422__auto___389 + (1));\ni__13422__auto___389 = G__390;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__13424__auto__ = ((((3) < args__13423__auto__.length))?(new cljs.core.IndexedSeq(args__13423__auto__.slice((3)),(0),null)):null);\nreturn quil.core$macros.with_sketch.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__13424__auto__);\n});\n\nquil.core$macros.with_sketch.cljs$core$IFn$_invoke$arity$variadic = (function (_AMPERSAND_form,_AMPERSAND_env,applet,body){\nif(cljs.core.truth_(quil.util.clj_compilation_QMARK_.call(null))){\nreturn null;\n} else {\nreturn cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.sketch\",\"with-sketch\",\"quil.sketch/with-sketch\",(-634067708),null)),(function (){var x__13164__auto__ = applet;\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})(),body));\n}\n});\n\nquil.core$macros.with_sketch.cljs$lang$maxFixedArity = (3);\n\nquil.core$macros.with_sketch.cljs$lang$applyTo = (function (seq384){\nvar G__385 = cljs.core.first.call(null,seq384);\nvar seq384__$1 = cljs.core.next.call(null,seq384);\nvar G__386 = cljs.core.first.call(null,seq384__$1);\nvar seq384__$2 = cljs.core.next.call(null,seq384__$1);\nvar G__387 = cljs.core.first.call(null,seq384__$2);\nvar seq384__$3 = cljs.core.next.call(null,seq384__$2);\nreturn quil.core$macros.with_sketch.cljs$core$IFn$_invoke$arity$variadic(G__385,G__386,G__387,seq384__$3);\n});\n\n\nquil.core$macros.with_sketch.cljs$lang$macro = true;\n/**\n * Retrieve sketch-specific state-atom. All changes to the\n *   atom will be reflected in the state.\n * \n *   (set-state! :foo 1)\n *   (state :foo) ;=> 1\n *   (swap! (state-atom) update-in [:foo] inc)\n *   (state :foo) ;=> 2\n */\nquil.core$macros.state_atom = (function quil$core$macros$state_atom(){\nreturn quil.sketch.current_applet.call(null).quil;\n});\n/**\n * Retrieve sketch-specific state by key. Must initially call\n *   set-state! to store state. If no parameter passed whole\n *   state map is returned.\n * \n *   (set-state! :foo 1)\n *   (state :foo) ;=> 1\n *   (state) ;=> {:foo 1}\n */\nquil.core$macros.state = (function quil$core$macros$state(var_args){\nvar args391 = [];\nvar len__13421__auto___394 = arguments.length;\nvar i__13422__auto___395 = (0);\nwhile(true){\nif((i__13422__auto___395 < len__13421__auto___394)){\nargs391.push((arguments[i__13422__auto___395]));\n\nvar G__396 = (i__13422__auto___395 + (1));\ni__13422__auto___395 = G__396;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__393 = args391.length;\nswitch (G__393) {\ncase (0):\nreturn quil.core$macros.state.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase (1):\nreturn quil.core$macros.state.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args391.length)].join('')));\n\n}\n});\n\nquil.core$macros.state.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn cljs.core.deref.call(null,quil.core$macros.state_atom.call(null));\n});\n\nquil.core$macros.state.cljs$core$IFn$_invoke$arity$1 = (function (key){\nvar state = quil.core$macros.state.call(null);\nif(cljs.core.contains_QMARK_.call(null,state,key)){\n} else {\nthrow Error([cljs.core.str(\"Unable to find state with key: \"),cljs.core.str(key)].join(''));\n}\n\nreturn cljs.core.get.call(null,state,key);\n});\n\nquil.core$macros.state.cljs$lang$maxFixedArity = (1);\n\n/**\n * Set sketch-specific state. May only be called once (ideally in the\n *   setup fn).  Subsequent calls have no effect.\n * \n *   Example:\n *   (set-state! :foo 1 :bar (atom true) :baz (/ (width) 2))\n */\nquil.core$macros.set_state_BANG_ = (function quil$core$macros$set_state_BANG_(var_args){\nvar args__13423__auto__ = [];\nvar len__13421__auto___399 = arguments.length;\nvar i__13422__auto___400 = (0);\nwhile(true){\nif((i__13422__auto___400 < len__13421__auto___399)){\nargs__13423__auto__.push((arguments[i__13422__auto___400]));\n\nvar G__401 = (i__13422__auto___400 + (1));\ni__13422__auto___400 = G__401;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__13424__auto__ = ((((0) < args__13423__auto__.length))?(new cljs.core.IndexedSeq(args__13423__auto__.slice((0)),(0),null)):null);\nreturn quil.core$macros.set_state_BANG_.cljs$core$IFn$_invoke$arity$variadic(argseq__13424__auto__);\n});\n\nquil.core$macros.set_state_BANG_.cljs$core$IFn$_invoke$arity$variadic = (function (state_vals){\nvar state_STAR_ = quil.core$macros.state_atom.call(null);\nif(cljs.core.truth_(cljs.core.deref.call(null,state_STAR_))){\nreturn null;\n} else {\nvar state_map = cljs.core.apply.call(null,cljs.core.hash_map,state_vals);\nreturn cljs.core.reset_BANG_.call(null,state_STAR_,state_map);\n}\n});\n\nquil.core$macros.set_state_BANG_.cljs$lang$maxFixedArity = (0);\n\nquil.core$macros.set_state_BANG_.cljs$lang$applyTo = (function (seq398){\nreturn quil.core$macros.set_state_BANG_.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq.call(null,seq398));\n});\n\n/**\n * Calculates the absolute value (magnitude) of a number. The\n *   absolute value of a number is always positive. Dynamically casts to\n *   an int or float appropriately\n */\nquil.core$macros.abs = (function quil$core$macros$abs(n){\nreturn quil.sketch.current_applet.call(null).abs(n);\n});\n/**\n * The inverse of cos, returns the arc cosine of a value. This\n *   function expects the values in the range of -1 to 1 and values are\n *   returned in the range 0 to Math/PI (3.1415927).\n */\nquil.core$macros.acos = (function quil$core$macros$acos(n){\nreturn quil.sketch.current_applet.call(null).acos(n);\n});\n/**\n * Extracts the alpha value from a color.\n */\nquil.core$macros.alpha = (function quil$core$macros$alpha(color){\nreturn quil.core$macros.current_graphics.call(null).alpha(cljs.core.unchecked_int.call(null,color));\n});\n/**\n * Sets the ambient reflectance for shapes drawn to the screen. This\n *   is combined with the ambient light component of environment. The\n *   color components set through the parameters define the\n *   reflectance. For example in the default color mode, setting x=255,\n *   y=126, z=0, would cause all the red light to reflect and half of the\n *   green light to reflect. Used in combination with emissive, specular,\n *   and shininess in setting the material properties of shapes.\n */\nquil.core$macros.ambient_float = (function quil$core$macros$ambient_float(var_args){\nvar args402 = [];\nvar len__13421__auto___405 = arguments.length;\nvar i__13422__auto___406 = (0);\nwhile(true){\nif((i__13422__auto___406 < len__13421__auto___405)){\nargs402.push((arguments[i__13422__auto___406]));\n\nvar G__407 = (i__13422__auto___406 + (1));\ni__13422__auto___406 = G__407;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__404 = args402.length;\nswitch (G__404) {\ncase (1):\nreturn quil.core$macros.ambient_float.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.ambient_float.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args402.length)].join('')));\n\n}\n});\n\nquil.core$macros.ambient_float.cljs$core$IFn$_invoke$arity$1 = (function (gray){\nreturn quil.core$macros.current_graphics.call(null).ambient(gray);\n});\n\nquil.core$macros.ambient_float.cljs$core$IFn$_invoke$arity$3 = (function (x,y,z){\nreturn quil.core$macros.current_graphics.call(null).ambient(x,y,z);\n});\n\nquil.core$macros.ambient_float.cljs$lang$maxFixedArity = (3);\n\n/**\n * Sets the ambient reflectance for shapes drawn to the screen. This\n *   is combined with the ambient light component of environment. The rgb\n *   color components set define the reflectance. Used in combination\n *   with emissive, specular, and shininess in setting the material\n *   properties of shapes.\n */\nquil.core$macros.ambient_int = (function quil$core$macros$ambient_int(rgb){\nreturn quil.core$macros.current_graphics.call(null).ambient((rgb | (0)));\n});\n/**\n * Sets the ambient reflectance for shapes drawn to the screen. This\n *   is combined with the ambient light component of environment. The\n *   color components set through the parameters define the\n *   reflectance. For example in the default color mode, setting x=255,\n *   y=126, z=0, would cause all the red light to reflect and half of the\n *   green light to reflect. Used in combination with emissive, specular,\n *   and shininess in setting the material properties of shapes.\n */\nquil.core$macros.ambient = (function quil$core$macros$ambient(var_args){\nvar args409 = [];\nvar len__13421__auto___412 = arguments.length;\nvar i__13422__auto___413 = (0);\nwhile(true){\nif((i__13422__auto___413 < len__13421__auto___412)){\nargs409.push((arguments[i__13422__auto___413]));\n\nvar G__414 = (i__13422__auto___413 + (1));\ni__13422__auto___413 = G__414;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__411 = args409.length;\nswitch (G__411) {\ncase (1):\nreturn quil.core$macros.ambient.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.ambient.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args409.length)].join('')));\n\n}\n});\n\nquil.core$macros.ambient.cljs$core$IFn$_invoke$arity$1 = (function (rgb){\nreturn quil.core$macros.ambient_float.call(null,rgb);\n});\n\nquil.core$macros.ambient.cljs$core$IFn$_invoke$arity$3 = (function (x,y,z){\nreturn quil.core$macros.ambient_float.call(null,x,y,z);\n});\n\nquil.core$macros.ambient.cljs$lang$maxFixedArity = (3);\n\n/**\n * Adds an ambient light. Ambient light doesn't come from a specific direction,\n *   the rays have light have bounced around so much that objects are\n *   evenly lit from all sides. Ambient lights are almost always used in\n *   combination with other types of lights. Lights need to be included\n *   in the draw to remain persistent in a looping program. Placing them\n *   in the setup of a looping program will cause them to only have an\n *   effect the first time through the loop. The effect of the\n *   parameters is determined by the current color mode.\n */\nquil.core$macros.ambient_light = (function quil$core$macros$ambient_light(var_args){\nvar args416 = [];\nvar len__13421__auto___419 = arguments.length;\nvar i__13422__auto___420 = (0);\nwhile(true){\nif((i__13422__auto___420 < len__13421__auto___419)){\nargs416.push((arguments[i__13422__auto___420]));\n\nvar G__421 = (i__13422__auto___420 + (1));\ni__13422__auto___420 = G__421;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__418 = args416.length;\nswitch (G__418) {\ncase (3):\nreturn quil.core$macros.ambient_light.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (6):\nreturn quil.core$macros.ambient_light.cljs$core$IFn$_invoke$arity$6((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args416.length)].join('')));\n\n}\n});\n\nquil.core$macros.ambient_light.cljs$core$IFn$_invoke$arity$3 = (function (red,green,blue){\nreturn quil.core$macros.current_graphics.call(null).ambientLight(red,green,blue);\n});\n\nquil.core$macros.ambient_light.cljs$core$IFn$_invoke$arity$6 = (function (red,green,blue,x,y,z){\nreturn quil.core$macros.current_graphics.call(null).ambientLight(red,green,blue,x,y,z);\n});\n\nquil.core$macros.ambient_light.cljs$lang$maxFixedArity = (6);\n\n/**\n * Multiplies the current matrix by the one specified through the\n *   parameters. This is very slow because it will try to calculate the\n *   inverse of the transform, so avoid it whenever possible. The\n *   equivalent function in OpenGL is glMultMatrix().\n */\nquil.core$macros.apply_matrix = (function quil$core$macros$apply_matrix(n00,n01,n02,n03,n10,n11,n12,n13,n20,n21,n22,n23,n30,n31,n32,n33){\nreturn quil.core$macros.current_graphics.call(null).applyMatrix(n00,n01,n02,n03,n10,n11,n12,n13,n20,n21,n22,n23,n30,n31,n32,n33);\n});\n/**\n * Draws an arc in the display window. Arcs are drawn along the outer\n *   edge of an ellipse defined by the x, y, width and height\n *   parameters. The origin or the arc's ellipse may be changed with the\n *   ellipse-mode function. The start and stop parameters specify the\n *   angles at which to draw the arc. The mode is either :open, :chord or :pie.\n */\nquil.core$macros.arc = (function quil$core$macros$arc(x,y,width,height,start,stop){\nreturn quil.core$macros.current_graphics.call(null).arc(x,y,width,height,start,stop);\n});\n/**\n * The inverse of sin, returns the arc sine of a value. This function\n *   expects the values in the range of -1 to 1 and values are returned\n *   in the range -PI/2 to PI/2.\n */\nquil.core$macros.asin = (function quil$core$macros$asin(n){\nreturn quil.sketch.current_applet.call(null).asin(n);\n});\n/**\n * The inverse of tan, returns the arc tangent of a value. This\n *   function expects the values in the range of -Infinity to\n *   Infinity (exclusive) and values are returned in the range -PI/2 to\n *   PI/2 .\n */\nquil.core$macros.atan = (function quil$core$macros$atan(n){\nreturn quil.sketch.current_applet.call(null).atan(n);\n});\n/**\n * Calculates the angle (in radians) from a specified point to the\n *   coordinate origin as measured from the positive x-axis. Values are\n *   returned as a float in the range from PI to -PI. The atan2 function\n *   is most often used for orienting geometry to the position of the\n *   cursor. Note: The y-coordinate of the point is the first parameter\n *   and the x-coordinate is the second due to the structure of\n *   calculating the tangent.\n */\nquil.core$macros.atan2 = (function quil$core$macros$atan2(y,x){\nreturn quil.sketch.current_applet.call(null).atan2(y,x);\n});\n/**\n * A sequence of strings representing the fonts on this system\n *   available for use.\n * \n *   Because of limitations in Java, not all fonts can be used and some\n *   might work with one operating system and not others. When sharing a\n *   sketch with other people or posting it on the web, you may need to\n *   include a .ttf or .otf version of your font in the data directory of\n *   the sketch because other people might not have the font installed on\n *   their computer. Only fonts that can legally be distributed should be\n *   included with a sketch.\n */\nquil.core$macros.available_fonts = (function quil$core$macros$available_fonts(){\nreturn cljs.core.seq.call(null,PFont.list());\n});\n/**\n * Sets the color used for the background of the Processing\n *   window. The default background is light gray. In the draw function,\n *   the background color is used to clear the display window at the\n *   beginning of each frame.\n * \n *   It is not possible to use transparency (alpha) in background colors\n *   with the main drawing surface, however they will work properly with\n *   create-graphics. Converts args to floats.\n */\nquil.core$macros.background_float = (function quil$core$macros$background_float(var_args){\nvar args423 = [];\nvar len__13421__auto___426 = arguments.length;\nvar i__13422__auto___427 = (0);\nwhile(true){\nif((i__13422__auto___427 < len__13421__auto___426)){\nargs423.push((arguments[i__13422__auto___427]));\n\nvar G__428 = (i__13422__auto___427 + (1));\ni__13422__auto___427 = G__428;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__425 = args423.length;\nswitch (G__425) {\ncase (1):\nreturn quil.core$macros.background_float.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.background_float.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.background_float.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core$macros.background_float.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args423.length)].join('')));\n\n}\n});\n\nquil.core$macros.background_float.cljs$core$IFn$_invoke$arity$1 = (function (gray){\nreturn quil.core$macros.current_graphics.call(null).background(gray);\n});\n\nquil.core$macros.background_float.cljs$core$IFn$_invoke$arity$2 = (function (gray,alpha){\nreturn quil.core$macros.current_graphics.call(null).background(gray,alpha);\n});\n\nquil.core$macros.background_float.cljs$core$IFn$_invoke$arity$3 = (function (r,g,b){\nreturn quil.core$macros.current_graphics.call(null).background(r,g,b);\n});\n\nquil.core$macros.background_float.cljs$core$IFn$_invoke$arity$4 = (function (r,g,b,a){\nreturn quil.core$macros.current_graphics.call(null).background(r,g,b,a);\n});\n\nquil.core$macros.background_float.cljs$lang$maxFixedArity = (4);\n\n/**\n * Sets the color used for the background of the Processing\n *   window. The default background is light gray. In the draw function,\n *   the background color is used to clear the display window at the\n *   beginning of each frame.\n * \n *   It is not possible to use transparency (alpha) in background colors\n *   with the main drawing surface, however they will work properly with\n *   create-graphics. Converts rgb to an int and alpha to a float.\n */\nquil.core$macros.background_int = (function quil$core$macros$background_int(var_args){\nvar args430 = [];\nvar len__13421__auto___433 = arguments.length;\nvar i__13422__auto___434 = (0);\nwhile(true){\nif((i__13422__auto___434 < len__13421__auto___433)){\nargs430.push((arguments[i__13422__auto___434]));\n\nvar G__435 = (i__13422__auto___434 + (1));\ni__13422__auto___434 = G__435;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__432 = args430.length;\nswitch (G__432) {\ncase (1):\nreturn quil.core$macros.background_int.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.background_int.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args430.length)].join('')));\n\n}\n});\n\nquil.core$macros.background_int.cljs$core$IFn$_invoke$arity$1 = (function (rgb){\nreturn quil.core$macros.current_graphics.call(null).background(cljs.core.unchecked_int.call(null,rgb));\n});\n\nquil.core$macros.background_int.cljs$core$IFn$_invoke$arity$2 = (function (rgb,alpha){\nreturn quil.core$macros.current_graphics.call(null).background(cljs.core.unchecked_int.call(null,rgb),alpha);\n});\n\nquil.core$macros.background_int.cljs$lang$maxFixedArity = (2);\n\n/**\n * Sets the color used for the background of the Processing\n *   window. The default background is light gray. In the draw function,\n *   the background color is used to clear the display window at the\n *   beginning of each frame.\n * \n *   It is not possible to use transparency (alpha) in background colors\n *   with the main drawing surface, however they will work properly with\n *   create-graphics. Converts args to floats.\n */\nquil.core$macros.background = (function quil$core$macros$background(var_args){\nvar args437 = [];\nvar len__13421__auto___440 = arguments.length;\nvar i__13422__auto___441 = (0);\nwhile(true){\nif((i__13422__auto___441 < len__13421__auto___440)){\nargs437.push((arguments[i__13422__auto___441]));\n\nvar G__442 = (i__13422__auto___441 + (1));\ni__13422__auto___441 = G__442;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__439 = args437.length;\nswitch (G__439) {\ncase (1):\nreturn quil.core$macros.background.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.background.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.background.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core$macros.background.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args437.length)].join('')));\n\n}\n});\n\nquil.core$macros.background.cljs$core$IFn$_invoke$arity$1 = (function (rgb){\nreturn quil.core$macros.current_graphics.call(null).background(rgb);\n});\n\nquil.core$macros.background.cljs$core$IFn$_invoke$arity$2 = (function (rgb,alpha){\nreturn quil.core$macros.current_graphics.call(null).background(rgb,alpha);\n});\n\nquil.core$macros.background.cljs$core$IFn$_invoke$arity$3 = (function (r,g,b){\nreturn quil.core$macros.background_float.call(null,r,g,b);\n});\n\nquil.core$macros.background.cljs$core$IFn$_invoke$arity$4 = (function (r,g,b,a){\nreturn quil.core$macros.background_float.call(null,r,g,b,a);\n});\n\nquil.core$macros.background.cljs$lang$maxFixedArity = (4);\n\n/**\n * Specify an image to be used as the background for a sketch. Its\n *   width and height must be the same size as the sketch window. Images\n *   used as background will ignore the current tint setting.\n */\nquil.core$macros.background_image = (function quil$core$macros$background_image(img){\nreturn quil.core$macros.current_graphics.call(null).background(img);\n});\n/**\n * Sets the matrix mode to the camera matrix so calls such as\n *   translate, rotate, apply-matrix and reset-matrix affect the\n *   camera. begin-camera should always be used with a following\n *   end-camera and pairs of begin-camera and end-camera cannot be\n *   nested.\n * \n *   For most situations the camera function will be sufficient.\n */\nquil.core$macros.begin_camera = (function quil$core$macros$begin_camera(){\nreturn quil.core$macros.current_graphics.call(null).beginCamera();\n});\n/**\n * Use the begin-contour and end-contour function to create negative\n *   shapes within shapes. These functions can only be within a\n *   begin-shape/end-shape pair and they only work with the :p2d and :p3d\n *   renderers.\n */\nquil.core$macros.begin_contour = (function quil$core$macros$begin_contour(){\nreturn quil.core$macros.current_graphics.call(null).beginContour();\n});\n/**\n * Enables the creation of complex forms. begin-shape begins recording\n *   vertices for a shape and end-shape stops recording. Use the mode\n *   keyword to specify which shape create from the provided\n *   vertices. With no mode specified, the shape can be any irregular\n *   polygon.\n * \n *   The available mode keywords are :points, :lines, :triangles,\n *                                :triangle-fan, :triangle-strip,\n *                                :quads, :quad-strip.\n * \n *   After calling the begin-shape function, a series of vertex commands\n *   must follow. To stop drawing the shape, call end-shape. The vertex\n *   function with two parameters specifies a position in 2D and the\n *   vertex function with three parameters specifies a position in\n *   3D. Each shape will be outlined with the current stroke color and\n *   filled with the fill color.\n * \n *   Transformations such as translate, rotate, and scale do not work\n *   within begin-shape. It is also not possible to use other shapes,\n *   such as ellipse or rect within begin-shape.\n */\nquil.core$macros.begin_shape = (function quil$core$macros$begin_shape(var_args){\nvar args444 = [];\nvar len__13421__auto___447 = arguments.length;\nvar i__13422__auto___448 = (0);\nwhile(true){\nif((i__13422__auto___448 < len__13421__auto___447)){\nargs444.push((arguments[i__13422__auto___448]));\n\nvar G__449 = (i__13422__auto___448 + (1));\ni__13422__auto___448 = G__449;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__446 = args444.length;\nswitch (G__446) {\ncase (0):\nreturn quil.core$macros.begin_shape.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase (1):\nreturn quil.core$macros.begin_shape.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args444.length)].join('')));\n\n}\n});\n\nquil.core$macros.begin_shape.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn quil.core$macros.current_graphics.call(null).beginShape();\n});\n\nquil.core$macros.begin_shape.cljs$core$IFn$_invoke$arity$1 = (function (mode){\nvar mode__$1 = quil.util.resolve_constant_key.call(null,mode,quil.core$macros.shape_modes);\nreturn quil.core$macros.current_graphics.call(null).beginShape((mode__$1 | (0)));\n});\n\nquil.core$macros.begin_shape.cljs$lang$maxFixedArity = (1);\n\n/**\n * Draws a Bezier curve on the screen. These curves are defined by a\n *   series of anchor and control points. The first two parameters\n *   specify the first anchor point and the last two parameters specify\n *   the other anchor point. The middle parameters specify the control\n *   points which define the shape of the curve.\n */\nquil.core$macros.bezier = (function quil$core$macros$bezier(var_args){\nvar args451 = [];\nvar len__13421__auto___454 = arguments.length;\nvar i__13422__auto___455 = (0);\nwhile(true){\nif((i__13422__auto___455 < len__13421__auto___454)){\nargs451.push((arguments[i__13422__auto___455]));\n\nvar G__456 = (i__13422__auto___455 + (1));\ni__13422__auto___455 = G__456;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__453 = args451.length;\nswitch (G__453) {\ncase (8):\nreturn quil.core$macros.bezier.cljs$core$IFn$_invoke$arity$8((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]));\n\nbreak;\ncase (12):\nreturn quil.core$macros.bezier.cljs$core$IFn$_invoke$arity$12((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]),(arguments[(8)]),(arguments[(9)]),(arguments[(10)]),(arguments[(11)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args451.length)].join('')));\n\n}\n});\n\nquil.core$macros.bezier.cljs$core$IFn$_invoke$arity$8 = (function (x1,y1,cx1,cy1,cx2,cy2,x2,y2){\nreturn quil.core$macros.current_graphics.call(null).bezier(x1,y1,cx1,cy1,cx2,cy2,x2,y2);\n});\n\nquil.core$macros.bezier.cljs$core$IFn$_invoke$arity$12 = (function (x1,y1,z1,cx1,cy1,cz1,cx2,cy2,cz2,x2,y2,z2){\nreturn quil.core$macros.current_graphics.call(null).bezier(x1,y1,z1,cx1,cy1,cz1,cx2,cy2,cz2,x2,y2,z2);\n});\n\nquil.core$macros.bezier.cljs$lang$maxFixedArity = (12);\n\n/**\n * Sets the resolution at which Beziers display. The default value is\n *   20. This function is only useful when using the :p3d or :opengl\n *   renderer as the default (:java2d) renderer does not use this\n *   information.\n */\nquil.core$macros.bezier_detail = (function quil$core$macros$bezier_detail(detail){\nreturn quil.core$macros.current_graphics.call(null).bezierDetail((detail | (0)));\n});\n/**\n * Evaluates the Bezier at point t for points a, b, c, d. The\n *   parameter t varies between 0 and 1, a and d are points on the curve,\n *   and b and c are the control points. This can be done once with the x\n *   coordinates and a second time with the y coordinates to get the\n *   location of a bezier curve at t.\n */\nquil.core$macros.bezier_point = (function quil$core$macros$bezier_point(a,b,c,d,t){\nreturn quil.core$macros.current_graphics.call(null).bezierPoint(a,b,c,d,t);\n});\n/**\n * Calculates the tangent of a point on a Bezier curve.\n *   (See http://en.wikipedia.org/wiki/Tangent)\n */\nquil.core$macros.bezier_tangent = (function quil$core$macros$bezier_tangent(a,b,c,d,t){\nreturn quil.core$macros.current_graphics.call(null).bezierTangent(a,b,c,d,t);\n});\n/**\n * Specifies vertex coordinates for Bezier curves. Each call to\n *   bezier-vertex defines the position of two control points and one\n *   anchor point of a Bezier curve, adding a new segment to a line or\n *   shape. The first time bezier-vertex is used within a begin-shape\n *   call, it must be prefaced with a call to vertex to set the first\n *   anchor point. This function must be used between begin-shape and\n *   end-shape and only when there is no parameter specified to\n *   begin-shape.\n */\nquil.core$macros.bezier_vertex = (function quil$core$macros$bezier_vertex(var_args){\nvar args458 = [];\nvar len__13421__auto___461 = arguments.length;\nvar i__13422__auto___462 = (0);\nwhile(true){\nif((i__13422__auto___462 < len__13421__auto___461)){\nargs458.push((arguments[i__13422__auto___462]));\n\nvar G__463 = (i__13422__auto___462 + (1));\ni__13422__auto___462 = G__463;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__460 = args458.length;\nswitch (G__460) {\ncase (6):\nreturn quil.core$macros.bezier_vertex.cljs$core$IFn$_invoke$arity$6((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]));\n\nbreak;\ncase (9):\nreturn quil.core$macros.bezier_vertex.cljs$core$IFn$_invoke$arity$9((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]),(arguments[(8)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args458.length)].join('')));\n\n}\n});\n\nquil.core$macros.bezier_vertex.cljs$core$IFn$_invoke$arity$6 = (function (cx1,cy1,cx2,cy2,x,y){\nreturn quil.core$macros.current_graphics.call(null).bezierVertex(cx1,cy1,cx2,cy2,x,y);\n});\n\nquil.core$macros.bezier_vertex.cljs$core$IFn$_invoke$arity$9 = (function (cx1,cy1,cz1,cx2,cy2,cz2,x,y,z){\nreturn quil.core$macros.current_graphics.call(null).bezierVertex(cx1,cy1,cz1,cx2,cy2,cz2,x,y,z);\n});\n\nquil.core$macros.bezier_vertex.cljs$lang$maxFixedArity = (9);\n\n/**\n * Returns a string representing the binary value of an int, char or\n *   byte. When converting an int to a string, it is possible to specify\n *   the number of digits used.\n */\nquil.core$macros.binary = (function quil$core$macros$binary(var_args){\nvar args465 = [];\nvar len__13421__auto___468 = arguments.length;\nvar i__13422__auto___469 = (0);\nwhile(true){\nif((i__13422__auto___469 < len__13421__auto___468)){\nargs465.push((arguments[i__13422__auto___469]));\n\nvar G__470 = (i__13422__auto___469 + (1));\ni__13422__auto___469 = G__470;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__467 = args465.length;\nswitch (G__467) {\ncase (1):\nreturn quil.core$macros.binary.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.binary.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args465.length)].join('')));\n\n}\n});\n\nquil.core$macros.binary.cljs$core$IFn$_invoke$arity$1 = (function (val){\nreturn quil.sketch.current_applet.call(null).binary(val);\n});\n\nquil.core$macros.binary.cljs$core$IFn$_invoke$arity$2 = (function (val,num_digits){\nreturn quil.sketch.current_applet.call(null).binary(val,num_digits);\n});\n\nquil.core$macros.binary.cljs$lang$maxFixedArity = (2);\n\n/**\n * Blends a region of pixels from one image into another with full alpha\n *   channel support. If src is not specified it defaults to current-graphics.\n *   If dest is not specified it defaults to current-graphics.\n * \n *   Note: blend-mode function is recommended to use instead of this one.\n * \n *   Available blend modes are:\n * \n *   :blend      - linear interpolation of colours: C = A*factor + B\n *   :add        - additive blending with white clip:\n *                                          C = min(A*factor + B, 255)\n *   :subtract   - subtractive blending with black clip:\n *                                          C = max(B - A*factor, 0)\n *   :darkest    - only the darkest colour succeeds:\n *                                          C = min(A*factor, B)\n *   :lightest   - only the lightest colour succeeds:\n *                                          C = max(A*factor, B)\n *   :difference - subtract colors from underlying image.\n *   :exclusion  - similar to :difference, but less extreme.\n *   :multiply   - Multiply the colors, result will always be darker.\n *   :screen     - Opposite multiply, uses inverse values of the colors.\n *   :overlay    - A mix of :multiply and :screen. Multiplies dark values\n *              and screens light values.\n *   :hard-light - :screen when greater than 50% gray, :multiply when\n *              lower.\n *   :soft-light - Mix of :darkest and :lightest. Works like :overlay,\n *              but not as harsh.\n *   :dodge      - Lightens light tones and increases contrast, ignores\n *              darks.\n *              Called \"Color Dodge\" in Illustrator and Photoshop.\n *   :burn       - Darker areas are applied, increasing contrast, ignores\n *              lights. Called \"Color Burn\" in Illustrator and\n *              Photoshop.\n */\nquil.core$macros.blend = (function quil$core$macros$blend(var_args){\nvar args472 = [];\nvar len__13421__auto___475 = arguments.length;\nvar i__13422__auto___476 = (0);\nwhile(true){\nif((i__13422__auto___476 < len__13421__auto___475)){\nargs472.push((arguments[i__13422__auto___476]));\n\nvar G__477 = (i__13422__auto___476 + (1));\ni__13422__auto___476 = G__477;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__474 = args472.length;\nswitch (G__474) {\ncase (9):\nreturn quil.core$macros.blend.cljs$core$IFn$_invoke$arity$9((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]),(arguments[(8)]));\n\nbreak;\ncase (10):\nreturn quil.core$macros.blend.cljs$core$IFn$_invoke$arity$10((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]),(arguments[(8)]),(arguments[(9)]));\n\nbreak;\ncase (11):\nreturn quil.core$macros.blend.cljs$core$IFn$_invoke$arity$11((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]),(arguments[(8)]),(arguments[(9)]),(arguments[(10)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args472.length)].join('')));\n\n}\n});\n\nquil.core$macros.blend.cljs$core$IFn$_invoke$arity$9 = (function (x,y,width,height,dx,dy,dwidth,dheight,mode){\nreturn quil.core$macros.blend.call(null,quil.core$macros.current_graphics.call(null),quil.core$macros.current_graphics.call(null),x,y,width,height,dx,dy,dwidth,dheight,mode);\n});\n\nquil.core$macros.blend.cljs$core$IFn$_invoke$arity$10 = (function (src_img,x,y,width,height,dx,dy,dwidth,dheight,mode){\nreturn quil.core$macros.blend.call(null,src_img,quil.core$macros.current_graphics.call(null),x,y,width,height,dx,dy,dwidth,dheight,mode);\n});\n\nquil.core$macros.blend.cljs$core$IFn$_invoke$arity$11 = (function (src_img,dest_img,x,y,width,height,dx,dy,dwidth,dheight,mode){\nvar mode__$1 = quil.util.resolve_constant_key.call(null,mode,quil.core$macros.blend_modes);\nreturn dest_img.blend(src_img,(x | (0)),(y | (0)),(width | (0)),(height | (0)),(dx | (0)),(dy | (0)),(dwidth | (0)),(dheight | (0)),(mode__$1 | (0)));\n});\n\nquil.core$macros.blend.cljs$lang$maxFixedArity = (11);\n\n/**\n * Blends two color values together based on the blending mode given specified\n *   with the mode keyword.\n * \n *   Available blend modes are:\n * \n *   :blend      - linear interpolation of colours: C = A*factor + B\n *   :add        - additive blending with white clip:\n *                                          C = min(A*factor + B, 255)\n *   :subtract   - subtractive blending with black clip:\n *                                          C = max(B - A*factor, 0)\n *   :darkest    - only the darkest colour succeeds:\n *                                          C = min(A*factor, B)\n *   :lightest   - only the lightest colour succeeds:\n *                                          C = max(A*factor, B)\n *   :difference - subtract colors from underlying image.\n *   :exclusion  - similar to :difference, but less extreme.\n *   :multiply   - Multiply the colors, result will always be darker.\n *   :screen     - Opposite multiply, uses inverse values of the colors.\n *   :overlay    - A mix of :multiply and :screen. Multiplies dark values\n *              and screens light values.\n *   :hard-light - :screen when greater than 50% gray, :multiply when\n *              lower.\n *   :soft-light - Mix of :darkest and :lightest. Works like :overlay,\n *              but not as harsh.\n *   :dodge      - Lightens light tones and increases contrast, ignores\n *              darks.\n *              Called \"Color Dodge\" in Illustrator and Photoshop.\n *   :burn       - Darker areas are applied, increasing contrast, ignores\n *              lights. Called \"Color Burn\" in Illustrator and\n *              Photoshop.\n */\nquil.core$macros.blend_color = (function quil$core$macros$blend_color(c1,c2,mode){\nvar mode__$1 = quil.util.resolve_constant_key.call(null,mode,quil.core$macros.blend_modes);\nreturn quil.core$macros.current_graphics.call(null).blendColor(c1,c2,mode__$1);\n});\n/**\n * Extracts the blue value from a color, scaled to match current color-mode.\n *   Returns a float.\n */\nquil.core$macros.blue = (function quil$core$macros$blue(color){\nreturn quil.core$macros.current_graphics.call(null).blue(cljs.core.unchecked_int.call(null,color));\n});\n/**\n * Creates an extruded rectangle.\n */\nquil.core$macros.box = (function quil$core$macros$box(var_args){\nvar args479 = [];\nvar len__13421__auto___482 = arguments.length;\nvar i__13422__auto___483 = (0);\nwhile(true){\nif((i__13422__auto___483 < len__13421__auto___482)){\nargs479.push((arguments[i__13422__auto___483]));\n\nvar G__484 = (i__13422__auto___483 + (1));\ni__13422__auto___483 = G__484;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__481 = args479.length;\nswitch (G__481) {\ncase (1):\nreturn quil.core$macros.box.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.box.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args479.length)].join('')));\n\n}\n});\n\nquil.core$macros.box.cljs$core$IFn$_invoke$arity$1 = (function (size){\nreturn quil.core$macros.current_graphics.call(null).box(size);\n});\n\nquil.core$macros.box.cljs$core$IFn$_invoke$arity$3 = (function (width,height,depth){\nreturn quil.core$macros.current_graphics.call(null).box(width,height,depth);\n});\n\nquil.core$macros.box.cljs$lang$maxFixedArity = (3);\n\n/**\n * Extracts the brightness value from a color. Returns a float.\n */\nquil.core$macros.brightness = (function quil$core$macros$brightness(color){\nreturn quil.core$macros.current_graphics.call(null).brightness(cljs.core.unchecked_int.call(null,color));\n});\n/**\n * Sets the position of the camera through setting the eye position,\n *   the center of the scene, and which axis is facing upward. Moving the\n *   eye position and the direction it is pointing (the center of the\n *   scene) allows the images to be seen from different angles. The\n *   version without any parameters sets the camera to the default\n *   position, pointing to the center of the display window with the Y\n *   axis as up. The default values are:\n * \n *   eyeX:     (/ (width) 2.0)\n *   eyeY:     (/ (height) 2.0)\n *   eyeZ:     (/ (/ (height) 2.0) (tan (/ (* Math/PI 60.0) 360.0)))\n *   centerX:  (/ (width) 2.0)\n *   centerY:  (/ (height) 2.0)\n *   centerZ:  0\n *   upX:      0\n *   upY:      1\n *   upZ:      0\n * \n *   Similar imilar to gluLookAt() in OpenGL, but it first clears the\n *   current camera settings.\n */\nquil.core$macros.camera = (function quil$core$macros$camera(var_args){\nvar args486 = [];\nvar len__13421__auto___489 = arguments.length;\nvar i__13422__auto___490 = (0);\nwhile(true){\nif((i__13422__auto___490 < len__13421__auto___489)){\nargs486.push((arguments[i__13422__auto___490]));\n\nvar G__491 = (i__13422__auto___490 + (1));\ni__13422__auto___490 = G__491;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__488 = args486.length;\nswitch (G__488) {\ncase (0):\nreturn quil.core$macros.camera.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase (9):\nreturn quil.core$macros.camera.cljs$core$IFn$_invoke$arity$9((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]),(arguments[(8)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args486.length)].join('')));\n\n}\n});\n\nquil.core$macros.camera.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn quil.core$macros.current_graphics.call(null).camera();\n});\n\nquil.core$macros.camera.cljs$core$IFn$_invoke$arity$9 = (function (eyeX,eyeY,eyeZ,centerX,centerY,centerZ,upX,upY,upZ){\nreturn quil.core$macros.current_graphics.call(null).camera(eyeX,eyeY,eyeZ,centerX,centerY,centerZ,upX,upY,upZ);\n});\n\nquil.core$macros.camera.cljs$lang$maxFixedArity = (9);\n\n/**\n * Calculates the closest int value that is greater than or equal to\n *   the value of the parameter. For example, (ceil 9.03) returns the\n *   value 10.\n */\nquil.core$macros.ceil = (function quil$core$macros$ceil(n){\nreturn quil.sketch.current_applet.call(null).ceil(n);\n});\n/**\n * Creates an integer representation of a color The parameters are\n *   interpreted as RGB or HSB values depending on the current\n *   color-mode. The default mode is RGB values from 0 to 255 and\n *   therefore, the function call (color 255 204 0) will return a bright\n *   yellow. Args are cast to floats.\n * \n *   r - red or hue value\n *   g - green or saturation value\n *   b - blue or brightness value\n *   a - alpha value\n */\nquil.core$macros.color = (function quil$core$macros$color(var_args){\nvar args493 = [];\nvar len__13421__auto___496 = arguments.length;\nvar i__13422__auto___497 = (0);\nwhile(true){\nif((i__13422__auto___497 < len__13421__auto___496)){\nargs493.push((arguments[i__13422__auto___497]));\n\nvar G__498 = (i__13422__auto___497 + (1));\ni__13422__auto___497 = G__498;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__495 = args493.length;\nswitch (G__495) {\ncase (1):\nreturn quil.core$macros.color.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.color.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.color.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core$macros.color.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args493.length)].join('')));\n\n}\n});\n\nquil.core$macros.color.cljs$core$IFn$_invoke$arity$1 = (function (gray){\nreturn quil.core$macros.current_graphics.call(null).color(gray);\n});\n\nquil.core$macros.color.cljs$core$IFn$_invoke$arity$2 = (function (gray,alpha){\nreturn quil.core$macros.current_graphics.call(null).color(gray,alpha);\n});\n\nquil.core$macros.color.cljs$core$IFn$_invoke$arity$3 = (function (r,g,b){\nreturn quil.core$macros.current_graphics.call(null).color(r,g,b);\n});\n\nquil.core$macros.color.cljs$core$IFn$_invoke$arity$4 = (function (r,g,b,a){\nreturn quil.core$macros.current_graphics.call(null).color(r,g,b,a);\n});\n\nquil.core$macros.color.cljs$lang$maxFixedArity = (4);\n\n/**\n * Changes the way Processing interprets color data. Available modes\n *   are :rgb and :hsb.By default, the parameters for fill, stroke,\n *   background, and color are defined by values between 0 and 255 using\n *   the :rgb color model. The color-mode fn is used to change the\n *   numerical range used for specifying colors and to switch color\n *   systems. For example, calling\n *   (color-mode :rgb 1.0) will specify that values are specified between\n *   0 and 1. The limits for defining colors are altered by setting the\n *   parameters range1, range2, range3, and range 4.\n */\nquil.core$macros.color_mode = (function quil$core$macros$color_mode(var_args){\nvar args500 = [];\nvar len__13421__auto___503 = arguments.length;\nvar i__13422__auto___504 = (0);\nwhile(true){\nif((i__13422__auto___504 < len__13421__auto___503)){\nargs500.push((arguments[i__13422__auto___504]));\n\nvar G__505 = (i__13422__auto___504 + (1));\ni__13422__auto___504 = G__505;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__502 = args500.length;\nswitch (G__502) {\ncase (1):\nreturn quil.core$macros.color_mode.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.color_mode.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (4):\nreturn quil.core$macros.color_mode.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase (5):\nreturn quil.core$macros.color_mode.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args500.length)].join('')));\n\n}\n});\n\nquil.core$macros.color_mode.cljs$core$IFn$_invoke$arity$1 = (function (mode){\nvar mode__$1 = quil.util.resolve_constant_key.call(null,mode,quil.core$macros.color_modes);\nreturn quil.core$macros.current_graphics.call(null).colorMode((mode__$1 | (0)));\n});\n\nquil.core$macros.color_mode.cljs$core$IFn$_invoke$arity$2 = (function (mode,max){\nvar mode__$1 = quil.util.resolve_constant_key.call(null,mode,quil.core$macros.color_modes);\nreturn quil.core$macros.current_graphics.call(null).colorMode((mode__$1 | (0)),max);\n});\n\nquil.core$macros.color_mode.cljs$core$IFn$_invoke$arity$4 = (function (mode,max_x,max_y,max_z){\nvar mode__$1 = quil.util.resolve_constant_key.call(null,mode,quil.core$macros.color_modes);\nreturn quil.core$macros.current_graphics.call(null).colorMode((mode__$1 | (0)),max_x,max_y,max_z);\n});\n\nquil.core$macros.color_mode.cljs$core$IFn$_invoke$arity$5 = (function (mode,max_x,max_y,max_z,max_a){\nvar mode__$1 = quil.util.resolve_constant_key.call(null,mode,quil.core$macros.color_modes);\nreturn quil.core$macros.current_graphics.call(null).colorMode((mode__$1 | (0)),max_x,max_y,max_z,max_a);\n});\n\nquil.core$macros.color_mode.cljs$lang$maxFixedArity = (5);\n\n/**\n * Constrains a value to not exceed a maximum and minimum value.\n */\nquil.core$macros.constrain = (function quil$core$macros$constrain(amt,low,high){\nreturn quil.sketch.current_applet.call(null).constrain(amt,low,high);\n});\n/**\n * Copies a region of pixels from the one image to another. If src-img\n *   is not specified it defaults to current-graphics. If dest-img is not\n *   specified - it defaults to current-graphics. If the source\n *   and destination regions aren't the same size, it will automatically\n *   resize the source pixels to fit the specified target region. No\n *   alpha information is used in the process, however if the source\n *   image has an alpha channel set, it will be copied as well. \n */\nquil.core$macros.copy = (function quil$core$macros$copy(var_args){\nvar args507 = [];\nvar len__13421__auto___534 = arguments.length;\nvar i__13422__auto___535 = (0);\nwhile(true){\nif((i__13422__auto___535 < len__13421__auto___534)){\nargs507.push((arguments[i__13422__auto___535]));\n\nvar G__536 = (i__13422__auto___535 + (1));\ni__13422__auto___535 = G__536;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__509 = args507.length;\nswitch (G__509) {\ncase (2):\nreturn quil.core$macros.copy.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.copy.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core$macros.copy.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args507.length)].join('')));\n\n}\n});\n\nquil.core$macros.copy.cljs$core$IFn$_invoke$arity$2 = (function (p__510,p__511){\nvar vec__512 = p__510;\nvar sx = cljs.core.nth.call(null,vec__512,(0),null);\nvar sy = cljs.core.nth.call(null,vec__512,(1),null);\nvar swidth = cljs.core.nth.call(null,vec__512,(2),null);\nvar sheight = cljs.core.nth.call(null,vec__512,(3),null);\nvar vec__515 = p__511;\nvar dx = cljs.core.nth.call(null,vec__515,(0),null);\nvar dy = cljs.core.nth.call(null,vec__515,(1),null);\nvar dwidth = cljs.core.nth.call(null,vec__515,(2),null);\nvar dheight = cljs.core.nth.call(null,vec__515,(3),null);\nreturn quil.core$macros.current_graphics.call(null).copy((sx | (0)),(sy | (0)),(swidth | (0)),(sheight | (0)),(dx | (0)),(dy | (0)),(dwidth | (0)),(dheight | (0)));\n});\n\nquil.core$macros.copy.cljs$core$IFn$_invoke$arity$3 = (function (src_img,p__518,p__519){\nvar vec__520 = p__518;\nvar sx = cljs.core.nth.call(null,vec__520,(0),null);\nvar sy = cljs.core.nth.call(null,vec__520,(1),null);\nvar swidth = cljs.core.nth.call(null,vec__520,(2),null);\nvar sheight = cljs.core.nth.call(null,vec__520,(3),null);\nvar vec__523 = p__519;\nvar dx = cljs.core.nth.call(null,vec__523,(0),null);\nvar dy = cljs.core.nth.call(null,vec__523,(1),null);\nvar dwidth = cljs.core.nth.call(null,vec__523,(2),null);\nvar dheight = cljs.core.nth.call(null,vec__523,(3),null);\nreturn quil.core$macros.copy.call(null,src_img,quil.core$macros.current_graphics.call(null),new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [sx,sy,swidth,sheight], null),new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [dx,dy,dwidth,dheight], null));\n});\n\nquil.core$macros.copy.cljs$core$IFn$_invoke$arity$4 = (function (src_img,dest_img,p__526,p__527){\nvar vec__528 = p__526;\nvar sx = cljs.core.nth.call(null,vec__528,(0),null);\nvar sy = cljs.core.nth.call(null,vec__528,(1),null);\nvar swidth = cljs.core.nth.call(null,vec__528,(2),null);\nvar sheight = cljs.core.nth.call(null,vec__528,(3),null);\nvar vec__531 = p__527;\nvar dx = cljs.core.nth.call(null,vec__531,(0),null);\nvar dy = cljs.core.nth.call(null,vec__531,(1),null);\nvar dwidth = cljs.core.nth.call(null,vec__531,(2),null);\nvar dheight = cljs.core.nth.call(null,vec__531,(3),null);\nreturn dest_img.copy(src_img,(sx | (0)),(sy | (0)),(swidth | (0)),(sheight | (0)),(dx | (0)),(dy | (0)),(dwidth | (0)),(dheight | (0)));\n});\n\nquil.core$macros.copy.cljs$lang$maxFixedArity = (4);\n\n/**\n * Calculates the cosine of an angle. This function expects the values\n *   of the angle parameter to be provided in radians (values from 0 to\n *   Math/PI*2). Values are returned in the range -1 to 1.\n */\nquil.core$macros.cos = (function quil$core$macros$cos(angle){\nreturn quil.sketch.current_applet.call(null).cos(angle);\n});\n/**\n * Dynamically converts a font to the format used by Processing (a\n *   PFont) from either a font name that's installed on the computer, or\n *   from a .ttf or .otf file inside the sketches 'data' folder. This\n *   function is an advanced feature for precise control.\n * \n *   Use available-fonts to obtain the names for the fonts recognized by\n *   the computer and are compatible with this function.\n * \n *   The size parameter states the font size you want to generate. The\n *   smooth parameter specifies if the font should be antialiased or not,\n *   and the charset parameter is an array of chars that specifies the\n *   characters to generate.\n * \n *   This function creates a bitmapped version of a font It loads a font\n *   by name, and converts it to a series of images based on the size of\n *   the font. When possible, the text function will use a native font\n *   rather than the bitmapped version created behind the scenes with\n *   create-font. For instance, when using the default renderer\n *   setting (JAVA2D), the actual native version of the font will be\n *   employed by the sketch, improving drawing quality and\n *   performance. With the :p2d, :p3d, and :opengl renderer settings, the\n *   bitmapped version will be used. While this can drastically improve\n *   speed and appearance, results are poor when exporting if the sketch\n *   does not include the .otf or .ttf file, and the requested font is\n *   not available on the machine running the sketch.\n */\nquil.core$macros.create_font = (function quil$core$macros$create_font(var_args){\nvar args538 = [];\nvar len__13421__auto___541 = arguments.length;\nvar i__13422__auto___542 = (0);\nwhile(true){\nif((i__13422__auto___542 < len__13421__auto___541)){\nargs538.push((arguments[i__13422__auto___542]));\n\nvar G__543 = (i__13422__auto___542 + (1));\ni__13422__auto___542 = G__543;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__540 = args538.length;\nswitch (G__540) {\ncase (2):\nreturn quil.core$macros.create_font.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.create_font.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core$macros.create_font.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args538.length)].join('')));\n\n}\n});\n\nquil.core$macros.create_font.cljs$core$IFn$_invoke$arity$2 = (function (name,size){\nreturn quil.sketch.current_applet.call(null).createFont([cljs.core.str(name)].join(''),size);\n});\n\nquil.core$macros.create_font.cljs$core$IFn$_invoke$arity$3 = (function (name,size,smooth){\nreturn quil.sketch.current_applet.call(null).createFont([cljs.core.str(name)].join(''),size,smooth);\n});\n\nquil.core$macros.create_font.cljs$core$IFn$_invoke$arity$4 = (function (name,size,smooth,charset){\nreturn quil.sketch.current_applet.call(null).createFont([cljs.core.str(name)].join(''),size,smooth,charset);\n});\n\nquil.core$macros.create_font.cljs$lang$maxFixedArity = (4);\n\n/**\n * Creates and returns a new PGraphics object of the types :p2d, :p3d,\n *   :java2d, :pdf. By default :java2d is used. Use this class if you\n *   need to draw into an off-screen graphics buffer. It's not possible\n *   to use create-graphics with the :opengl renderer, because it doesn't\n *   allow offscreen use. The :pdf renderer requires the filename parameter.\n * \n *   Note: don't use create-graphics in draw in clojurescript, it leaks memory.\n *   You should create graphic in setup and reuse it in draw instead of creating\n *   a new one.\n * \n *   It's important to call any drawing commands between (.beginDraw graphics) and\n *   (.endDraw graphics) statements or use with-graphics macro. This is also true\n *   for any commands that affect drawing, such as smooth or color-mode.\n * \n *   If you're using :pdf renderer - don't forget to call (.dispose graphics)\n *   as last command inside with-graphics macro, otherwise graphics won't be\n *   saved.\n * \n *   Unlike the main drawing surface which is completely opaque, surfaces\n *   created with create-graphics can have transparency. This makes it\n *   possible to draw into a graphics and maintain the alpha channel. By\n *   using save to write a PNG or TGA file, the transparency of the\n *   graphics object will be honored.\n */\nquil.core$macros.create_graphics = (function quil$core$macros$create_graphics(var_args){\nvar args545 = [];\nvar len__13421__auto___548 = arguments.length;\nvar i__13422__auto___549 = (0);\nwhile(true){\nif((i__13422__auto___549 < len__13421__auto___548)){\nargs545.push((arguments[i__13422__auto___549]));\n\nvar G__550 = (i__13422__auto___549 + (1));\ni__13422__auto___549 = G__550;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__547 = args545.length;\nswitch (G__547) {\ncase (2):\nreturn quil.core$macros.create_graphics.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.create_graphics.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core$macros.create_graphics.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args545.length)].join('')));\n\n}\n});\n\nquil.core$macros.create_graphics.cljs$core$IFn$_invoke$arity$2 = (function (w,h){\nreturn quil.sketch.current_applet.call(null).createGraphics((w | (0)),(h | (0)),new cljs.core.Keyword(null,\"p2d\",\"p2d\",(-2106175755)));\n});\n\nquil.core$macros.create_graphics.cljs$core$IFn$_invoke$arity$3 = (function (w,h,renderer){\nreturn quil.sketch.current_applet.call(null).createGraphics((w | (0)),(h | (0)),quil.sketch.resolve_renderer.call(null,renderer));\n});\n\nquil.core$macros.create_graphics.cljs$core$IFn$_invoke$arity$4 = (function (w,h,renderer,path){\nreturn quil.sketch.current_applet.call(null).createGraphics((w | (0)),(h | (0)),quil.sketch.resolve_renderer.call(null,renderer),path);\n});\n\nquil.core$macros.create_graphics.cljs$lang$maxFixedArity = (4);\n\n/**\n * Creates a new PImage (the datatype for storing images). This\n *   provides a fresh buffer of pixels to play with. Set the size of the\n *   buffer with the width and height parameters. The format parameter\n *   defines how the pixels are stored. See the PImage reference for more\n *   information.\n * \n *   Possible formats: :rgb, :argb, :alpha (grayscale alpha channel)\n * \n *   Prefer using create-image over initialising new PImage instances\n *   directly.\n */\nquil.core$macros.create_image = (function quil$core$macros$create_image(w,h,format){\nvar format__$1 = quil.util.resolve_constant_key.call(null,format,quil.core$macros.image_formats);\nreturn quil.sketch.current_applet.call(null).createImage((w | (0)),(h | (0)),(format__$1 | (0)));\n});\n/**\n * Return the current fill color.\n */\nquil.core$macros.current_fill = (function quil$core$macros$current_fill(){\nreturn quil.core$macros.current_graphics.call(null).fillColor();\n});\n/**\n * Return the current stroke color.\n */\nquil.core$macros.current_stroke = (function quil$core$macros$current_stroke(){\nreturn quil.core$macros.current_graphics.call(null).strokeColor();\n});\n/**\n * Sets the cursor to a predefined symbol or makes it\n *   visible if already hidden (after no-cursor was called).\n * \n *   Available modes: :arrow, :cross, :hand, :move, :text, :wait\n * \n *   See cursor-image for specifying a generic image as the cursor\n *   symbol.\n */\nquil.core$macros.cursor = (function quil$core$macros$cursor(var_args){\nvar args552 = [];\nvar len__13421__auto___555 = arguments.length;\nvar i__13422__auto___556 = (0);\nwhile(true){\nif((i__13422__auto___556 < len__13421__auto___555)){\nargs552.push((arguments[i__13422__auto___556]));\n\nvar G__557 = (i__13422__auto___556 + (1));\ni__13422__auto___556 = G__557;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__554 = args552.length;\nswitch (G__554) {\ncase (0):\nreturn quil.core$macros.cursor.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase (1):\nreturn quil.core$macros.cursor.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args552.length)].join('')));\n\n}\n});\n\nquil.core$macros.cursor.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn quil.sketch.current_applet.call(null).cursor();\n});\n\nquil.core$macros.cursor.cljs$core$IFn$_invoke$arity$1 = (function (cursor_mode){\nvar cursor_mode__$1 = quil.util.resolve_constant_key.call(null,cursor_mode,quil.core$macros.cursor_modes);\nreturn quil.sketch.current_applet.call(null).cursor([cljs.core.str(cursor_mode__$1)].join(''));\n});\n\nquil.core$macros.cursor.cljs$lang$maxFixedArity = (1);\n\n/**\n * Set the cursor to a predefined image. The horizontal and vertical\n *   active spots of the cursor may be specified with hx and hy.\n *   It is recommended to make the size 16x16 or 32x32 pixels.\n */\nquil.core$macros.cursor_image = (function quil$core$macros$cursor_image(var_args){\nvar args559 = [];\nvar len__13421__auto___562 = arguments.length;\nvar i__13422__auto___563 = (0);\nwhile(true){\nif((i__13422__auto___563 < len__13421__auto___562)){\nargs559.push((arguments[i__13422__auto___563]));\n\nvar G__564 = (i__13422__auto___563 + (1));\ni__13422__auto___563 = G__564;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__561 = args559.length;\nswitch (G__561) {\ncase (1):\nreturn quil.core$macros.cursor_image.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.cursor_image.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args559.length)].join('')));\n\n}\n});\n\nquil.core$macros.cursor_image.cljs$core$IFn$_invoke$arity$1 = (function (img){\nreturn quil.sketch.current_applet.call(null).cursor(img);\n});\n\nquil.core$macros.cursor_image.cljs$core$IFn$_invoke$arity$3 = (function (img,hx,hy){\nreturn quil.sketch.current_applet.call(null).cursor(img,(hx | (0)),(hy | (0)));\n});\n\nquil.core$macros.cursor_image.cljs$lang$maxFixedArity = (3);\n\n/**\n * Draws a curved line on the screen. The first and second parameters\n *   specify the beginning control point and the last two parameters\n *   specify the ending control point. The middle parameters specify the\n *   start and stop of the curve. Longer curves can be created by putting\n *   a series of curve fns together or using curve-vertex. An additional\n *   fn called curve-tightness provides control for the visual quality of\n *   the curve. The curve fn is an implementation of Catmull-Rom\n *   splines.\n */\nquil.core$macros.curve = (function quil$core$macros$curve(var_args){\nvar args566 = [];\nvar len__13421__auto___569 = arguments.length;\nvar i__13422__auto___570 = (0);\nwhile(true){\nif((i__13422__auto___570 < len__13421__auto___569)){\nargs566.push((arguments[i__13422__auto___570]));\n\nvar G__571 = (i__13422__auto___570 + (1));\ni__13422__auto___570 = G__571;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__568 = args566.length;\nswitch (G__568) {\ncase (8):\nreturn quil.core$macros.curve.cljs$core$IFn$_invoke$arity$8((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]));\n\nbreak;\ncase (12):\nreturn quil.core$macros.curve.cljs$core$IFn$_invoke$arity$12((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]),(arguments[(8)]),(arguments[(9)]),(arguments[(10)]),(arguments[(11)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args566.length)].join('')));\n\n}\n});\n\nquil.core$macros.curve.cljs$core$IFn$_invoke$arity$8 = (function (x1,y1,x2,y2,x3,y3,x4,y4){\nreturn quil.core$macros.current_graphics.call(null).curve(x1,y1,x2,y2,x3,y3,x4,y4);\n});\n\nquil.core$macros.curve.cljs$core$IFn$_invoke$arity$12 = (function (x1,y1,z1,x2,y2,z2,x3,y3,z3,x4,y4,z4){\nreturn quil.core$macros.current_graphics.call(null).curve(x1,y1,z1,x2,y2,z2,x3,y3,z3,x4,y4,z4);\n});\n\nquil.core$macros.curve.cljs$lang$maxFixedArity = (12);\n\n/**\n * Sets the resolution at which curves display. The default value is\n *   20. This function is only useful when using the :p3d or :opengl\n *   renderer as the default (:java2d) renderer does not use this\n *   information.\n */\nquil.core$macros.curve_detail = (function quil$core$macros$curve_detail(detail){\nreturn quil.core$macros.current_graphics.call(null).curveDetail((detail | (0)));\n});\n/**\n * Evalutes the curve at point t for points a, b, c, d. The parameter\n *   t varies between 0 and 1, a and d are points on the curve, and b c\n *   and are the control points. This can be done once with the x\n *   coordinates and a second time with the y coordinates to get the\n *   location of a curve at t.\n */\nquil.core$macros.curve_point = (function quil$core$macros$curve_point(a,b,c,d,t){\nreturn quil.core$macros.current_graphics.call(null).curvePoint(a,b,c,d,t);\n});\n/**\n * Calculates the tangent of a point on a curve.\n *   See: http://en.wikipedia.org/wiki/Tangent\n */\nquil.core$macros.curve_tangent = (function quil$core$macros$curve_tangent(a,b,c,d,t){\nreturn quil.core$macros.current_graphics.call(null).curveTangent(a,b,c,d,t);\n});\n/**\n * Modifies the quality of forms created with curve and\n *   curve-vertex. The parameter squishy determines how the curve fits\n *   to the vertex points. The value 0.0 is the default value for\n *   squishy (this value defines the curves to be Catmull-Rom splines)\n *   and the value 1.0 connects all the points with straight\n *   lines. Values within the range -5.0 and 5.0 will deform the curves\n *   but will leave them recognizable and as values increase in\n *   magnitude, they will continue to deform.\n */\nquil.core$macros.curve_tightness = (function quil$core$macros$curve_tightness(ti){\nreturn quil.core$macros.current_graphics.call(null).curveTightness(ti);\n});\n/**\n * Specifies vertex coordinates for curves. This function may only be\n *   used between begin-shape and end-shape and only when there is no\n *   mode keyword specified to begin-shape. The first and last points in a\n *   series of curve-vertex lines will be used to guide the beginning and\n *   end of a the curve. A minimum of four points is required to draw a\n *   tiny curve between the second and third points. Adding a fifth point\n *   with curve-vertex will draw the curve between the second, third, and\n *   fourth points. The curve-vertex function is an implementation of\n *   Catmull-Rom splines.\n */\nquil.core$macros.curve_vertex = (function quil$core$macros$curve_vertex(var_args){\nvar args573 = [];\nvar len__13421__auto___576 = arguments.length;\nvar i__13422__auto___577 = (0);\nwhile(true){\nif((i__13422__auto___577 < len__13421__auto___576)){\nargs573.push((arguments[i__13422__auto___577]));\n\nvar G__578 = (i__13422__auto___577 + (1));\ni__13422__auto___577 = G__578;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__575 = args573.length;\nswitch (G__575) {\ncase (2):\nreturn quil.core$macros.curve_vertex.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.curve_vertex.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args573.length)].join('')));\n\n}\n});\n\nquil.core$macros.curve_vertex.cljs$core$IFn$_invoke$arity$2 = (function (x,y){\nreturn quil.core$macros.current_graphics.call(null).curveVertex(x,y);\n});\n\nquil.core$macros.curve_vertex.cljs$core$IFn$_invoke$arity$3 = (function (x,y,z){\nreturn quil.core$macros.current_graphics.call(null).curveVertex(x,y,z);\n});\n\nquil.core$macros.curve_vertex.cljs$lang$maxFixedArity = (3);\n\n/**\n * Get the current day of the month (1 through 31).\n */\nquil.core$macros.day = (function quil$core$macros$day(){\nreturn quil.sketch.current_applet.call(null).day();\n});\n/**\n * Converts a radian measurement to its corresponding value in\n *   degrees. Radians and degrees are two ways of measuring the same\n *   thing. There are 360 degrees in a circle and (* 2 Math/PI) radians\n *   in a circle. For example, (= 90° (/ Math/PI 2) 1.5707964). All\n *   trigonometric methods in Processing require their parameters to be\n *   specified in radians.\n */\nquil.core$macros.degrees = (function quil$core$macros$degrees(radians){\nreturn quil.sketch.current_applet.call(null).degrees(radians);\n});\n/**\n * Forces the program to stop running for a specified time. Delay\n *   times are specified in thousandths of a second, therefore the\n *   function call (delay 3000) will stop the program for three\n *   seconds. Because the screen is updated only at the end of draw,\n *   the program may appear to 'freeze', because the screen will not\n *   update when the delay fn is used. This function has no affect\n *   inside setup.\n */\nquil.core$macros.delay_frame = (function quil$core$macros$delay_frame(freeze_ms){\nreturn quil.sketch.current_applet.call(null).delay((freeze_ms | (0)));\n});\n/**\n * Adds a directional light. Directional light comes from one\n *   direction and is stronger when hitting a surface squarely and weaker\n *   if it hits at a gentle angle. After hitting a surface, a\n *   directional lights scatters in all directions. Lights need to be\n *   included in the draw fn to remain persistent in a looping\n *   program. Placing them in the setup fn of a looping program will cause\n *   them to only have an effect the first time through the loop. The\n *   affect of the r, g, and b parameters is determined by the current\n *   color mode. The nx, ny, and nz parameters specify the direction the\n *   light is facing. For example, setting ny to -1 will cause the\n *   geometry to be lit from below (the light is facing directly upward)\n */\nquil.core$macros.directional_light = (function quil$core$macros$directional_light(r,g,b,nx,ny,nz){\nreturn quil.core$macros.current_graphics.call(null).directionalLight(r,g,b,nx,ny,nz);\n});\n/**\n * Calculates the distance between two points\n */\nquil.core$macros.dist = (function quil$core$macros$dist(var_args){\nvar args580 = [];\nvar len__13421__auto___583 = arguments.length;\nvar i__13422__auto___584 = (0);\nwhile(true){\nif((i__13422__auto___584 < len__13421__auto___583)){\nargs580.push((arguments[i__13422__auto___584]));\n\nvar G__585 = (i__13422__auto___584 + (1));\ni__13422__auto___584 = G__585;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__582 = args580.length;\nswitch (G__582) {\ncase (4):\nreturn quil.core$macros.dist.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase (6):\nreturn quil.core$macros.dist.cljs$core$IFn$_invoke$arity$6((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args580.length)].join('')));\n\n}\n});\n\nquil.core$macros.dist.cljs$core$IFn$_invoke$arity$4 = (function (x1,y1,x2,y2){\nreturn quil.sketch.current_applet.call(null).dist(x1,y1,x2,y2);\n});\n\nquil.core$macros.dist.cljs$core$IFn$_invoke$arity$6 = (function (x1,y1,z1,x2,y2,z2){\nreturn quil.sketch.current_applet.call(null).dist(x1,y1,z1,x2,y2,z2);\n});\n\nquil.core$macros.dist.cljs$lang$maxFixedArity = (6);\n\n/**\n * Macro for drawing on graphics which saves result in the file at the end.\n *   Similar to 'with-graphics' macro. do-record assumed to be used with :pdf\n *   graphics. Example:\n * \n *   (q/do-record (q/create-graphics 200 200 :pdf \"output.pdf\")\n *  (q/fill 250 0 0)\n *  (q/ellipse 100 100 150 150))\n *   \n */\nquil.core$macros.do_record = (function quil$core$macros$do_record(var_args){\nvar args__13423__auto__ = [];\nvar len__13421__auto___591 = arguments.length;\nvar i__13422__auto___592 = (0);\nwhile(true){\nif((i__13422__auto___592 < len__13421__auto___591)){\nargs__13423__auto__.push((arguments[i__13422__auto___592]));\n\nvar G__593 = (i__13422__auto___592 + (1));\ni__13422__auto___592 = G__593;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__13424__auto__ = ((((3) < args__13423__auto__.length))?(new cljs.core.IndexedSeq(args__13423__auto__.slice((3)),(0),null)):null);\nreturn quil.core$macros.do_record.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__13424__auto__);\n});\n\nquil.core$macros.do_record.cljs$core$IFn$_invoke$arity$variadic = (function (_AMPERSAND_form,_AMPERSAND_env,graphics,body){\nreturn cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"cljs.core\",\"let\",\"cljs.core/let\",(-308701135),null)),(function (){var x__13164__auto__ = cljs.core.vec.call(null,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"gr__16__auto__\",\"gr__16__auto__\",(-1845213481),null)),(function (){var x__13164__auto__ = graphics;\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})())));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})(),(function (){var x__13164__auto__ = cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.core\",\"with-graphics\",\"quil.core/with-graphics\",(481277883),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"gr__16__auto__\",\"gr__16__auto__\",(-1845213481),null)),body));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})(),(function (){var x__13164__auto__ = cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\".dispose\",\".dispose\",(-1697594101),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"gr__16__auto__\",\"gr__16__auto__\",(-1845213481),null))));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})()));\n});\n\nquil.core$macros.do_record.cljs$lang$maxFixedArity = (3);\n\nquil.core$macros.do_record.cljs$lang$applyTo = (function (seq587){\nvar G__588 = cljs.core.first.call(null,seq587);\nvar seq587__$1 = cljs.core.next.call(null,seq587);\nvar G__589 = cljs.core.first.call(null,seq587__$1);\nvar seq587__$2 = cljs.core.next.call(null,seq587__$1);\nvar G__590 = cljs.core.first.call(null,seq587__$2);\nvar seq587__$3 = cljs.core.next.call(null,seq587__$2);\nreturn quil.core$macros.do_record.cljs$core$IFn$_invoke$arity$variadic(G__588,G__589,G__590,seq587__$3);\n});\n\n\nquil.core$macros.do_record.cljs$lang$macro = true;\n/**\n * Draws an ellipse (oval) in the display window. An ellipse with an\n *   equal width and height is a circle.  The origin may be changed with\n *   the ellipse-mode function\n */\nquil.core$macros.ellipse = (function quil$core$macros$ellipse(x,y,width,height){\nreturn quil.core$macros.current_graphics.call(null).ellipse(x,y,width,height);\n});\n/**\n * Modifies the origin of the ellispse according to the specified mode:\n * \n *   :center  - specifies the location of the ellipse as\n *           the center of the shape. (Default).\n *   :radius  - similar to center, but the width and height parameters to\n *           ellipse specify the radius of the ellipse, rather than the\n *           diameter.\n *   :corner  - draws the shape from the upper-left corner of its bounding\n *           box.\n *   :corners - uses the four parameters to ellipse to set two opposing\n *           corners of the ellipse's bounding box.\n */\nquil.core$macros.ellipse_mode = (function quil$core$macros$ellipse_mode(mode){\nvar mode__$1 = quil.util.resolve_constant_key.call(null,mode,quil.core$macros.ellipse_modes);\nreturn quil.core$macros.current_graphics.call(null).ellipseMode((mode__$1 | (0)));\n});\n/**\n * Sets the emissive color of the material used for drawing shapes\n *  drawn to the screen. Used in combination with ambient, specular, and\n *  shininess in setting the material properties of shapes. Converts all\n *  args to floats\n */\nquil.core$macros.emissive_float = (function quil$core$macros$emissive_float(var_args){\nvar args594 = [];\nvar len__13421__auto___597 = arguments.length;\nvar i__13422__auto___598 = (0);\nwhile(true){\nif((i__13422__auto___598 < len__13421__auto___597)){\nargs594.push((arguments[i__13422__auto___598]));\n\nvar G__599 = (i__13422__auto___598 + (1));\ni__13422__auto___598 = G__599;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__596 = args594.length;\nswitch (G__596) {\ncase (1):\nreturn quil.core$macros.emissive_float.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.emissive_float.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args594.length)].join('')));\n\n}\n});\n\nquil.core$macros.emissive_float.cljs$core$IFn$_invoke$arity$1 = (function (float_val){\nreturn quil.core$macros.current_graphics.call(null).emissive(float_val);\n});\n\nquil.core$macros.emissive_float.cljs$core$IFn$_invoke$arity$3 = (function (r,g,b){\nreturn quil.core$macros.current_graphics.call(null).emissive(r,g,b);\n});\n\nquil.core$macros.emissive_float.cljs$lang$maxFixedArity = (3);\n\n/**\n * Sets the emissive color of the material used for drawing shapes\n *   drawn to the screen. Used in combination with ambient, specular, and\n *   shininess in setting the material properties of shapes. Converts all\n *   args to ints\n */\nquil.core$macros.emissive_int = (function quil$core$macros$emissive_int(int_val){\nreturn quil.core$macros.current_graphics.call(null).emissive((int_val | (0)));\n});\n/**\n * Sets the emissive color of the material used for drawing shapes\n *   drawn to the screen. Used in combination with ambient, specular, and\n *   shininess in setting the material properties of shapes.\n * \n *   If passed one arg - it is assumed to be an int (i.e. a color),\n *   multiple args are converted to floats.\n */\nquil.core$macros.emissive = (function quil$core$macros$emissive(var_args){\nvar args601 = [];\nvar len__13421__auto___604 = arguments.length;\nvar i__13422__auto___605 = (0);\nwhile(true){\nif((i__13422__auto___605 < len__13421__auto___604)){\nargs601.push((arguments[i__13422__auto___605]));\n\nvar G__606 = (i__13422__auto___605 + (1));\ni__13422__auto___605 = G__606;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__603 = args601.length;\nswitch (G__603) {\ncase (1):\nreturn quil.core$macros.emissive.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.emissive.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args601.length)].join('')));\n\n}\n});\n\nquil.core$macros.emissive.cljs$core$IFn$_invoke$arity$1 = (function (c){\nreturn quil.core$macros.emissive_float.call(null,c);\n});\n\nquil.core$macros.emissive.cljs$core$IFn$_invoke$arity$3 = (function (r,g,b){\nreturn quil.core$macros.emissive_float.call(null,r,g,b);\n});\n\nquil.core$macros.emissive.cljs$lang$maxFixedArity = (3);\n\n/**\n * Unsets the matrix mode from the camera matrix. See begin-camera.\n */\nquil.core$macros.end_camera = (function quil$core$macros$end_camera(){\nreturn quil.core$macros.current_graphics.call(null).endCamera();\n});\n/**\n * Use the begin-contour and end-contour function to create negative\n *   shapes within shapes. These functions can only be within a\n *   begin-shape/end-shape pair and they only work with the :p2d and :p3d\n *   renderers.\n */\nquil.core$macros.end_contour = (function quil$core$macros$end_contour(){\nreturn quil.core$macros.current_graphics.call(null).endContour();\n});\n/**\n * Complement to begin-raw; they must always be used together. See\n *   the begin-raw docstring for details.\n */\nquil.core$macros.end_raw = (function quil$core$macros$end_raw(){\nreturn quil.core$macros.current_graphics.call(null).endRaw();\n});\n/**\n * May only be called after begin-shape. When end-shape is called,\n *   all of image data defined since the previous call to begin-shape is\n *   written into the image buffer. The keyword :close may be passed to\n *   close the shape (to connect the beginning and the end).\n */\nquil.core$macros.end_shape = (function quil$core$macros$end_shape(var_args){\nvar args608 = [];\nvar len__13421__auto___611 = arguments.length;\nvar i__13422__auto___612 = (0);\nwhile(true){\nif((i__13422__auto___612 < len__13421__auto___611)){\nargs608.push((arguments[i__13422__auto___612]));\n\nvar G__613 = (i__13422__auto___612 + (1));\ni__13422__auto___612 = G__613;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__610 = args608.length;\nswitch (G__610) {\ncase (0):\nreturn quil.core$macros.end_shape.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase (1):\nreturn quil.core$macros.end_shape.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args608.length)].join('')));\n\n}\n});\n\nquil.core$macros.end_shape.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn quil.core$macros.current_graphics.call(null).endShape();\n});\n\nquil.core$macros.end_shape.cljs$core$IFn$_invoke$arity$1 = (function (mode){\nif(cljs.core._EQ_.call(null,new cljs.core.Keyword(null,\"close\",\"close\",(1835149582)),mode)){\n} else {\n}\n\nreturn quil.core$macros.current_graphics.call(null).endShape((2));\n});\n\nquil.core$macros.end_shape.cljs$lang$maxFixedArity = (1);\n\n/**\n * Quits/stops/exits the program.  Rather than terminating\n *   immediately, exit will cause the sketch to exit after draw has\n *   completed (or after setup completes if called during the setup\n *   method). \n */\nquil.core$macros.exit = (function quil$core$macros$exit(){\nreturn quil.sketch.current_applet.call(null).exit();\n});\n/**\n * Returns Euler's number e (2.71828...) raised to the power of the\n *   value parameter.\n */\nquil.core$macros.exp = (function quil$core$macros$exp(val){\nreturn quil.sketch.current_applet.call(null).exp(val);\n});\n/**\n * Sets custom property on graphcs object indicating that it has\n *   fill color.\n */\nquil.core$macros.clear_no_fill_cljs = (function quil$core$macros$clear_no_fill_cljs(graphics){\nreturn (graphics[quil.core$macros.no_fill_prop] = false);\n});\n/**\n * Sets the color used to fill shapes. For example, (fill 204 102 0),\n *   will specify that all subsequent shapes will be filled with orange.\n */\nquil.core$macros.fill_float = (function quil$core$macros$fill_float(var_args){\nvar args615 = [];\nvar len__13421__auto___618 = arguments.length;\nvar i__13422__auto___619 = (0);\nwhile(true){\nif((i__13422__auto___619 < len__13421__auto___618)){\nargs615.push((arguments[i__13422__auto___619]));\n\nvar G__620 = (i__13422__auto___619 + (1));\ni__13422__auto___619 = G__620;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__617 = args615.length;\nswitch (G__617) {\ncase (1):\nreturn quil.core$macros.fill_float.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.fill_float.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.fill_float.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core$macros.fill_float.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args615.length)].join('')));\n\n}\n});\n\nquil.core$macros.fill_float.cljs$core$IFn$_invoke$arity$1 = (function (gray){\nquil.core$macros.current_graphics.call(null).fill(gray);\n\nreturn quil.core$macros.clear_no_fill_cljs.call(null,quil.core$macros.current_graphics.call(null));\n});\n\nquil.core$macros.fill_float.cljs$core$IFn$_invoke$arity$2 = (function (gray,alpha){\nquil.core$macros.current_graphics.call(null).fill(gray,alpha);\n\nreturn quil.core$macros.clear_no_fill_cljs.call(null,quil.core$macros.current_graphics.call(null));\n});\n\nquil.core$macros.fill_float.cljs$core$IFn$_invoke$arity$3 = (function (r,g,b){\nquil.core$macros.current_graphics.call(null).fill(r,g,b);\n\nreturn quil.core$macros.clear_no_fill_cljs.call(null,quil.core$macros.current_graphics.call(null));\n});\n\nquil.core$macros.fill_float.cljs$core$IFn$_invoke$arity$4 = (function (r,g,b,alpha){\nquil.core$macros.current_graphics.call(null).fill(r,g,b,alpha);\n\nreturn quil.core$macros.clear_no_fill_cljs.call(null,quil.core$macros.current_graphics.call(null));\n});\n\nquil.core$macros.fill_float.cljs$lang$maxFixedArity = (4);\n\n/**\n * Sets the color used to fill shapes.\n */\nquil.core$macros.fill_int = (function quil$core$macros$fill_int(var_args){\nvar args622 = [];\nvar len__13421__auto___625 = arguments.length;\nvar i__13422__auto___626 = (0);\nwhile(true){\nif((i__13422__auto___626 < len__13421__auto___625)){\nargs622.push((arguments[i__13422__auto___626]));\n\nvar G__627 = (i__13422__auto___626 + (1));\ni__13422__auto___626 = G__627;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__624 = args622.length;\nswitch (G__624) {\ncase (1):\nreturn quil.core$macros.fill_int.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.fill_int.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args622.length)].join('')));\n\n}\n});\n\nquil.core$macros.fill_int.cljs$core$IFn$_invoke$arity$1 = (function (rgb){\nquil.core$macros.current_graphics.call(null).fill(cljs.core.unchecked_int.call(null,rgb));\n\nreturn quil.core$macros.clear_no_fill_cljs.call(null,quil.core$macros.current_graphics.call(null));\n});\n\nquil.core$macros.fill_int.cljs$core$IFn$_invoke$arity$2 = (function (rgb,alpha){\nquil.core$macros.current_graphics.call(null).fill(cljs.core.unchecked_int.call(null,rgb),alpha);\n\nreturn quil.core$macros.clear_no_fill_cljs.call(null,quil.core$macros.current_graphics.call(null));\n});\n\nquil.core$macros.fill_int.cljs$lang$maxFixedArity = (2);\n\n/**\n * Sets the color used to fill shapes.\n */\nquil.core$macros.fill = (function quil$core$macros$fill(var_args){\nvar args629 = [];\nvar len__13421__auto___632 = arguments.length;\nvar i__13422__auto___633 = (0);\nwhile(true){\nif((i__13422__auto___633 < len__13421__auto___632)){\nargs629.push((arguments[i__13422__auto___633]));\n\nvar G__634 = (i__13422__auto___633 + (1));\ni__13422__auto___633 = G__634;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__631 = args629.length;\nswitch (G__631) {\ncase (1):\nreturn quil.core$macros.fill.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.fill.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.fill.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core$macros.fill.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args629.length)].join('')));\n\n}\n});\n\nquil.core$macros.fill.cljs$core$IFn$_invoke$arity$1 = (function (rgb){\nreturn quil.core$macros.fill_float.call(null,rgb);\n});\n\nquil.core$macros.fill.cljs$core$IFn$_invoke$arity$2 = (function (rgb,alpha){\nreturn quil.core$macros.fill_float.call(null,rgb,alpha);\n});\n\nquil.core$macros.fill.cljs$core$IFn$_invoke$arity$3 = (function (r,g,b){\nreturn quil.core$macros.fill_float.call(null,r,g,b);\n});\n\nquil.core$macros.fill.cljs$core$IFn$_invoke$arity$4 = (function (r,g,b,a){\nreturn quil.core$macros.fill_float.call(null,r,g,b,a);\n});\n\nquil.core$macros.fill.cljs$lang$maxFixedArity = (4);\n\n/**\n * Originally named filter in Processing Language.\n *   Filters the display window with the specified mode and level.\n *   Level defines the quality of the filter and mode may be one of the\n *   following keywords:\n * \n *   :threshold - converts the image to black and white pixels depending\n *             if they are above or below the threshold defined by\n *             the level parameter. The level must be between\n *             0.0 (black) and 1.0 (white). If no level is specified,\n *             0.5 is used.\n *   :gray      - converts any colors in the image to grayscale\n *             equivalents. Doesn't work with level.\n *   :invert    - sets each pixel to its inverse value. Doesn't work with\n *             level.\n *   :posterize - limits each channel of the image to the number of\n *             colors specified as the level parameter. The parameter can\n *             be set to values between 2 and 255, but results are most\n *             noticeable in the lower ranges.\n *   :blur      - executes a Guassian blur with the level parameter\n *             specifying the extent of the blurring. If no level\n *             parameter is used, the blur is equivalent to Guassian\n *             blur of radius 1.\n *   :opaque    - sets the alpha channel to entirely opaque. Doesn't work\n *             with level.\n *   :erode     - reduces the light areas. Doesn't work with level.\n *   :dilate    - increases the light areas.  Doesn't work with level.\n */\nquil.core$macros.display_filter = (function quil$core$macros$display_filter(var_args){\nvar args636 = [];\nvar len__13421__auto___639 = arguments.length;\nvar i__13422__auto___640 = (0);\nwhile(true){\nif((i__13422__auto___640 < len__13421__auto___639)){\nargs636.push((arguments[i__13422__auto___640]));\n\nvar G__641 = (i__13422__auto___640 + (1));\ni__13422__auto___640 = G__641;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__638 = args636.length;\nswitch (G__638) {\ncase (1):\nreturn quil.core$macros.display_filter.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.display_filter.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args636.length)].join('')));\n\n}\n});\n\nquil.core$macros.display_filter.cljs$core$IFn$_invoke$arity$1 = (function (mode){\nreturn quil.core$macros.current_graphics.call(null).filter((quil.util.resolve_constant_key.call(null,mode,quil.core$macros.filter_modes) | (0)));\n});\n\nquil.core$macros.display_filter.cljs$core$IFn$_invoke$arity$2 = (function (mode,level){\nvar mode__$1 = quil.util.resolve_constant_key.call(null,mode,quil.core$macros.filter_modes);\nreturn quil.core$macros.current_graphics.call(null).filter((mode__$1 | (0)),level);\n});\n\nquil.core$macros.display_filter.cljs$lang$maxFixedArity = (2);\n\n/**\n * Calculates the closest int value that is less than or equal to the\n *   value of the parameter. For example, (floor 9.03) returns the value 9.\n */\nquil.core$macros.floor = (function quil$core$macros$floor(n){\nreturn quil.sketch.current_applet.call(null).floor(n);\n});\n/**\n * Returns a boolean value representing whether the applet has focus.\n */\nquil.core$macros.focused = (function quil$core$macros$focused(){\nreturn quil.sketch.current_applet.call(null).focused;\n});\n/**\n * The system variable frameCount contains the number of frames\n *   displayed since the program started. Inside setup() the value is 0\n *   and after the first iteration of draw it is 1, etc.\n */\nquil.core$macros.frame_count = (function quil$core$macros$frame_count(){\nreturn quil.sketch.current_applet.call(null).frameCount;\n});\n/**\n * Returns the current framerate\n */\nquil.core$macros.current_frame_rate = (function quil$core$macros$current_frame_rate(){\nreturn quil.sketch.current_applet.call(null).__frameRate;\n});\n/**\n * Specifies a new target framerate (number of frames to be displayed every\n *   second). If the processor is not fast enough to maintain the\n *   specified rate, it will not be achieved. For example, the function\n *   call (frame-rate 30) will attempt to refresh 30 times a second. It\n *   is recommended to set the frame rate within setup. The default rate\n *   is 60 frames per second.\n */\nquil.core$macros.frame_rate = (function quil$core$macros$frame_rate(new_rate){\ncljs.core.reset_BANG_.call(null,quil.sketch.current_applet.call(null).target_frame_rate,new_rate);\n\nreturn quil.sketch.current_applet.call(null).frameRate(new_rate);\n});\n/**\n * Sets a perspective matrix defined through the parameters. Works\n *   like glFrustum, except it wipes out the current perspective matrix\n *   rather than muliplying itself with it.\n */\nquil.core$macros.frustum = (function quil$core$macros$frustum(left,right,bottom,top,near,far){\nreturn quil.core$macros.current_graphics.call(null).frustum(left,right,bottom,top,near,far);\n});\n/**\n * Reads the color of any pixel or grabs a section of an image. If no\n *   parameters are specified, a copy of entire image is returned. Get the\n *   value of one pixel by specifying an x,y coordinate. Get a section of\n *   the image by specifying an additional width and height parameter.\n *   If the pixel requested is outside of the image window, black is returned.\n *   The numbers returned are scaled according to the current color ranges,\n *   but only RGB values are returned by this function. For example, even though\n *   you may have drawn a shape with (color-mode :hsb), the numbers returned\n *   will be in RGB.\n * \n *   Getting the color of a single pixel with (get x y) is easy, but not\n *   as fast as grabbing the data directly using the pixels fn.\n * \n *   If no img specified - current-graphics is used.\n */\nquil.core$macros.get_pixel = (function quil$core$macros$get_pixel(var_args){\nvar args643 = [];\nvar len__13421__auto___646 = arguments.length;\nvar i__13422__auto___647 = (0);\nwhile(true){\nif((i__13422__auto___647 < len__13421__auto___646)){\nargs643.push((arguments[i__13422__auto___647]));\n\nvar G__648 = (i__13422__auto___647 + (1));\ni__13422__auto___647 = G__648;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__645 = args643.length;\nswitch (G__645) {\ncase (0):\nreturn quil.core$macros.get_pixel.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase (1):\nreturn quil.core$macros.get_pixel.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.get_pixel.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.get_pixel.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core$macros.get_pixel.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase (5):\nreturn quil.core$macros.get_pixel.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args643.length)].join('')));\n\n}\n});\n\nquil.core$macros.get_pixel.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn quil.core$macros.get_pixel.call(null,quil.core$macros.current_graphics.call(null));\n});\n\nquil.core$macros.get_pixel.cljs$core$IFn$_invoke$arity$1 = (function (img){\nreturn img.get();\n});\n\nquil.core$macros.get_pixel.cljs$core$IFn$_invoke$arity$2 = (function (x,y){\nreturn quil.core$macros.get_pixel.call(null,quil.core$macros.current_graphics.call(null),x,y);\n});\n\nquil.core$macros.get_pixel.cljs$core$IFn$_invoke$arity$3 = (function (img,x,y){\nreturn img.get((x | (0)),(y | (0)));\n});\n\nquil.core$macros.get_pixel.cljs$core$IFn$_invoke$arity$4 = (function (x,y,w,h){\nreturn quil.core$macros.get_pixel.call(null,quil.core$macros.current_graphics.call(null),x,y,w,h);\n});\n\nquil.core$macros.get_pixel.cljs$core$IFn$_invoke$arity$5 = (function (img,x,y,w,h){\nreturn img.get((x | (0)),(y | (0)),(w | (0)),(h | (0)));\n});\n\nquil.core$macros.get_pixel.cljs$lang$maxFixedArity = (5);\n\n/**\n * Extracts the green value from a color, scaled to match current\n *   color-mode. This value is always returned as a float so be careful\n *   not to assign it to an int value.\n */\nquil.core$macros.green = (function quil$core$macros$green(col){\nreturn quil.core$macros.current_graphics.call(null).green(cljs.core.unchecked_int.call(null,col));\n});\n/**\n * Converts a byte, char, int, or color to a String containing the\n *   equivalent hexadecimal notation. For example color(0, 102, 153) will\n *   convert to the String \"FF006699\". This function can help make your\n *   geeky debugging sessions much happier. \n */\nquil.core$macros.hex = (function quil$core$macros$hex(var_args){\nvar args650 = [];\nvar len__13421__auto___653 = arguments.length;\nvar i__13422__auto___654 = (0);\nwhile(true){\nif((i__13422__auto___654 < len__13421__auto___653)){\nargs650.push((arguments[i__13422__auto___654]));\n\nvar G__655 = (i__13422__auto___654 + (1));\ni__13422__auto___654 = G__655;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__652 = args650.length;\nswitch (G__652) {\ncase (1):\nreturn quil.core$macros.hex.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.hex.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args650.length)].join('')));\n\n}\n});\n\nquil.core$macros.hex.cljs$core$IFn$_invoke$arity$1 = (function (val){\nreturn quil.sketch.current_applet.call(null).hex(val);\n});\n\nquil.core$macros.hex.cljs$core$IFn$_invoke$arity$2 = (function (val,num_digits){\nreturn quil.sketch.current_applet.call(null).hex(val,num_digits);\n});\n\nquil.core$macros.hex.cljs$lang$maxFixedArity = (2);\n\n/**\n * Height of the display window. The value of height is zero until\n *   size is called.\n */\nquil.core$macros.height = (function quil$core$macros$height(){\nreturn quil.sketch.current_applet.call(null).height;\n});\n/**\n * Set various hints and hacks for the renderer. This is used to\n *   handle obscure rendering features that cannot be implemented in a\n *   consistent manner across renderers. Many options will often graduate\n *   to standard features instead of hints over time.\n * \n *   Options:\n * \n *   :enable-native-fonts - Use the native version fonts when they are\n *  installed, rather than the bitmapped version from a .vlw\n *  file. This is useful with the default (or JAVA2D) renderer\n *  setting, as it will improve font rendering speed. This is not\n *  enabled by default, because it can be misleading while testing\n *  because the type will look great on your machine (because you have\n *  the font installed) but lousy on others' machines if the identical\n *  font is unavailable. This option can only be set per-sketch, and\n *  must be called before any use of text-font.\n * \n *   :disable-native-fonts - Disables native font support.\n * \n *   :disable-depth-test - Disable the zbuffer, allowing you to draw on\n *  top of everything at will. When depth testing is disabled, items\n *  will be drawn to the screen sequentially, like a painting. This\n *  hint is most often used to draw in 3D, then draw in 2D on top of\n *  it (for instance, to draw GUI controls in 2D on top of a 3D\n *  interface). Starting in release 0149, this will also clear the\n *  depth buffer. Restore the default with :enable-depth-test\n *  but note that with the depth buffer cleared, any 3D drawing that\n *  happens later in draw will ignore existing shapes on the screen.\n * \n *   :enable-depth-test - Enables the zbuffer.\n * \n *   :enable-depth-sort - Enable primitive z-sorting of triangles and\n *  lines in :p3d and :opengl rendering modes. This can slow\n *  performance considerably, and the algorithm is not yet perfect.\n * \n *   :disable-depth-sort - Disables hint :enable-depth-sort\n * \n *   :disable-opengl-errors - Speeds up the OPENGL renderer setting\n *   by not checking for errors while running.\n * \n *   :enable-opengl-errors - Turns on OpenGL error checking\n * \n *   :enable-depth-mask\n *   :disable-depth-mask\n * \n *   :enable-optimized-stroke\n *   :disable-optimized-stroke\n *   :enable-retina-pixels\n *   :disable-retina-pixels\n *   :enable-stroke-perspective\n *   :disable-stroke-perspective\n *   :enable-stroke-pure\n *   :disable-stroke-pure\n *   :enable-texture-mipmaps\n *   :disable-texture-mipmaps\n */\nquil.core$macros.hint = (function quil$core$macros$hint(hint_type){\nvar hint_type__$1 = (((hint_type instanceof cljs.core.Keyword))?cljs.core.get.call(null,quil.core$macros.hint_options,hint_type):hint_type);\nreturn quil.core$macros.current_graphics.call(null).hint((hint_type__$1 | (0)));\n});\n/**\n * Returns the current hour as a value from 0 - 23.\n */\nquil.core$macros.hour = (function quil$core$macros$hour(){\nreturn quil.sketch.current_applet.call(null).hour();\n});\n/**\n * Extracts the hue value from a color.\n */\nquil.core$macros.hue = (function quil$core$macros$hue(col){\nreturn quil.core$macros.current_graphics.call(null).hue(cljs.core.unchecked_int.call(null,col));\n});\n/**\n * Displays images to the screen. Processing currently works with GIF,\n *   JPEG, and Targa images. The color of an image may be modified with\n *   the tint function and if a GIF has transparency, it will maintain\n *   its transparency. The img parameter specifies the image to display\n *   and the x and y parameters define the location of the image from its\n *   upper-left corner. The image is displayed at its original size\n *   unless the width and height parameters specify a different size. The\n *   image-mode fn changes the way the parameters work. A call to\n *   (image-mode :corners) will change the width and height parameters to\n *   define the x and y values of the opposite corner of the image.\n * \n *   Starting with release 0124, when using the default (JAVA2D)\n *   renderer, smooth will also improve image quality of resized\n *   images.\n */\nquil.core$macros.image = (function quil$core$macros$image(var_args){\nvar args657 = [];\nvar len__13421__auto___660 = arguments.length;\nvar i__13422__auto___661 = (0);\nwhile(true){\nif((i__13422__auto___661 < len__13421__auto___660)){\nargs657.push((arguments[i__13422__auto___661]));\n\nvar G__662 = (i__13422__auto___661 + (1));\ni__13422__auto___661 = G__662;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__659 = args657.length;\nswitch (G__659) {\ncase (3):\nreturn quil.core$macros.image.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (5):\nreturn quil.core$macros.image.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args657.length)].join('')));\n\n}\n});\n\nquil.core$macros.image.cljs$core$IFn$_invoke$arity$3 = (function (img,x,y){\nreturn quil.core$macros.current_graphics.call(null).image(img,x,y);\n});\n\nquil.core$macros.image.cljs$core$IFn$_invoke$arity$5 = (function (img,x,y,c,d){\nreturn quil.core$macros.current_graphics.call(null).image(img,x,y,c,d);\n});\n\nquil.core$macros.image.cljs$lang$maxFixedArity = (5);\n\n/**\n * Originally named filter in Processing Language.\n *   Filters given image with the specified mode and level.\n *   Level defines the quality of the filter and mode may be one of\n *   the following keywords:\n * \n *   :threshold - converts the image to black and white pixels depending\n *             if they are above or below the threshold defined by\n *             the level parameter. The level must be between\n *             0.0 (black) and 1.0 (white). If no level is specified,\n *             0.5 is used.\n *   :gray      - converts any colors in the image to grayscale\n *             equivalents. Doesn't work with level.\n *   :invert    - sets each pixel to its inverse value. Doesn't work with\n *             level.\n *   :posterize - limits each channel of the image to the number of\n *             colors specified as the level parameter. The parameter can\n *             be set to values between 2 and 255, but results are most\n *             noticeable in the lower ranges.\n *   :blur      - executes a Guassian blur with the level parameter\n *             specifying the extent of the blurring. If no level\n *             parameter is used, the blur is equivalent to Guassian\n *             blur of radius 1.\n *   :opaque    - sets the alpha channel to entirely opaque. Doesn't work\n *             with level.\n *   :erode     - reduces the light areas. Doesn't work with level.\n *   :dilate    - increases the light areas.  Doesn't work with level.\n */\nquil.core$macros.image_filter = (function quil$core$macros$image_filter(var_args){\nvar args664 = [];\nvar len__13421__auto___667 = arguments.length;\nvar i__13422__auto___668 = (0);\nwhile(true){\nif((i__13422__auto___668 < len__13421__auto___667)){\nargs664.push((arguments[i__13422__auto___668]));\n\nvar G__669 = (i__13422__auto___668 + (1));\ni__13422__auto___668 = G__669;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__666 = args664.length;\nswitch (G__666) {\ncase (2):\nreturn quil.core$macros.image_filter.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.image_filter.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args664.length)].join('')));\n\n}\n});\n\nquil.core$macros.image_filter.cljs$core$IFn$_invoke$arity$2 = (function (img,mode){\nvar mode__$1 = quil.util.resolve_constant_key.call(null,mode,quil.core$macros.filter_modes);\nreturn img.filter((mode__$1 | (0)));\n});\n\nquil.core$macros.image_filter.cljs$core$IFn$_invoke$arity$3 = (function (img,mode,level){\nvar mode__$1 = quil.util.resolve_constant_key.call(null,mode,quil.core$macros.filter_modes);\nreturn img.filter((mode__$1 | (0)),level);\n});\n\nquil.core$macros.image_filter.cljs$lang$maxFixedArity = (3);\n\n/**\n * Modifies the location from which images draw. The default mode is :corner.\n * Available modes are:\n * \n *   :corner  - specifies the location to be the upper left corner and\n *           uses the fourth and fifth parameters of image to set the\n *           image's width and height.\n * \n *   :corners - uses the second and third parameters of image to set the\n *           location of one corner of the image and uses the fourth\n *           and fifth parameters to set the opposite corner.\n * \n *   :center  - draw images centered at the given x and y position.\n */\nquil.core$macros.image_mode = (function quil$core$macros$image_mode(mode){\nvar mode__$1 = quil.util.resolve_constant_key.call(null,mode,quil.core$macros.image_modes);\nreturn quil.core$macros.current_graphics.call(null).imageMode((mode__$1 | (0)));\n});\n/**\n * The variable keyCode is used to detect special keys such as the UP,\n *   DOWN, LEFT, RIGHT arrow keys and ALT, CONTROL, SHIFT. When checking\n *   for these keys, it's first necessary to check and see if the key is\n *   coded. This is done with the conditional (= (key) CODED).\n * \n *   The keys included in the ASCII specification (BACKSPACE, TAB, ENTER,\n *   RETURN, ESC, and DELETE) do not require checking to see if they key\n *   is coded, and you should simply use the key variable instead of\n *   key-code If you're making cross-platform projects, note that the\n *   ENTER key is commonly used on PCs and Unix and the RETURN key is\n *   used instead on Macintosh. Check for both ENTER and RETURN to make\n *   sure your program will work for all platforms.\n * \n *   For users familiar with Java, the values for UP and DOWN are simply\n *   shorter versions of Java's KeyEvent.VK_UP and\n *   KeyEvent.VK_DOWN. Other keyCode values can be found in the Java\n *   KeyEvent reference.\n */\nquil.core$macros.key_code = (function quil$core$macros$key_code(){\nreturn quil.sketch.current_applet.call(null).keyCode;\n});\n/**\n * true if any key is currently pressed, false otherwise.\n */\nquil.core$macros.key_pressed_QMARK_ = (function quil$core$macros$key_pressed_QMARK_(){\nreturn quil.sketch.current_applet.call(null).keyPressed;\n});\n/**\n * Sets the falloff rates for point lights, spot lights, and ambient\n *   lights. The parameters are used to determine the falloff with the\n *   following equation:\n * \n *   d = distance from light position to vertex position\n *   falloff = 1 / (CONSTANT + d * LINEAR + (d*d) * QUADRATIC)\n * \n *   Like fill, it affects only the elements which are created after it\n *   in the code. The default value is (light-falloff 1.0 0.0 0.0).\n *   Thinking about an ambient light with a falloff can be tricky. It is\n *   used, for example, if you wanted a region of your scene to be lit\n *   ambiently one color and another region to be lit ambiently by\n *   another color, you would use an ambient light with location and\n *   falloff. You can think of it as a point light that doesn't care\n *   which direction a surface is facing.\n */\nquil.core$macros.light_falloff = (function quil$core$macros$light_falloff(constant,linear,quadratic){\nreturn quil.core$macros.current_graphics.call(null).lightFalloff(constant,linear,quadratic);\n});\n/**\n * Calculates a color or colors between two color at a specific\n *   increment. The amt parameter is the amount to interpolate between\n *   the two values where 0.0 equal to the first point, 0.1 is very near\n *   the first point, 0.5 is half-way in between, etc.\n */\nquil.core$macros.lerp_color = (function quil$core$macros$lerp_color(c1,c2,amt){\nreturn quil.core$macros.current_graphics.call(null).lerpColor(cljs.core.unchecked_int.call(null,c1),cljs.core.unchecked_int.call(null,c2),amt);\n});\n/**\n * Calculates a number between two numbers at a specific\n *   increment. The amt parameter is the amount to interpolate between\n *   the two values where 0.0 equal to the first point, 0.1 is very near\n *   the first point, 0.5 is half-way in between, etc. The lerp function\n *   is convenient for creating motion along a straight path and for\n *   drawing dotted lines.\n */\nquil.core$macros.lerp = (function quil$core$macros$lerp(start,stop,amt){\nreturn quil.sketch.current_applet.call(null).lerp(start,stop,amt);\n});\n/**\n * Sets the default ambient light, directional light, falloff, and\n *   specular values. The defaults are:\n * \n *   (ambient-light 128 128 128)\n *   (directional-light 128 128 128 0 0 -1)\n *   (light-falloff 1 0 0)\n *   (light-specular 0 0 0).\n * \n *   Lights need to be included in the draw to remain persistent in a\n *   looping program. Placing them in the setup of a looping program\n *   will cause them to only have an effect the first time through the\n *   loop.\n */\nquil.core$macros.lights = (function quil$core$macros$lights(){\nreturn quil.core$macros.current_graphics.call(null).lights();\n});\n/**\n * Sets the specular color for lights. Like fill, it affects only the\n *   elements which are created after it in the code. Specular refers to\n *   light which bounces off a surface in a perferred direction (rather\n *   than bouncing in all directions like a diffuse light) and is used\n *   for creating highlights. The specular quality of a light interacts\n *   with the specular material qualities set through the specular and\n *   shininess functions.\n */\nquil.core$macros.light_specular = (function quil$core$macros$light_specular(r,g,b){\nreturn quil.core$macros.current_graphics.call(null).lightSpecular(r,g,b);\n});\n/**\n * Draws a line (a direct path between two points) to the screen. The\n *   version of line with four parameters draws the line in 2D. To color\n *   a line, use the stroke function. A line cannot be filled, therefore\n *   the fill method will not affect the color of a line. 2D lines are\n *   drawn with a width of one pixel by default, but this can be changed\n *   with the stroke-weight function. The version with six parameters\n *   allows the line to be placed anywhere within XYZ space. \n */\nquil.core$macros.line = (function quil$core$macros$line(var_args){\nvar args671 = [];\nvar len__13421__auto___674 = arguments.length;\nvar i__13422__auto___675 = (0);\nwhile(true){\nif((i__13422__auto___675 < len__13421__auto___674)){\nargs671.push((arguments[i__13422__auto___675]));\n\nvar G__676 = (i__13422__auto___675 + (1));\ni__13422__auto___675 = G__676;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__673 = args671.length;\nswitch (G__673) {\ncase (2):\nreturn quil.core$macros.line.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (4):\nreturn quil.core$macros.line.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase (6):\nreturn quil.core$macros.line.cljs$core$IFn$_invoke$arity$6((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args671.length)].join('')));\n\n}\n});\n\nquil.core$macros.line.cljs$core$IFn$_invoke$arity$2 = (function (p1,p2){\nreturn cljs.core.apply.call(null,quil.core$macros.line,cljs.core.concat.call(null,p1,p2));\n});\n\nquil.core$macros.line.cljs$core$IFn$_invoke$arity$4 = (function (x1,y1,x2,y2){\nreturn quil.core$macros.current_graphics.call(null).line(x1,y1,x2,y2);\n});\n\nquil.core$macros.line.cljs$core$IFn$_invoke$arity$6 = (function (x1,y1,z1,x2,y2,z2){\nreturn quil.core$macros.current_graphics.call(null).line(x1,y1,z1,x2,y2,z2);\n});\n\nquil.core$macros.line.cljs$lang$maxFixedArity = (6);\n\n/**\n * Loads a font into a variable of type PFont. To load correctly,\n *   fonts must be located in the data directory of the current sketch.\n *   To create a font to use with Processing use the create-font fn.\n * \n *   Like load-image and other methods that load data, the load-font fn\n *   should not be used inside draw, because it will slow down the sketch\n *   considerably, as the font will be re-loaded from the disk (or\n *   network) on each frame.\n * \n *   For most renderers, Processing displays fonts using the .vlw font\n *   format, which uses images for each letter, rather than defining them\n *   through vector data. When hint :enable-native-fonts is used with the\n *   JAVA2D renderer, the native version of a font will be used if it is\n *   installed on the user's machine.\n * \n *   Using create-font (instead of load-font) enables vector data to be\n *   used with the JAVA2D (default) renderer setting. This can be helpful\n *   when many font sizes are needed, or when using any renderer based on\n *   JAVA2D, such as the PDF library.\n */\nquil.core$macros.load_font = (function quil$core$macros$load_font(filename){\nreturn quil.sketch.current_applet.call(null).loadFont([cljs.core.str(filename)].join(''));\n});\n/**\n * Loads an image into a variable of type PImage. Four types of\n *   images ( .gif, .jpg, .tga, .png) images may be loaded. To load\n *   correctly, images must be located in the data directory of the\n *   current sketch. In most cases, load all images in setup to preload\n *   them at the start of the program. Loading images inside draw will\n *   reduce the speed of a program.\n * \n *   The filename parameter can also be a URL to a file found online.\n * \n *   If an image is not loaded successfully, the null value is returned\n *   and an error message will be printed to the console. The error\n *   message does not halt the program, however the null value may cause\n *   a NullPointerException if your code does not check whether the value\n *   returned from load-image is nil.\n * \n *   Depending on the type of error, a PImage object may still be\n *   returned, but the width and height of the image will be set to\n *   -1. This happens if bad image data is returned or cannot be decoded\n *   properly. Sometimes this happens with image URLs that produce a 403\n *   error or that redirect to a password prompt, because load-image\n *   will attempt to interpret the HTML as image data.\n */\nquil.core$macros.load_image = (function quil$core$macros$load_image(filename){\nreturn quil.sketch.current_applet.call(null).loadImage([cljs.core.str(filename)].join(''));\n});\n/**\n * Loads a shader into the PShader object. Shaders are compatible with the\n *   P2D and P3D renderers, but not with the default renderer.\n */\nquil.core$macros.load_shader = (function quil$core$macros$load_shader(var_args){\nvar args678 = [];\nvar len__13421__auto___681 = arguments.length;\nvar i__13422__auto___682 = (0);\nwhile(true){\nif((i__13422__auto___682 < len__13421__auto___681)){\nargs678.push((arguments[i__13422__auto___682]));\n\nvar G__683 = (i__13422__auto___682 + (1));\ni__13422__auto___682 = G__683;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__680 = args678.length;\nswitch (G__680) {\ncase (1):\nreturn quil.core$macros.load_shader.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.load_shader.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args678.length)].join('')));\n\n}\n});\n\nquil.core$macros.load_shader.cljs$core$IFn$_invoke$arity$1 = (function (fragment_filename){\nreturn quil.core$macros.current_graphics.call(null).loadShader(fragment_filename);\n});\n\nquil.core$macros.load_shader.cljs$core$IFn$_invoke$arity$2 = (function (fragment_filename,vertex_filename){\nreturn quil.core$macros.current_graphics.call(null).loadShader(fragment_filename,vertex_filename);\n});\n\nquil.core$macros.load_shader.cljs$lang$maxFixedArity = (2);\n\n/**\n * Load a geometry from a file as a PShape.\n */\nquil.core$macros.load_shape = (function quil$core$macros$load_shape(filename){\nreturn quil.sketch.current_applet.call(null).loadShape(filename);\n});\n/**\n * Calculates the natural logarithm (the base-e logarithm) of a\n *   number. This function expects the values greater than 0.0.\n */\nquil.core$macros.log = (function quil$core$macros$log(val){\nreturn quil.sketch.current_applet.call(null).log(val);\n});\n/**\n * Calculates the magnitude (or length) of a vector. A vector is a\n *   direction in space commonly used in computer graphics and linear\n *   algebra. Because it has no start position, the magnitude of a vector\n *   can be thought of as the distance from coordinate (0,0) to its (x,y)\n *   value. Therefore, mag is a shortcut for writing (dist 0 0 x y).\n */\nquil.core$macros.mag = (function quil$core$macros$mag(var_args){\nvar args685 = [];\nvar len__13421__auto___688 = arguments.length;\nvar i__13422__auto___689 = (0);\nwhile(true){\nif((i__13422__auto___689 < len__13421__auto___688)){\nargs685.push((arguments[i__13422__auto___689]));\n\nvar G__690 = (i__13422__auto___689 + (1));\ni__13422__auto___689 = G__690;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__687 = args685.length;\nswitch (G__687) {\ncase (2):\nreturn quil.core$macros.mag.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.mag.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args685.length)].join('')));\n\n}\n});\n\nquil.core$macros.mag.cljs$core$IFn$_invoke$arity$2 = (function (a,b){\nreturn quil.sketch.current_applet.call(null).mag(a,b);\n});\n\nquil.core$macros.mag.cljs$core$IFn$_invoke$arity$3 = (function (a,b,c){\nreturn quil.sketch.current_applet.call(null).mag(a,b,c);\n});\n\nquil.core$macros.mag.cljs$lang$maxFixedArity = (3);\n\n/**\n * Re-maps a number from one range to another.\n * \n *   Numbers outside the range are not clamped to 0 and 1, because\n *   out-of-range values are often intentional and useful.\n */\nquil.core$macros.map_range = (function quil$core$macros$map_range(val,low1,high1,low2,high2){\nreturn quil.sketch.current_applet.call(null).map(val,low1,high1,low2,high2);\n});\n/**\n * Returns the number of milliseconds (thousandths of a second) since\n *   starting the sketch. This information is often used for timing\n *   animation sequences.\n */\nquil.core$macros.millis = (function quil$core$macros$millis(){\nreturn quil.sketch.current_applet.call(null).millis();\n});\n/**\n * Returns the current minute as a value from 0 - 59\n */\nquil.core$macros.minute = (function quil$core$macros$minute(){\nreturn quil.sketch.current_applet.call(null).minute();\n});\n/**\n * Returns the three-dimensional x, y, z position in model space. This\n *   returns the x value for a given coordinate based on the current set\n *   of transformations (scale, rotate, translate, etc.) The x value can\n *   be used to place an object in space relative to the location of the\n *   original point once the transformations are no longer in use.\n */\nquil.core$macros.model_x = (function quil$core$macros$model_x(x,y,z){\nreturn quil.core$macros.current_graphics.call(null).modelX(x,y,z);\n});\n/**\n * Returns the three-dimensional x, y, z position in model space. This\n *   returns the y value for a given coordinate based on the current set\n *   of transformations (scale, rotate, translate, etc.) The y value can\n *   be used to place an object in space relative to the location of the\n *   original point once the transformations are no longer in use.\n */\nquil.core$macros.model_y = (function quil$core$macros$model_y(x,y,z){\nreturn quil.core$macros.current_graphics.call(null).modelY(x,y,z);\n});\n/**\n * Returns the three-dimensional x, y, z position in model space. This\n *   returns the z value for a given coordinate based on the current set\n *   of transformations (scale, rotate, translate, etc.) The z value can\n *   be used to place an object in space relative to the location of the\n *   original point once the transformations are no longer in use.\n */\nquil.core$macros.model_z = (function quil$core$macros$model_z(x,y,z){\nreturn quil.core$macros.current_graphics.call(null).modelZ(x,y,z);\n});\n/**\n * Returns the current month as a value from 1 - 12.\n */\nquil.core$macros.month = (function quil$core$macros$month(){\nreturn quil.sketch.current_applet.call(null).month();\n});\n/**\n * The value of the system variable mouseButton is either :left, :right,\n *   or :center depending on which button is pressed. nil if no button pressed\n */\nquil.core$macros.mouse_button = (function quil$core$macros$mouse_button(){\nvar button_code = quil.sketch.current_applet.call(null).mouseButton;\nvar pred__695 = cljs.core._EQ_;\nvar expr__696 = button_code;\nif(cljs.core.truth_(pred__695.call(null,(37),expr__696))){\nreturn new cljs.core.Keyword(null,\"left\",\"left\",(-399115937));\n} else {\nif(cljs.core.truth_(pred__695.call(null,(39),expr__696))){\nreturn new cljs.core.Keyword(null,\"right\",\"right\",(-452581833));\n} else {\nif(cljs.core.truth_(pred__695.call(null,(3),expr__696))){\nreturn new cljs.core.Keyword(null,\"center\",\"center\",(-748944368));\n} else {\nreturn null;\n}\n}\n}\n});\n/**\n * Variable storing if a mouse button is pressed. The value of the\n *   system variable mousePressed is true if a mouse button is pressed\n *   and false if a button is not pressed.\n */\nquil.core$macros.mouse_pressed_QMARK_ = (function quil$core$macros$mouse_pressed_QMARK_(){\nreturn quil.sketch.current_applet.call(null).mousePressed;\n});\n/**\n * Current horizontal coordinate of the mouse.\n */\nquil.core$macros.mouse_x = (function quil$core$macros$mouse_x(){\nreturn quil.sketch.current_applet.call(null).mouseX;\n});\n/**\n * Current vertical coordinate of the mouse.\n */\nquil.core$macros.mouse_y = (function quil$core$macros$mouse_y(){\nreturn quil.sketch.current_applet.call(null).mouseY;\n});\n/**\n * Hides the cursor from view. Will not work when running the in full\n *   screen (Present) mode.\n */\nquil.core$macros.no_cursor = (function quil$core$macros$no_cursor(){\nreturn quil.sketch.current_applet.call(null).noCursor();\n});\n/**\n * Disables filling geometry. If both no-stroke and no-fill are called,\n *   nothing will be drawn to the screen.\n */\nquil.core$macros.no_fill = (function quil$core$macros$no_fill(){\nquil.core$macros.current_graphics.call(null).noFill();\n\nreturn (quil.core$macros.current_graphics.call(null)[quil.core$macros.no_fill_prop] = true);\n});\n/**\n * Returns the Perlin noise value at specified coordinates. Perlin\n *   noise is a random sequence generator producing a more natural\n *   ordered, harmonic succession of numbers compared to the standard\n *   random function. It was invented by Ken Perlin in the 1980s and\n *   been used since in graphical applications to produce procedural\n *   textures, natural motion, shapes, terrains etc.\n * \n *   The main difference to the random function is that Perlin noise is\n *   defined in an infinite n-dimensional space where each pair of\n *   coordinates corresponds to a fixed semi-random value (fixed only for\n *   the lifespan of the program). The resulting value will always be\n *   between 0.0 and 1.0. Processing can compute 1D, 2D and 3D noise,\n *   depending on the number of coordinates given. The noise value can be\n *   animated by moving through the noise space and the 2nd and 3rd\n *   dimensions can also be interpreted as time.\n * \n *   The actual noise is structured similar to an audio signal, in\n *   respect to the function's use of frequencies. Similar to the concept\n *   of harmonics in physics, perlin noise is computed over several\n *   octaves which are added together for the final result.\n * \n *   Another way to adjust the character of the resulting sequence is the\n *   scale of the input coordinates. As the function works within an\n *   infinite space the value of the coordinates doesn't matter as such,\n *   only the distance between successive coordinates does (eg. when\n *   using noise within a loop). As a general rule the smaller the\n *   difference between coordinates, the smoother the resulting noise\n *   sequence will be. Steps of 0.005-0.03 work best for most\n *   applications, but this will differ depending on use.\n */\nquil.core$macros.noise = (function quil$core$macros$noise(var_args){\nvar args698 = [];\nvar len__13421__auto___701 = arguments.length;\nvar i__13422__auto___702 = (0);\nwhile(true){\nif((i__13422__auto___702 < len__13421__auto___701)){\nargs698.push((arguments[i__13422__auto___702]));\n\nvar G__703 = (i__13422__auto___702 + (1));\ni__13422__auto___702 = G__703;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__700 = args698.length;\nswitch (G__700) {\ncase (1):\nreturn quil.core$macros.noise.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.noise.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.noise.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args698.length)].join('')));\n\n}\n});\n\nquil.core$macros.noise.cljs$core$IFn$_invoke$arity$1 = (function (x){\nreturn quil.sketch.current_applet.call(null).noise(x);\n});\n\nquil.core$macros.noise.cljs$core$IFn$_invoke$arity$2 = (function (x,y){\nreturn quil.sketch.current_applet.call(null).noise(x,y);\n});\n\nquil.core$macros.noise.cljs$core$IFn$_invoke$arity$3 = (function (x,y,z){\nreturn quil.sketch.current_applet.call(null).noise(x,y,z);\n});\n\nquil.core$macros.noise.cljs$lang$maxFixedArity = (3);\n\n/**\n * Adjusts the character and level of detail produced by the Perlin\n *   noise function. Similar to harmonics in physics, noise is computed\n *   over several octaves. Lower octaves contribute more to the output\n *   signal and as such define the overal intensity of the noise, whereas\n *   higher octaves create finer grained details in the noise\n *   sequence. By default, noise is computed over 4 octaves with each\n *   octave contributing exactly half than its predecessor, starting at\n *   50% strength for the 1st octave. This falloff amount can be changed\n *   by adding an additional function parameter. Eg. a falloff factor of\n *   0.75 means each octave will now have 75% impact (25% less) of the\n *   previous lower octave. Any value between 0.0 and 1.0 is valid,\n *   however note that values greater than 0.5 might result in greater\n *   than 1.0 values returned by noise.\n * \n *   By changing these parameters, the signal created by the noise\n *   function can be adapted to fit very specific needs and\n *   characteristics.\n */\nquil.core$macros.noise_detail = (function quil$core$macros$noise_detail(var_args){\nvar args705 = [];\nvar len__13421__auto___708 = arguments.length;\nvar i__13422__auto___709 = (0);\nwhile(true){\nif((i__13422__auto___709 < len__13421__auto___708)){\nargs705.push((arguments[i__13422__auto___709]));\n\nvar G__710 = (i__13422__auto___709 + (1));\ni__13422__auto___709 = G__710;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__707 = args705.length;\nswitch (G__707) {\ncase (1):\nreturn quil.core$macros.noise_detail.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.noise_detail.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args705.length)].join('')));\n\n}\n});\n\nquil.core$macros.noise_detail.cljs$core$IFn$_invoke$arity$1 = (function (octaves){\nreturn quil.sketch.current_applet.call(null).noiseDetail((octaves | (0)));\n});\n\nquil.core$macros.noise_detail.cljs$core$IFn$_invoke$arity$2 = (function (octaves,falloff){\nreturn quil.sketch.current_applet.call(null).noiseDetail((octaves | (0)),falloff);\n});\n\nquil.core$macros.noise_detail.cljs$lang$maxFixedArity = (2);\n\n/**\n * Sets the seed value for noise. By default, noise produces different\n *   results each time the program is run. Set the value parameter to a\n *   constant to return the same pseudo-random numbers each time the\n *   software is run.\n */\nquil.core$macros.noise_seed = (function quil$core$macros$noise_seed(val){\nreturn quil.sketch.current_applet.call(null).noiseSeed((val | (0)));\n});\n/**\n * Disable all lighting. Lighting is turned off by default and enabled\n *   with the lights fn. This function can be used to disable lighting so\n *   that 2D geometry (which does not require lighting) can be drawn\n *   after a set of lighted 3D geometry.\n */\nquil.core$macros.no_lights = (function quil$core$macros$no_lights(){\nreturn quil.core$macros.current_graphics.call(null).noLights();\n});\n/**\n * Stops Processing from continuously executing the code within\n *   draw. If start-loop is called, the code in draw will begin to run\n *   continuously again. If using no-loop in setup, it should be the last\n *   line inside the block.\n * \n *   When no-loop is used, it's not possible to manipulate or access the\n *   screen inside event handling functions such as mouse-pressed or\n *   key-pressed. Instead, use those functions to call redraw or\n *   loop which will run draw, which can update the screen\n *   properly. This means that when no-loop has been called, no drawing\n *   can happen, and functions like save-frame may not be used.\n * \n *   Note that if the sketch is resized, redraw will be called to\n *   update the sketch, even after no-oop has been\n *   specified. Otherwise, the sketch would enter an odd state until\n *   loop was called.\n */\nquil.core$macros.no_loop = (function quil$core$macros$no_loop(){\nreturn quil.sketch.current_applet.call(null).noLoop();\n});\n/**\n * Normalize a value to exist between 0 and 1 (inclusive).\n */\nquil.core$macros.norm = (function quil$core$macros$norm(val,start,stop){\nreturn quil.sketch.current_applet.call(null).norm(val,start,stop);\n});\n/**\n * Sets the current normal vector. This is for drawing three\n *   dimensional shapes and surfaces and specifies a vector perpendicular\n *   to the surface of the shape which determines how lighting affects\n *   it. Processing attempts to automatically assign normals to shapes,\n *   but since that's imperfect, this is a better option when you want\n *   more control. This function is identical to glNormal3f() in OpenGL.\n */\nquil.core$macros.normal = (function quil$core$macros$normal(nx,ny,nz){\nreturn quil.core$macros.current_graphics.call(null).normal(nx,ny,nz);\n});\n/**\n * Draws all geometry with jagged (aliased) edges. Must be called inside\n *   :settings handler.\n */\nquil.core$macros.no_smooth = (function quil$core$macros$no_smooth(){\nreturn quil.core$macros.current_graphics.call(null).noSmooth();\n});\n/**\n * Disables drawing the stroke (outline). If both no-stroke and\n *   no-fill are called, nothing will be drawn to the screen.\n */\nquil.core$macros.no_stroke = (function quil$core$macros$no_stroke(){\nreturn quil.core$macros.current_graphics.call(null).noStroke();\n});\n/**\n * Removes the current fill value for displaying images and reverts to\n *   displaying images with their original hues.\n */\nquil.core$macros.no_tint = (function quil$core$macros$no_tint(){\nreturn quil.core$macros.current_graphics.call(null).noTint();\n});\n/**\n * Sets an orthographic projection and defines a parallel clipping\n *   volume. All objects with the same dimension appear the same size,\n *   regardless of whether they are near or far from the camera. The\n *   parameters to this function specify the clipping volume where left\n *   and right are the minimum and maximum x values, top and bottom are\n *   the minimum and maximum y values, and near and far are the minimum\n *   and maximum z values. If no parameters are given, the default is\n *   used: (ortho 0 width 0 height -10 10)\n */\nquil.core$macros.ortho = (function quil$core$macros$ortho(var_args){\nvar args712 = [];\nvar len__13421__auto___715 = arguments.length;\nvar i__13422__auto___716 = (0);\nwhile(true){\nif((i__13422__auto___716 < len__13421__auto___715)){\nargs712.push((arguments[i__13422__auto___716]));\n\nvar G__717 = (i__13422__auto___716 + (1));\ni__13422__auto___716 = G__717;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__714 = args712.length;\nswitch (G__714) {\ncase (0):\nreturn quil.core$macros.ortho.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase (4):\nreturn quil.core$macros.ortho.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase (6):\nreturn quil.core$macros.ortho.cljs$core$IFn$_invoke$arity$6((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args712.length)].join('')));\n\n}\n});\n\nquil.core$macros.ortho.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn quil.core$macros.current_graphics.call(null).ortho();\n});\n\nquil.core$macros.ortho.cljs$core$IFn$_invoke$arity$4 = (function (left,right,bottom,top){\nreturn quil.core$macros.current_graphics.call(null).ortho(left,right,bottom,top);\n});\n\nquil.core$macros.ortho.cljs$core$IFn$_invoke$arity$6 = (function (left,right,bottom,top,near,far){\nreturn quil.core$macros.current_graphics.call(null).ortho(left,right,bottom,top,near,far);\n});\n\nquil.core$macros.ortho.cljs$lang$maxFixedArity = (6);\n\n/**\n * Sets a perspective projection applying foreshortening, making\n *   distant objects appear smaller than closer ones. The parameters\n *   define a viewing volume with the shape of truncated pyramid. Objects\n *   near to the front of the volume appear their actual size, while\n *   farther objects appear smaller. This projection simulates the\n *   perspective of the world more accurately than orthographic\n *   projection. The version of perspective without parameters sets the\n *   default perspective and the version with four parameters allows the\n *   programmer to set the area precisely. The default values are:\n *   perspective(PI/3.0, width/height, cameraZ/10.0, cameraZ*10.0) where\n *   cameraZ is ((height/2.0) / tan(PI*60.0/360.0));\n */\nquil.core$macros.perspective = (function quil$core$macros$perspective(var_args){\nvar args719 = [];\nvar len__13421__auto___722 = arguments.length;\nvar i__13422__auto___723 = (0);\nwhile(true){\nif((i__13422__auto___723 < len__13421__auto___722)){\nargs719.push((arguments[i__13422__auto___723]));\n\nvar G__724 = (i__13422__auto___723 + (1));\ni__13422__auto___723 = G__724;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__721 = args719.length;\nswitch (G__721) {\ncase (0):\nreturn quil.core$macros.perspective.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase (4):\nreturn quil.core$macros.perspective.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args719.length)].join('')));\n\n}\n});\n\nquil.core$macros.perspective.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn quil.core$macros.current_graphics.call(null).perspective();\n});\n\nquil.core$macros.perspective.cljs$core$IFn$_invoke$arity$4 = (function (fovy,aspect,z_near,z_far){\nreturn quil.core$macros.current_graphics.call(null).perspective(fovy,aspect,z_near,z_far);\n});\n\nquil.core$macros.perspective.cljs$lang$maxFixedArity = (4);\n\n/**\n * Array containing the values for all the pixels in the display\n *   window or image. This array is therefore the size of the display window. If\n *   this array is modified, the update-pixels fn must be called to update\n *   the changes. Calls .loadPixels before obtaining the pixel array.\n */\nquil.core$macros.pixels = (function quil$core$macros$pixels(var_args){\nvar args726 = [];\nvar len__13421__auto___729 = arguments.length;\nvar i__13422__auto___730 = (0);\nwhile(true){\nif((i__13422__auto___730 < len__13421__auto___729)){\nargs726.push((arguments[i__13422__auto___730]));\n\nvar G__731 = (i__13422__auto___730 + (1));\ni__13422__auto___730 = G__731;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__728 = args726.length;\nswitch (G__728) {\ncase (0):\nreturn quil.core$macros.pixels.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase (1):\nreturn quil.core$macros.pixels.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args726.length)].join('')));\n\n}\n});\n\nquil.core$macros.pixels.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn quil.core$macros.pixels.call(null,quil.core$macros.current_graphics.call(null));\n});\n\nquil.core$macros.pixels.cljs$core$IFn$_invoke$arity$1 = (function (img){\nimg.loadPixels();\n\nvar pix_array = img.pixels.toArray();\nimg.stored_pix_array = pix_array;\n\nreturn pix_array;\n});\n\nquil.core$macros.pixels.cljs$lang$maxFixedArity = (1);\n\n/**\n * Horizontal coordinate of the mouse in the previous frame\n */\nquil.core$macros.pmouse_x = (function quil$core$macros$pmouse_x(){\nreturn quil.sketch.current_applet.call(null).pmouseX;\n});\n/**\n * Vertical coordinate of the mouse in the previous frame\n */\nquil.core$macros.pmouse_y = (function quil$core$macros$pmouse_y(){\nreturn quil.sketch.current_applet.call(null).pmouseY;\n});\n/**\n * Draws a point, a coordinate in space at the dimension of one\n *   pixel. The first parameter is the horizontal value for the point,\n *   the second value is the vertical value for the point, and the\n *   optional third value is the depth value. Drawing this shape in 3D\n *   using the z parameter requires the :P3D or :opengl renderer to be\n *   used.\n */\nquil.core$macros.point = (function quil$core$macros$point(var_args){\nvar args733 = [];\nvar len__13421__auto___736 = arguments.length;\nvar i__13422__auto___737 = (0);\nwhile(true){\nif((i__13422__auto___737 < len__13421__auto___736)){\nargs733.push((arguments[i__13422__auto___737]));\n\nvar G__738 = (i__13422__auto___737 + (1));\ni__13422__auto___737 = G__738;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__735 = args733.length;\nswitch (G__735) {\ncase (2):\nreturn quil.core$macros.point.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.point.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args733.length)].join('')));\n\n}\n});\n\nquil.core$macros.point.cljs$core$IFn$_invoke$arity$2 = (function (x,y){\nreturn quil.core$macros.current_graphics.call(null).point(x,y);\n});\n\nquil.core$macros.point.cljs$core$IFn$_invoke$arity$3 = (function (x,y,z){\nreturn quil.core$macros.current_graphics.call(null).point(x,y,z);\n});\n\nquil.core$macros.point.cljs$lang$maxFixedArity = (3);\n\n/**\n * Adds a point light. Lights need to be included in the draw() to\n *   remain persistent in a looping program. Placing them in the setup()\n *   of a looping program will cause them to only have an effect the\n *   first time through the loop. The affect of the r, g, and b\n *   parameters is determined by the current color mode. The x, y, and z\n *   parameters set the position of the light\n */\nquil.core$macros.point_light = (function quil$core$macros$point_light(r,g,b,x,y,z){\nreturn quil.core$macros.current_graphics.call(null).pointLight(r,g,b,x,y,z);\n});\n/**\n * Pops the current transformation matrix off the matrix\n *   stack. Understanding pushing and popping requires understanding the\n *   concept of a matrix stack. The push-matrix fn saves the current\n *   coordinate system to the stack and pop-matrix restores the prior\n *   coordinate system. push-matrix and pop-matrix are used in conjuction\n *   with the other transformation methods and may be embedded to control\n *   the scope of the transformations.\n */\nquil.core$macros.pop_matrix = (function quil$core$macros$pop_matrix(){\nreturn quil.core$macros.current_graphics.call(null).popMatrix();\n});\n/**\n * Restores the prior settings on the 'style stack'. Used in\n *   conjunction with push-style. Together they allow you to change the\n *   style settings and later return to what you had. When a new style is\n *   started with push-style, it builds on the current style information.\n *   The push-style and pop-style functions can be nested to provide more\n *   control\n */\nquil.core$macros.pop_style = (function quil$core$macros$pop_style(){\nreturn quil.core$macros.current_graphics.call(null).popStyle();\n});\n/**\n * Facilitates exponential expressions. The pow() function is an\n *   efficient way of multiplying numbers by themselves (or their\n *   reciprocal) in large quantities. For example, (pow 3 5) is\n *   equivalent to the expression (* 3 3 3 3 3) and (pow 3 -5) is\n *   equivalent to (/ 1 (* 3 3 3 3 3)).\n */\nquil.core$macros.pow = (function quil$core$macros$pow(num,exponent){\nreturn quil.sketch.current_applet.call(null).pow(num,exponent);\n});\n/**\n * Prints the current camera matrix to std out. Useful for debugging.\n */\nquil.core$macros.print_camera = (function quil$core$macros$print_camera(){\nreturn quil.core$macros.current_graphics.call(null).printCamera();\n});\n/**\n * Prints the current matrix to std out. Useful for debugging.\n */\nquil.core$macros.print_matrix = (function quil$core$macros$print_matrix(){\nreturn quil.core$macros.current_graphics.call(null).printMatrix();\n});\n/**\n * Prints the current projection matrix to std out. Useful for\n *   debugging\n */\nquil.core$macros.print_projection = (function quil$core$macros$print_projection(){\nreturn quil.core$macros.current_graphics.call(null).printProjection();\n});\n/**\n * Pushes the current transformation matrix onto the matrix\n *   stack. Understanding push-matrix and pop-matrix requires\n *   understanding the concept of a matrix stack. The push-matrix\n *   function saves the current coordinate system to the stack and\n *   pop-matrix restores the prior coordinate system. push-matrix and\n *   pop-matrix are used in conjuction with the other transformation\n *   methods and may be embedded to control the scope of the\n *   transformations.\n */\nquil.core$macros.push_matrix = (function quil$core$macros$push_matrix(){\nreturn quil.core$macros.current_graphics.call(null).pushMatrix();\n});\n/**\n * Saves the current style settings onto a 'style stack'. Use with\n *   pop-style which restores the prior settings. Note that these\n *   functions are always used together. They allow you to change the\n *   style settings and later return to what you had. When a new style is\n *   started with push-style, it builds on the current style\n *   information. The push-style and pop-style fns can be embedded to\n *   provide more control.\n * \n *   The style information controlled by the following functions are\n *   included in the style: fill, stroke, tint, stroke-weight,\n *   stroke-cap, stroke-join, image-mode, rect-mode, ellipse-mode,\n *   shape-mode, color-mode, text-align, text-font, text-mode, text-size,\n *   text-leading, emissive, specular, shininess, and ambient\n */\nquil.core$macros.push_style = (function quil$core$macros$push_style(){\nreturn quil.core$macros.current_graphics.call(null).pushStyle();\n});\n/**\n * A quad is a quadrilateral, a four sided polygon. It is similar to a\n *   rectangle, but the angles between its edges are not constrained to\n *   be ninety degrees. The first pair of parameters (x1,y1) sets the\n *   first vertex and the subsequent pairs should proceed clockwise or\n *   counter-clockwise around the defined shape.\n */\nquil.core$macros.quad = (function quil$core$macros$quad(x1,y1,x2,y2,x3,y3,x4,y4){\nreturn quil.core$macros.current_graphics.call(null).quad(x1,y1,x2,y2,x3,y3,x4,y4);\n});\n/**\n * Specifies vertex coordinates for quadratic Bezier curves. Each call to\n *   quadratic-vertex defines the position of one control points and one\n *   anchor point of a Bezier curve, adding a new segment to a line or shape.\n *   The first time quadratic-vertex is used within a begin-shape call, it\n *   must be prefaced with a call to vertex to set the first anchor point.\n *   This function must be used between begin-shape and end-shape and only\n *   when there is no MODE parameter specified to begin-shape. Using the 3D\n *   version requires rendering with :p3d.\n */\nquil.core$macros.quadratic_vertex = (function quil$core$macros$quadratic_vertex(var_args){\nvar args740 = [];\nvar len__13421__auto___743 = arguments.length;\nvar i__13422__auto___744 = (0);\nwhile(true){\nif((i__13422__auto___744 < len__13421__auto___743)){\nargs740.push((arguments[i__13422__auto___744]));\n\nvar G__745 = (i__13422__auto___744 + (1));\ni__13422__auto___744 = G__745;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__742 = args740.length;\nswitch (G__742) {\ncase (4):\nreturn quil.core$macros.quadratic_vertex.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase (6):\nreturn quil.core$macros.quadratic_vertex.cljs$core$IFn$_invoke$arity$6((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args740.length)].join('')));\n\n}\n});\n\nquil.core$macros.quadratic_vertex.cljs$core$IFn$_invoke$arity$4 = (function (cx,cy,x3,y3){\nreturn quil.core$macros.current_graphics.call(null).quadraticVertex(cx,cy,x3,y3);\n});\n\nquil.core$macros.quadratic_vertex.cljs$core$IFn$_invoke$arity$6 = (function (cx,cy,cz,x3,y3,z3){\nreturn quil.core$macros.current_graphics.call(null).quadraticVertex(cx,cy,cz,x3,y3,z3);\n});\n\nquil.core$macros.quadratic_vertex.cljs$lang$maxFixedArity = (6);\n\n/**\n * Converts a degree measurement to its corresponding value in\n *   radians. Radians and degrees are two ways of measuring the same\n *   thing. There are 360 degrees in a circle and 2*PI radians in a\n *   circle. For example, 90° = PI/2 = 1.5707964. All trigonometric\n *   methods in Processing require their parameters to be specified in\n *   radians.\n */\nquil.core$macros.radians = (function quil$core$macros$radians(degrees){\nreturn quil.sketch.current_applet.call(null).radians(degrees);\n});\n/**\n * Generates random numbers. Each time the random function is called,\n *   it returns an unexpected value within the specified range. If one\n *   parameter is passed to the function it will return a float between\n *   zero and the value of the high parameter. The function call (random\n *   5) returns values between 0 and 5 (starting at zero, up to but not\n *   including 5). If two parameters are passed, it will return a float\n *   with a value between the parameters. The function call\n *   (random -5 10.2) returns values starting at -5 up to (but not\n *   including) 10.2.\n */\nquil.core$macros.random = (function quil$core$macros$random(var_args){\nvar args747 = [];\nvar len__13421__auto___750 = arguments.length;\nvar i__13422__auto___751 = (0);\nwhile(true){\nif((i__13422__auto___751 < len__13421__auto___750)){\nargs747.push((arguments[i__13422__auto___751]));\n\nvar G__752 = (i__13422__auto___751 + (1));\ni__13422__auto___751 = G__752;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__749 = args747.length;\nswitch (G__749) {\ncase (1):\nreturn quil.core$macros.random.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.random.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args747.length)].join('')));\n\n}\n});\n\nquil.core$macros.random.cljs$core$IFn$_invoke$arity$1 = (function (max){\nreturn quil.sketch.current_applet.call(null).random(max);\n});\n\nquil.core$macros.random.cljs$core$IFn$_invoke$arity$2 = (function (min,max){\nreturn quil.sketch.current_applet.call(null).random(min,max);\n});\n\nquil.core$macros.random.cljs$lang$maxFixedArity = (2);\n\n/**\n * Returns a float from a random series of numbers having a mean of 0 and\n *   standard deviation of 1. Each time the randomGaussian() function is called,\n *   it returns a number fitting a Gaussian, or normal, distribution.\n *   There is theoretically no minimum or maximum value that randomGaussian()\n *   might return. Rather, there is just a very low probability that values far\n *   from the mean will be returned; and a higher probability that numbers near\n *   the mean will be returned. .\n */\nquil.core$macros.random_gaussian = (function quil$core$macros$random_gaussian(){\nreturn quil.sketch.current_applet.call(null).randomGaussian();\n});\n/**\n * Sets the seed value for random. By default, random produces\n *   different results each time the program is run. Set the value\n *   parameter to a constant to return the same pseudo-random numbers\n *   each time the software is run.\n */\nquil.core$macros.random_seed = (function quil$core$macros$random_seed(w){\nreturn quil.sketch.current_applet.call(null).randomSeed(w);\n});\n/**\n * Contains the value of the most recent key on the keyboard that was\n *   used (either pressed or released).\n * \n *   For non-ASCII keys, use the keyCode variable. The keys included in\n *   the ASCII specification (BACKSPACE, TAB, ENTER, RETURN, ESC, and\n *   DELETE) do not require checking to see if they key is coded, and you\n *   should simply use the key variable instead of keyCode If you're\n *   making cross-platform projects, note that the ENTER key is commonly\n *   used on PCs and Unix and the RETURN key is used instead on\n *   Macintosh. Check for both ENTER and RETURN to make sure your program\n *   will work for all platforms.\n */\nquil.core$macros.raw_key = (function quil$core$macros$raw_key(){\nreturn quil.sketch.current_applet.call(null).key;\n});\n/**\n * Draws a rectangle to the screen. A rectangle is a four-sided shape\n *   with every angle at ninety degrees. By default, the first two\n *   parameters set the location of the upper-left corner, the third\n *   sets the width, and the fourth sets the height. These parameters\n *   may be changed with rect-mode.\n * \n *   To draw a rounded rectangle, add a fifth parameter, which is used as\n *   the radius value for all four corners. To use a different radius value\n *   for each corner, include eight parameters.\n */\nquil.core$macros.rect = (function quil$core$macros$rect(var_args){\nvar args754 = [];\nvar len__13421__auto___757 = arguments.length;\nvar i__13422__auto___758 = (0);\nwhile(true){\nif((i__13422__auto___758 < len__13421__auto___757)){\nargs754.push((arguments[i__13422__auto___758]));\n\nvar G__759 = (i__13422__auto___758 + (1));\ni__13422__auto___758 = G__759;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__756 = args754.length;\nswitch (G__756) {\ncase (4):\nreturn quil.core$macros.rect.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase (5):\nreturn quil.core$macros.rect.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ncase (8):\nreturn quil.core$macros.rect.cljs$core$IFn$_invoke$arity$8((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args754.length)].join('')));\n\n}\n});\n\nquil.core$macros.rect.cljs$core$IFn$_invoke$arity$4 = (function (x,y,width,height){\nreturn quil.core$macros.current_graphics.call(null).rect(x,y,width,height);\n});\n\nquil.core$macros.rect.cljs$core$IFn$_invoke$arity$5 = (function (x,y,width,height,r){\nreturn quil.core$macros.current_graphics.call(null).rect(x,y,width,height,r);\n});\n\nquil.core$macros.rect.cljs$core$IFn$_invoke$arity$8 = (function (x,y,width,height,top_left_r,top_right_r,bottom_right_r,bottom_left_r){\nreturn quil.core$macros.current_graphics.call(null).rect(x,y,width,height,top_left_r,top_right_r,bottom_right_r,bottom_left_r);\n});\n\nquil.core$macros.rect.cljs$lang$maxFixedArity = (8);\n\n/**\n * Modifies the location from which rectangles draw. The default mode\n *   is :corner. Available modes are:\n * \n * \n *   :corner  - Specifies the location to be the upper left corner of the\n *           shape and uses the third and fourth parameters of rect to\n *           specify the width and height.\n * \n *   :corners - Uses the first and second parameters of rect to set the\n *           location of one corner and uses the third and fourth\n *           parameters to set the opposite corner.\n * \n *   :center  - Draws the image from its center point and uses the third\n *           and forth parameters of rect to specify the image's width\n *           and height.\n * \n *   :radius  - Draws the image from its center point and uses the third\n *           and forth parameters of rect() to specify half of the\n *           image's width and height.\n */\nquil.core$macros.rect_mode = (function quil$core$macros$rect_mode(mode){\nvar mode__$1 = quil.util.resolve_constant_key.call(null,mode,quil.core$macros.rect_modes);\nreturn quil.core$macros.current_graphics.call(null).rectMode((mode__$1 | (0)));\n});\n/**\n * Extracts the red value from a color, scaled to match current color-mode.\n */\nquil.core$macros.red = (function quil$core$macros$red(c){\nreturn quil.core$macros.current_graphics.call(null).red(cljs.core.unchecked_int.call(null,c));\n});\n/**\n * Executes the code within the draw fn one time. This functions\n *   allows the program to update the display window only when necessary,\n *   for example when an event registered by mouse-pressed or\n *   key-pressed occurs.\n * \n *   In structuring a program, it only makes sense to call redraw\n *   within events such as mouse-pressed. This is because redraw does\n *   not run draw immediately (it only sets a flag that indicates an\n *   update is needed).\n * \n *   Calling redraw within draw has no effect because draw is\n *   continuously called anyway.\n */\nquil.core$macros.redraw = (function quil$core$macros$redraw(){\nreturn quil.sketch.current_applet.call(null).redraw();\n});\n/**\n * This function load images on a separate thread so that your sketch\n *   does not freeze while images load during setup. While the image is\n *   loading, its width and height will be 0. If an error occurs while\n *   loading the image, its width and height will be set to -1. You'll\n *   know when the image has loaded properly because its width and height\n *   will be greater than 0. Asynchronous image loading (particularly\n *   when downloading from a server) can dramatically improve\n *   performance.\n */\nquil.core$macros.request_image = (function quil$core$macros$request_image(filename){\nreturn quil.sketch.current_applet.call(null).requestImage([cljs.core.str(filename)].join(''));\n});\n/**\n * Replaces the current matrix with the identity matrix. The\n *   equivalent function in OpenGL is glLoadIdentity()\n */\nquil.core$macros.reset_matrix = (function quil$core$macros$reset_matrix(){\nreturn quil.core$macros.current_graphics.call(null).resetMatrix();\n});\n/**\n * Resize the image to a new width and height.\n *   To make the image scale proportionally, use 0 as the value for the wide or\n *   high parameter. For instance, to make the width of an image 150 pixels,\n *   and change the height using the same proportion, use resize(150, 0).\n * \n *   Even though a PGraphics is technically a PImage, it is not possible\n *   to rescale the image data found in a PGraphics.\n *   (It's simply not possible to do this consistently across renderers:\n *   technically infeasible with P3D, or what would it even do with PDF?)\n *   If you want to resize PGraphics content, first get a copy of its image data\n *   using the get() method, and call resize() on the PImage that is returned.\n */\nquil.core$macros.resize = (function quil$core$macros$resize(img,w,h){\nreturn img.resize(w,h);\n});\n/**\n * Rotates a shape the amount specified by the angle parameter. Angles\n *   should be specified in radians (values from 0 to TWO-PI) or\n *   converted to radians with the radians function.\n * \n *   Objects are always rotated around their relative position to the\n *   origin and positive numbers rotate objects in a clockwise\n *   direction. Transformations apply to everything that happens after\n *   and subsequent calls to the function accumulates the effect. For\n *   example, calling (rotate HALF-PI) and then (rotate HALF-PI) is the\n *   same as (rotate PI). All tranformations are reset when draw begins\n *   again.\n * \n *   Technically, rotate multiplies the current transformation matrix by\n *   a rotation matrix. This function can be further controlled by the\n *   push-matrix and pop-matrix.\n */\nquil.core$macros.rotate = (function quil$core$macros$rotate(var_args){\nvar args761 = [];\nvar len__13421__auto___764 = arguments.length;\nvar i__13422__auto___765 = (0);\nwhile(true){\nif((i__13422__auto___765 < len__13421__auto___764)){\nargs761.push((arguments[i__13422__auto___765]));\n\nvar G__766 = (i__13422__auto___765 + (1));\ni__13422__auto___765 = G__766;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__763 = args761.length;\nswitch (G__763) {\ncase (1):\nreturn quil.core$macros.rotate.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (4):\nreturn quil.core$macros.rotate.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args761.length)].join('')));\n\n}\n});\n\nquil.core$macros.rotate.cljs$core$IFn$_invoke$arity$1 = (function (angle){\nreturn quil.core$macros.current_graphics.call(null).rotate(angle);\n});\n\nquil.core$macros.rotate.cljs$core$IFn$_invoke$arity$4 = (function (angle,vx,vy,vz){\nreturn quil.core$macros.current_graphics.call(null).rotate(angle,vx,vy,vz);\n});\n\nquil.core$macros.rotate.cljs$lang$maxFixedArity = (4);\n\n/**\n * Rotates a shape around the x-axis the amount specified by the angle\n *   parameter. Angles should be specified in radians (values from 0 to\n *   (* PI 2)) or converted to radians with the radians function. Objects\n *   are always rotated around their relative position to the origin and\n *   positive numbers rotate objects in a counterclockwise\n *   direction. Transformations apply to everything that happens after\n *   and subsequent calls to the function accumulates the effect. For\n *   example, calling (rotate-x HALF-PI) and then (rotate-x HALF-PI) is\n *   the same as (rotate-x PI). If rotate-x is called within the draw fn,\n *   the transformation is reset when the loop begins again. This\n *   function requires either the :p3d or :opengl renderer.\n */\nquil.core$macros.rotate_x = (function quil$core$macros$rotate_x(angle){\nreturn quil.core$macros.current_graphics.call(null).rotateX(angle);\n});\n/**\n * Rotates a shape around the y-axis the amount specified by the angle\n *   parameter. Angles should be specified in radians (values from 0\n *   to (* PI 2)) or converted to radians with the radians function.\n *   Objects are always rotated around their relative position to the\n *   origin and positive numbers rotate objects in a counterclockwise\n *   direction. Transformations apply to everything that happens after\n *   and subsequent calls to the function accumulates the effect. For\n *   example, calling (rotate-y HALF-PI) and then (rotate-y HALF-PI) is\n *   the same as (rotate-y PI). If rotate-y is called within the draw fn,\n *   the transformation is reset when the loop begins again. This\n *   function requires either the :p3d or :opengl renderer.\n */\nquil.core$macros.rotate_y = (function quil$core$macros$rotate_y(angle){\nreturn quil.core$macros.current_graphics.call(null).rotateY(angle);\n});\n/**\n * Rotates a shape around the z-axis the amount specified by the angle\n *   parameter. Angles should be specified in radians (values from 0\n *   to (* PI 2)) or converted to radians with the radians function.\n *   Objects are always rotated around their relative position to the\n *   origin and positive numbers rotate objects in a counterclockwise\n *   direction. Transformations apply to everything that happens after\n *   and subsequent calls to the function accumulates the effect. For\n *   example, calling (rotate-z HALF-PI) and then (rotate-z HALF-PI) is\n *   the same as (rotate-z PI). If rotate-y is called within the draw fn,\n *   the transformation is reset when the loop begins again. This\n *   function requires either the :p3d or :opengl renderer.\n */\nquil.core$macros.rotate_z = (function quil$core$macros$rotate_z(angle){\nreturn quil.core$macros.current_graphics.call(null).rotateZ(angle);\n});\n/**\n * Calculates the integer closest to the value parameter. For example,\n *   (round 9.2) returns the value 9.\n */\nquil.core$macros.round = (function quil$core$macros$round(val){\nreturn quil.sketch.current_applet.call(null).round(val);\n});\n/**\n * Extracts the saturation value from a color.\n */\nquil.core$macros.saturation = (function quil$core$macros$saturation(c){\nreturn quil.core$macros.current_graphics.call(null).saturation(cljs.core.unchecked_int.call(null,c));\n});\n/**\n * Saves an image from the display window. Images are saved in TIFF,\n *   TARGA, JPEG, and PNG format depending on the extension within the\n *   filename parameter. For example, image.tif will have a TIFF image\n *   and image.png will save a PNG image. If no extension is included in\n *   the filename, the image will save in TIFF format and .tif will be\n *   added to the name. All images saved from the main drawing window\n *   will be opaque. To save images without a background, use\n *   create-graphics.\n */\nquil.core$macros.save = (function quil$core$macros$save(filename){\nreturn quil.core$macros.current_graphics.call(null).save([cljs.core.str(filename)].join(''));\n});\n/**\n * Saves an image identical to the current display window as a\n *   file. May be called multple times - each file saved will have a\n *   unique name. Name and image formate may be modified by passing a\n *   string parameter of the form \"foo-####.ext\" where foo- can be any\n *   arbitrary string, #### will be replaced with the current frame id\n *   and .ext is one of .tiff, .targa, .png, .jpeg or .jpg\n * \n *   Examples:\n *   (save-frame)\n *   (save-frame \"pretty-pic-####.jpg\")\n */\nquil.core$macros.save_frame = (function quil$core$macros$save_frame(var_args){\nvar args768 = [];\nvar len__13421__auto___771 = arguments.length;\nvar i__13422__auto___772 = (0);\nwhile(true){\nif((i__13422__auto___772 < len__13421__auto___771)){\nargs768.push((arguments[i__13422__auto___772]));\n\nvar G__773 = (i__13422__auto___772 + (1));\ni__13422__auto___772 = G__773;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__770 = args768.length;\nswitch (G__770) {\ncase (0):\nreturn quil.core$macros.save_frame.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase (1):\nreturn quil.core$macros.save_frame.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args768.length)].join('')));\n\n}\n});\n\nquil.core$macros.save_frame.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn quil.sketch.current_applet.call(null).saveFrame();\n});\n\nquil.core$macros.save_frame.cljs$core$IFn$_invoke$arity$1 = (function (name){\nreturn quil.sketch.current_applet.call(null).saveFrame([cljs.core.str(name)].join(''));\n});\n\nquil.core$macros.save_frame.cljs$lang$maxFixedArity = (1);\n\n/**\n * Increases or decreases the size of a shape by expanding and\n *   contracting vertices. Objects always scale from their relative\n *   origin to the coordinate system. Scale values are specified as\n *   decimal percentages. For example, the function call (scale 2)\n *   increases the dimension of a shape by 200%. Transformations apply to\n *   everything that happens after and subsequent calls to the function\n *   multiply the effect. For example, calling (scale 2) and then\n *   (scale 1.5) is the same as (scale 3). If scale is called within\n *   draw, the transformation is reset when the loop begins again. Using\n *   this fuction with the z parameter requires specfying :p3d or :opengl\n *   as the renderer. This function can be further controlled by\n *   push-matrix and pop-matrix.\n */\nquil.core$macros.scale = (function quil$core$macros$scale(var_args){\nvar args775 = [];\nvar len__13421__auto___778 = arguments.length;\nvar i__13422__auto___779 = (0);\nwhile(true){\nif((i__13422__auto___779 < len__13421__auto___778)){\nargs775.push((arguments[i__13422__auto___779]));\n\nvar G__780 = (i__13422__auto___779 + (1));\ni__13422__auto___779 = G__780;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__777 = args775.length;\nswitch (G__777) {\ncase (1):\nreturn quil.core$macros.scale.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.scale.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.scale.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args775.length)].join('')));\n\n}\n});\n\nquil.core$macros.scale.cljs$core$IFn$_invoke$arity$1 = (function (s){\nreturn quil.core$macros.current_graphics.call(null).scale(s);\n});\n\nquil.core$macros.scale.cljs$core$IFn$_invoke$arity$2 = (function (sx,sy){\nreturn quil.core$macros.current_graphics.call(null).scale(sx,sy);\n});\n\nquil.core$macros.scale.cljs$core$IFn$_invoke$arity$3 = (function (sx,sy,sz){\nreturn quil.core$macros.current_graphics.call(null).scale(sx,sy,sz);\n});\n\nquil.core$macros.scale.cljs$lang$maxFixedArity = (3);\n\n/**\n * Takes a three-dimensional x, y, z position and returns the x value\n *   for where it will appear on a (two-dimensional) screen, once\n *   affected by translate, scale or any other transformations\n */\nquil.core$macros.screen_x = (function quil$core$macros$screen_x(var_args){\nvar args782 = [];\nvar len__13421__auto___785 = arguments.length;\nvar i__13422__auto___786 = (0);\nwhile(true){\nif((i__13422__auto___786 < len__13421__auto___785)){\nargs782.push((arguments[i__13422__auto___786]));\n\nvar G__787 = (i__13422__auto___786 + (1));\ni__13422__auto___786 = G__787;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__784 = args782.length;\nswitch (G__784) {\ncase (2):\nreturn quil.core$macros.screen_x.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.screen_x.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args782.length)].join('')));\n\n}\n});\n\nquil.core$macros.screen_x.cljs$core$IFn$_invoke$arity$2 = (function (x,y){\nreturn quil.core$macros.current_graphics.call(null).screenX(x,y);\n});\n\nquil.core$macros.screen_x.cljs$core$IFn$_invoke$arity$3 = (function (x,y,z){\nreturn quil.core$macros.current_graphics.call(null).screenX(x,y,z);\n});\n\nquil.core$macros.screen_x.cljs$lang$maxFixedArity = (3);\n\n/**\n * Takes a three-dimensional x, y, z position and returns the y value\n *   for where it will appear on a (two-dimensional) screen, once\n *   affected by translate, scale or any other transformations\n */\nquil.core$macros.screen_y = (function quil$core$macros$screen_y(var_args){\nvar args789 = [];\nvar len__13421__auto___792 = arguments.length;\nvar i__13422__auto___793 = (0);\nwhile(true){\nif((i__13422__auto___793 < len__13421__auto___792)){\nargs789.push((arguments[i__13422__auto___793]));\n\nvar G__794 = (i__13422__auto___793 + (1));\ni__13422__auto___793 = G__794;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__791 = args789.length;\nswitch (G__791) {\ncase (2):\nreturn quil.core$macros.screen_y.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.screen_y.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args789.length)].join('')));\n\n}\n});\n\nquil.core$macros.screen_y.cljs$core$IFn$_invoke$arity$2 = (function (x,y){\nreturn quil.core$macros.current_graphics.call(null).screenY(x,y);\n});\n\nquil.core$macros.screen_y.cljs$core$IFn$_invoke$arity$3 = (function (x,y,z){\nreturn quil.core$macros.current_graphics.call(null).screenY(x,y,z);\n});\n\nquil.core$macros.screen_y.cljs$lang$maxFixedArity = (3);\n\n/**\n * Given an x, y, z coordinate, returns its z value.\n * This value can be used to determine if an x, y, z coordinate is in\n * front or in back of another (x, y, z) coordinate. The units are\n * based on how the zbuffer is set up, and don't relate to anything\n * 'real'. They're only useful for in comparison to another value\n * obtained from screen-z, or directly out of the zbuffer\n */\nquil.core$macros.screen_z = (function quil$core$macros$screen_z(x,y,z){\nreturn quil.core$macros.current_graphics.call(null).screenZ(x,y,z);\n});\n/**\n * Returns the current second as a value from 0 - 59.\n */\nquil.core$macros.seconds = (function quil$core$macros$seconds(){\nreturn quil.sketch.current_applet.call(null).second();\n});\n/**\n * Changes the color of any pixel in the display window. The x and y\n *   parameters specify the pixel to change and the color parameter\n *   specifies the color value. The color parameter is affected by the\n *   current color mode (the default is RGB values from 0 to 255).\n * \n *   Setting the color of a single pixel with (set x, y) is easy, but not\n *   as fast as putting the data directly into pixels[].\n * \n *   This function ignores imageMode().\n * \n *   Due to what appears to be a bug in Apple's Java implementation, the\n *   point() and set() methods are extremely slow in some circumstances\n *   when used with the default renderer. Using :p2d or :p3d will fix the\n *   problem. Grouping many calls to point or set-pixel together can also\n *   help. (Bug 1094)\n */\nquil.core$macros.set_pixel = (function quil$core$macros$set_pixel(var_args){\nvar args796 = [];\nvar len__13421__auto___799 = arguments.length;\nvar i__13422__auto___800 = (0);\nwhile(true){\nif((i__13422__auto___800 < len__13421__auto___799)){\nargs796.push((arguments[i__13422__auto___800]));\n\nvar G__801 = (i__13422__auto___800 + (1));\ni__13422__auto___800 = G__801;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__798 = args796.length;\nswitch (G__798) {\ncase (3):\nreturn quil.core$macros.set_pixel.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core$macros.set_pixel.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args796.length)].join('')));\n\n}\n});\n\nquil.core$macros.set_pixel.cljs$core$IFn$_invoke$arity$3 = (function (x,y,c){\nreturn quil.core$macros.set_pixel.call(null,quil.core$macros.current_graphics.call(null),x,y,c);\n});\n\nquil.core$macros.set_pixel.cljs$core$IFn$_invoke$arity$4 = (function (img,x,y,c){\nreturn img.set((x | (0)),(y | (0)),(c | (0)));\n});\n\nquil.core$macros.set_pixel.cljs$lang$maxFixedArity = (4);\n\n/**\n * Writes an image directly into the display window. The x and y\n *   parameters define the coordinates for the upper-left corner of the\n *   image.\n */\nquil.core$macros.set_image = (function quil$core$macros$set_image(x,y,src){\nreturn quil.core$macros.current_graphics.call(null).set((x | (0)),(y | (0)),src);\n});\n/**\n * Displays shapes to the screen. The shapes must have been loaded\n *   with load-shape. Processing currently works with SVG shapes\n *   only. The sh parameter specifies the shape to display and the x and\n *   y parameters define the location of the shape from its upper-left\n *   corner. The shape is displayed at its original size unless the width\n *   and height parameters specify a different size. The shape-mode\n *   fn changes the way the parameters work. A call to\n *   (shape-mode :corners), for example, will change the width and height\n *   parameters to define the x and y values of the opposite corner of\n *   the shape.\n * \n *   Note complex shapes may draw awkwardly with the renderers :p2d, :p3d, and\n *   :opengl. Those renderers do not yet support shapes that have holes\n *   or complicated breaks.\n */\nquil.core$macros.shape = (function quil$core$macros$shape(var_args){\nvar args803 = [];\nvar len__13421__auto___806 = arguments.length;\nvar i__13422__auto___807 = (0);\nwhile(true){\nif((i__13422__auto___807 < len__13421__auto___806)){\nargs803.push((arguments[i__13422__auto___807]));\n\nvar G__808 = (i__13422__auto___807 + (1));\ni__13422__auto___807 = G__808;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__805 = args803.length;\nswitch (G__805) {\ncase (1):\nreturn quil.core$macros.shape.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.shape.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (5):\nreturn quil.core$macros.shape.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args803.length)].join('')));\n\n}\n});\n\nquil.core$macros.shape.cljs$core$IFn$_invoke$arity$1 = (function (sh){\nreturn quil.core$macros.current_graphics.call(null).shape(sh);\n});\n\nquil.core$macros.shape.cljs$core$IFn$_invoke$arity$3 = (function (sh,x,y){\nreturn quil.core$macros.current_graphics.call(null).shape(sh,x,y);\n});\n\nquil.core$macros.shape.cljs$core$IFn$_invoke$arity$5 = (function (sh,x,y,width,height){\nreturn quil.core$macros.current_graphics.call(null).shape(sh,x,y,width,height);\n});\n\nquil.core$macros.shape.cljs$lang$maxFixedArity = (5);\n\n/**\n * Shears a shape around the x-axis the amount specified by the angle\n *   parameter. Angles should be specified in radians (values from 0 to\n *   PI*2) or converted to radians with the radians() function. Objects\n *   are always sheared around their relative position to the origin and\n *   positive numbers shear objects in a clockwise direction.\n *   Transformations apply to everything that happens after and\n *   subsequent calls to the function accumulates the effect. For\n *   example, calling (shear-x (/ PI 2)) and then (shear-x (/ PI 2)) is\n *   the same as (shear-x PI). If shear-x is called within the draw fn,\n *   the transformation is reset when the loop begins again. This\n *   function works in P2D or JAVA2D mode.\n * \n *   Technically, shear-x multiplies the current transformation matrix\n *   by a rotation matrix. This function can be further controlled by the\n *   push-matrix and pop-matrix fns.\n */\nquil.core$macros.shear_x = (function quil$core$macros$shear_x(angle){\nreturn quil.core$macros.current_graphics.call(null).shearX(angle);\n});\n/**\n * Shears a shape around the y-axis the amount specified by the angle\n *   parameter. Angles should be specified in radians (values from 0 to\n *   PI*2) or converted to radians with the radians() function. Objects\n *   are always sheared around their relative position to the origin and\n *   positive numbers shear objects in a clockwise direction.\n *   Transformations apply to everything that happens after and\n *   subsequent calls to the function accumulates the effect. For\n *   example, calling (shear-y (/ PI 2)) and then (shear-y (/ PI 2)) is\n *   the same as (shear-y PI). If shear-y is called within the draw fn,\n *   the transformation is reset when the loop begins again. This\n *   function works in P2D or JAVA2D mode.\n * \n *   Technically, shear-y multiplies the current transformation matrix\n *   by a rotation matrix. This function can be further controlled by the\n *   push-matrix and pop-matrix fns.\n */\nquil.core$macros.shear_y = (function quil$core$macros$shear_y(angle){\nreturn quil.core$macros.current_graphics.call(null).shearY(angle);\n});\n/**\n * Modifies the location from which shapes draw. Available modes are\n *   :corner, :corners and :center. Default is :corner.\n * \n *   :corner  - specifies the location to be the upper left corner of the\n *           shape and uses the third and fourth parameters of shape\n *           to specify the width and height.\n * \n *   :corners - uses the first and second parameters of shape to set\n *           the location of one corner and uses the third and fourth\n *           parameters to set the opposite corner.\n * \n *   :center  - draws the shape from its center point and uses the third\n *           and forth parameters of shape to specify the width and\n *           height. \n */\nquil.core$macros.shape_mode = (function quil$core$macros$shape_mode(mode){\nvar mode__$1 = quil.util.resolve_constant_key.call(null,mode,quil.core$macros.p_shape_modes);\nreturn quil.core$macros.current_graphics.call(null).shapeMode((mode__$1 | (0)));\n});\n/**\n * Sets the amount of gloss in the surface of shapes. Used in\n *   combination with ambient, specular, and emissive in setting\n *   the material properties of shapes.\n */\nquil.core$macros.shininess = (function quil$core$macros$shininess(shine){\nreturn quil.core$macros.current_graphics.call(null).shininess(shine);\n});\n/**\n * Calculates the sine of an angle. This function expects the values\n *   of the angle parameter to be provided in radians (values from 0 to\n *   6.28). A float within the range -1 to 1 is returned.\n */\nquil.core$macros.sin = (function quil$core$macros$sin(angle){\nreturn quil.sketch.current_applet.call(null).sin(angle);\n});\n/**\n * Draws all geometry with smooth (anti-aliased) edges. This will slow\n *   down the frame rate of the application, but will enhance the visual\n *   refinement.\n * \n *   Must be called inside :settings handler.\n * \n *   The level parameter (int) increases the level of smoothness with the\n *   P2D and P3D renderers. This is the level of over sampling applied to\n *   the graphics buffer. The value '2' will double the rendering size\n *   before scaling it down to the display size. This is called '2x\n *   anti-aliasing.' The value 4 is used for 4x anti-aliasing and 8 is\n *   specified for 8x anti-aliasing. If level is set to 0, it will disable\n *   all smoothing; it's the equivalent of the function noSmooth().\n *   The maximum anti-aliasing level is determined by the hardware of the\n *   machine that is running the software.\n * \n *   Note that smooth will also improve image quality of resized images.\n */\nquil.core$macros.smooth = (function quil$core$macros$smooth(var_args){\nvar args810 = [];\nvar len__13421__auto___813 = arguments.length;\nvar i__13422__auto___814 = (0);\nwhile(true){\nif((i__13422__auto___814 < len__13421__auto___813)){\nargs810.push((arguments[i__13422__auto___814]));\n\nvar G__815 = (i__13422__auto___814 + (1));\ni__13422__auto___814 = G__815;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__812 = args810.length;\nswitch (G__812) {\ncase (0):\nreturn quil.core$macros.smooth.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase (1):\nreturn quil.core$macros.smooth.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args810.length)].join('')));\n\n}\n});\n\nquil.core$macros.smooth.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn quil.core$macros.current_graphics.call(null).smooth();\n});\n\nquil.core$macros.smooth.cljs$core$IFn$_invoke$arity$1 = (function (level){\nreturn quil.core$macros.current_graphics.call(null).smooth((level | (0)));\n});\n\nquil.core$macros.smooth.cljs$lang$maxFixedArity = (1);\n\n/**\n * Sets the specular color of the materials used for shapes drawn to\n *   the screen, which sets the color of hightlights. Specular refers to\n *   light which bounces off a surface in a perferred direction (rather\n *   than bouncing in all directions like a diffuse light). Used in\n *   combination with emissive, ambient, and shininess in setting\n *   the material properties of shapes.\n */\nquil.core$macros.specular = (function quil$core$macros$specular(var_args){\nvar args817 = [];\nvar len__13421__auto___820 = arguments.length;\nvar i__13422__auto___821 = (0);\nwhile(true){\nif((i__13422__auto___821 < len__13421__auto___820)){\nargs817.push((arguments[i__13422__auto___821]));\n\nvar G__822 = (i__13422__auto___821 + (1));\ni__13422__auto___821 = G__822;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__819 = args817.length;\nswitch (G__819) {\ncase (1):\nreturn quil.core$macros.specular.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.specular.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args817.length)].join('')));\n\n}\n});\n\nquil.core$macros.specular.cljs$core$IFn$_invoke$arity$1 = (function (gray){\nreturn quil.core$macros.current_graphics.call(null).specular(gray);\n});\n\nquil.core$macros.specular.cljs$core$IFn$_invoke$arity$3 = (function (x,y,z){\nreturn quil.core$macros.current_graphics.call(null).specular(x,y,z);\n});\n\nquil.core$macros.specular.cljs$lang$maxFixedArity = (3);\n\n/**\n * Generates a hollow ball made from tessellated triangles.\n */\nquil.core$macros.sphere = (function quil$core$macros$sphere(radius){\nreturn quil.core$macros.current_graphics.call(null).sphere(radius);\n});\n/**\n * Controls the detail used to render a sphere by adjusting the number\n *   of vertices of the sphere mesh. The default resolution is 30, which\n *   creates a fairly detailed sphere definition with vertices every\n *   360/30 = 12 degrees. If you're going to render a great number of\n *   spheres per frame, it is advised to reduce the level of detail using\n *   this function. The setting stays active until sphere-detail is\n *   called again with a new parameter and so should not be called prior\n *   to every sphere statement, unless you wish to render spheres with\n *   different settings, e.g. using less detail for smaller spheres or\n *   ones further away from the camera. To controla the detail of the\n *   horizontal and vertical resolution independently, use the version of\n *   the functions with two parameters.\n */\nquil.core$macros.sphere_detail = (function quil$core$macros$sphere_detail(var_args){\nvar args824 = [];\nvar len__13421__auto___827 = arguments.length;\nvar i__13422__auto___828 = (0);\nwhile(true){\nif((i__13422__auto___828 < len__13421__auto___827)){\nargs824.push((arguments[i__13422__auto___828]));\n\nvar G__829 = (i__13422__auto___828 + (1));\ni__13422__auto___828 = G__829;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__826 = args824.length;\nswitch (G__826) {\ncase (1):\nreturn quil.core$macros.sphere_detail.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.sphere_detail.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args824.length)].join('')));\n\n}\n});\n\nquil.core$macros.sphere_detail.cljs$core$IFn$_invoke$arity$1 = (function (res){\nreturn quil.core$macros.current_graphics.call(null).sphereDetail((res | (0)));\n});\n\nquil.core$macros.sphere_detail.cljs$core$IFn$_invoke$arity$2 = (function (ures,vres){\nreturn quil.core$macros.current_graphics.call(null).sphereDetail((ures | (0)),(vres | (0)));\n});\n\nquil.core$macros.sphere_detail.cljs$lang$maxFixedArity = (2);\n\n/**\n * Adds a spot light. Lights need to be included in the draw to\n *   remain persistent in a looping program. Placing them in the setup\n *   of a looping program will cause them to only have an effect the\n *   first time through the loop. The affect of the r, g, and b\n *   parameters is determined by the current color mode. The x, y, and z\n *   parameters specify the position of the light and nx, ny, nz specify\n *   the direction or light. The angle parameter affects angle of the\n *   spotlight cone.\n */\nquil.core$macros.spot_light = (function quil$core$macros$spot_light(var_args){\nvar args831 = [];\nvar len__13421__auto___846 = arguments.length;\nvar i__13422__auto___847 = (0);\nwhile(true){\nif((i__13422__auto___847 < len__13421__auto___846)){\nargs831.push((arguments[i__13422__auto___847]));\n\nvar G__848 = (i__13422__auto___847 + (1));\ni__13422__auto___847 = G__848;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__833 = args831.length;\nswitch (G__833) {\ncase (11):\nreturn quil.core$macros.spot_light.cljs$core$IFn$_invoke$arity$11((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]),(arguments[(8)]),(arguments[(9)]),(arguments[(10)]));\n\nbreak;\ncase (5):\nreturn quil.core$macros.spot_light.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args831.length)].join('')));\n\n}\n});\n\nquil.core$macros.spot_light.cljs$core$IFn$_invoke$arity$11 = (function (r,g,b,x,y,z,nx,ny,nz,angle,concentration){\nreturn quil.core$macros.current_graphics.call(null).spotLight(r,g,b,x,y,z,nx,ny,nz,angle,concentration);\n});\n\nquil.core$macros.spot_light.cljs$core$IFn$_invoke$arity$5 = (function (p__834,p__835,p__836,angle,concentration){\nvar vec__837 = p__834;\nvar r = cljs.core.nth.call(null,vec__837,(0),null);\nvar g = cljs.core.nth.call(null,vec__837,(1),null);\nvar b = cljs.core.nth.call(null,vec__837,(2),null);\nvar vec__840 = p__835;\nvar x = cljs.core.nth.call(null,vec__840,(0),null);\nvar y = cljs.core.nth.call(null,vec__840,(1),null);\nvar z = cljs.core.nth.call(null,vec__840,(2),null);\nvar vec__843 = p__836;\nvar nx = cljs.core.nth.call(null,vec__843,(0),null);\nvar ny = cljs.core.nth.call(null,vec__843,(1),null);\nvar nz = cljs.core.nth.call(null,vec__843,(2),null);\nreturn quil.core$macros.current_graphics.call(null).spotLight(r,g,b,x,y,z,nx,ny,nz,angle,concentration);\n});\n\nquil.core$macros.spot_light.cljs$lang$maxFixedArity = (11);\n\n/**\n * Squares a number (multiplies a number by itself). The result is\n *   always a positive number, as multiplying two negative numbers always\n *   yields a positive result. For example, -1 * -1 = 1.\n */\nquil.core$macros.sq = (function quil$core$macros$sq(a){\nreturn quil.sketch.current_applet.call(null).sq(a);\n});\n/**\n * Calculates the square root of a number. The square root of a number\n *   is always positive, even though there may be a valid negative\n *   root. The square root s of number a is such that (= a (* s s)) . It\n *   is the opposite of squaring.\n */\nquil.core$macros.sqrt = (function quil$core$macros$sqrt(a){\nreturn quil.sketch.current_applet.call(null).sqrt(a);\n});\n/**\n * Causes Processing to continuously execute the code within\n *   draw. If no-loop is called, the code in draw stops executing.\n */\nquil.core$macros.start_loop = (function quil$core$macros$start_loop(){\nreturn quil.sketch.current_applet.call(null).loop();\n});\n/**\n * Sets the color used to draw lines and borders around\n *   shapes. Converts all args to floats\n */\nquil.core$macros.stroke_float = (function quil$core$macros$stroke_float(var_args){\nvar args850 = [];\nvar len__13421__auto___853 = arguments.length;\nvar i__13422__auto___854 = (0);\nwhile(true){\nif((i__13422__auto___854 < len__13421__auto___853)){\nargs850.push((arguments[i__13422__auto___854]));\n\nvar G__855 = (i__13422__auto___854 + (1));\ni__13422__auto___854 = G__855;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__852 = args850.length;\nswitch (G__852) {\ncase (1):\nreturn quil.core$macros.stroke_float.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.stroke_float.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.stroke_float.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core$macros.stroke_float.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args850.length)].join('')));\n\n}\n});\n\nquil.core$macros.stroke_float.cljs$core$IFn$_invoke$arity$1 = (function (gray){\nreturn quil.core$macros.current_graphics.call(null).stroke(gray);\n});\n\nquil.core$macros.stroke_float.cljs$core$IFn$_invoke$arity$2 = (function (gray,alpha){\nreturn quil.core$macros.current_graphics.call(null).stroke(gray,alpha);\n});\n\nquil.core$macros.stroke_float.cljs$core$IFn$_invoke$arity$3 = (function (x,y,z){\nreturn quil.core$macros.current_graphics.call(null).stroke(x,y,z);\n});\n\nquil.core$macros.stroke_float.cljs$core$IFn$_invoke$arity$4 = (function (x,y,z,a){\nreturn quil.core$macros.current_graphics.call(null).stroke(x,y,z,a);\n});\n\nquil.core$macros.stroke_float.cljs$lang$maxFixedArity = (4);\n\n/**\n * Sets the color used to draw lines and borders around\n *   shapes. Converts rgb to int and alpha to a float.\n */\nquil.core$macros.stroke_int = (function quil$core$macros$stroke_int(var_args){\nvar args857 = [];\nvar len__13421__auto___860 = arguments.length;\nvar i__13422__auto___861 = (0);\nwhile(true){\nif((i__13422__auto___861 < len__13421__auto___860)){\nargs857.push((arguments[i__13422__auto___861]));\n\nvar G__862 = (i__13422__auto___861 + (1));\ni__13422__auto___861 = G__862;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__859 = args857.length;\nswitch (G__859) {\ncase (1):\nreturn quil.core$macros.stroke_int.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.stroke_int.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args857.length)].join('')));\n\n}\n});\n\nquil.core$macros.stroke_int.cljs$core$IFn$_invoke$arity$1 = (function (rgb){\nreturn quil.core$macros.current_graphics.call(null).stroke(cljs.core.unchecked_int.call(null,rgb));\n});\n\nquil.core$macros.stroke_int.cljs$core$IFn$_invoke$arity$2 = (function (rgb,alpha){\nreturn quil.core$macros.current_graphics.call(null).stroke(cljs.core.unchecked_int.call(null,rgb),alpha);\n});\n\nquil.core$macros.stroke_int.cljs$lang$maxFixedArity = (2);\n\n/**\n * Sets the color used to draw lines and borders around shapes. This\n *   color is either specified in terms of the RGB or HSB color depending\n *   on the current color-mode (the default color space is RGB, with\n *   each value in the range from 0 to 255).\n */\nquil.core$macros.stroke = (function quil$core$macros$stroke(var_args){\nvar args864 = [];\nvar len__13421__auto___867 = arguments.length;\nvar i__13422__auto___868 = (0);\nwhile(true){\nif((i__13422__auto___868 < len__13421__auto___867)){\nargs864.push((arguments[i__13422__auto___868]));\n\nvar G__869 = (i__13422__auto___868 + (1));\ni__13422__auto___868 = G__869;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__866 = args864.length;\nswitch (G__866) {\ncase (1):\nreturn quil.core$macros.stroke.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.stroke.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.stroke.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core$macros.stroke.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args864.length)].join('')));\n\n}\n});\n\nquil.core$macros.stroke.cljs$core$IFn$_invoke$arity$1 = (function (rgb){\nreturn quil.core$macros.stroke_float.call(null,rgb);\n});\n\nquil.core$macros.stroke.cljs$core$IFn$_invoke$arity$2 = (function (rgb,alpha){\nreturn quil.core$macros.stroke_float.call(null,rgb,alpha);\n});\n\nquil.core$macros.stroke.cljs$core$IFn$_invoke$arity$3 = (function (x,y,z){\nreturn quil.core$macros.stroke_float.call(null,x,y,z);\n});\n\nquil.core$macros.stroke.cljs$core$IFn$_invoke$arity$4 = (function (x,y,z,a){\nreturn quil.core$macros.stroke_float.call(null,x,y,z,a);\n});\n\nquil.core$macros.stroke.cljs$lang$maxFixedArity = (4);\n\n/**\n * Sets the style for rendering line endings. These ends are either\n *   squared, extended, or rounded and specified with the corresponding\n *   parameters :square, :project, and :round. The default cap is :round.\n */\nquil.core$macros.stroke_cap = (function quil$core$macros$stroke_cap(cap_mode){\nvar cap_mode__$1 = quil.util.resolve_constant_key.call(null,cap_mode,quil.core$macros.stroke_cap_modes);\nreturn quil.core$macros.current_graphics.call(null).strokeCap([cljs.core.str(cap_mode__$1)].join(''));\n});\n/**\n * Sets the style of the joints which connect line\n *   segments. These joints are either mitered, beveled, or rounded and\n *   specified with the corresponding parameters :miter, :bevel, and\n *   :round. The default joint is :miter.\n * \n *   This function is not available with the :p2d, :p3d, or :opengl\n *   renderers.\n */\nquil.core$macros.stroke_join = (function quil$core$macros$stroke_join(join_mode){\nvar join_mode__$1 = quil.util.resolve_constant_key.call(null,join_mode,quil.core$macros.stroke_join_modes);\nreturn quil.core$macros.current_graphics.call(null).strokeJoin([cljs.core.str(join_mode__$1)].join(''));\n});\n/**\n * Sets the width of the stroke used for lines, points, and the border\n *   around shapes. All widths are set in units of pixels. \n */\nquil.core$macros.stroke_weight = (function quil$core$macros$stroke_weight(weight){\nreturn quil.core$macros.current_graphics.call(null).strokeWeight(weight);\n});\n/**\n * Calculates the ratio of the sine and cosine of an angle. This\n *   function expects the values of the angle parameter to be provided in\n *   radians (values from 0 to PI*2). Values are returned in the range\n *   infinity to -infinity.\n */\nquil.core$macros.tan = (function quil$core$macros$tan(angle){\nreturn quil.sketch.current_applet.call(null).tan(angle);\n});\n/**\n * Returns the target framerate specified with the fn frame-rate\n */\nquil.core$macros.target_frame_rate = (function quil$core$macros$target_frame_rate(){\nreturn cljs.core.deref.call(null,quil.sketch.current_applet.call(null).target_frame_rate);\n});\n/**\n * Returns whether fill is disabled for current graphics.\n */\nquil.core$macros.no_fill_QMARK_ = (function quil$core$macros$no_fill_QMARK_(graphics){\nreturn (graphics[quil.core$macros.no_fill_prop]) === true;\n});\n/**\n * Draws a char to the screen in the specified position. See text fn\n *   for more details.\n */\nquil.core$macros.text_char = (function quil$core$macros$text_char(var_args){\nvar args871 = [];\nvar len__13421__auto___874 = arguments.length;\nvar i__13422__auto___875 = (0);\nwhile(true){\nif((i__13422__auto___875 < len__13421__auto___874)){\nargs871.push((arguments[i__13422__auto___875]));\n\nvar G__876 = (i__13422__auto___875 + (1));\ni__13422__auto___875 = G__876;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__873 = args871.length;\nswitch (G__873) {\ncase (3):\nreturn quil.core$macros.text_char.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core$macros.text_char.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args871.length)].join('')));\n\n}\n});\n\nquil.core$macros.text_char.cljs$core$IFn$_invoke$arity$3 = (function (c,x,y){\nif(cljs.core.truth_(quil.core$macros.no_fill_QMARK_.call(null,quil.core$macros.current_graphics.call(null)))){\nreturn null;\n} else {\nreturn quil.core$macros.current_graphics.call(null).text(cljs.core.char$.call(null,c),x,y);\n}\n});\n\nquil.core$macros.text_char.cljs$core$IFn$_invoke$arity$4 = (function (c,x,y,z){\nif(cljs.core.truth_(quil.core$macros.no_fill_QMARK_.call(null,quil.core$macros.current_graphics.call(null)))){\nreturn null;\n} else {\nreturn quil.core$macros.current_graphics.call(null).text(cljs.core.char$.call(null,c),x,y,z);\n}\n});\n\nquil.core$macros.text_char.cljs$lang$maxFixedArity = (4);\n\n/**\n * Draws a number to the screen in the specified position. See text fn\n *   for more details.\n */\nquil.core$macros.text_num = (function quil$core$macros$text_num(var_args){\nvar args878 = [];\nvar len__13421__auto___881 = arguments.length;\nvar i__13422__auto___882 = (0);\nwhile(true){\nif((i__13422__auto___882 < len__13421__auto___881)){\nargs878.push((arguments[i__13422__auto___882]));\n\nvar G__883 = (i__13422__auto___882 + (1));\ni__13422__auto___882 = G__883;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__880 = args878.length;\nswitch (G__880) {\ncase (3):\nreturn quil.core$macros.text_num.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core$macros.text_num.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args878.length)].join('')));\n\n}\n});\n\nquil.core$macros.text_num.cljs$core$IFn$_invoke$arity$3 = (function (num,x,y){\nif(cljs.core.truth_(quil.core$macros.no_fill_QMARK_.call(null,quil.core$macros.current_graphics.call(null)))){\nreturn null;\n} else {\nreturn quil.core$macros.current_graphics.call(null).text(num,x,y);\n}\n});\n\nquil.core$macros.text_num.cljs$core$IFn$_invoke$arity$4 = (function (num,x,y,z){\nif(cljs.core.truth_(quil.core$macros.no_fill_QMARK_.call(null,quil.core$macros.current_graphics.call(null)))){\nreturn null;\n} else {\nreturn quil.core$macros.current_graphics.call(null).text(num,x,y,z);\n}\n});\n\nquil.core$macros.text_num.cljs$lang$maxFixedArity = (4);\n\n/**\n * Draws text to the screen in the position specified by the x and y\n *   parameters and the optional z parameter. A default font will be used\n *   unless a font is set with the text-font fn. Change the color of the\n *   text with the fill fn. The text displays in relation to the\n *   text-align fn, which gives the option to draw to the left, right, and\n *   center of the coordinates.\n * \n *   The x1, y1, x2 and y2 parameters define a\n *   rectangular area to display within and may only be used with string\n *   data. For text drawn inside a rectangle, the coordinates are\n *   interpreted based on the current rect-mode setting.\n */\nquil.core$macros.text = (function quil$core$macros$text(var_args){\nvar args885 = [];\nvar len__13421__auto___888 = arguments.length;\nvar i__13422__auto___889 = (0);\nwhile(true){\nif((i__13422__auto___889 < len__13421__auto___888)){\nargs885.push((arguments[i__13422__auto___889]));\n\nvar G__890 = (i__13422__auto___889 + (1));\ni__13422__auto___889 = G__890;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__887 = args885.length;\nswitch (G__887) {\ncase (3):\nreturn quil.core$macros.text.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core$macros.text.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase (5):\nreturn quil.core$macros.text.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args885.length)].join('')));\n\n}\n});\n\nquil.core$macros.text.cljs$core$IFn$_invoke$arity$3 = (function (s,x,y){\nif(cljs.core.truth_(quil.core$macros.no_fill_QMARK_.call(null,quil.core$macros.current_graphics.call(null)))){\nreturn null;\n} else {\nreturn quil.core$macros.current_graphics.call(null).text(s,x,y);\n}\n});\n\nquil.core$macros.text.cljs$core$IFn$_invoke$arity$4 = (function (s,x,y,z){\nif(cljs.core.truth_(quil.core$macros.no_fill_QMARK_.call(null,quil.core$macros.current_graphics.call(null)))){\nreturn null;\n} else {\nreturn quil.core$macros.current_graphics.call(null).text(s,x,y,z);\n}\n});\n\nquil.core$macros.text.cljs$core$IFn$_invoke$arity$5 = (function (s,x1,y1,x2,y2){\nif(cljs.core.truth_(quil.core$macros.no_fill_QMARK_.call(null,quil.core$macros.current_graphics.call(null)))){\nreturn null;\n} else {\nreturn quil.core$macros.current_graphics.call(null).text(s,x1,y1,x2,y2);\n}\n});\n\nquil.core$macros.text.cljs$lang$maxFixedArity = (5);\n\n/**\n * Sets the current alignment for drawing text. Available modes are:\n * \n *   horizontal - :left, :center, and :right\n *   vertical   - :top, :bottom, :center, and :baseline\n * \n *   An optional second parameter specifies the vertical alignment\n *   mode. :baseline is the default. The :top and :center parameters are\n *   straightforward. The :bottom parameter offsets the line based on the\n *   current text-descent. For multiple lines, the final line will be\n *   aligned to the bottom, with the previous lines appearing above it.\n * \n *   When using text with width and height parameters, :baseline is\n *   ignored, and treated as :top. (Otherwise, text would by default draw\n *   outside the box, since :baseline is the default setting. :baseline is\n *   not a useful drawing mode for text drawn in a rectangle.)\n * \n *   The vertical alignment is based on the value of text-ascent, which\n *   many fonts do not specify correctly. It may be necessary to use a\n *   hack and offset by a few pixels by hand so that the offset looks\n *   correct. To do this as less of a hack, use some percentage of\n *   text-ascent or text-descent so that the hack works even if you\n *   change the size of the font.\n */\nquil.core$macros.text_align = (function quil$core$macros$text_align(var_args){\nvar args892 = [];\nvar len__13421__auto___895 = arguments.length;\nvar i__13422__auto___896 = (0);\nwhile(true){\nif((i__13422__auto___896 < len__13421__auto___895)){\nargs892.push((arguments[i__13422__auto___896]));\n\nvar G__897 = (i__13422__auto___896 + (1));\ni__13422__auto___896 = G__897;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__894 = args892.length;\nswitch (G__894) {\ncase (1):\nreturn quil.core$macros.text_align.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.text_align.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args892.length)].join('')));\n\n}\n});\n\nquil.core$macros.text_align.cljs$core$IFn$_invoke$arity$1 = (function (align){\nvar align__$1 = quil.util.resolve_constant_key.call(null,align,quil.core$macros.horizontal_alignment_modes);\nreturn quil.core$macros.current_graphics.call(null).textAlign((align__$1 | (0)));\n});\n\nquil.core$macros.text_align.cljs$core$IFn$_invoke$arity$2 = (function (align_x,align_y){\nvar align_x__$1 = quil.util.resolve_constant_key.call(null,align_x,quil.core$macros.horizontal_alignment_modes);\nvar align_y__$1 = quil.util.resolve_constant_key.call(null,align_y,quil.core$macros.vertical_alignment_modes);\nreturn quil.core$macros.current_graphics.call(null).textAlign((align_x__$1 | (0)),(align_y__$1 | (0)));\n});\n\nquil.core$macros.text_align.cljs$lang$maxFixedArity = (2);\n\n/**\n * Returns the ascent of the current font at its current size. This\n *   information is useful for determining the height of the font above\n *   the baseline. For example, adding the text-ascent and text-descent\n *   values will give you the total height of the line.\n */\nquil.core$macros.text_ascent = (function quil$core$macros$text_ascent(){\nreturn quil.core$macros.current_graphics.call(null).textAscent();\n});\n/**\n * Returns descent of the current font at its current size. This\n *   information is useful for determining the height of the font below\n *   the baseline. For example, adding the text-ascent and text-descent\n *   values will give you the total height of the line.\n */\nquil.core$macros.text_descent = (function quil$core$macros$text_descent(){\nreturn quil.core$macros.current_graphics.call(null).textDescent();\n});\n/**\n * Sets the current font that will be drawn with the text\n *   function. Fonts must be loaded with load-font before it can be\n *   used. This font will be used in all subsequent calls to the text\n *   function. If no size parameter is input, the font will appear at its\n *   original size until it is changed with text-size.\n * \n *   Because fonts are usually bitmaped, you should create fonts at the\n *   sizes that will be used most commonly. Using textFont without the\n *   size parameter will result in the cleanest-looking text.\n * \n *   With the default (JAVA2D) and PDF renderers, it's also possible to\n *   enable the use of native fonts via the command\n *   (hint :enable-native-fonts). This will produce vector text in JAVA2D\n *   sketches and PDF output in cases where the vector data is available:\n *   when the font is still installed, or the font is created via the\n *   create-font fn\n */\nquil.core$macros.text_font = (function quil$core$macros$text_font(var_args){\nvar args899 = [];\nvar len__13421__auto___902 = arguments.length;\nvar i__13422__auto___903 = (0);\nwhile(true){\nif((i__13422__auto___903 < len__13421__auto___902)){\nargs899.push((arguments[i__13422__auto___903]));\n\nvar G__904 = (i__13422__auto___903 + (1));\ni__13422__auto___903 = G__904;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__901 = args899.length;\nswitch (G__901) {\ncase (1):\nreturn quil.core$macros.text_font.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.text_font.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args899.length)].join('')));\n\n}\n});\n\nquil.core$macros.text_font.cljs$core$IFn$_invoke$arity$1 = (function (font){\nreturn quil.core$macros.current_graphics.call(null).textFont(font);\n});\n\nquil.core$macros.text_font.cljs$core$IFn$_invoke$arity$2 = (function (font,size){\nreturn quil.core$macros.current_graphics.call(null).textFont(font,(size | (0)));\n});\n\nquil.core$macros.text_font.cljs$lang$maxFixedArity = (2);\n\n/**\n * Sets the spacing between lines of text in units of pixels. This\n *   setting will be used in all subsequent calls to the text function.\n */\nquil.core$macros.text_leading = (function quil$core$macros$text_leading(leading){\nreturn quil.core$macros.current_graphics.call(null).textLeading(leading);\n});\n/**\n * Sets the way text draws to the screen - available modes\n *   are :model and :shape\n * \n *   In the default configuration (the :model mode), it's possible to\n *   rotate, scale, and place letters in two and three dimensional space.\n * \n *   The :shape mode draws text using the glyph outlines of individual\n *   characters rather than as textures. This mode is only supported with\n *   the PDF and OPENGL renderer settings. With the PDF renderer, you\n *   must specify the :shape text-mode before any other drawing occurs.\n *   If the outlines are not available, then :shape will be ignored and\n *   :model will be used instead.\n * \n *   The :shape option in OPENGL mode can be combined with begin-raw to\n *   write vector-accurate text to 2D and 3D output files, for instance\n *   DXF or PDF. :shape is not currently optimized for OPENGL, so if\n *   recording shape data, use :model until you're ready to capture the\n *   geometry with begin-raw.\n */\nquil.core$macros.text_mode = (function quil$core$macros$text_mode(mode){\nvar mode__$1 = quil.util.resolve_constant_key.call(null,mode,quil.core$macros.text_modes);\nreturn quil.core$macros.current_graphics.call(null).textMode((mode__$1 | (0)));\n});\n/**\n * Sets the current font size. This size will be used in all\n *   subsequent calls to the text fn. Font size is measured in\n *   units of pixels.\n */\nquil.core$macros.text_size = (function quil$core$macros$text_size(size){\nreturn quil.core$macros.current_graphics.call(null).textSize(size);\n});\n/**\n * Sets a texture to be applied to vertex points. The texture fn must\n *   be called between begin-shape and end-shape and before any calls to\n *   vertex.\n * \n *   When textures are in use, the fill color is ignored. Instead, use\n *   tint to specify the color of the texture as it is applied to the\n *   shape.\n */\nquil.core$macros.texture = (function quil$core$macros$texture(img){\nreturn quil.core$macros.current_graphics.call(null).texture(img);\n});\n/**\n * Sets the coordinate space for texture mapping. There are two\n *   options, :image and :normal.\n * \n *   :image refers to the actual coordinates of the image and :normal\n *   refers to a normalized space of values ranging from 0 to 1. The\n *   default mode is :image. In :image, if an image is 100 x 200 pixels,\n *   mapping the image onto the entire size of a quad would require the\n *   points (0,0) (0,100) (100,200) (0,200). The same mapping in\n *   NORMAL_SPACE is (0,0) (0,1) (1,1) (0,1).\n */\nquil.core$macros.texture_mode = (function quil$core$macros$texture_mode(mode){\nvar mode__$1 = quil.util.resolve_constant_key.call(null,mode,quil.core$macros.texture_modes);\nreturn quil.core$macros.current_graphics.call(null).textureMode((mode__$1 | (0)));\n});\n/**\n * Calculates and returns the width of any text string.\n */\nquil.core$macros.text_width = (function quil$core$macros$text_width(data){\nreturn quil.core$macros.current_graphics.call(null).textWidth(data);\n});\n/**\n * Sets the fill value for displaying images. Images can be tinted to\n *   specified colors or made transparent by setting the alpha.\n * \n *   To make an image transparent, but not change it's color, use white\n *   as the tint color and specify an alpha value. For instance,\n *   tint(255, 128) will make an image 50% transparent (unless\n *   colorMode() has been used).\n * \n *   The value for the parameter gray must be less than or equal to the\n *   current maximum value as specified by colorMode(). The default\n *   maximum value is 255.\n * \n *   Also used to control the coloring of textures in 3D.\n */\nquil.core$macros.tint_float = (function quil$core$macros$tint_float(var_args){\nvar args906 = [];\nvar len__13421__auto___909 = arguments.length;\nvar i__13422__auto___910 = (0);\nwhile(true){\nif((i__13422__auto___910 < len__13421__auto___909)){\nargs906.push((arguments[i__13422__auto___910]));\n\nvar G__911 = (i__13422__auto___910 + (1));\ni__13422__auto___910 = G__911;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__908 = args906.length;\nswitch (G__908) {\ncase (1):\nreturn quil.core$macros.tint_float.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.tint_float.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.tint_float.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core$macros.tint_float.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args906.length)].join('')));\n\n}\n});\n\nquil.core$macros.tint_float.cljs$core$IFn$_invoke$arity$1 = (function (gray){\nreturn quil.core$macros.current_graphics.call(null).tint(gray);\n});\n\nquil.core$macros.tint_float.cljs$core$IFn$_invoke$arity$2 = (function (gray,alpha){\nreturn quil.core$macros.current_graphics.call(null).tint(gray,alpha);\n});\n\nquil.core$macros.tint_float.cljs$core$IFn$_invoke$arity$3 = (function (r,g,b){\nreturn quil.core$macros.current_graphics.call(null).tint(r,g,b);\n});\n\nquil.core$macros.tint_float.cljs$core$IFn$_invoke$arity$4 = (function (r,g,b,a){\nreturn quil.core$macros.current_graphics.call(null).tint(g,g,b,a);\n});\n\nquil.core$macros.tint_float.cljs$lang$maxFixedArity = (4);\n\n/**\n * Sets the fill value for displaying images. Images can be tinted to\n *   specified colors or made transparent by setting the alpha.\n * \n *   To make an image transparent, but not change it's color, use white\n *   as the tint color and specify an alpha value. For instance,\n *   tint(255, 128) will make an image 50% transparent (unless\n *   colorMode() has been used).\n * \n *   The value for the parameter gray must be less than or equal to the\n *   current maximum value as specified by colorMode(). The default\n *   maximum value is 255.\n * \n *   Also used to control the coloring of textures in 3D.\n */\nquil.core$macros.tint_int = (function quil$core$macros$tint_int(var_args){\nvar args913 = [];\nvar len__13421__auto___916 = arguments.length;\nvar i__13422__auto___917 = (0);\nwhile(true){\nif((i__13422__auto___917 < len__13421__auto___916)){\nargs913.push((arguments[i__13422__auto___917]));\n\nvar G__918 = (i__13422__auto___917 + (1));\ni__13422__auto___917 = G__918;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__915 = args913.length;\nswitch (G__915) {\ncase (1):\nreturn quil.core$macros.tint_int.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.tint_int.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args913.length)].join('')));\n\n}\n});\n\nquil.core$macros.tint_int.cljs$core$IFn$_invoke$arity$1 = (function (rgb){\nreturn quil.core$macros.current_graphics.call(null).tint(cljs.core.unchecked_int.call(null,rgb));\n});\n\nquil.core$macros.tint_int.cljs$core$IFn$_invoke$arity$2 = (function (rgb,alpha){\nreturn quil.core$macros.current_graphics.call(null).tint(cljs.core.unchecked_int.call(null,rgb),alpha);\n});\n\nquil.core$macros.tint_int.cljs$lang$maxFixedArity = (2);\n\n/**\n * Sets the fill value for displaying images. Images can be tinted to\n *   specified colors or made transparent by setting the alpha.\n * \n *   To make an image transparent, but not change it's color, use white\n *   as the tint color and specify an alpha value. For instance,\n *   tint(255, 128) will make an image 50% transparent (unless\n *   colorMode() has been used).\n * \n *   The value for the parameter gray must be less than or equal to the\n *   current maximum value as specified by colorMode(). The default\n *   maximum value is 255.\n * \n *   Also used to control the coloring of textures in 3D.\n */\nquil.core$macros.tint = (function quil$core$macros$tint(var_args){\nvar args920 = [];\nvar len__13421__auto___923 = arguments.length;\nvar i__13422__auto___924 = (0);\nwhile(true){\nif((i__13422__auto___924 < len__13421__auto___923)){\nargs920.push((arguments[i__13422__auto___924]));\n\nvar G__925 = (i__13422__auto___924 + (1));\ni__13422__auto___924 = G__925;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__922 = args920.length;\nswitch (G__922) {\ncase (1):\nreturn quil.core$macros.tint.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.tint.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.tint.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core$macros.tint.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args920.length)].join('')));\n\n}\n});\n\nquil.core$macros.tint.cljs$core$IFn$_invoke$arity$1 = (function (rgb){\nreturn quil.core$macros.current_graphics.call(null).tint(rgb);\n});\n\nquil.core$macros.tint.cljs$core$IFn$_invoke$arity$2 = (function (rgb,alpha){\nreturn quil.core$macros.current_graphics.call(null).tint(rgb,alpha);\n});\n\nquil.core$macros.tint.cljs$core$IFn$_invoke$arity$3 = (function (r,g,b){\nreturn quil.core$macros.tint_float.call(null,r,g,b);\n});\n\nquil.core$macros.tint.cljs$core$IFn$_invoke$arity$4 = (function (r,g,b,a){\nreturn quil.core$macros.tint_float.call(null,r,g,b,a);\n});\n\nquil.core$macros.tint.cljs$lang$maxFixedArity = (4);\n\n/**\n * Specifies an amount to displace objects within the display\n *   window. The x parameter specifies left/right translation, the y\n *   parameter specifies up/down translation, and the z parameter\n *   specifies translations toward/away from the screen.  Transformations\n *   apply to everything that happens after and subsequent calls to the\n *   function accumulates the effect. For example, calling (translate 50\n *   0) and then (translate 20, 0) is the same as (translate 70, 0). If\n *   translate is called within draw, the transformation is reset when\n *   the loop begins again. This function can be further controlled by\n *   the push-matrix and pop-matrix.\n */\nquil.core$macros.translate = (function quil$core$macros$translate(var_args){\nvar args927 = [];\nvar len__13421__auto___930 = arguments.length;\nvar i__13422__auto___931 = (0);\nwhile(true){\nif((i__13422__auto___931 < len__13421__auto___930)){\nargs927.push((arguments[i__13422__auto___931]));\n\nvar G__932 = (i__13422__auto___931 + (1));\ni__13422__auto___931 = G__932;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__929 = args927.length;\nswitch (G__929) {\ncase (1):\nreturn quil.core$macros.translate.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.translate.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.translate.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args927.length)].join('')));\n\n}\n});\n\nquil.core$macros.translate.cljs$core$IFn$_invoke$arity$1 = (function (v){\nreturn cljs.core.apply.call(null,quil.core$macros.translate,v);\n});\n\nquil.core$macros.translate.cljs$core$IFn$_invoke$arity$2 = (function (tx,ty){\nreturn quil.core$macros.current_graphics.call(null).translate(tx,ty);\n});\n\nquil.core$macros.translate.cljs$core$IFn$_invoke$arity$3 = (function (tx,ty,tz){\nreturn quil.core$macros.current_graphics.call(null).translate(tx,ty,tz);\n});\n\nquil.core$macros.translate.cljs$lang$maxFixedArity = (3);\n\n/**\n * A triangle is a plane created by connecting three points. The first\n *   two arguments specify the first point, the middle two arguments\n *   specify the second point, and the last two arguments specify the\n *   third point.\n */\nquil.core$macros.triangle = (function quil$core$macros$triangle(x1,y1,x2,y2,x3,y3){\nreturn quil.core$macros.current_graphics.call(null).triangle(x1,y1,x2,y2,x3,y3);\n});\n/**\n * Unpack a binary string to an integer. See binary for converting\n *   integers to strings.\n */\nquil.core$macros.unbinary = (function quil$core$macros$unbinary(str_val){\nreturn quil.sketch.current_applet.call(null).unbinary([cljs.core.str(str_val)].join(''));\n});\n/**\n * Converts a String representation of a hexadecimal number to its\n *   equivalent integer value.\n */\nquil.core$macros.unhex = (function quil$core$macros$unhex(hex_str){\nreturn quil.sketch.current_applet.call(null).unhex([cljs.core.str(hex_str)].join(''));\n});\n/**\n * Updates the display window or image with the data in the pixels array.\n *   Use in conjunction with (pixels). If you're only reading pixels from\n *   the array, there's no need to call update-pixels unless there are\n *   changes.\n * \n *   Certain renderers may or may not seem to require pixels or\n *   update-pixels. However, the rule is that any time you want to\n *   manipulate the pixels array, you must first call pixels, and\n *   after changes have been made, call update-pixels. Even if the\n *   renderer may not seem to use this function in the current Processing\n *   release, this will always be subject to change.\n */\nquil.core$macros.update_pixels = (function quil$core$macros$update_pixels(var_args){\nvar args934 = [];\nvar len__13421__auto___937 = arguments.length;\nvar i__13422__auto___938 = (0);\nwhile(true){\nif((i__13422__auto___938 < len__13421__auto___937)){\nargs934.push((arguments[i__13422__auto___938]));\n\nvar G__939 = (i__13422__auto___938 + (1));\ni__13422__auto___938 = G__939;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__936 = args934.length;\nswitch (G__936) {\ncase (0):\nreturn quil.core$macros.update_pixels.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase (1):\nreturn quil.core$macros.update_pixels.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args934.length)].join('')));\n\n}\n});\n\nquil.core$macros.update_pixels.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn quil.core$macros.update_pixels.call(null,quil.core$macros.current_graphics.call(null));\n});\n\nquil.core$macros.update_pixels.cljs$core$IFn$_invoke$arity$1 = (function (img){\nvar temp__10400__auto___941 = img.stored_pix_array;\nif(cljs.core.truth_(temp__10400__auto___941)){\nvar pix_array_942 = temp__10400__auto___941;\nimg.pixels.set(pix_array_942);\n\nimg.stored_pix_array = null;\n} else {\n}\n\nreturn img.updatePixels();\n});\n\nquil.core$macros.update_pixels.cljs$lang$maxFixedArity = (1);\n\n/**\n * All shapes are constructed by connecting a series of\n *   vertices. vertex is used to specify the vertex coordinates for\n *   points, lines, triangles, quads, and polygons and is used\n *   exclusively within the begin-shape and end-shape fns.\n * \n *   Drawing a vertex in 3D using the z parameter requires the :p3d or\n *   :opengl renderers to be used.\n * \n *   This function is also used to map a texture onto the geometry. The\n *   texture fn declares the texture to apply to the geometry and the u\n *   and v coordinates set define the mapping of this texture to the\n *   form. By default, the coordinates used for u and v are specified in\n *   relation to the image's size in pixels, but this relation can be\n *   changed with texture-mode.\n */\nquil.core$macros.vertex = (function quil$core$macros$vertex(var_args){\nvar args943 = [];\nvar len__13421__auto___946 = arguments.length;\nvar i__13422__auto___947 = (0);\nwhile(true){\nif((i__13422__auto___947 < len__13421__auto___946)){\nargs943.push((arguments[i__13422__auto___947]));\n\nvar G__948 = (i__13422__auto___947 + (1));\ni__13422__auto___947 = G__948;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__945 = args943.length;\nswitch (G__945) {\ncase (2):\nreturn quil.core$macros.vertex.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.vertex.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core$macros.vertex.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase (5):\nreturn quil.core$macros.vertex.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args943.length)].join('')));\n\n}\n});\n\nquil.core$macros.vertex.cljs$core$IFn$_invoke$arity$2 = (function (x,y){\nreturn quil.core$macros.current_graphics.call(null).vertex(x,y);\n});\n\nquil.core$macros.vertex.cljs$core$IFn$_invoke$arity$3 = (function (x,y,z){\nreturn quil.core$macros.current_graphics.call(null).vertex(x,y,z);\n});\n\nquil.core$macros.vertex.cljs$core$IFn$_invoke$arity$4 = (function (x,y,u,v){\nreturn quil.core$macros.current_graphics.call(null).vertex(x,y,u,v);\n});\n\nquil.core$macros.vertex.cljs$core$IFn$_invoke$arity$5 = (function (x,y,z,u,v){\nreturn quil.core$macros.current_graphics.call(null).vertex(x,y,z,u,v);\n});\n\nquil.core$macros.vertex.cljs$lang$maxFixedArity = (5);\n\n/**\n * Returns the current year as an integer (2003, 2004, 2005, etc).\n */\nquil.core$macros.year = (function quil$core$macros$year(){\nreturn quil.sketch.current_applet.call(null).year();\n});\n/**\n * Width of the display window. The value of width is zero until size is\n *   called.\n */\nquil.core$macros.width = (function quil$core$macros$width(){\nreturn quil.sketch.current_applet.call(null).width;\n});\n/**\n * Temporarily set the fill color for the body of this macro.\n * The code outside of with-fill form will have the previous fill color set.\n * \n * The fill color has to be in a vector!\n * Example: (with-fill [255] ...)\n *          (with-fill [10 80 98] ...)\n */\nquil.core$macros.with_fill = (function quil$core$macros$with_fill(var_args){\nvar args__13423__auto__ = [];\nvar len__13421__auto___954 = arguments.length;\nvar i__13422__auto___955 = (0);\nwhile(true){\nif((i__13422__auto___955 < len__13421__auto___954)){\nargs__13423__auto__.push((arguments[i__13422__auto___955]));\n\nvar G__956 = (i__13422__auto___955 + (1));\ni__13422__auto___955 = G__956;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__13424__auto__ = ((((3) < args__13423__auto__.length))?(new cljs.core.IndexedSeq(args__13423__auto__.slice((3)),(0),null)):null);\nreturn quil.core$macros.with_fill.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__13424__auto__);\n});\n\nquil.core$macros.with_fill.cljs$core$IFn$_invoke$arity$variadic = (function (_AMPERSAND_form,_AMPERSAND_env,fill_args,body){\nreturn cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"cljs.core\",\"let\",\"cljs.core/let\",(-308701135),null)),(function (){var x__13164__auto__ = cljs.core.vec.call(null,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"old-fill__17__auto__\",\"old-fill__17__auto__\",(1834626265),null)),(function (){var x__13164__auto__ = cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.core\",\"current-fill\",\"quil.core/current-fill\",(269663137),null))));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})())));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})(),(function (){var x__13164__auto__ = cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"cljs.core\",\"apply\",\"cljs.core/apply\",(1757277831),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.core\",\"fill\",\"quil.core/fill\",(814613078),null)),(function (){var x__13164__auto__ = fill_args;\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})()));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})(),body,(function (){var x__13164__auto__ = cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.core\",\"fill\",\"quil.core/fill\",(814613078),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"old-fill__17__auto__\",\"old-fill__17__auto__\",(1834626265),null))));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})()));\n});\n\nquil.core$macros.with_fill.cljs$lang$maxFixedArity = (3);\n\nquil.core$macros.with_fill.cljs$lang$applyTo = (function (seq950){\nvar G__951 = cljs.core.first.call(null,seq950);\nvar seq950__$1 = cljs.core.next.call(null,seq950);\nvar G__952 = cljs.core.first.call(null,seq950__$1);\nvar seq950__$2 = cljs.core.next.call(null,seq950__$1);\nvar G__953 = cljs.core.first.call(null,seq950__$2);\nvar seq950__$3 = cljs.core.next.call(null,seq950__$2);\nreturn quil.core$macros.with_fill.cljs$core$IFn$_invoke$arity$variadic(G__951,G__952,G__953,seq950__$3);\n});\n\n\nquil.core$macros.with_fill.cljs$lang$macro = true;\n/**\n * Temporarily set the stroke color for the body of this macro.\n * The code outside of with-stroke form will have the previous stroke color set.\n * \n * The stroke color has to be in a vector!\n * Example: (with-stroke [255] ...)\n *          (with-stroke [10 80 98] ...)\n */\nquil.core$macros.with_stroke = (function quil$core$macros$with_stroke(var_args){\nvar args__13423__auto__ = [];\nvar len__13421__auto___961 = arguments.length;\nvar i__13422__auto___962 = (0);\nwhile(true){\nif((i__13422__auto___962 < len__13421__auto___961)){\nargs__13423__auto__.push((arguments[i__13422__auto___962]));\n\nvar G__963 = (i__13422__auto___962 + (1));\ni__13422__auto___962 = G__963;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__13424__auto__ = ((((3) < args__13423__auto__.length))?(new cljs.core.IndexedSeq(args__13423__auto__.slice((3)),(0),null)):null);\nreturn quil.core$macros.with_stroke.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__13424__auto__);\n});\n\nquil.core$macros.with_stroke.cljs$core$IFn$_invoke$arity$variadic = (function (_AMPERSAND_form,_AMPERSAND_env,stroke_args,body){\nreturn cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"cljs.core\",\"let\",\"cljs.core/let\",(-308701135),null)),(function (){var x__13164__auto__ = cljs.core.vec.call(null,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"old-stroke__18__auto__\",\"old-stroke__18__auto__\",(-699469010),null)),(function (){var x__13164__auto__ = cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.core\",\"current-stroke\",\"quil.core/current-stroke\",(-1148124489),null))));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})())));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})(),(function (){var x__13164__auto__ = cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"cljs.core\",\"apply\",\"cljs.core/apply\",(1757277831),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.core\",\"stroke\",\"quil.core/stroke\",(577473004),null)),(function (){var x__13164__auto__ = stroke_args;\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})()));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})(),body,(function (){var x__13164__auto__ = cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.core\",\"stroke\",\"quil.core/stroke\",(577473004),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"old-stroke__18__auto__\",\"old-stroke__18__auto__\",(-699469010),null))));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})()));\n});\n\nquil.core$macros.with_stroke.cljs$lang$maxFixedArity = (3);\n\nquil.core$macros.with_stroke.cljs$lang$applyTo = (function (seq957){\nvar G__958 = cljs.core.first.call(null,seq957);\nvar seq957__$1 = cljs.core.next.call(null,seq957);\nvar G__959 = cljs.core.first.call(null,seq957__$1);\nvar seq957__$2 = cljs.core.next.call(null,seq957__$1);\nvar G__960 = cljs.core.first.call(null,seq957__$2);\nvar seq957__$3 = cljs.core.next.call(null,seq957__$2);\nreturn quil.core$macros.with_stroke.cljs$core$IFn$_invoke$arity$variadic(G__958,G__959,G__960,seq957__$3);\n});\n\n\nquil.core$macros.with_stroke.cljs$lang$macro = true;\n/**\n * Performs body with translation, restores current transformation on\n *   exit.\n */\nquil.core$macros.with_translation = (function quil$core$macros$with_translation(var_args){\nvar args__13423__auto__ = [];\nvar len__13421__auto___968 = arguments.length;\nvar i__13422__auto___969 = (0);\nwhile(true){\nif((i__13422__auto___969 < len__13421__auto___968)){\nargs__13423__auto__.push((arguments[i__13422__auto___969]));\n\nvar G__970 = (i__13422__auto___969 + (1));\ni__13422__auto___969 = G__970;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__13424__auto__ = ((((3) < args__13423__auto__.length))?(new cljs.core.IndexedSeq(args__13423__auto__.slice((3)),(0),null)):null);\nreturn quil.core$macros.with_translation.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__13424__auto__);\n});\n\nquil.core$macros.with_translation.cljs$core$IFn$_invoke$arity$variadic = (function (_AMPERSAND_form,_AMPERSAND_env,translation_vector,body){\nreturn cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"cljs.core\",\"let\",\"cljs.core/let\",(-308701135),null)),(function (){var x__13164__auto__ = cljs.core.vec.call(null,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"tr__19__auto__\",\"tr__19__auto__\",(740010118),null)),(function (){var x__13164__auto__ = translation_vector;\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})())));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})(),(function (){var x__13164__auto__ = cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.core\",\"push-matrix\",\"quil.core/push-matrix\",(1356326676),null))));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})(),(function (){var x__13164__auto__ = cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"try\",\"try\",(-1273693247),null)),(function (){var x__13164__auto__ = cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.core\",\"translate\",\"quil.core/translate\",(150889028),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"tr__19__auto__\",\"tr__19__auto__\",(740010118),null))));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})(),body,(function (){var x__13164__auto__ = cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"finally\",\"finally\",(-1065347064),null)),(function (){var x__13164__auto__ = cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.core\",\"pop-matrix\",\"quil.core/pop-matrix\",(310892617),null))));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})()));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})()));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})()));\n});\n\nquil.core$macros.with_translation.cljs$lang$maxFixedArity = (3);\n\nquil.core$macros.with_translation.cljs$lang$applyTo = (function (seq964){\nvar G__965 = cljs.core.first.call(null,seq964);\nvar seq964__$1 = cljs.core.next.call(null,seq964);\nvar G__966 = cljs.core.first.call(null,seq964__$1);\nvar seq964__$2 = cljs.core.next.call(null,seq964__$1);\nvar G__967 = cljs.core.first.call(null,seq964__$2);\nvar seq964__$3 = cljs.core.next.call(null,seq964__$2);\nreturn quil.core$macros.with_translation.cljs$core$IFn$_invoke$arity$variadic(G__965,G__966,G__967,seq964__$3);\n});\n\n\nquil.core$macros.with_translation.cljs$lang$macro = true;\n/**\n * Performs body with rotation, restores current transformation on exit.\n *   Accepts a vector [angle] or [angle x-axis y-axis z-axis].\n * \n *   Example:\n *  (with-rotation [angle]\n *    (vertex 1 2))\n */\nquil.core$macros.with_rotation = (function quil$core$macros$with_rotation(var_args){\nvar args__13423__auto__ = [];\nvar len__13421__auto___975 = arguments.length;\nvar i__13422__auto___976 = (0);\nwhile(true){\nif((i__13422__auto___976 < len__13421__auto___975)){\nargs__13423__auto__.push((arguments[i__13422__auto___976]));\n\nvar G__977 = (i__13422__auto___976 + (1));\ni__13422__auto___976 = G__977;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__13424__auto__ = ((((3) < args__13423__auto__.length))?(new cljs.core.IndexedSeq(args__13423__auto__.slice((3)),(0),null)):null);\nreturn quil.core$macros.with_rotation.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__13424__auto__);\n});\n\nquil.core$macros.with_rotation.cljs$core$IFn$_invoke$arity$variadic = (function (_AMPERSAND_form,_AMPERSAND_env,rotation,body){\nreturn cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"cljs.core\",\"let\",\"cljs.core/let\",(-308701135),null)),(function (){var x__13164__auto__ = cljs.core.vec.call(null,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"tr__20__auto__\",\"tr__20__auto__\",(1374510188),null)),(function (){var x__13164__auto__ = rotation;\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})())));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})(),(function (){var x__13164__auto__ = cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.core\",\"push-matrix\",\"quil.core/push-matrix\",(1356326676),null))));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})(),(function (){var x__13164__auto__ = cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"try\",\"try\",(-1273693247),null)),(function (){var x__13164__auto__ = cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"cljs.core\",\"apply\",\"cljs.core/apply\",(1757277831),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.core\",\"rotate\",\"quil.core/rotate\",(-1944995048),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"tr__20__auto__\",\"tr__20__auto__\",(1374510188),null))));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})(),body,(function (){var x__13164__auto__ = cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"finally\",\"finally\",(-1065347064),null)),(function (){var x__13164__auto__ = cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.core\",\"pop-matrix\",\"quil.core/pop-matrix\",(310892617),null))));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})()));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})()));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})()));\n});\n\nquil.core$macros.with_rotation.cljs$lang$maxFixedArity = (3);\n\nquil.core$macros.with_rotation.cljs$lang$applyTo = (function (seq971){\nvar G__972 = cljs.core.first.call(null,seq971);\nvar seq971__$1 = cljs.core.next.call(null,seq971);\nvar G__973 = cljs.core.first.call(null,seq971__$1);\nvar seq971__$2 = cljs.core.next.call(null,seq971__$1);\nvar G__974 = cljs.core.first.call(null,seq971__$2);\nvar seq971__$3 = cljs.core.next.call(null,seq971__$2);\nreturn quil.core$macros.with_rotation.cljs$core$IFn$_invoke$arity$variadic(G__972,G__973,G__974,seq971__$3);\n});\n\n\nquil.core$macros.with_rotation.cljs$lang$macro = true;\n/**\n * All subsequent calls of any drawing function will draw on given\n *   graphics. 'with-graphics' cannot be nested (you can draw simultaneously\n *   only on 1 graphics)\n */\nquil.core$macros.with_graphics = (function quil$core$macros$with_graphics(var_args){\nvar args__13423__auto__ = [];\nvar len__13421__auto___982 = arguments.length;\nvar i__13422__auto___983 = (0);\nwhile(true){\nif((i__13422__auto___983 < len__13421__auto___982)){\nargs__13423__auto__.push((arguments[i__13422__auto___983]));\n\nvar G__984 = (i__13422__auto___983 + (1));\ni__13422__auto___983 = G__984;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__13424__auto__ = ((((3) < args__13423__auto__.length))?(new cljs.core.IndexedSeq(args__13423__auto__.slice((3)),(0),null)):null);\nreturn quil.core$macros.with_graphics.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__13424__auto__);\n});\n\nquil.core$macros.with_graphics.cljs$core$IFn$_invoke$arity$variadic = (function (_AMPERSAND_form,_AMPERSAND_env,graphics,body){\nreturn cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"cljs.core\",\"let\",\"cljs.core/let\",(-308701135),null)),(function (){var x__13164__auto__ = cljs.core.vec.call(null,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"gr__21__auto__\",\"gr__21__auto__\",(-1979290458),null)),(function (){var x__13164__auto__ = graphics;\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})())));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})(),(function (){var x__13164__auto__ = cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"cljs.core\",\"binding\",\"cljs.core/binding\",(2050379843),null)),(function (){var x__13164__auto__ = cljs.core.vec.call(null,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.core\",\"*graphics*\",\"quil.core/*graphics*\",(-1088142302),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"gr__21__auto__\",\"gr__21__auto__\",(-1979290458),null)))));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})(),(function (){var x__13164__auto__ = cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\".beginDraw\",\".beginDraw\",(1110767550),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"gr__21__auto__\",\"gr__21__auto__\",(-1979290458),null))));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})(),body,(function (){var x__13164__auto__ = cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\".endDraw\",\".endDraw\",(795589408),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"gr__21__auto__\",\"gr__21__auto__\",(-1979290458),null))));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})()));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})()));\n});\n\nquil.core$macros.with_graphics.cljs$lang$maxFixedArity = (3);\n\nquil.core$macros.with_graphics.cljs$lang$applyTo = (function (seq978){\nvar G__979 = cljs.core.first.call(null,seq978);\nvar seq978__$1 = cljs.core.next.call(null,seq978);\nvar G__980 = cljs.core.first.call(null,seq978__$1);\nvar seq978__$2 = cljs.core.next.call(null,seq978__$1);\nvar G__981 = cljs.core.first.call(null,seq978__$2);\nvar seq978__$3 = cljs.core.next.call(null,seq978__$2);\nreturn quil.core$macros.with_graphics.cljs$core$IFn$_invoke$arity$variadic(G__979,G__980,G__981,seq978__$3);\n});\n\n\nquil.core$macros.with_graphics.cljs$lang$macro = true;\n/**\n * Create and start a new visualisation applet. Can be used to create\n *   new sketches programmatically. See documentation for 'defsketch' for\n *   list of available options.\n */\nquil.core$macros.sketch = (function quil$core$macros$sketch(var_args){\nvar args__13423__auto__ = [];\nvar len__13421__auto___986 = arguments.length;\nvar i__13422__auto___987 = (0);\nwhile(true){\nif((i__13422__auto___987 < len__13421__auto___986)){\nargs__13423__auto__.push((arguments[i__13422__auto___987]));\n\nvar G__988 = (i__13422__auto___987 + (1));\ni__13422__auto___987 = G__988;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__13424__auto__ = ((((0) < args__13423__auto__.length))?(new cljs.core.IndexedSeq(args__13423__auto__.slice((0)),(0),null)):null);\nreturn quil.core$macros.sketch.cljs$core$IFn$_invoke$arity$variadic(argseq__13424__auto__);\n});\n\nquil.core$macros.sketch.cljs$core$IFn$_invoke$arity$variadic = (function (opts){\nreturn cljs.core.apply.call(null,quil.sketch.sketch,opts);\n});\n\nquil.core$macros.sketch.cljs$lang$maxFixedArity = (0);\n\nquil.core$macros.sketch.cljs$lang$applyTo = (function (seq985){\nreturn quil.core$macros.sketch.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq.call(null,seq985));\n});\n\n/**\n * Define and start a sketch and bind it to a var with the symbol\n *   app-name. If any of the options to the various callbacks are\n *   symbols, it wraps them in a call to var to ensure they aren't\n *   inlined and that redefinitions to the original fns are reflected in\n *   the visualisation.\n * \n *   Available options:\n * \n * :size           - A vector of width and height for the sketch or :fullscreen.\n *                   Defaults to [500 300]. If you're using :fullscreen you may\n *                   want to enable present mode - :features [:present]\n * \n * :renderer       - Specifies the renderer type. One of :p2d, :p3d, :java2d,\n *                   :opengl, :pdf). Defaults to :java2d. :dxf renderer\n *                   can't be used as sketch renderer. Use begin-raw method\n *                   instead. In clojurescript only :p2d and :p3d renderers\n *                   are supported.\n * \n * :output-file    - Specifies an output file path. Only used in :pdf mode.\n *                   Not supported in clojurescript.\n * \n * :title          - A string which will be displayed at the top of\n *                   the sketch window. Not supported in clojurescript.\n * \n * :features       - A vector of keywords customizing sketch behaviour.\n *                   Supported features:\n * \n *                   :keep-on-top - Sketch window will always be above other\n *                                  windows. Note: some platforms might not\n *                                  support always-on-top windows.\n *                                  Not supported in clojurescript.\n * \n *                   :exit-on-close - Shutdown JVM  when sketch is closed.\n *                                    Not supported in clojurescript.\n * \n *                   :resizable - Makes sketch resizable.\n *                                Not supported in clojurescript.\n * \n *                   :no-safe-fns - Do not catch and print exceptions thrown\n *                                  inside functions provided to sketch (like\n *                                  draw, mouse-click, key-pressed and\n *                                  other). By default all exceptions thrown\n *                                  inside these functions are catched. This\n *                                  prevents sketch from breaking when bad\n *                                  function was provided and allows you to\n *                                  fix it and reload it on fly. You can\n *                                  disable this behaviour by enabling\n *                                  :no-safe-fns feature.\n *                                  Not supported in clojurescript.\n * \n *                   :present - Switch to present mode (fullscreen without\n *                              borders, OS panels). You may want to use\n *                              this feature together with :size :fullscreen.\n *                              Not supported in clojurescript.\n * \n *                   :no-start - Disables autostart if sketch was created using\n *                               defsketch macro. To start sketch you have to\n *                               call function created defsketch.\n *                               Supported only in clojurescript.\n * \n *                   :global-key-events - Allows a sketch to receive any\n *                                        keyboard event sent to the page,\n *                                        regardless of whether the canvas it is\n *                                        loaded in has focus or not.\n *                                        Supported only in clojurescript.\n * \n *                   Usage example: :features [:keep-on-top :present]\n * \n * :bgcolor        - Sets background color for unused space in present mode.\n *                   Color is specified in hex format: #XXXXXX.\n *                   Example: :bgcolor \"#00FFFF\" (cyan background)\n *                   Not supported in clojurescript.\n * \n * :display        - Sets what display should be used by this sketch.\n *                   Displays are numbered starting from 0. Example: :display 1.\n *                   Not supported in clojurescript.\n * \n * :setup          - A function to be called once when setting the sketch up.\n * \n * :draw           - A function to be repeatedly called at most n times per\n *                   second where n is the target frame-rate set for\n *                   the visualisation.\n * \n * :host           - String id of canvas element or DOM element itself.\n *                   Specifies host for the sketch. Must be specified in sketch,\n *                   may be omitted in defsketch. If ommitted in defsketch,\n *                   :host is set to the name of the sketch. If element with\n *                   specified id is not found on the page and page is empty -\n *                   new canvas element will be created. Used in clojurescript.\n * \n * :focus-gained   - Called when the sketch gains focus.\n *                   Not supported in clojurescript.\n * \n * :focus-lost     - Called when the sketch loses focus.\n *                   Not supported in clojurescript.\n * \n * :mouse-entered  - Called when the mouse enters the sketch window.\n * \n * :mouse-exited   - Called when the mouse leaves the sketch window\n * \n * :mouse-pressed  - Called every time a mouse button is pressed.\n * \n * :mouse-released - Called every time a mouse button is released.\n * \n * :mouse-clicked  - called once after a mouse button has been pressed\n *                   and then released.\n * \n * :mouse-moved    - Called every time the mouse moves and a button is\n *                   not pressed.\n * \n * :mouse-dragged  - Called every time the mouse moves and a button is\n *                   pressed.\n * \n * :mouse-wheel    - Called every time mouse wheel is rotated.\n *                   Takes 1 argument - wheel rotation, an int.\n *                   Negative values if the mouse wheel was rotated\n *                   up/away from the user, and positive values\n *                   if the mouse wheel was rotated down/ towards the user\n * \n * :key-pressed    - Called every time any key is pressed.\n * \n * :key-released   - Called every time any key is released.\n * \n * :key-typed      - Called once every time non-modifier keys are\n *                   pressed.\n * \n * :on-close       - Called once, when sketch is closed\n *                   Not supported in clojurescript.\n * \n * :middleware     - Vector of middleware to be applied to the sketch.\n *                   Middleware will be applied in the same order as in comp\n *                   function: [f g] will be applied as (f (g options)).\n * \n * :settings       - cousin of :setup. A function to be called once when\n *                   setting sketch up. Should be used only for (smooth) and\n *                   (no-smooth). Due to Processing limitations these functions\n *                   cannot be used neither in :setup nor in :draw.\n */\nquil.core$macros.defsketch = (function quil$core$macros$defsketch(var_args){\nvar args__13423__auto__ = [];\nvar len__13421__auto___993 = arguments.length;\nvar i__13422__auto___994 = (0);\nwhile(true){\nif((i__13422__auto___994 < len__13421__auto___993)){\nargs__13423__auto__.push((arguments[i__13422__auto___994]));\n\nvar G__995 = (i__13422__auto___994 + (1));\ni__13422__auto___994 = G__995;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__13424__auto__ = ((((3) < args__13423__auto__.length))?(new cljs.core.IndexedSeq(args__13423__auto__.slice((3)),(0),null)):null);\nreturn quil.core$macros.defsketch.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__13424__auto__);\n});\n\nquil.core$macros.defsketch.cljs$core$IFn$_invoke$arity$variadic = (function (_AMPERSAND_form,_AMPERSAND_env,app_name,options){\nreturn cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.sketch\",\"defsketch\",\"quil.sketch/defsketch\",(495366770),null)),(function (){var x__13164__auto__ = app_name;\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})(),options));\n});\n\nquil.core$macros.defsketch.cljs$lang$maxFixedArity = (3);\n\nquil.core$macros.defsketch.cljs$lang$applyTo = (function (seq989){\nvar G__990 = cljs.core.first.call(null,seq989);\nvar seq989__$1 = cljs.core.next.call(null,seq989);\nvar G__991 = cljs.core.first.call(null,seq989__$1);\nvar seq989__$2 = cljs.core.next.call(null,seq989__$1);\nvar G__992 = cljs.core.first.call(null,seq989__$2);\nvar seq989__$3 = cljs.core.next.call(null,seq989__$2);\nreturn quil.core$macros.defsketch.cljs$core$IFn$_invoke$arity$variadic(G__990,G__991,G__992,seq989__$3);\n});\n\n\nquil.core$macros.defsketch.cljs$lang$macro = true;\n/**\n * Returns true if char c is a 'coded' char i.e. it is necessary to\n *   fetch the key-code as an integer and use that to determine the\n *   specific key pressed. See key-keyword.\n */\nquil.core$macros.key_coded_QMARK_ = (function quil$core$macros$key_coded_QMARK_(c){\nreturn cljs.core._EQ_.call(null,(65535),String(c).charCodeAt());\n});\n/**\n * Returns a keyword representing the currently pressed key. Modifier\n *   keys are represented as: :up, :down, :left, :right, :alt, :control,\n *   :shift, :command, :f1-24\n */\nquil.core$macros.key_as_keyword = (function quil$core$macros$key_as_keyword(){\nvar key_char = quil.core$macros.raw_key.call(null);\nvar code = quil.core$macros.key_code.call(null);\nif(cljs.core.truth_(quil.core$macros.key_coded_QMARK_.call(null,key_char))){\nreturn cljs.core.get.call(null,quil.core$macros.KEY_CODES,code,new cljs.core.Keyword(null,\"unknown-key\",\"unknown-key\",(255305911)));\n} else {\nreturn cljs.core.keyword.call(null,String(key_char));\n}\n});\n","quil/util$macros.cache.json":"[\"^ \",\"~:rename-macros\",[\"^ \"],\"~:renames\",[\"^ \"],\"~:use-macros\",[\"^ \"],\"~:excludes\",[\"~#set\",[]],\"~:name\",\"~$quil.util$macros\",\"~:imports\",null,\"~:requires\",[\"^ \",\"~$cstr\",\"~$clojure.string\",\"^:\",\"^:\"],\"~:uses\",null,\"~:defs\",[\"^ \",\"~$clj-compilation?\",[\"^ \",\"~:protocol-inline\",null,\"~:meta\",[\"^ \",\"~:file\",\"~$quil.util\",\"~:line\",71,\"~:column\",7,\"~:end-line\",71,\"~:end-column\",23,\"~:arglists\",[\"~#list\",[\"~$quote\",[\"^G\",[[]]]]]],\"^5\",\"~$quil.util$macros/clj-compilation?\",\"~:variadic\",false,\"^@\",\"quil/util.cljc\",\"^E\",23,\"~:method-params\",[\"^G\",[[]]],\"~:protocol-impl\",null,\"~:arglists-meta\",[\"^G\",[null,null]],\"^C\",1,\"^B\",71,\"^D\",71,\"~:max-fixed-arity\",0,\"~:fn-var\",true,\"^F\",[\"^G\",[\"^H\",[\"^G\",[[]]]]]],\"~$make-quil-constant-map\",[\"^ \",\"^>\",null,\"^?\",[\"^ \",\"^@\",\"^A\",\"^B\",98,\"^C\",7,\"^D\",98,\"^E\",29,\"^F\",[\"^G\",[\"^H\",[\"^G\",[[\"~$target\",\"~$const-map-name\",\"~$const-map\"]]]]]],\"^5\",\"~$quil.util$macros/make-quil-constant-map\",\"^J\",false,\"^@\",\"quil/util.cljc\",\"^E\",29,\"^K\",[\"^G\",[[\"^Q\",\"^R\",\"^S\"]]],\"^L\",null,\"^M\",[\"^G\",[null,null]],\"^C\",1,\"^B\",98,\"^D\",98,\"^N\",3,\"^O\",true,\"^F\",[\"^G\",[\"^H\",[\"^G\",[[\"^Q\",\"^R\",\"^S\"]]]]]],\"~$print-definition-list\",[\"^ \",\"^>\",null,\"^?\",[\"^ \",\"^@\",\"^A\",\"^B\",60,\"^C\",7,\"^D\",60,\"^E\",28,\"^F\",[\"^G\",[\"^H\",[\"^G\",[[\"~$definitions\"]]]]]],\"^5\",\"~$quil.util$macros/print-definition-list\",\"^J\",false,\"^@\",\"quil/util.cljc\",\"^E\",28,\"^K\",[\"^G\",[[\"^V\"]]],\"^L\",null,\"^M\",[\"^G\",[null,null]],\"^C\",1,\"^B\",60,\"^D\",60,\"^N\",1,\"^O\",true,\"^F\",[\"^G\",[\"^H\",[\"^G\",[[\"^V\"]]]]]],\"~$generate-quil-constants\",[\"^ \",\"^>\",null,\"^?\",[\"^ \",\"^@\",\"^A\",\"^B\",105,\"^C\",11,\"^D\",105,\"^E\",34,\"~:macro\",true,\"^F\",[\"^G\",[\"^H\",[\"^G\",[[\"^Q\",\"~$&\",\"~$opts\"]]]]],\"~:top-fn\",[\"^ \",\"^J\",true,\"^N\",3,\"^K\",[[\"^G\",[\"~$&form\",\"~$&env\",\"^Q\",\"^Z\"]]],\"^F\",[\"^G\",[[\"^10\",\"^11\",\"^Q\",\"~$&\",\"^Z\"]]],\"^M\",[\"^G\",[null]]]],\"^5\",\"~$quil.util$macros/generate-quil-constants\",\"^J\",true,\"^@\",\"quil/util.cljc\",\"^E\",34,\"^[\",[\"^ \",\"^J\",true,\"^N\",3,\"^K\",[[\"^G\",[\"^10\",\"^11\",\"^Q\",\"^Z\"]]],\"^F\",[\"^G\",[[\"^10\",\"^11\",\"^Q\",\"~$&\",\"^Z\"]]],\"^M\",[\"^G\",[null]]],\"^K\",[[\"^G\",[\"^10\",\"^11\",\"^Q\",\"^Z\"]]],\"^L\",null,\"^M\",[\"^G\",[null]],\"^C\",1,\"^B\",105,\"^Y\",true,\"^D\",105,\"^N\",3,\"^O\",false,\"^F\",[\"^G\",[[\"^10\",\"^11\",\"^Q\",\"~$&\",\"^Z\"]]]],\"~$resolve-constant-key\",[\"^ \",\"^>\",null,\"^?\",[\"^ \",\"^@\",\"^A\",\"^B\",27,\"^C\",7,\"^D\",27,\"^E\",27,\"^F\",[\"^G\",[\"^H\",[\"^G\",[[\"~$key\",\"~$mappings\"]]]]],\"~:doc\",\"Returns the val associated with key in mappings or key directly if it\\n  is one of the vals in mappings. Otherwise throws an exception.\"],\"^5\",\"~$quil.util$macros/resolve-constant-key\",\"^J\",false,\"^@\",\"quil/util.cljc\",\"^E\",27,\"^K\",[\"^G\",[[\"^14\",\"^15\"]]],\"^L\",null,\"^M\",[\"^G\",[null,null]],\"^C\",1,\"^B\",27,\"^D\",27,\"^N\",2,\"^O\",true,\"^F\",[\"^G\",[\"^H\",[\"^G\",[[\"^14\",\"^15\"]]]]],\"^16\",\"Returns the val associated with key in mappings or key directly if it\\n  is one of the vals in mappings. Otherwise throws an exception.\"],\"~$no-fn\",[\"^ \",\"^>\",null,\"^?\",[\"^ \",\"^@\",\"^A\",\"^B\",5,\"^C\",7,\"^D\",5,\"^E\",12,\"^F\",[\"^G\",[\"^H\",[\"^G\",[[]]]]],\"^16\",\"Function that does nothing.\"],\"^5\",\"~$quil.util$macros/no-fn\",\"^J\",false,\"^@\",\"quil/util.cljc\",\"^E\",12,\"^K\",[\"^G\",[[]]],\"^L\",null,\"^M\",[\"^G\",[null,null]],\"^C\",1,\"^B\",5,\"^D\",5,\"^N\",0,\"^O\",true,\"^F\",[\"^G\",[\"^H\",[\"^G\",[[]]]]],\"^16\",\"Function that does nothing.\"],\"~$prepare-quil-clj-constants\",[\"^ \",\"^>\",null,\"^?\",[\"^ \",\"^@\",\"^A\",\"^B\",86,\"^C\",7,\"^D\",86,\"^E\",33,\"^F\",[\"^G\",[\"^H\",[\"^G\",[[\"~$constants\"]]]]]],\"^5\",\"~$quil.util$macros/prepare-quil-clj-constants\",\"^J\",false,\"^@\",\"quil/util.cljc\",\"^E\",33,\"^K\",[\"^G\",[[\"^1;\"]]],\"^L\",null,\"^M\",[\"^G\",[null,null]],\"^C\",1,\"^B\",86,\"^D\",86,\"^N\",1,\"^O\",true,\"^F\",[\"^G\",[\"^H\",[\"^G\",[[\"^1;\"]]]]]],\"~$prepare-quil-cljs-constants\",[\"^ \",\"^>\",null,\"^?\",[\"^ \",\"^@\",\"^A\",\"^B\",92,\"^C\",7,\"^D\",92,\"^E\",34,\"^F\",[\"^G\",[\"^H\",[\"^G\",[[\"^1;\"]]]]]],\"^5\",\"~$quil.util$macros/prepare-quil-cljs-constants\",\"^J\",false,\"^@\",\"quil/util.cljc\",\"^E\",34,\"^K\",[\"^G\",[[\"^1;\"]]],\"^L\",null,\"^M\",[\"^G\",[null,null]],\"^C\",1,\"^B\",92,\"^D\",92,\"^N\",1,\"^O\",true,\"^F\",[\"^G\",[\"^H\",[\"^G\",[[\"^1;\"]]]]]],\"~$length-of-longest-key\",[\"^ \",\"^>\",null,\"^?\",[\"^ \",\"^@\",\"^A\",\"^B\",39,\"^C\",8,\"^D\",39,\"^E\",29,\"~:private\",true,\"^F\",[\"^G\",[\"^H\",[\"^G\",[[\"~$m\"]]]]],\"^16\",\"Returns the length of the longest key of map m. Assumes m's keys are strings\\n   and returns 0 if map is empty:\\n   (length-of-longest-key {\\\"foo\\\" 1 \\\"barr\\\" 2 \\\"bazzz\\\" 3}) ;=> 5\\n   (length-of-longest-key {}) ;=> 0\"],\"^1@\",true,\"^5\",\"~$quil.util$macros/length-of-longest-key\",\"^J\",false,\"^@\",\"quil/util.cljc\",\"^E\",29,\"^K\",[\"^G\",[[\"~$m\"]]],\"^L\",null,\"^M\",[\"^G\",[null,null]],\"^C\",1,\"^B\",39,\"^D\",39,\"^N\",1,\"^O\",true,\"^F\",[\"^G\",[\"^H\",[\"^G\",[[\"~$m\"]]]]],\"^16\",\"Returns the length of the longest key of map m. Assumes m's keys are strings\\n   and returns 0 if map is empty:\\n   (length-of-longest-key {\\\"foo\\\" 1 \\\"barr\\\" 2 \\\"bazzz\\\" 3}) ;=> 5\\n   (length-of-longest-key {}) ;=> 0\"],\"~$gen-padding\",[\"^ \",\"^>\",null,\"^?\",[\"^ \",\"^1@\",true,\"^@\",\"^A\",\"^E\",19,\"^[\",[\"^ \",\"^J\",false,\"^N\",3,\"^K\",[\"^G\",[[\"~$len\"],[\"^1C\",\"~$pad\"],[\"~$s\",\"^1C\",\"^1D\"]]],\"^F\",[\"^G\",[[\"^1C\"],[\"^1C\",\"^1D\"],[\"~$s\",\"^1C\",\"^1D\"]]],\"^M\",[\"^G\",[null,null,null]]],\"^C\",8,\"^B\",48,\"^D\",48,\"^F\",[\"^G\",[\"^H\",[\"^G\",[[\"^1C\"],[\"^1C\",\"^1D\"],[\"~$s\",\"^1C\",\"^1D\"]]]]],\"^16\",\"Generates a padding string starting concatting s with len times pad:\\n   (gen-padding \\\"\\\" 5 \\\"b\\\") ;=> \\\"bbbbb\\\"\\n   May be called without starting string s in which case it defaults to the\\n   empty string and also without pad in which case it defaults to a single space\"],\"^1@\",true,\"^5\",\"~$quil.util$macros/gen-padding\",\"^J\",false,\"^@\",\"quil/util.cljc\",\"^E\",19,\"^[\",[\"^ \",\"^J\",false,\"^N\",3,\"^K\",[\"^G\",[[\"^1C\"],[\"^1C\",\"^1D\"],[\"~$s\",\"^1C\",\"^1D\"]]],\"^F\",[\"^G\",[[\"^1C\"],[\"^1C\",\"^1D\"],[\"~$s\",\"^1C\",\"^1D\"]]],\"^M\",[\"^G\",[null,null,null]]],\"^K\",[\"^G\",[[\"^1C\"],[\"^1C\",\"^1D\"],[\"~$s\",\"^1C\",\"^1D\"]]],\"^L\",null,\"^M\",[\"^G\",[null,null,null]],\"^C\",1,\"^B\",48,\"^D\",48,\"^N\",3,\"^O\",true,\"^F\",[\"^G\",[[\"^1C\"],[\"^1C\",\"^1D\"],[\"~$s\",\"^1C\",\"^1D\"]]],\"^16\",\"Generates a padding string starting concatting s with len times pad:\\n   (gen-padding \\\"\\\" 5 \\\"b\\\") ;=> \\\"bbbbb\\\"\\n   May be called without starting string s in which case it defaults to the\\n   empty string and also without pad in which case it defaults to a single space\"],\"~$prepare-quil-name\",[\"^ \",\"^>\",null,\"^?\",[\"^ \",\"^@\",\"^A\",\"^B\",81,\"^C\",7,\"^D\",81,\"^E\",24,\"^F\",[\"^G\",[\"^H\",[\"^G\",[[\"~$const-keyword\"]]]]]],\"^5\",\"~$quil.util$macros/prepare-quil-name\",\"^J\",false,\"^@\",\"quil/util.cljc\",\"^E\",24,\"^K\",[\"^G\",[[\"^1G\"]]],\"^L\",null,\"^M\",[\"^G\",[null,null]],\"^C\",1,\"^B\",81,\"^D\",81,\"^N\",1,\"^O\",true,\"^F\",[\"^G\",[\"^H\",[\"^G\",[[\"^1G\"]]]]]]],\"~:require-macros\",[\"^ \"],\"~:cljs.analyzer/constants\",[\"^ \",\"~:seen\",[\"^4\",[\"~:else\",\"~$cljs.core/aget\",\"~$js/Processing.prototype.PConstants\",\"~$def\",\"~:clj\",\"~$do\"]],\"~:order\",[\"^1L\",\"^1M\",\"^1N\",\"^1O\",\"^1P\",\"^1Q\"]],\"^16\",null]","quil/sketch$macros.js":"// Compiled by ClojureScript 1.9.293 {:elide-asserts true}\ngoog.provide(\"quil.sketch$macros\");\nquil.sketch$macros.with_sketch = (function quil$sketch$macros$with_sketch(var_args){\nvar args__13423__auto__ = [];\nvar len__13421__auto___282 = arguments.length;\nvar i__13422__auto___283 = (0);\nwhile(true){\nif((i__13422__auto___283 < len__13421__auto___282)){\nargs__13423__auto__.push((arguments[i__13422__auto___283]));\n\nvar G__284 = (i__13422__auto___283 + (1));\ni__13422__auto___283 = G__284;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__13424__auto__ = ((((3) < args__13423__auto__.length))?(new cljs.core.IndexedSeq(args__13423__auto__.slice((3)),(0),null)):null);\nreturn quil.sketch$macros.with_sketch.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__13424__auto__);\n});\n\nquil.sketch$macros.with_sketch.cljs$core$IFn$_invoke$arity$variadic = (function (_AMPERSAND_form,_AMPERSAND_env,applet,body){\nreturn cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"cljs.core\",\"binding\",\"cljs.core/binding\",(2050379843),null)),(function (){var x__13164__auto__ = cljs.core.vec.call(null,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.sketch\",\"*applet*\",\"quil.sketch/*applet*\",(-1126699869),null)),(function (){var x__13164__auto__ = applet;\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})())));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})(),body));\n});\n\nquil.sketch$macros.with_sketch.cljs$lang$maxFixedArity = (3);\n\nquil.sketch$macros.with_sketch.cljs$lang$applyTo = (function (seq278){\nvar G__279 = cljs.core.first.call(null,seq278);\nvar seq278__$1 = cljs.core.next.call(null,seq278);\nvar G__280 = cljs.core.first.call(null,seq278__$1);\nvar seq278__$2 = cljs.core.next.call(null,seq278__$1);\nvar G__281 = cljs.core.first.call(null,seq278__$2);\nvar seq278__$3 = cljs.core.next.call(null,seq278__$2);\nreturn quil.sketch$macros.with_sketch.cljs$core$IFn$_invoke$arity$variadic(G__279,G__280,G__281,seq278__$3);\n});\n\n\nquil.sketch$macros.with_sketch.cljs$lang$macro = true;\n/**\n * Wrap fns allows dynamic redefinition of function such as draw, update\n *   in cljs. This is achieved by wrapping all provided functions to\n *   anonymous functions such that 'my-draw' function turns into\n *   (fn [& args] (apply my-draw args)). This adds a level of indirection\n *   so that when quil calls draw, it invokes anonymous function which in\n *   turn always calls my-draw by name and if you redefine - new version\n *   will be used. Hence we need this cryptic macro.\n */\nquil.sketch$macros.wrap_fns = (function quil$sketch$macros$wrap_fns(opts){\nreturn cljs.core.into.call(null,cljs.core.PersistentArrayMap.EMPTY,(function (){var iter__12962__auto__ = (function quil$sketch$macros$wrap_fns_$_iter__301(s__302){\nreturn (new cljs.core.LazySeq(null,(function (){\nvar s__302__$1 = s__302;\nwhile(true){\nvar temp__10400__auto__ = cljs.core.seq.call(null,s__302__$1);\nif(temp__10400__auto__){\nvar s__302__$2 = temp__10400__auto__;\nif(cljs.core.chunked_seq_QMARK_.call(null,s__302__$2)){\nvar c__12960__auto__ = cljs.core.chunk_first.call(null,s__302__$2);\nvar size__12961__auto__ = cljs.core.count.call(null,c__12960__auto__);\nvar b__304 = cljs.core.chunk_buffer.call(null,size__12961__auto__);\nif((function (){var i__303 = (0);\nwhile(true){\nif((i__303 < size__12961__auto__)){\nvar vec__311 = cljs.core._nth.call(null,c__12960__auto__,i__303);\nvar k = cljs.core.nth.call(null,vec__311,(0),null);\nvar v = cljs.core.nth.call(null,vec__311,(1),null);\ncljs.core.chunk_append.call(null,b__304,(((v instanceof cljs.core.Symbol))?new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [k,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"if\",\"if\",(1181717262),null)),(function (){var x__13164__auto__ = cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"cljs.core\",\"fn?\",\"cljs.core/fn?\",(71876239),null)),(function (){var x__13164__auto__ = v;\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})()));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})(),(function (){var x__13164__auto__ = cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"cljs.core\",\"fn\",\"cljs.core/fn\",(-1065745098),null)),(function (){var x__13164__auto__ = cljs.core.vec.call(null,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"&\",\"&\",(-2144855648),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"args\",\"args\",(-1338879193),null)))));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})(),(function (){var x__13164__auto__ = cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"cljs.core\",\"apply\",\"cljs.core/apply\",(1757277831),null)),(function (){var x__13164__auto__ = v;\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})(),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"args\",\"args\",(-1338879193),null))));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})()));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})(),(function (){var x__13164__auto__ = v;\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})()))], null):new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [k,v], null)));\n\nvar G__317 = (i__303 + (1));\ni__303 = G__317;\ncontinue;\n} else {\nreturn true;\n}\nbreak;\n}\n})()){\nreturn cljs.core.chunk_cons.call(null,cljs.core.chunk.call(null,b__304),quil$sketch$macros$wrap_fns_$_iter__301.call(null,cljs.core.chunk_rest.call(null,s__302__$2)));\n} else {\nreturn cljs.core.chunk_cons.call(null,cljs.core.chunk.call(null,b__304),null);\n}\n} else {\nvar vec__314 = cljs.core.first.call(null,s__302__$2);\nvar k = cljs.core.nth.call(null,vec__314,(0),null);\nvar v = cljs.core.nth.call(null,vec__314,(1),null);\nreturn cljs.core.cons.call(null,(((v instanceof cljs.core.Symbol))?new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [k,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"if\",\"if\",(1181717262),null)),(function (){var x__13164__auto__ = cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"cljs.core\",\"fn?\",\"cljs.core/fn?\",(71876239),null)),(function (){var x__13164__auto__ = v;\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})()));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})(),(function (){var x__13164__auto__ = cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"cljs.core\",\"fn\",\"cljs.core/fn\",(-1065745098),null)),(function (){var x__13164__auto__ = cljs.core.vec.call(null,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"&\",\"&\",(-2144855648),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"args\",\"args\",(-1338879193),null)))));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})(),(function (){var x__13164__auto__ = cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"cljs.core\",\"apply\",\"cljs.core/apply\",(1757277831),null)),(function (){var x__13164__auto__ = v;\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})(),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"args\",\"args\",(-1338879193),null))));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})()));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})(),(function (){var x__13164__auto__ = v;\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})()))], null):new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [k,v], null)),quil$sketch$macros$wrap_fns_$_iter__301.call(null,cljs.core.rest.call(null,s__302__$2)));\n}\n} else {\nreturn null;\n}\nbreak;\n}\n}),null,null));\n});\nreturn iter__12962__auto__.call(null,opts);\n})());\n});\nquil.sketch$macros.defsketch = (function quil$sketch$macros$defsketch(var_args){\nvar args__13423__auto__ = [];\nvar len__13421__auto___322 = arguments.length;\nvar i__13422__auto___323 = (0);\nwhile(true){\nif((i__13422__auto___323 < len__13421__auto___322)){\nargs__13423__auto__.push((arguments[i__13422__auto___323]));\n\nvar G__324 = (i__13422__auto___323 + (1));\ni__13422__auto___323 = G__324;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__13424__auto__ = ((((3) < args__13423__auto__.length))?(new cljs.core.IndexedSeq(args__13423__auto__.slice((3)),(0),null)):null);\nreturn quil.sketch$macros.defsketch.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__13424__auto__);\n});\n\nquil.sketch$macros.defsketch.cljs$core$IFn$_invoke$arity$variadic = (function (_AMPERSAND_form,_AMPERSAND_env,app_name,options){\nvar raw_opts = cljs.core.apply.call(null,cljs.core.hash_map,options);\nvar opts = quil.sketch$macros.wrap_fns.call(null,cljs.core.merge.call(null,new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"host\",\"host\",(-1558485167)),[cljs.core.str(app_name)].join('')], null),raw_opts));\nreturn cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"do\",\"do\",(1686842252),null)),(function (){var x__13164__auto__ = cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"cljs.core\",\"defn\",\"cljs.core/defn\",(-1606493717),null)),(function (){var x__13164__auto__ = cljs.core.vary_meta.call(null,app_name,cljs.core.assoc,new cljs.core.Keyword(null,\"export\",\"export\",(214356590)),true);\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})(),(function (){var x__13164__auto__ = cljs.core.vec.call(null,cljs.core.sequence.call(null,cljs.core.concat.call(null)));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})(),(function (){var x__13164__auto__ = cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.sketch\",\"sketch\",\"quil.sketch/sketch\",(-934423233),null)),cljs.core.apply.call(null,cljs.core.concat,cljs.core.seq.call(null,opts))));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})()));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})(),(function (){var x__13164__auto__ = cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"cljs.core\",\"when-not\",\"cljs.core/when-not\",(-556141047),null)),(function (){var x__13164__auto__ = cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"cljs.core\",\"some\",\"cljs.core/some\",(-977628065),null)),(function (){var x__13164__auto__ = cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"fn*\",\"fn*\",(-752876845),null)),(function (){var x__13164__auto__ = cljs.core.vec.call(null,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"p1__9__10__auto__\",\"p1__9__10__auto__\",(1905896585),null)))));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})(),(function (){var x__13164__auto__ = cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"cljs.core\",\"=\",\"cljs.core/=\",(-1891498332),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Keyword(null,\"no-start\",\"no-start\",(1381488856))),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"p1__9__10__auto__\",\"p1__9__10__auto__\",(1905896585),null))));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})()));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})(),(function (){var x__13164__auto__ = new cljs.core.Keyword(null,\"features\",\"features\",(-1146962336)).cljs$core$IFn$_invoke$arity$1(opts);\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})()));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})(),(function (){var x__13164__auto__ = cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.sketch\",\"add-sketch-to-init-list\",\"quil.sketch/add-sketch-to-init-list\",(-205126918),null)),(function (){var x__13164__auto__ = cljs.core.apply.call(null,cljs.core.array_map,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Keyword(null,\"fn\",\"fn\",(-1175266204))),(function (){var x__13164__auto__ = app_name;\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})(),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Keyword(null,\"host-id\",\"host-id\",(742376279))),(function (){var x__13164__auto__ = new cljs.core.Keyword(null,\"host\",\"host\",(-1558485167)).cljs$core$IFn$_invoke$arity$1(opts);\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})())));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})()));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})()));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})()));\n});\n\nquil.sketch$macros.defsketch.cljs$lang$maxFixedArity = (3);\n\nquil.sketch$macros.defsketch.cljs$lang$applyTo = (function (seq318){\nvar G__319 = cljs.core.first.call(null,seq318);\nvar seq318__$1 = cljs.core.next.call(null,seq318);\nvar G__320 = cljs.core.first.call(null,seq318__$1);\nvar seq318__$2 = cljs.core.next.call(null,seq318__$1);\nvar G__321 = cljs.core.first.call(null,seq318__$2);\nvar seq318__$3 = cljs.core.next.call(null,seq318__$2);\nreturn quil.sketch$macros.defsketch.cljs$core$IFn$_invoke$arity$variadic(G__319,G__320,G__321,seq318__$3);\n});\n\n\nquil.sketch$macros.defsketch.cljs$lang$macro = true;\n","quil/core.js":"// Compiled by ClojureScript 1.9.293 {:elide-asserts true}\ngoog.provide(\"quil.core\");\nquil.core._STAR_graphics_STAR_ = null;\nquil.core.no_fill_prop = \"no-fill-quil\";\n/**\n * Graphics currently used for drawing. By default it is sketch graphics,\n *   but if called inside with-graphics macro - graphics passed to the macro\n *   is returned. This method should be used if you need to call some methods\n *   that are not implemented by quil. Example:\n *   (.beginDraw (current-graphics)).\n */\nquil.core.current_graphics = (function quil$core$current_graphics(){\nvar or__11101__auto__ = quil.core._STAR_graphics_STAR_;\nif(cljs.core.truth_(or__11101__auto__)){\nreturn or__11101__auto__;\n} else {\nreturn quil.sketch.current_applet.call(null);\n}\n});\nquil.core.arc_modes = new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\"open\",\"open\",(-1763596448)),(Processing.prototype.PConstants[\"OPEN\"]),new cljs.core.Keyword(null,\"chord\",\"chord\",(-696248342)),(Processing.prototype.PConstants[\"CHORD\"]),new cljs.core.Keyword(null,\"pie\",\"pie\",(1530441672)),(Processing.prototype.PConstants[\"PIE\"])], null);\n\nquil.core.shape_modes = new cljs.core.PersistentArrayMap(null, 7, [new cljs.core.Keyword(null,\"points\",\"points\",(-1486596883)),(Processing.prototype.PConstants[\"POINTS\"]),new cljs.core.Keyword(null,\"lines\",\"lines\",(-700165781)),(Processing.prototype.PConstants[\"LINES\"]),new cljs.core.Keyword(null,\"triangles\",\"triangles\",(-1525417058)),(Processing.prototype.PConstants[\"TRIANGLES\"]),new cljs.core.Keyword(null,\"triangle-fan\",\"triangle-fan\",(1743150739)),(Processing.prototype.PConstants[\"TRIANGLE_FAN\"]),new cljs.core.Keyword(null,\"triangle-strip\",\"triangle-strip\",(221845500)),(Processing.prototype.PConstants[\"TRIANGLE_STRIP\"]),new cljs.core.Keyword(null,\"quads\",\"quads\",(1347497505)),(Processing.prototype.PConstants[\"QUADS\"]),new cljs.core.Keyword(null,\"quad-strip\",\"quad-strip\",(-1297270686)),(Processing.prototype.PConstants[\"QUAD_STRIP\"])], null);\n\nquil.core.blend_modes = cljs.core.PersistentHashMap.fromArrays([new cljs.core.Keyword(null,\"burn\",\"burn\",(-458179293)),new cljs.core.Keyword(null,\"screen\",\"screen\",(1990059748)),new cljs.core.Keyword(null,\"darkest\",\"darkest\",(68197253)),new cljs.core.Keyword(null,\"dodge\",\"dodge\",(-1556666427)),new cljs.core.Keyword(null,\"replace\",\"replace\",(-786587770)),new cljs.core.Keyword(null,\"overlay\",\"overlay\",(-139131598)),new cljs.core.Keyword(null,\"difference\",\"difference\",(1916101396)),new cljs.core.Keyword(null,\"exclusion\",\"exclusion\",(531897910)),new cljs.core.Keyword(null,\"hard-light\",\"hard-light\",(-37591145)),new cljs.core.Keyword(null,\"multiply\",\"multiply\",(-1036907048)),new cljs.core.Keyword(null,\"lightest\",\"lightest\",(-2043115912)),new cljs.core.Keyword(null,\"blend\",\"blend\",(249565561)),new cljs.core.Keyword(null,\"add\",\"add\",(235287739)),new cljs.core.Keyword(null,\"soft-light\",\"soft-light\",(513207899)),new cljs.core.Keyword(null,\"subtract\",\"subtract\",(2136988635))],[(Processing.prototype.PConstants[\"BURN\"]),(Processing.prototype.PConstants[\"SCREEN\"]),(Processing.prototype.PConstants[\"DARKEST\"]),(Processing.prototype.PConstants[\"DODGE\"]),(Processing.prototype.PConstants[\"REPLACE\"]),(Processing.prototype.PConstants[\"OVERLAY\"]),(Processing.prototype.PConstants[\"DIFFERENCE\"]),(Processing.prototype.PConstants[\"EXCLUSION\"]),(Processing.prototype.PConstants[\"HARD_LIGHT\"]),(Processing.prototype.PConstants[\"MULTIPLY\"]),(Processing.prototype.PConstants[\"LIGHTEST\"]),(Processing.prototype.PConstants[\"BLEND\"]),(Processing.prototype.PConstants[\"ADD\"]),(Processing.prototype.PConstants[\"SOFT_LIGHT\"]),(Processing.prototype.PConstants[\"SUBTRACT\"])]);\n\nquil.core.color_modes = new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\"rgb\",\"rgb\",(1432123467)),(Processing.prototype.PConstants[\"RGB\"]),new cljs.core.Keyword(null,\"hsb\",\"hsb\",(-753472031)),(Processing.prototype.PConstants[\"HSB\"])], null);\n\nquil.core.image_formats = new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\"rgb\",\"rgb\",(1432123467)),(Processing.prototype.PConstants[\"RGB\"]),new cljs.core.Keyword(null,\"argb\",\"argb\",(633844107)),(Processing.prototype.PConstants[\"ARGB\"]),new cljs.core.Keyword(null,\"alpha\",\"alpha\",(-1574982441)),(Processing.prototype.PConstants[\"ALPHA\"])], null);\n\nquil.core.ellipse_modes = new cljs.core.PersistentArrayMap(null, 4, [new cljs.core.Keyword(null,\"center\",\"center\",(-748944368)),(Processing.prototype.PConstants[\"CENTER\"]),new cljs.core.Keyword(null,\"radius\",\"radius\",(-2073122258)),(Processing.prototype.PConstants[\"RADIUS\"]),new cljs.core.Keyword(null,\"corner\",\"corner\",(1296717125)),(Processing.prototype.PConstants[\"CORNER\"]),new cljs.core.Keyword(null,\"corners\",\"corners\",(-137817903)),(Processing.prototype.PConstants[\"CORNERS\"])], null);\n\nquil.core.hint_options = cljs.core.PersistentHashMap.fromArrays([new cljs.core.Keyword(null,\"disable-stroke-perspective\",\"disable-stroke-perspective\",(479198433)),new cljs.core.Keyword(null,\"disable-depth-mask\",\"disable-depth-mask\",(3298562)),new cljs.core.Keyword(null,\"enable-depth-test\",\"enable-depth-test\",(1519326084)),new cljs.core.Keyword(null,\"enable-depth-sort\",\"enable-depth-sort\",(-383089627)),new cljs.core.Keyword(null,\"disable-texture-mipmaps\",\"disable-texture-mipmaps\",(1697917541)),new cljs.core.Keyword(null,\"disable-stroke-pure\",\"disable-stroke-pure\",(735493926)),new cljs.core.Keyword(null,\"disable-depth-test\",\"disable-depth-test\",(284606407)),new cljs.core.Keyword(null,\"enable-stroke-perspective\",\"enable-stroke-perspective\",(-259923319)),new cljs.core.Keyword(null,\"disable-optimized-stroke\",\"disable-optimized-stroke\",(74038544)),new cljs.core.Keyword(null,\"enable-opengl-errors\",\"enable-opengl-errors\",(89998962)),new cljs.core.Keyword(null,\"enable-stroke-pure\",\"enable-stroke-pure\",(881345587)),new cljs.core.Keyword(null,\"enable-depth-mask\",\"enable-depth-mask\",(872785875)),new cljs.core.Keyword(null,\"enable-optimized-stroke\",\"enable-optimized-stroke\",(1537575253)),new cljs.core.Keyword(null,\"disable-opengl-errors\",\"disable-opengl-errors\",(506822839)),new cljs.core.Keyword(null,\"disable-depth-sort\",\"disable-depth-sort\",(-1568352839)),new cljs.core.Keyword(null,\"enable-texture-mipmaps\",\"enable-texture-mipmaps\",(1241892671))],[(Processing.prototype.PConstants[\"DISABLE_STROKE_PERSPECTIVE\"]),(Processing.prototype.PConstants[\"DISABLE_DEPTH_MASK\"]),(Processing.prototype.PConstants[\"ENABLE_DEPTH_TEST\"]),(Processing.prototype.PConstants[\"ENABLE_DEPTH_SORT\"]),(Processing.prototype.PConstants[\"DISABLE_TEXTURE_MIPMAPS\"]),(Processing.prototype.PConstants[\"DISABLE_STROKE_PURE\"]),(Processing.prototype.PConstants[\"DISABLE_DEPTH_TEST\"]),(Processing.prototype.PConstants[\"ENABLE_STROKE_PERSPECTIVE\"]),(Processing.prototype.PConstants[\"DISABLE_OPTIMIZED_STROKE\"]),(Processing.prototype.PConstants[\"ENABLE_OPENGL_ERRORS\"]),(Processing.prototype.PConstants[\"ENABLE_STROKE_PURE\"]),(Processing.prototype.PConstants[\"ENABLE_DEPTH_MASK\"]),(Processing.prototype.PConstants[\"ENABLE_OPTIMIZED_STROKE\"]),(Processing.prototype.PConstants[\"DISABLE_OPENGL_ERRORS\"]),(Processing.prototype.PConstants[\"DISABLE_DEPTH_SORT\"]),(Processing.prototype.PConstants[\"ENABLE_TEXTURE_MIPMAPS\"])]);\n\nquil.core.image_modes = new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\"corner\",\"corner\",(1296717125)),(Processing.prototype.PConstants[\"CORNER\"]),new cljs.core.Keyword(null,\"corners\",\"corners\",(-137817903)),(Processing.prototype.PConstants[\"CORNERS\"]),new cljs.core.Keyword(null,\"center\",\"center\",(-748944368)),(Processing.prototype.PConstants[\"CENTER\"])], null);\n\nquil.core.rect_modes = new cljs.core.PersistentArrayMap(null, 4, [new cljs.core.Keyword(null,\"corner\",\"corner\",(1296717125)),(Processing.prototype.PConstants[\"CORNER\"]),new cljs.core.Keyword(null,\"corners\",\"corners\",(-137817903)),(Processing.prototype.PConstants[\"CORNERS\"]),new cljs.core.Keyword(null,\"center\",\"center\",(-748944368)),(Processing.prototype.PConstants[\"CENTER\"]),new cljs.core.Keyword(null,\"radius\",\"radius\",(-2073122258)),(Processing.prototype.PConstants[\"RADIUS\"])], null);\n\nquil.core.p_shape_modes = new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\"corner\",\"corner\",(1296717125)),(Processing.prototype.PConstants[\"CORNER\"]),new cljs.core.Keyword(null,\"corners\",\"corners\",(-137817903)),(Processing.prototype.PConstants[\"CORNERS\"]),new cljs.core.Keyword(null,\"center\",\"center\",(-748944368)),(Processing.prototype.PConstants[\"CENTER\"])], null);\n\nquil.core.stroke_cap_modes = new cljs.core.PersistentArrayMap(null, 4, [new cljs.core.Keyword(null,\"square\",\"square\",(812434677)),(Processing.prototype.PConstants[\"SQUARE\"]),new cljs.core.Keyword(null,\"round\",\"round\",(2009433328)),(Processing.prototype.PConstants[\"ROUND\"]),new cljs.core.Keyword(null,\"project\",\"project\",(1124394579)),(Processing.prototype.PConstants[\"PROJECT\"]),new cljs.core.Keyword(null,\"model\",\"model\",(331153215)),(Processing.prototype.PConstants[\"MODEL\"])], null);\n\nquil.core.stroke_join_modes = new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\"miter\",\"miter\",(327727052)),(Processing.prototype.PConstants[\"MITER\"]),new cljs.core.Keyword(null,\"bevel\",\"bevel\",(2090515654)),(Processing.prototype.PConstants[\"BEVEL\"]),new cljs.core.Keyword(null,\"round\",\"round\",(2009433328)),(Processing.prototype.PConstants[\"ROUND\"])], null);\n\nquil.core.horizontal_alignment_modes = new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\"left\",\"left\",(-399115937)),(Processing.prototype.PConstants[\"LEFT\"]),new cljs.core.Keyword(null,\"center\",\"center\",(-748944368)),(Processing.prototype.PConstants[\"CENTER\"]),new cljs.core.Keyword(null,\"right\",\"right\",(-452581833)),(Processing.prototype.PConstants[\"RIGHT\"])], null);\n\nquil.core.vertical_alignment_modes = new cljs.core.PersistentArrayMap(null, 4, [new cljs.core.Keyword(null,\"top\",\"top\",(-1856271961)),(Processing.prototype.PConstants[\"TOP\"]),new cljs.core.Keyword(null,\"bottom\",\"bottom\",(-1550509018)),(Processing.prototype.PConstants[\"BOTTOM\"]),new cljs.core.Keyword(null,\"center\",\"center\",(-748944368)),(Processing.prototype.PConstants[\"CENTER\"]),new cljs.core.Keyword(null,\"baseline\",\"baseline\",(1151033280)),(Processing.prototype.PConstants[\"BASELINE\"])], null);\n\nquil.core.text_modes = new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\"model\",\"model\",(331153215)),(Processing.prototype.PConstants[\"MODEL\"]),new cljs.core.Keyword(null,\"shape\",\"shape\",(1190694006)),(Processing.prototype.PConstants[\"SHAPE\"])], null);\n\nquil.core.texture_modes = new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\"image\",\"image\",(-58725096)),(Processing.prototype.PConstants[\"IMAGE\"]),new cljs.core.Keyword(null,\"normal\",\"normal\",(-1519123858)),(Processing.prototype.PConstants[\"NORMAL\"])], null);\n\nquil.core.texture_wrap_modes = new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\"clamp\",\"clamp\",(1803814940)),(Processing.prototype.PConstants[\"CLAMP\"]),new cljs.core.Keyword(null,\"repeat\",\"repeat\",(832692087)),(Processing.prototype.PConstants[\"REPEAT\"])], null);\n\nquil.core.filter_modes = new cljs.core.PersistentArrayMap(null, 8, [new cljs.core.Keyword(null,\"threshold\",\"threshold\",(204221583)),(Processing.prototype.PConstants[\"THRESHOLD\"]),new cljs.core.Keyword(null,\"gray\",\"gray\",(1013268388)),(Processing.prototype.PConstants[\"GRAY\"]),new cljs.core.Keyword(null,\"invert\",\"invert\",(1553577503)),(Processing.prototype.PConstants[\"INVERT\"]),new cljs.core.Keyword(null,\"posterize\",\"posterize\",(-148251901)),(Processing.prototype.PConstants[\"POSTERIZE\"]),new cljs.core.Keyword(null,\"blur\",\"blur\",(-453500461)),(Processing.prototype.PConstants[\"BLUR\"]),new cljs.core.Keyword(null,\"opaque\",\"opaque\",(-1243552654)),(Processing.prototype.PConstants[\"OPAQUE\"]),new cljs.core.Keyword(null,\"erode\",\"erode\",(1539530618)),(Processing.prototype.PConstants[\"ERODE\"]),new cljs.core.Keyword(null,\"dilate\",\"dilate\",(1504745153)),(Processing.prototype.PConstants[\"DILATE\"])], null);\n\nquil.core.cursor_modes = new cljs.core.PersistentArrayMap(null, 6, [new cljs.core.Keyword(null,\"arrow\",\"arrow\",(1071351425)),(Processing.prototype.PConstants[\"ARROW\"]),new cljs.core.Keyword(null,\"cross\",\"cross\",(194557789)),(Processing.prototype.PConstants[\"CROSS\"]),new cljs.core.Keyword(null,\"hand\",\"hand\",(791601933)),(Processing.prototype.PConstants[\"HAND\"]),new cljs.core.Keyword(null,\"move\",\"move\",(-2110884309)),(Processing.prototype.PConstants[\"MOVE\"]),new cljs.core.Keyword(null,\"text\",\"text\",(-1790561697)),(Processing.prototype.PConstants[\"TEXT\"]),new cljs.core.Keyword(null,\"wait\",\"wait\",(-260664777)),(Processing.prototype.PConstants[\"WAIT\"])], null);\nquil.core.PI = Math.PI;\nquil.core.HALF_PI = (quil.core.PI / (2));\nquil.core.THIRD_PI = (quil.core.PI / (3));\nquil.core.QUARTER_PI = (quil.core.PI / (4));\nquil.core.TWO_PI = (quil.core.PI * (2));\nquil.core.DEG_TO_RAD = (quil.core.PI / (180));\nquil.core.RAD_TO_DEG = ((180) / quil.core.PI);\nquil.core.KEY_CODES = cljs.core.PersistentHashMap.fromArrays([(37),(38),(39),(40),(16),(112),(17),(113),(18),(114),(115),(116),(117),(118),(119),(120),(121),(122),(123),(157)],[new cljs.core.Keyword(null,\"left\",\"left\",(-399115937)),new cljs.core.Keyword(null,\"up\",\"up\",(-269712113)),new cljs.core.Keyword(null,\"right\",\"right\",(-452581833)),new cljs.core.Keyword(null,\"down\",\"down\",(1565245570)),new cljs.core.Keyword(null,\"shift\",\"shift\",(997140064)),new cljs.core.Keyword(null,\"f1\",\"f1\",(1714532389)),new cljs.core.Keyword(null,\"control\",\"control\",(1892578036)),new cljs.core.Keyword(null,\"f2\",\"f2\",(396168596)),new cljs.core.Keyword(null,\"alt\",\"alt\",(-3214426)),new cljs.core.Keyword(null,\"f3\",\"f3\",(1954829043)),new cljs.core.Keyword(null,\"f4\",\"f4\",(990968764)),new cljs.core.Keyword(null,\"f5\",\"f5\",(1587057387)),new cljs.core.Keyword(null,\"f6\",\"f6\",(2103080604)),new cljs.core.Keyword(null,\"f7\",\"f7\",(356150168)),new cljs.core.Keyword(null,\"f8\",\"f8\",(-2141475484)),new cljs.core.Keyword(null,\"f9\",\"f9\",(704633338)),new cljs.core.Keyword(null,\"f10\",\"f10\",(627525541)),new cljs.core.Keyword(null,\"f11\",\"f11\",(-1417398799)),new cljs.core.Keyword(null,\"f12\",\"f12\",(853352790)),new cljs.core.Keyword(null,\"command\",\"command\",(-894540724))]);\n/**\n * Writes to the text area of the Processing environment's console.\n *   This is often helpful for looking at the data a program is producing.\n *   Each call to this function creates a new line of output.\n *   Individual elements can be separated with quotes (\"\") and joined with the string concatenation operator (+).\n *   Also writes the content of an array to the text area of the Processing environment.\n *   This is often helpful for looking at the data a program is producing.\n *   A new line is put between each element of the array. This function can only print 1D arrays,\n *   but can test to see if the content are null or not null for 2+ dimensional arrays.\n */\nquil.core.prc_println = (function quil$core$prc_println(msg){\nreturn quil.sketch.current_applet.call(null).println(msg);\n});\n/**\n * Writes to the console area of the Processing environment.\n *   This is often helpful for looking at the data a program is producing.\n *   The companion function println() works like print(), but creates a new line of text for each call to the function.\n * Individual elements can be separated with quotes (\"\") and joined with the addition operator (+). \n */\nquil.core.prc_print = (function quil$core$prc_print(msg){\nreturn quil.sketch.current_applet.call(null).print(msg);\n});\n/**\n * Returns sketch object by id of canvas element of sketch.\n */\nquil.core.get_sketch_by_id = (function quil$core$get_sketch_by_id(id){\nreturn Processing.getInstanceById(id);\n});\nquil.core.with_sketch = (function quil$core$with_sketch(var_args){\nvar args__13423__auto__ = [];\nvar len__13421__auto___432 = arguments.length;\nvar i__13422__auto___433 = (0);\nwhile(true){\nif((i__13422__auto___433 < len__13421__auto___432)){\nargs__13423__auto__.push((arguments[i__13422__auto___433]));\n\nvar G__434 = (i__13422__auto___433 + (1));\ni__13422__auto___433 = G__434;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__13424__auto__ = ((((3) < args__13423__auto__.length))?(new cljs.core.IndexedSeq(args__13423__auto__.slice((3)),(0),null)):null);\nreturn quil.core.with_sketch.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__13424__auto__);\n});\n\nquil.core.with_sketch.cljs$core$IFn$_invoke$arity$variadic = (function (_AMPERSAND_form,_AMPERSAND_env,applet,body){\nif(cljs.core.truth_(quil.util.clj_compilation_QMARK_.call(null))){\nreturn null;\n} else {\nreturn cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.sketch\",\"with-sketch\",\"quil.sketch/with-sketch\",(-634067708),null)),(function (){var x__13164__auto__ = applet;\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})(),body));\n}\n});\n\nquil.core.with_sketch.cljs$lang$maxFixedArity = (3);\n\nquil.core.with_sketch.cljs$lang$applyTo = (function (seq428){\nvar G__429 = cljs.core.first.call(null,seq428);\nvar seq428__$1 = cljs.core.next.call(null,seq428);\nvar G__430 = cljs.core.first.call(null,seq428__$1);\nvar seq428__$2 = cljs.core.next.call(null,seq428__$1);\nvar G__431 = cljs.core.first.call(null,seq428__$2);\nvar seq428__$3 = cljs.core.next.call(null,seq428__$2);\nreturn quil.core.with_sketch.cljs$core$IFn$_invoke$arity$variadic(G__429,G__430,G__431,seq428__$3);\n});\n\n\nquil.core.with_sketch.cljs$lang$macro = true;\n/**\n * Retrieve sketch-specific state-atom. All changes to the\n *   atom will be reflected in the state.\n * \n *   (set-state! :foo 1)\n *   (state :foo) ;=> 1\n *   (swap! (state-atom) update-in [:foo] inc)\n *   (state :foo) ;=> 2\n */\nquil.core.state_atom = (function quil$core$state_atom(){\nreturn quil.sketch.current_applet.call(null).quil;\n});\n/**\n * Retrieve sketch-specific state by key. Must initially call\n *   set-state! to store state. If no parameter passed whole\n *   state map is returned.\n * \n *   (set-state! :foo 1)\n *   (state :foo) ;=> 1\n *   (state) ;=> {:foo 1}\n */\nquil.core.state = (function quil$core$state(var_args){\nvar args435 = [];\nvar len__13421__auto___438 = arguments.length;\nvar i__13422__auto___439 = (0);\nwhile(true){\nif((i__13422__auto___439 < len__13421__auto___438)){\nargs435.push((arguments[i__13422__auto___439]));\n\nvar G__440 = (i__13422__auto___439 + (1));\ni__13422__auto___439 = G__440;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__437 = args435.length;\nswitch (G__437) {\ncase (0):\nreturn quil.core.state.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase (1):\nreturn quil.core.state.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args435.length)].join('')));\n\n}\n});\n\nquil.core.state.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn cljs.core.deref.call(null,quil.core.state_atom.call(null));\n});\n\nquil.core.state.cljs$core$IFn$_invoke$arity$1 = (function (key){\nvar state = quil.core.state.call(null);\nif(cljs.core.contains_QMARK_.call(null,state,key)){\n} else {\nthrow Error([cljs.core.str(\"Unable to find state with key: \"),cljs.core.str(key)].join(''));\n}\n\nreturn cljs.core.get.call(null,state,key);\n});\n\nquil.core.state.cljs$lang$maxFixedArity = (1);\n\n/**\n * Set sketch-specific state. May only be called once (ideally in the\n *   setup fn).  Subsequent calls have no effect.\n * \n *   Example:\n *   (set-state! :foo 1 :bar (atom true) :baz (/ (width) 2))\n */\nquil.core.set_state_BANG_ = (function quil$core$set_state_BANG_(var_args){\nvar args__13423__auto__ = [];\nvar len__13421__auto___443 = arguments.length;\nvar i__13422__auto___444 = (0);\nwhile(true){\nif((i__13422__auto___444 < len__13421__auto___443)){\nargs__13423__auto__.push((arguments[i__13422__auto___444]));\n\nvar G__445 = (i__13422__auto___444 + (1));\ni__13422__auto___444 = G__445;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__13424__auto__ = ((((0) < args__13423__auto__.length))?(new cljs.core.IndexedSeq(args__13423__auto__.slice((0)),(0),null)):null);\nreturn quil.core.set_state_BANG_.cljs$core$IFn$_invoke$arity$variadic(argseq__13424__auto__);\n});\n\nquil.core.set_state_BANG_.cljs$core$IFn$_invoke$arity$variadic = (function (state_vals){\nvar state_STAR_ = quil.core.state_atom.call(null);\nif(cljs.core.truth_(cljs.core.deref.call(null,state_STAR_))){\nreturn null;\n} else {\nvar state_map = cljs.core.apply.call(null,cljs.core.hash_map,state_vals);\nreturn cljs.core.reset_BANG_.call(null,state_STAR_,state_map);\n}\n});\n\nquil.core.set_state_BANG_.cljs$lang$maxFixedArity = (0);\n\nquil.core.set_state_BANG_.cljs$lang$applyTo = (function (seq442){\nreturn quil.core.set_state_BANG_.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq.call(null,seq442));\n});\n\n/**\n * Calculates the absolute value (magnitude) of a number. The\n *   absolute value of a number is always positive. Dynamically casts to\n *   an int or float appropriately\n */\nquil.core.abs = (function quil$core$abs(n){\nreturn quil.sketch.current_applet.call(null).abs(n);\n});\n/**\n * The inverse of cos, returns the arc cosine of a value. This\n *   function expects the values in the range of -1 to 1 and values are\n *   returned in the range 0 to Math/PI (3.1415927).\n */\nquil.core.acos = (function quil$core$acos(n){\nreturn quil.sketch.current_applet.call(null).acos(n);\n});\n/**\n * Extracts the alpha value from a color.\n */\nquil.core.alpha = (function quil$core$alpha(color){\nreturn quil.core.current_graphics.call(null).alpha(cljs.core.unchecked_int.call(null,color));\n});\n/**\n * Sets the ambient reflectance for shapes drawn to the screen. This\n *   is combined with the ambient light component of environment. The\n *   color components set through the parameters define the\n *   reflectance. For example in the default color mode, setting x=255,\n *   y=126, z=0, would cause all the red light to reflect and half of the\n *   green light to reflect. Used in combination with emissive, specular,\n *   and shininess in setting the material properties of shapes.\n */\nquil.core.ambient_float = (function quil$core$ambient_float(var_args){\nvar args446 = [];\nvar len__13421__auto___449 = arguments.length;\nvar i__13422__auto___450 = (0);\nwhile(true){\nif((i__13422__auto___450 < len__13421__auto___449)){\nargs446.push((arguments[i__13422__auto___450]));\n\nvar G__451 = (i__13422__auto___450 + (1));\ni__13422__auto___450 = G__451;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__448 = args446.length;\nswitch (G__448) {\ncase (1):\nreturn quil.core.ambient_float.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (3):\nreturn quil.core.ambient_float.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args446.length)].join('')));\n\n}\n});\n\nquil.core.ambient_float.cljs$core$IFn$_invoke$arity$1 = (function (gray){\nreturn quil.core.current_graphics.call(null).ambient(gray);\n});\n\nquil.core.ambient_float.cljs$core$IFn$_invoke$arity$3 = (function (x,y,z){\nreturn quil.core.current_graphics.call(null).ambient(x,y,z);\n});\n\nquil.core.ambient_float.cljs$lang$maxFixedArity = (3);\n\n/**\n * Sets the ambient reflectance for shapes drawn to the screen. This\n *   is combined with the ambient light component of environment. The rgb\n *   color components set define the reflectance. Used in combination\n *   with emissive, specular, and shininess in setting the material\n *   properties of shapes.\n */\nquil.core.ambient_int = (function quil$core$ambient_int(rgb){\nreturn quil.core.current_graphics.call(null).ambient((rgb | (0)));\n});\n/**\n * Sets the ambient reflectance for shapes drawn to the screen. This\n *   is combined with the ambient light component of environment. The\n *   color components set through the parameters define the\n *   reflectance. For example in the default color mode, setting x=255,\n *   y=126, z=0, would cause all the red light to reflect and half of the\n *   green light to reflect. Used in combination with emissive, specular,\n *   and shininess in setting the material properties of shapes.\n */\nquil.core.ambient = (function quil$core$ambient(var_args){\nvar args453 = [];\nvar len__13421__auto___456 = arguments.length;\nvar i__13422__auto___457 = (0);\nwhile(true){\nif((i__13422__auto___457 < len__13421__auto___456)){\nargs453.push((arguments[i__13422__auto___457]));\n\nvar G__458 = (i__13422__auto___457 + (1));\ni__13422__auto___457 = G__458;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__455 = args453.length;\nswitch (G__455) {\ncase (1):\nreturn quil.core.ambient.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (3):\nreturn quil.core.ambient.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args453.length)].join('')));\n\n}\n});\n\nquil.core.ambient.cljs$core$IFn$_invoke$arity$1 = (function (rgb){\nreturn quil.core.ambient_float.call(null,rgb);\n});\n\nquil.core.ambient.cljs$core$IFn$_invoke$arity$3 = (function (x,y,z){\nreturn quil.core.ambient_float.call(null,x,y,z);\n});\n\nquil.core.ambient.cljs$lang$maxFixedArity = (3);\n\n/**\n * Adds an ambient light. Ambient light doesn't come from a specific direction,\n *   the rays have light have bounced around so much that objects are\n *   evenly lit from all sides. Ambient lights are almost always used in\n *   combination with other types of lights. Lights need to be included\n *   in the draw to remain persistent in a looping program. Placing them\n *   in the setup of a looping program will cause them to only have an\n *   effect the first time through the loop. The effect of the\n *   parameters is determined by the current color mode.\n */\nquil.core.ambient_light = (function quil$core$ambient_light(var_args){\nvar args460 = [];\nvar len__13421__auto___463 = arguments.length;\nvar i__13422__auto___464 = (0);\nwhile(true){\nif((i__13422__auto___464 < len__13421__auto___463)){\nargs460.push((arguments[i__13422__auto___464]));\n\nvar G__465 = (i__13422__auto___464 + (1));\ni__13422__auto___464 = G__465;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__462 = args460.length;\nswitch (G__462) {\ncase (3):\nreturn quil.core.ambient_light.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (6):\nreturn quil.core.ambient_light.cljs$core$IFn$_invoke$arity$6((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args460.length)].join('')));\n\n}\n});\n\nquil.core.ambient_light.cljs$core$IFn$_invoke$arity$3 = (function (red,green,blue){\nreturn quil.core.current_graphics.call(null).ambientLight(red,green,blue);\n});\n\nquil.core.ambient_light.cljs$core$IFn$_invoke$arity$6 = (function (red,green,blue,x,y,z){\nreturn quil.core.current_graphics.call(null).ambientLight(red,green,blue,x,y,z);\n});\n\nquil.core.ambient_light.cljs$lang$maxFixedArity = (6);\n\n/**\n * Multiplies the current matrix by the one specified through the\n *   parameters. This is very slow because it will try to calculate the\n *   inverse of the transform, so avoid it whenever possible. The\n *   equivalent function in OpenGL is glMultMatrix().\n */\nquil.core.apply_matrix = (function quil$core$apply_matrix(n00,n01,n02,n03,n10,n11,n12,n13,n20,n21,n22,n23,n30,n31,n32,n33){\nreturn quil.core.current_graphics.call(null).applyMatrix(n00,n01,n02,n03,n10,n11,n12,n13,n20,n21,n22,n23,n30,n31,n32,n33);\n});\n/**\n * Draws an arc in the display window. Arcs are drawn along the outer\n *   edge of an ellipse defined by the x, y, width and height\n *   parameters. The origin or the arc's ellipse may be changed with the\n *   ellipse-mode function. The start and stop parameters specify the\n *   angles at which to draw the arc. The mode is either :open, :chord or :pie.\n */\nquil.core.arc = (function quil$core$arc(x,y,width,height,start,stop){\nreturn quil.core.current_graphics.call(null).arc(x,y,width,height,start,stop);\n});\n/**\n * The inverse of sin, returns the arc sine of a value. This function\n *   expects the values in the range of -1 to 1 and values are returned\n *   in the range -PI/2 to PI/2.\n */\nquil.core.asin = (function quil$core$asin(n){\nreturn quil.sketch.current_applet.call(null).asin(n);\n});\n/**\n * The inverse of tan, returns the arc tangent of a value. This\n *   function expects the values in the range of -Infinity to\n *   Infinity (exclusive) and values are returned in the range -PI/2 to\n *   PI/2 .\n */\nquil.core.atan = (function quil$core$atan(n){\nreturn quil.sketch.current_applet.call(null).atan(n);\n});\n/**\n * Calculates the angle (in radians) from a specified point to the\n *   coordinate origin as measured from the positive x-axis. Values are\n *   returned as a float in the range from PI to -PI. The atan2 function\n *   is most often used for orienting geometry to the position of the\n *   cursor. Note: The y-coordinate of the point is the first parameter\n *   and the x-coordinate is the second due to the structure of\n *   calculating the tangent.\n */\nquil.core.atan2 = (function quil$core$atan2(y,x){\nreturn quil.sketch.current_applet.call(null).atan2(y,x);\n});\n/**\n * A sequence of strings representing the fonts on this system\n *   available for use.\n * \n *   Because of limitations in Java, not all fonts can be used and some\n *   might work with one operating system and not others. When sharing a\n *   sketch with other people or posting it on the web, you may need to\n *   include a .ttf or .otf version of your font in the data directory of\n *   the sketch because other people might not have the font installed on\n *   their computer. Only fonts that can legally be distributed should be\n *   included with a sketch.\n */\nquil.core.available_fonts = (function quil$core$available_fonts(){\nreturn cljs.core.seq.call(null,PFont.list());\n});\n/**\n * Sets the color used for the background of the Processing\n *   window. The default background is light gray. In the draw function,\n *   the background color is used to clear the display window at the\n *   beginning of each frame.\n * \n *   It is not possible to use transparency (alpha) in background colors\n *   with the main drawing surface, however they will work properly with\n *   create-graphics. Converts args to floats.\n */\nquil.core.background_float = (function quil$core$background_float(var_args){\nvar args467 = [];\nvar len__13421__auto___470 = arguments.length;\nvar i__13422__auto___471 = (0);\nwhile(true){\nif((i__13422__auto___471 < len__13421__auto___470)){\nargs467.push((arguments[i__13422__auto___471]));\n\nvar G__472 = (i__13422__auto___471 + (1));\ni__13422__auto___471 = G__472;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__469 = args467.length;\nswitch (G__469) {\ncase (1):\nreturn quil.core.background_float.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core.background_float.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core.background_float.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core.background_float.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args467.length)].join('')));\n\n}\n});\n\nquil.core.background_float.cljs$core$IFn$_invoke$arity$1 = (function (gray){\nreturn quil.core.current_graphics.call(null).background(gray);\n});\n\nquil.core.background_float.cljs$core$IFn$_invoke$arity$2 = (function (gray,alpha){\nreturn quil.core.current_graphics.call(null).background(gray,alpha);\n});\n\nquil.core.background_float.cljs$core$IFn$_invoke$arity$3 = (function (r,g,b){\nreturn quil.core.current_graphics.call(null).background(r,g,b);\n});\n\nquil.core.background_float.cljs$core$IFn$_invoke$arity$4 = (function (r,g,b,a){\nreturn quil.core.current_graphics.call(null).background(r,g,b,a);\n});\n\nquil.core.background_float.cljs$lang$maxFixedArity = (4);\n\n/**\n * Sets the color used for the background of the Processing\n *   window. The default background is light gray. In the draw function,\n *   the background color is used to clear the display window at the\n *   beginning of each frame.\n * \n *   It is not possible to use transparency (alpha) in background colors\n *   with the main drawing surface, however they will work properly with\n *   create-graphics. Converts rgb to an int and alpha to a float.\n */\nquil.core.background_int = (function quil$core$background_int(var_args){\nvar args474 = [];\nvar len__13421__auto___477 = arguments.length;\nvar i__13422__auto___478 = (0);\nwhile(true){\nif((i__13422__auto___478 < len__13421__auto___477)){\nargs474.push((arguments[i__13422__auto___478]));\n\nvar G__479 = (i__13422__auto___478 + (1));\ni__13422__auto___478 = G__479;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__476 = args474.length;\nswitch (G__476) {\ncase (1):\nreturn quil.core.background_int.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core.background_int.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args474.length)].join('')));\n\n}\n});\n\nquil.core.background_int.cljs$core$IFn$_invoke$arity$1 = (function (rgb){\nreturn quil.core.current_graphics.call(null).background(cljs.core.unchecked_int.call(null,rgb));\n});\n\nquil.core.background_int.cljs$core$IFn$_invoke$arity$2 = (function (rgb,alpha){\nreturn quil.core.current_graphics.call(null).background(cljs.core.unchecked_int.call(null,rgb),alpha);\n});\n\nquil.core.background_int.cljs$lang$maxFixedArity = (2);\n\n/**\n * Sets the color used for the background of the Processing\n *   window. The default background is light gray. In the draw function,\n *   the background color is used to clear the display window at the\n *   beginning of each frame.\n * \n *   It is not possible to use transparency (alpha) in background colors\n *   with the main drawing surface, however they will work properly with\n *   create-graphics. Converts args to floats.\n */\nquil.core.background = (function quil$core$background(var_args){\nvar args481 = [];\nvar len__13421__auto___484 = arguments.length;\nvar i__13422__auto___485 = (0);\nwhile(true){\nif((i__13422__auto___485 < len__13421__auto___484)){\nargs481.push((arguments[i__13422__auto___485]));\n\nvar G__486 = (i__13422__auto___485 + (1));\ni__13422__auto___485 = G__486;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__483 = args481.length;\nswitch (G__483) {\ncase (1):\nreturn quil.core.background.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core.background.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core.background.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core.background.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args481.length)].join('')));\n\n}\n});\n\nquil.core.background.cljs$core$IFn$_invoke$arity$1 = (function (rgb){\nreturn quil.core.current_graphics.call(null).background(rgb);\n});\n\nquil.core.background.cljs$core$IFn$_invoke$arity$2 = (function (rgb,alpha){\nreturn quil.core.current_graphics.call(null).background(rgb,alpha);\n});\n\nquil.core.background.cljs$core$IFn$_invoke$arity$3 = (function (r,g,b){\nreturn quil.core.background_float.call(null,r,g,b);\n});\n\nquil.core.background.cljs$core$IFn$_invoke$arity$4 = (function (r,g,b,a){\nreturn quil.core.background_float.call(null,r,g,b,a);\n});\n\nquil.core.background.cljs$lang$maxFixedArity = (4);\n\n/**\n * Specify an image to be used as the background for a sketch. Its\n *   width and height must be the same size as the sketch window. Images\n *   used as background will ignore the current tint setting.\n */\nquil.core.background_image = (function quil$core$background_image(img){\nreturn quil.core.current_graphics.call(null).background(img);\n});\n/**\n * Sets the matrix mode to the camera matrix so calls such as\n *   translate, rotate, apply-matrix and reset-matrix affect the\n *   camera. begin-camera should always be used with a following\n *   end-camera and pairs of begin-camera and end-camera cannot be\n *   nested.\n * \n *   For most situations the camera function will be sufficient.\n */\nquil.core.begin_camera = (function quil$core$begin_camera(){\nreturn quil.core.current_graphics.call(null).beginCamera();\n});\n/**\n * Use the begin-contour and end-contour function to create negative\n *   shapes within shapes. These functions can only be within a\n *   begin-shape/end-shape pair and they only work with the :p2d and :p3d\n *   renderers.\n */\nquil.core.begin_contour = (function quil$core$begin_contour(){\nreturn quil.core.current_graphics.call(null).beginContour();\n});\n/**\n * Enables the creation of complex forms. begin-shape begins recording\n *   vertices for a shape and end-shape stops recording. Use the mode\n *   keyword to specify which shape create from the provided\n *   vertices. With no mode specified, the shape can be any irregular\n *   polygon.\n * \n *   The available mode keywords are :points, :lines, :triangles,\n *                                :triangle-fan, :triangle-strip,\n *                                :quads, :quad-strip.\n * \n *   After calling the begin-shape function, a series of vertex commands\n *   must follow. To stop drawing the shape, call end-shape. The vertex\n *   function with two parameters specifies a position in 2D and the\n *   vertex function with three parameters specifies a position in\n *   3D. Each shape will be outlined with the current stroke color and\n *   filled with the fill color.\n * \n *   Transformations such as translate, rotate, and scale do not work\n *   within begin-shape. It is also not possible to use other shapes,\n *   such as ellipse or rect within begin-shape.\n */\nquil.core.begin_shape = (function quil$core$begin_shape(var_args){\nvar args488 = [];\nvar len__13421__auto___491 = arguments.length;\nvar i__13422__auto___492 = (0);\nwhile(true){\nif((i__13422__auto___492 < len__13421__auto___491)){\nargs488.push((arguments[i__13422__auto___492]));\n\nvar G__493 = (i__13422__auto___492 + (1));\ni__13422__auto___492 = G__493;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__490 = args488.length;\nswitch (G__490) {\ncase (0):\nreturn quil.core.begin_shape.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase (1):\nreturn quil.core.begin_shape.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args488.length)].join('')));\n\n}\n});\n\nquil.core.begin_shape.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn quil.core.current_graphics.call(null).beginShape();\n});\n\nquil.core.begin_shape.cljs$core$IFn$_invoke$arity$1 = (function (mode){\nvar mode__$1 = quil.util.resolve_constant_key.call(null,mode,quil.core.shape_modes);\nreturn quil.core.current_graphics.call(null).beginShape((mode__$1 | (0)));\n});\n\nquil.core.begin_shape.cljs$lang$maxFixedArity = (1);\n\n/**\n * Draws a Bezier curve on the screen. These curves are defined by a\n *   series of anchor and control points. The first two parameters\n *   specify the first anchor point and the last two parameters specify\n *   the other anchor point. The middle parameters specify the control\n *   points which define the shape of the curve.\n */\nquil.core.bezier = (function quil$core$bezier(var_args){\nvar args495 = [];\nvar len__13421__auto___498 = arguments.length;\nvar i__13422__auto___499 = (0);\nwhile(true){\nif((i__13422__auto___499 < len__13421__auto___498)){\nargs495.push((arguments[i__13422__auto___499]));\n\nvar G__500 = (i__13422__auto___499 + (1));\ni__13422__auto___499 = G__500;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__497 = args495.length;\nswitch (G__497) {\ncase (8):\nreturn quil.core.bezier.cljs$core$IFn$_invoke$arity$8((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]));\n\nbreak;\ncase (12):\nreturn quil.core.bezier.cljs$core$IFn$_invoke$arity$12((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]),(arguments[(8)]),(arguments[(9)]),(arguments[(10)]),(arguments[(11)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args495.length)].join('')));\n\n}\n});\n\nquil.core.bezier.cljs$core$IFn$_invoke$arity$8 = (function (x1,y1,cx1,cy1,cx2,cy2,x2,y2){\nreturn quil.core.current_graphics.call(null).bezier(x1,y1,cx1,cy1,cx2,cy2,x2,y2);\n});\n\nquil.core.bezier.cljs$core$IFn$_invoke$arity$12 = (function (x1,y1,z1,cx1,cy1,cz1,cx2,cy2,cz2,x2,y2,z2){\nreturn quil.core.current_graphics.call(null).bezier(x1,y1,z1,cx1,cy1,cz1,cx2,cy2,cz2,x2,y2,z2);\n});\n\nquil.core.bezier.cljs$lang$maxFixedArity = (12);\n\n/**\n * Sets the resolution at which Beziers display. The default value is\n *   20. This function is only useful when using the :p3d or :opengl\n *   renderer as the default (:java2d) renderer does not use this\n *   information.\n */\nquil.core.bezier_detail = (function quil$core$bezier_detail(detail){\nreturn quil.core.current_graphics.call(null).bezierDetail((detail | (0)));\n});\n/**\n * Evaluates the Bezier at point t for points a, b, c, d. The\n *   parameter t varies between 0 and 1, a and d are points on the curve,\n *   and b and c are the control points. This can be done once with the x\n *   coordinates and a second time with the y coordinates to get the\n *   location of a bezier curve at t.\n */\nquil.core.bezier_point = (function quil$core$bezier_point(a,b,c,d,t){\nreturn quil.core.current_graphics.call(null).bezierPoint(a,b,c,d,t);\n});\n/**\n * Calculates the tangent of a point on a Bezier curve.\n *   (See http://en.wikipedia.org/wiki/Tangent)\n */\nquil.core.bezier_tangent = (function quil$core$bezier_tangent(a,b,c,d,t){\nreturn quil.core.current_graphics.call(null).bezierTangent(a,b,c,d,t);\n});\n/**\n * Specifies vertex coordinates for Bezier curves. Each call to\n *   bezier-vertex defines the position of two control points and one\n *   anchor point of a Bezier curve, adding a new segment to a line or\n *   shape. The first time bezier-vertex is used within a begin-shape\n *   call, it must be prefaced with a call to vertex to set the first\n *   anchor point. This function must be used between begin-shape and\n *   end-shape and only when there is no parameter specified to\n *   begin-shape.\n */\nquil.core.bezier_vertex = (function quil$core$bezier_vertex(var_args){\nvar args502 = [];\nvar len__13421__auto___505 = arguments.length;\nvar i__13422__auto___506 = (0);\nwhile(true){\nif((i__13422__auto___506 < len__13421__auto___505)){\nargs502.push((arguments[i__13422__auto___506]));\n\nvar G__507 = (i__13422__auto___506 + (1));\ni__13422__auto___506 = G__507;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__504 = args502.length;\nswitch (G__504) {\ncase (6):\nreturn quil.core.bezier_vertex.cljs$core$IFn$_invoke$arity$6((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]));\n\nbreak;\ncase (9):\nreturn quil.core.bezier_vertex.cljs$core$IFn$_invoke$arity$9((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]),(arguments[(8)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args502.length)].join('')));\n\n}\n});\n\nquil.core.bezier_vertex.cljs$core$IFn$_invoke$arity$6 = (function (cx1,cy1,cx2,cy2,x,y){\nreturn quil.core.current_graphics.call(null).bezierVertex(cx1,cy1,cx2,cy2,x,y);\n});\n\nquil.core.bezier_vertex.cljs$core$IFn$_invoke$arity$9 = (function (cx1,cy1,cz1,cx2,cy2,cz2,x,y,z){\nreturn quil.core.current_graphics.call(null).bezierVertex(cx1,cy1,cz1,cx2,cy2,cz2,x,y,z);\n});\n\nquil.core.bezier_vertex.cljs$lang$maxFixedArity = (9);\n\n/**\n * Returns a string representing the binary value of an int, char or\n *   byte. When converting an int to a string, it is possible to specify\n *   the number of digits used.\n */\nquil.core.binary = (function quil$core$binary(var_args){\nvar args509 = [];\nvar len__13421__auto___512 = arguments.length;\nvar i__13422__auto___513 = (0);\nwhile(true){\nif((i__13422__auto___513 < len__13421__auto___512)){\nargs509.push((arguments[i__13422__auto___513]));\n\nvar G__514 = (i__13422__auto___513 + (1));\ni__13422__auto___513 = G__514;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__511 = args509.length;\nswitch (G__511) {\ncase (1):\nreturn quil.core.binary.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core.binary.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args509.length)].join('')));\n\n}\n});\n\nquil.core.binary.cljs$core$IFn$_invoke$arity$1 = (function (val){\nreturn quil.sketch.current_applet.call(null).binary(val);\n});\n\nquil.core.binary.cljs$core$IFn$_invoke$arity$2 = (function (val,num_digits){\nreturn quil.sketch.current_applet.call(null).binary(val,num_digits);\n});\n\nquil.core.binary.cljs$lang$maxFixedArity = (2);\n\n/**\n * Blends a region of pixels from one image into another with full alpha\n *   channel support. If src is not specified it defaults to current-graphics.\n *   If dest is not specified it defaults to current-graphics.\n * \n *   Note: blend-mode function is recommended to use instead of this one.\n * \n *   Available blend modes are:\n * \n *   :blend      - linear interpolation of colours: C = A*factor + B\n *   :add        - additive blending with white clip:\n *                                          C = min(A*factor + B, 255)\n *   :subtract   - subtractive blending with black clip:\n *                                          C = max(B - A*factor, 0)\n *   :darkest    - only the darkest colour succeeds:\n *                                          C = min(A*factor, B)\n *   :lightest   - only the lightest colour succeeds:\n *                                          C = max(A*factor, B)\n *   :difference - subtract colors from underlying image.\n *   :exclusion  - similar to :difference, but less extreme.\n *   :multiply   - Multiply the colors, result will always be darker.\n *   :screen     - Opposite multiply, uses inverse values of the colors.\n *   :overlay    - A mix of :multiply and :screen. Multiplies dark values\n *              and screens light values.\n *   :hard-light - :screen when greater than 50% gray, :multiply when\n *              lower.\n *   :soft-light - Mix of :darkest and :lightest. Works like :overlay,\n *              but not as harsh.\n *   :dodge      - Lightens light tones and increases contrast, ignores\n *              darks.\n *              Called \"Color Dodge\" in Illustrator and Photoshop.\n *   :burn       - Darker areas are applied, increasing contrast, ignores\n *              lights. Called \"Color Burn\" in Illustrator and\n *              Photoshop.\n */\nquil.core.blend = (function quil$core$blend(var_args){\nvar args516 = [];\nvar len__13421__auto___519 = arguments.length;\nvar i__13422__auto___520 = (0);\nwhile(true){\nif((i__13422__auto___520 < len__13421__auto___519)){\nargs516.push((arguments[i__13422__auto___520]));\n\nvar G__521 = (i__13422__auto___520 + (1));\ni__13422__auto___520 = G__521;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__518 = args516.length;\nswitch (G__518) {\ncase (9):\nreturn quil.core.blend.cljs$core$IFn$_invoke$arity$9((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]),(arguments[(8)]));\n\nbreak;\ncase (10):\nreturn quil.core.blend.cljs$core$IFn$_invoke$arity$10((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]),(arguments[(8)]),(arguments[(9)]));\n\nbreak;\ncase (11):\nreturn quil.core.blend.cljs$core$IFn$_invoke$arity$11((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]),(arguments[(8)]),(arguments[(9)]),(arguments[(10)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args516.length)].join('')));\n\n}\n});\n\nquil.core.blend.cljs$core$IFn$_invoke$arity$9 = (function (x,y,width,height,dx,dy,dwidth,dheight,mode){\nreturn quil.core.blend.call(null,quil.core.current_graphics.call(null),quil.core.current_graphics.call(null),x,y,width,height,dx,dy,dwidth,dheight,mode);\n});\n\nquil.core.blend.cljs$core$IFn$_invoke$arity$10 = (function (src_img,x,y,width,height,dx,dy,dwidth,dheight,mode){\nreturn quil.core.blend.call(null,src_img,quil.core.current_graphics.call(null),x,y,width,height,dx,dy,dwidth,dheight,mode);\n});\n\nquil.core.blend.cljs$core$IFn$_invoke$arity$11 = (function (src_img,dest_img,x,y,width,height,dx,dy,dwidth,dheight,mode){\nvar mode__$1 = quil.util.resolve_constant_key.call(null,mode,quil.core.blend_modes);\nreturn dest_img.blend(src_img,(x | (0)),(y | (0)),(width | (0)),(height | (0)),(dx | (0)),(dy | (0)),(dwidth | (0)),(dheight | (0)),(mode__$1 | (0)));\n});\n\nquil.core.blend.cljs$lang$maxFixedArity = (11);\n\n/**\n * Blends two color values together based on the blending mode given specified\n *   with the mode keyword.\n * \n *   Available blend modes are:\n * \n *   :blend      - linear interpolation of colours: C = A*factor + B\n *   :add        - additive blending with white clip:\n *                                          C = min(A*factor + B, 255)\n *   :subtract   - subtractive blending with black clip:\n *                                          C = max(B - A*factor, 0)\n *   :darkest    - only the darkest colour succeeds:\n *                                          C = min(A*factor, B)\n *   :lightest   - only the lightest colour succeeds:\n *                                          C = max(A*factor, B)\n *   :difference - subtract colors from underlying image.\n *   :exclusion  - similar to :difference, but less extreme.\n *   :multiply   - Multiply the colors, result will always be darker.\n *   :screen     - Opposite multiply, uses inverse values of the colors.\n *   :overlay    - A mix of :multiply and :screen. Multiplies dark values\n *              and screens light values.\n *   :hard-light - :screen when greater than 50% gray, :multiply when\n *              lower.\n *   :soft-light - Mix of :darkest and :lightest. Works like :overlay,\n *              but not as harsh.\n *   :dodge      - Lightens light tones and increases contrast, ignores\n *              darks.\n *              Called \"Color Dodge\" in Illustrator and Photoshop.\n *   :burn       - Darker areas are applied, increasing contrast, ignores\n *              lights. Called \"Color Burn\" in Illustrator and\n *              Photoshop.\n */\nquil.core.blend_color = (function quil$core$blend_color(c1,c2,mode){\nvar mode__$1 = quil.util.resolve_constant_key.call(null,mode,quil.core.blend_modes);\nreturn quil.core.current_graphics.call(null).blendColor(c1,c2,mode__$1);\n});\n/**\n * Extracts the blue value from a color, scaled to match current color-mode.\n *   Returns a float.\n */\nquil.core.blue = (function quil$core$blue(color){\nreturn quil.core.current_graphics.call(null).blue(cljs.core.unchecked_int.call(null,color));\n});\n/**\n * Creates an extruded rectangle.\n */\nquil.core.box = (function quil$core$box(var_args){\nvar args523 = [];\nvar len__13421__auto___526 = arguments.length;\nvar i__13422__auto___527 = (0);\nwhile(true){\nif((i__13422__auto___527 < len__13421__auto___526)){\nargs523.push((arguments[i__13422__auto___527]));\n\nvar G__528 = (i__13422__auto___527 + (1));\ni__13422__auto___527 = G__528;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__525 = args523.length;\nswitch (G__525) {\ncase (1):\nreturn quil.core.box.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (3):\nreturn quil.core.box.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args523.length)].join('')));\n\n}\n});\n\nquil.core.box.cljs$core$IFn$_invoke$arity$1 = (function (size){\nreturn quil.core.current_graphics.call(null).box(size);\n});\n\nquil.core.box.cljs$core$IFn$_invoke$arity$3 = (function (width,height,depth){\nreturn quil.core.current_graphics.call(null).box(width,height,depth);\n});\n\nquil.core.box.cljs$lang$maxFixedArity = (3);\n\n/**\n * Extracts the brightness value from a color. Returns a float.\n */\nquil.core.brightness = (function quil$core$brightness(color){\nreturn quil.core.current_graphics.call(null).brightness(cljs.core.unchecked_int.call(null,color));\n});\n/**\n * Sets the position of the camera through setting the eye position,\n *   the center of the scene, and which axis is facing upward. Moving the\n *   eye position and the direction it is pointing (the center of the\n *   scene) allows the images to be seen from different angles. The\n *   version without any parameters sets the camera to the default\n *   position, pointing to the center of the display window with the Y\n *   axis as up. The default values are:\n * \n *   eyeX:     (/ (width) 2.0)\n *   eyeY:     (/ (height) 2.0)\n *   eyeZ:     (/ (/ (height) 2.0) (tan (/ (* Math/PI 60.0) 360.0)))\n *   centerX:  (/ (width) 2.0)\n *   centerY:  (/ (height) 2.0)\n *   centerZ:  0\n *   upX:      0\n *   upY:      1\n *   upZ:      0\n * \n *   Similar imilar to gluLookAt() in OpenGL, but it first clears the\n *   current camera settings.\n */\nquil.core.camera = (function quil$core$camera(var_args){\nvar args530 = [];\nvar len__13421__auto___533 = arguments.length;\nvar i__13422__auto___534 = (0);\nwhile(true){\nif((i__13422__auto___534 < len__13421__auto___533)){\nargs530.push((arguments[i__13422__auto___534]));\n\nvar G__535 = (i__13422__auto___534 + (1));\ni__13422__auto___534 = G__535;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__532 = args530.length;\nswitch (G__532) {\ncase (0):\nreturn quil.core.camera.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase (9):\nreturn quil.core.camera.cljs$core$IFn$_invoke$arity$9((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]),(arguments[(8)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args530.length)].join('')));\n\n}\n});\n\nquil.core.camera.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn quil.core.current_graphics.call(null).camera();\n});\n\nquil.core.camera.cljs$core$IFn$_invoke$arity$9 = (function (eyeX,eyeY,eyeZ,centerX,centerY,centerZ,upX,upY,upZ){\nreturn quil.core.current_graphics.call(null).camera(eyeX,eyeY,eyeZ,centerX,centerY,centerZ,upX,upY,upZ);\n});\n\nquil.core.camera.cljs$lang$maxFixedArity = (9);\n\n/**\n * Calculates the closest int value that is greater than or equal to\n *   the value of the parameter. For example, (ceil 9.03) returns the\n *   value 10.\n */\nquil.core.ceil = (function quil$core$ceil(n){\nreturn quil.sketch.current_applet.call(null).ceil(n);\n});\n/**\n * Creates an integer representation of a color The parameters are\n *   interpreted as RGB or HSB values depending on the current\n *   color-mode. The default mode is RGB values from 0 to 255 and\n *   therefore, the function call (color 255 204 0) will return a bright\n *   yellow. Args are cast to floats.\n * \n *   r - red or hue value\n *   g - green or saturation value\n *   b - blue or brightness value\n *   a - alpha value\n */\nquil.core.color = (function quil$core$color(var_args){\nvar args537 = [];\nvar len__13421__auto___540 = arguments.length;\nvar i__13422__auto___541 = (0);\nwhile(true){\nif((i__13422__auto___541 < len__13421__auto___540)){\nargs537.push((arguments[i__13422__auto___541]));\n\nvar G__542 = (i__13422__auto___541 + (1));\ni__13422__auto___541 = G__542;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__539 = args537.length;\nswitch (G__539) {\ncase (1):\nreturn quil.core.color.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core.color.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core.color.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core.color.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args537.length)].join('')));\n\n}\n});\n\nquil.core.color.cljs$core$IFn$_invoke$arity$1 = (function (gray){\nreturn quil.core.current_graphics.call(null).color(gray);\n});\n\nquil.core.color.cljs$core$IFn$_invoke$arity$2 = (function (gray,alpha){\nreturn quil.core.current_graphics.call(null).color(gray,alpha);\n});\n\nquil.core.color.cljs$core$IFn$_invoke$arity$3 = (function (r,g,b){\nreturn quil.core.current_graphics.call(null).color(r,g,b);\n});\n\nquil.core.color.cljs$core$IFn$_invoke$arity$4 = (function (r,g,b,a){\nreturn quil.core.current_graphics.call(null).color(r,g,b,a);\n});\n\nquil.core.color.cljs$lang$maxFixedArity = (4);\n\n/**\n * Changes the way Processing interprets color data. Available modes\n *   are :rgb and :hsb.By default, the parameters for fill, stroke,\n *   background, and color are defined by values between 0 and 255 using\n *   the :rgb color model. The color-mode fn is used to change the\n *   numerical range used for specifying colors and to switch color\n *   systems. For example, calling\n *   (color-mode :rgb 1.0) will specify that values are specified between\n *   0 and 1. The limits for defining colors are altered by setting the\n *   parameters range1, range2, range3, and range 4.\n */\nquil.core.color_mode = (function quil$core$color_mode(var_args){\nvar args544 = [];\nvar len__13421__auto___547 = arguments.length;\nvar i__13422__auto___548 = (0);\nwhile(true){\nif((i__13422__auto___548 < len__13421__auto___547)){\nargs544.push((arguments[i__13422__auto___548]));\n\nvar G__549 = (i__13422__auto___548 + (1));\ni__13422__auto___548 = G__549;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__546 = args544.length;\nswitch (G__546) {\ncase (1):\nreturn quil.core.color_mode.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core.color_mode.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (4):\nreturn quil.core.color_mode.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase (5):\nreturn quil.core.color_mode.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args544.length)].join('')));\n\n}\n});\n\nquil.core.color_mode.cljs$core$IFn$_invoke$arity$1 = (function (mode){\nvar mode__$1 = quil.util.resolve_constant_key.call(null,mode,quil.core.color_modes);\nreturn quil.core.current_graphics.call(null).colorMode((mode__$1 | (0)));\n});\n\nquil.core.color_mode.cljs$core$IFn$_invoke$arity$2 = (function (mode,max){\nvar mode__$1 = quil.util.resolve_constant_key.call(null,mode,quil.core.color_modes);\nreturn quil.core.current_graphics.call(null).colorMode((mode__$1 | (0)),max);\n});\n\nquil.core.color_mode.cljs$core$IFn$_invoke$arity$4 = (function (mode,max_x,max_y,max_z){\nvar mode__$1 = quil.util.resolve_constant_key.call(null,mode,quil.core.color_modes);\nreturn quil.core.current_graphics.call(null).colorMode((mode__$1 | (0)),max_x,max_y,max_z);\n});\n\nquil.core.color_mode.cljs$core$IFn$_invoke$arity$5 = (function (mode,max_x,max_y,max_z,max_a){\nvar mode__$1 = quil.util.resolve_constant_key.call(null,mode,quil.core.color_modes);\nreturn quil.core.current_graphics.call(null).colorMode((mode__$1 | (0)),max_x,max_y,max_z,max_a);\n});\n\nquil.core.color_mode.cljs$lang$maxFixedArity = (5);\n\n/**\n * Constrains a value to not exceed a maximum and minimum value.\n */\nquil.core.constrain = (function quil$core$constrain(amt,low,high){\nreturn quil.sketch.current_applet.call(null).constrain(amt,low,high);\n});\n/**\n * Copies a region of pixels from the one image to another. If src-img\n *   is not specified it defaults to current-graphics. If dest-img is not\n *   specified - it defaults to current-graphics. If the source\n *   and destination regions aren't the same size, it will automatically\n *   resize the source pixels to fit the specified target region. No\n *   alpha information is used in the process, however if the source\n *   image has an alpha channel set, it will be copied as well. \n */\nquil.core.copy = (function quil$core$copy(var_args){\nvar args551 = [];\nvar len__13421__auto___578 = arguments.length;\nvar i__13422__auto___579 = (0);\nwhile(true){\nif((i__13422__auto___579 < len__13421__auto___578)){\nargs551.push((arguments[i__13422__auto___579]));\n\nvar G__580 = (i__13422__auto___579 + (1));\ni__13422__auto___579 = G__580;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__553 = args551.length;\nswitch (G__553) {\ncase (2):\nreturn quil.core.copy.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core.copy.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core.copy.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args551.length)].join('')));\n\n}\n});\n\nquil.core.copy.cljs$core$IFn$_invoke$arity$2 = (function (p__554,p__555){\nvar vec__556 = p__554;\nvar sx = cljs.core.nth.call(null,vec__556,(0),null);\nvar sy = cljs.core.nth.call(null,vec__556,(1),null);\nvar swidth = cljs.core.nth.call(null,vec__556,(2),null);\nvar sheight = cljs.core.nth.call(null,vec__556,(3),null);\nvar vec__559 = p__555;\nvar dx = cljs.core.nth.call(null,vec__559,(0),null);\nvar dy = cljs.core.nth.call(null,vec__559,(1),null);\nvar dwidth = cljs.core.nth.call(null,vec__559,(2),null);\nvar dheight = cljs.core.nth.call(null,vec__559,(3),null);\nreturn quil.core.current_graphics.call(null).copy((sx | (0)),(sy | (0)),(swidth | (0)),(sheight | (0)),(dx | (0)),(dy | (0)),(dwidth | (0)),(dheight | (0)));\n});\n\nquil.core.copy.cljs$core$IFn$_invoke$arity$3 = (function (src_img,p__562,p__563){\nvar vec__564 = p__562;\nvar sx = cljs.core.nth.call(null,vec__564,(0),null);\nvar sy = cljs.core.nth.call(null,vec__564,(1),null);\nvar swidth = cljs.core.nth.call(null,vec__564,(2),null);\nvar sheight = cljs.core.nth.call(null,vec__564,(3),null);\nvar vec__567 = p__563;\nvar dx = cljs.core.nth.call(null,vec__567,(0),null);\nvar dy = cljs.core.nth.call(null,vec__567,(1),null);\nvar dwidth = cljs.core.nth.call(null,vec__567,(2),null);\nvar dheight = cljs.core.nth.call(null,vec__567,(3),null);\nreturn quil.core.copy.call(null,src_img,quil.core.current_graphics.call(null),new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [sx,sy,swidth,sheight], null),new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [dx,dy,dwidth,dheight], null));\n});\n\nquil.core.copy.cljs$core$IFn$_invoke$arity$4 = (function (src_img,dest_img,p__570,p__571){\nvar vec__572 = p__570;\nvar sx = cljs.core.nth.call(null,vec__572,(0),null);\nvar sy = cljs.core.nth.call(null,vec__572,(1),null);\nvar swidth = cljs.core.nth.call(null,vec__572,(2),null);\nvar sheight = cljs.core.nth.call(null,vec__572,(3),null);\nvar vec__575 = p__571;\nvar dx = cljs.core.nth.call(null,vec__575,(0),null);\nvar dy = cljs.core.nth.call(null,vec__575,(1),null);\nvar dwidth = cljs.core.nth.call(null,vec__575,(2),null);\nvar dheight = cljs.core.nth.call(null,vec__575,(3),null);\nreturn dest_img.copy(src_img,(sx | (0)),(sy | (0)),(swidth | (0)),(sheight | (0)),(dx | (0)),(dy | (0)),(dwidth | (0)),(dheight | (0)));\n});\n\nquil.core.copy.cljs$lang$maxFixedArity = (4);\n\n/**\n * Calculates the cosine of an angle. This function expects the values\n *   of the angle parameter to be provided in radians (values from 0 to\n *   Math/PI*2). Values are returned in the range -1 to 1.\n */\nquil.core.cos = (function quil$core$cos(angle){\nreturn quil.sketch.current_applet.call(null).cos(angle);\n});\n/**\n * Dynamically converts a font to the format used by Processing (a\n *   PFont) from either a font name that's installed on the computer, or\n *   from a .ttf or .otf file inside the sketches 'data' folder. This\n *   function is an advanced feature for precise control.\n * \n *   Use available-fonts to obtain the names for the fonts recognized by\n *   the computer and are compatible with this function.\n * \n *   The size parameter states the font size you want to generate. The\n *   smooth parameter specifies if the font should be antialiased or not,\n *   and the charset parameter is an array of chars that specifies the\n *   characters to generate.\n * \n *   This function creates a bitmapped version of a font It loads a font\n *   by name, and converts it to a series of images based on the size of\n *   the font. When possible, the text function will use a native font\n *   rather than the bitmapped version created behind the scenes with\n *   create-font. For instance, when using the default renderer\n *   setting (JAVA2D), the actual native version of the font will be\n *   employed by the sketch, improving drawing quality and\n *   performance. With the :p2d, :p3d, and :opengl renderer settings, the\n *   bitmapped version will be used. While this can drastically improve\n *   speed and appearance, results are poor when exporting if the sketch\n *   does not include the .otf or .ttf file, and the requested font is\n *   not available on the machine running the sketch.\n */\nquil.core.create_font = (function quil$core$create_font(var_args){\nvar args582 = [];\nvar len__13421__auto___585 = arguments.length;\nvar i__13422__auto___586 = (0);\nwhile(true){\nif((i__13422__auto___586 < len__13421__auto___585)){\nargs582.push((arguments[i__13422__auto___586]));\n\nvar G__587 = (i__13422__auto___586 + (1));\ni__13422__auto___586 = G__587;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__584 = args582.length;\nswitch (G__584) {\ncase (2):\nreturn quil.core.create_font.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core.create_font.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core.create_font.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args582.length)].join('')));\n\n}\n});\n\nquil.core.create_font.cljs$core$IFn$_invoke$arity$2 = (function (name,size){\nreturn quil.sketch.current_applet.call(null).createFont([cljs.core.str(name)].join(''),size);\n});\n\nquil.core.create_font.cljs$core$IFn$_invoke$arity$3 = (function (name,size,smooth){\nreturn quil.sketch.current_applet.call(null).createFont([cljs.core.str(name)].join(''),size,smooth);\n});\n\nquil.core.create_font.cljs$core$IFn$_invoke$arity$4 = (function (name,size,smooth,charset){\nreturn quil.sketch.current_applet.call(null).createFont([cljs.core.str(name)].join(''),size,smooth,charset);\n});\n\nquil.core.create_font.cljs$lang$maxFixedArity = (4);\n\n/**\n * Creates and returns a new PGraphics object of the types :p2d, :p3d,\n *   :java2d, :pdf. By default :java2d is used. Use this class if you\n *   need to draw into an off-screen graphics buffer. It's not possible\n *   to use create-graphics with the :opengl renderer, because it doesn't\n *   allow offscreen use. The :pdf renderer requires the filename parameter.\n * \n *   Note: don't use create-graphics in draw in clojurescript, it leaks memory.\n *   You should create graphic in setup and reuse it in draw instead of creating\n *   a new one.\n * \n *   It's important to call any drawing commands between (.beginDraw graphics) and\n *   (.endDraw graphics) statements or use with-graphics macro. This is also true\n *   for any commands that affect drawing, such as smooth or color-mode.\n * \n *   If you're using :pdf renderer - don't forget to call (.dispose graphics)\n *   as last command inside with-graphics macro, otherwise graphics won't be\n *   saved.\n * \n *   Unlike the main drawing surface which is completely opaque, surfaces\n *   created with create-graphics can have transparency. This makes it\n *   possible to draw into a graphics and maintain the alpha channel. By\n *   using save to write a PNG or TGA file, the transparency of the\n *   graphics object will be honored.\n */\nquil.core.create_graphics = (function quil$core$create_graphics(var_args){\nvar args589 = [];\nvar len__13421__auto___592 = arguments.length;\nvar i__13422__auto___593 = (0);\nwhile(true){\nif((i__13422__auto___593 < len__13421__auto___592)){\nargs589.push((arguments[i__13422__auto___593]));\n\nvar G__594 = (i__13422__auto___593 + (1));\ni__13422__auto___593 = G__594;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__591 = args589.length;\nswitch (G__591) {\ncase (2):\nreturn quil.core.create_graphics.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core.create_graphics.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core.create_graphics.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args589.length)].join('')));\n\n}\n});\n\nquil.core.create_graphics.cljs$core$IFn$_invoke$arity$2 = (function (w,h){\nreturn quil.sketch.current_applet.call(null).createGraphics((w | (0)),(h | (0)),new cljs.core.Keyword(null,\"p2d\",\"p2d\",(-2106175755)));\n});\n\nquil.core.create_graphics.cljs$core$IFn$_invoke$arity$3 = (function (w,h,renderer){\nreturn quil.sketch.current_applet.call(null).createGraphics((w | (0)),(h | (0)),quil.sketch.resolve_renderer.call(null,renderer));\n});\n\nquil.core.create_graphics.cljs$core$IFn$_invoke$arity$4 = (function (w,h,renderer,path){\nreturn quil.sketch.current_applet.call(null).createGraphics((w | (0)),(h | (0)),quil.sketch.resolve_renderer.call(null,renderer),path);\n});\n\nquil.core.create_graphics.cljs$lang$maxFixedArity = (4);\n\n/**\n * Creates a new PImage (the datatype for storing images). This\n *   provides a fresh buffer of pixels to play with. Set the size of the\n *   buffer with the width and height parameters. The format parameter\n *   defines how the pixels are stored. See the PImage reference for more\n *   information.\n * \n *   Possible formats: :rgb, :argb, :alpha (grayscale alpha channel)\n * \n *   Prefer using create-image over initialising new PImage instances\n *   directly.\n */\nquil.core.create_image = (function quil$core$create_image(w,h,format){\nvar format__$1 = quil.util.resolve_constant_key.call(null,format,quil.core.image_formats);\nreturn quil.sketch.current_applet.call(null).createImage((w | (0)),(h | (0)),(format__$1 | (0)));\n});\n/**\n * Return the current fill color.\n */\nquil.core.current_fill = (function quil$core$current_fill(){\nreturn quil.core.current_graphics.call(null).fillColor();\n});\n/**\n * Return the current stroke color.\n */\nquil.core.current_stroke = (function quil$core$current_stroke(){\nreturn quil.core.current_graphics.call(null).strokeColor();\n});\n/**\n * Sets the cursor to a predefined symbol or makes it\n *   visible if already hidden (after no-cursor was called).\n * \n *   Available modes: :arrow, :cross, :hand, :move, :text, :wait\n * \n *   See cursor-image for specifying a generic image as the cursor\n *   symbol.\n */\nquil.core.cursor = (function quil$core$cursor(var_args){\nvar args596 = [];\nvar len__13421__auto___599 = arguments.length;\nvar i__13422__auto___600 = (0);\nwhile(true){\nif((i__13422__auto___600 < len__13421__auto___599)){\nargs596.push((arguments[i__13422__auto___600]));\n\nvar G__601 = (i__13422__auto___600 + (1));\ni__13422__auto___600 = G__601;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__598 = args596.length;\nswitch (G__598) {\ncase (0):\nreturn quil.core.cursor.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase (1):\nreturn quil.core.cursor.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args596.length)].join('')));\n\n}\n});\n\nquil.core.cursor.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn quil.sketch.current_applet.call(null).cursor();\n});\n\nquil.core.cursor.cljs$core$IFn$_invoke$arity$1 = (function (cursor_mode){\nvar cursor_mode__$1 = quil.util.resolve_constant_key.call(null,cursor_mode,quil.core.cursor_modes);\nreturn quil.sketch.current_applet.call(null).cursor([cljs.core.str(cursor_mode__$1)].join(''));\n});\n\nquil.core.cursor.cljs$lang$maxFixedArity = (1);\n\n/**\n * Set the cursor to a predefined image. The horizontal and vertical\n *   active spots of the cursor may be specified with hx and hy.\n *   It is recommended to make the size 16x16 or 32x32 pixels.\n */\nquil.core.cursor_image = (function quil$core$cursor_image(var_args){\nvar args603 = [];\nvar len__13421__auto___606 = arguments.length;\nvar i__13422__auto___607 = (0);\nwhile(true){\nif((i__13422__auto___607 < len__13421__auto___606)){\nargs603.push((arguments[i__13422__auto___607]));\n\nvar G__608 = (i__13422__auto___607 + (1));\ni__13422__auto___607 = G__608;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__605 = args603.length;\nswitch (G__605) {\ncase (1):\nreturn quil.core.cursor_image.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (3):\nreturn quil.core.cursor_image.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args603.length)].join('')));\n\n}\n});\n\nquil.core.cursor_image.cljs$core$IFn$_invoke$arity$1 = (function (img){\nreturn quil.sketch.current_applet.call(null).cursor(img);\n});\n\nquil.core.cursor_image.cljs$core$IFn$_invoke$arity$3 = (function (img,hx,hy){\nreturn quil.sketch.current_applet.call(null).cursor(img,(hx | (0)),(hy | (0)));\n});\n\nquil.core.cursor_image.cljs$lang$maxFixedArity = (3);\n\n/**\n * Draws a curved line on the screen. The first and second parameters\n *   specify the beginning control point and the last two parameters\n *   specify the ending control point. The middle parameters specify the\n *   start and stop of the curve. Longer curves can be created by putting\n *   a series of curve fns together or using curve-vertex. An additional\n *   fn called curve-tightness provides control for the visual quality of\n *   the curve. The curve fn is an implementation of Catmull-Rom\n *   splines.\n */\nquil.core.curve = (function quil$core$curve(var_args){\nvar args610 = [];\nvar len__13421__auto___613 = arguments.length;\nvar i__13422__auto___614 = (0);\nwhile(true){\nif((i__13422__auto___614 < len__13421__auto___613)){\nargs610.push((arguments[i__13422__auto___614]));\n\nvar G__615 = (i__13422__auto___614 + (1));\ni__13422__auto___614 = G__615;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__612 = args610.length;\nswitch (G__612) {\ncase (8):\nreturn quil.core.curve.cljs$core$IFn$_invoke$arity$8((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]));\n\nbreak;\ncase (12):\nreturn quil.core.curve.cljs$core$IFn$_invoke$arity$12((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]),(arguments[(8)]),(arguments[(9)]),(arguments[(10)]),(arguments[(11)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args610.length)].join('')));\n\n}\n});\n\nquil.core.curve.cljs$core$IFn$_invoke$arity$8 = (function (x1,y1,x2,y2,x3,y3,x4,y4){\nreturn quil.core.current_graphics.call(null).curve(x1,y1,x2,y2,x3,y3,x4,y4);\n});\n\nquil.core.curve.cljs$core$IFn$_invoke$arity$12 = (function (x1,y1,z1,x2,y2,z2,x3,y3,z3,x4,y4,z4){\nreturn quil.core.current_graphics.call(null).curve(x1,y1,z1,x2,y2,z2,x3,y3,z3,x4,y4,z4);\n});\n\nquil.core.curve.cljs$lang$maxFixedArity = (12);\n\n/**\n * Sets the resolution at which curves display. The default value is\n *   20. This function is only useful when using the :p3d or :opengl\n *   renderer as the default (:java2d) renderer does not use this\n *   information.\n */\nquil.core.curve_detail = (function quil$core$curve_detail(detail){\nreturn quil.core.current_graphics.call(null).curveDetail((detail | (0)));\n});\n/**\n * Evalutes the curve at point t for points a, b, c, d. The parameter\n *   t varies between 0 and 1, a and d are points on the curve, and b c\n *   and are the control points. This can be done once with the x\n *   coordinates and a second time with the y coordinates to get the\n *   location of a curve at t.\n */\nquil.core.curve_point = (function quil$core$curve_point(a,b,c,d,t){\nreturn quil.core.current_graphics.call(null).curvePoint(a,b,c,d,t);\n});\n/**\n * Calculates the tangent of a point on a curve.\n *   See: http://en.wikipedia.org/wiki/Tangent\n */\nquil.core.curve_tangent = (function quil$core$curve_tangent(a,b,c,d,t){\nreturn quil.core.current_graphics.call(null).curveTangent(a,b,c,d,t);\n});\n/**\n * Modifies the quality of forms created with curve and\n *   curve-vertex. The parameter squishy determines how the curve fits\n *   to the vertex points. The value 0.0 is the default value for\n *   squishy (this value defines the curves to be Catmull-Rom splines)\n *   and the value 1.0 connects all the points with straight\n *   lines. Values within the range -5.0 and 5.0 will deform the curves\n *   but will leave them recognizable and as values increase in\n *   magnitude, they will continue to deform.\n */\nquil.core.curve_tightness = (function quil$core$curve_tightness(ti){\nreturn quil.core.current_graphics.call(null).curveTightness(ti);\n});\n/**\n * Specifies vertex coordinates for curves. This function may only be\n *   used between begin-shape and end-shape and only when there is no\n *   mode keyword specified to begin-shape. The first and last points in a\n *   series of curve-vertex lines will be used to guide the beginning and\n *   end of a the curve. A minimum of four points is required to draw a\n *   tiny curve between the second and third points. Adding a fifth point\n *   with curve-vertex will draw the curve between the second, third, and\n *   fourth points. The curve-vertex function is an implementation of\n *   Catmull-Rom splines.\n */\nquil.core.curve_vertex = (function quil$core$curve_vertex(var_args){\nvar args617 = [];\nvar len__13421__auto___620 = arguments.length;\nvar i__13422__auto___621 = (0);\nwhile(true){\nif((i__13422__auto___621 < len__13421__auto___620)){\nargs617.push((arguments[i__13422__auto___621]));\n\nvar G__622 = (i__13422__auto___621 + (1));\ni__13422__auto___621 = G__622;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__619 = args617.length;\nswitch (G__619) {\ncase (2):\nreturn quil.core.curve_vertex.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core.curve_vertex.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args617.length)].join('')));\n\n}\n});\n\nquil.core.curve_vertex.cljs$core$IFn$_invoke$arity$2 = (function (x,y){\nreturn quil.core.current_graphics.call(null).curveVertex(x,y);\n});\n\nquil.core.curve_vertex.cljs$core$IFn$_invoke$arity$3 = (function (x,y,z){\nreturn quil.core.current_graphics.call(null).curveVertex(x,y,z);\n});\n\nquil.core.curve_vertex.cljs$lang$maxFixedArity = (3);\n\n/**\n * Get the current day of the month (1 through 31).\n */\nquil.core.day = (function quil$core$day(){\nreturn quil.sketch.current_applet.call(null).day();\n});\n/**\n * Converts a radian measurement to its corresponding value in\n *   degrees. Radians and degrees are two ways of measuring the same\n *   thing. There are 360 degrees in a circle and (* 2 Math/PI) radians\n *   in a circle. For example, (= 90° (/ Math/PI 2) 1.5707964). All\n *   trigonometric methods in Processing require their parameters to be\n *   specified in radians.\n */\nquil.core.degrees = (function quil$core$degrees(radians){\nreturn quil.sketch.current_applet.call(null).degrees(radians);\n});\n/**\n * Forces the program to stop running for a specified time. Delay\n *   times are specified in thousandths of a second, therefore the\n *   function call (delay 3000) will stop the program for three\n *   seconds. Because the screen is updated only at the end of draw,\n *   the program may appear to 'freeze', because the screen will not\n *   update when the delay fn is used. This function has no affect\n *   inside setup.\n */\nquil.core.delay_frame = (function quil$core$delay_frame(freeze_ms){\nreturn quil.sketch.current_applet.call(null).delay((freeze_ms | (0)));\n});\n/**\n * Adds a directional light. Directional light comes from one\n *   direction and is stronger when hitting a surface squarely and weaker\n *   if it hits at a gentle angle. After hitting a surface, a\n *   directional lights scatters in all directions. Lights need to be\n *   included in the draw fn to remain persistent in a looping\n *   program. Placing them in the setup fn of a looping program will cause\n *   them to only have an effect the first time through the loop. The\n *   affect of the r, g, and b parameters is determined by the current\n *   color mode. The nx, ny, and nz parameters specify the direction the\n *   light is facing. For example, setting ny to -1 will cause the\n *   geometry to be lit from below (the light is facing directly upward)\n */\nquil.core.directional_light = (function quil$core$directional_light(r,g,b,nx,ny,nz){\nreturn quil.core.current_graphics.call(null).directionalLight(r,g,b,nx,ny,nz);\n});\n/**\n * Calculates the distance between two points\n */\nquil.core.dist = (function quil$core$dist(var_args){\nvar args624 = [];\nvar len__13421__auto___627 = arguments.length;\nvar i__13422__auto___628 = (0);\nwhile(true){\nif((i__13422__auto___628 < len__13421__auto___627)){\nargs624.push((arguments[i__13422__auto___628]));\n\nvar G__629 = (i__13422__auto___628 + (1));\ni__13422__auto___628 = G__629;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__626 = args624.length;\nswitch (G__626) {\ncase (4):\nreturn quil.core.dist.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase (6):\nreturn quil.core.dist.cljs$core$IFn$_invoke$arity$6((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args624.length)].join('')));\n\n}\n});\n\nquil.core.dist.cljs$core$IFn$_invoke$arity$4 = (function (x1,y1,x2,y2){\nreturn quil.sketch.current_applet.call(null).dist(x1,y1,x2,y2);\n});\n\nquil.core.dist.cljs$core$IFn$_invoke$arity$6 = (function (x1,y1,z1,x2,y2,z2){\nreturn quil.sketch.current_applet.call(null).dist(x1,y1,z1,x2,y2,z2);\n});\n\nquil.core.dist.cljs$lang$maxFixedArity = (6);\n\n/**\n * Macro for drawing on graphics which saves result in the file at the end.\n *   Similar to 'with-graphics' macro. do-record assumed to be used with :pdf\n *   graphics. Example:\n * \n *   (q/do-record (q/create-graphics 200 200 :pdf \"output.pdf\")\n *  (q/fill 250 0 0)\n *  (q/ellipse 100 100 150 150))\n *   \n */\nquil.core.do_record = (function quil$core$do_record(var_args){\nvar args__13423__auto__ = [];\nvar len__13421__auto___635 = arguments.length;\nvar i__13422__auto___636 = (0);\nwhile(true){\nif((i__13422__auto___636 < len__13421__auto___635)){\nargs__13423__auto__.push((arguments[i__13422__auto___636]));\n\nvar G__637 = (i__13422__auto___636 + (1));\ni__13422__auto___636 = G__637;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__13424__auto__ = ((((3) < args__13423__auto__.length))?(new cljs.core.IndexedSeq(args__13423__auto__.slice((3)),(0),null)):null);\nreturn quil.core.do_record.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__13424__auto__);\n});\n\nquil.core.do_record.cljs$core$IFn$_invoke$arity$variadic = (function (_AMPERSAND_form,_AMPERSAND_env,graphics,body){\nreturn cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"cljs.core\",\"let\",\"cljs.core/let\",(-308701135),null)),(function (){var x__13164__auto__ = cljs.core.vec.call(null,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"gr__16__auto__\",\"gr__16__auto__\",(-1845213481),null)),(function (){var x__13164__auto__ = graphics;\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})())));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})(),(function (){var x__13164__auto__ = cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.core\",\"with-graphics\",\"quil.core/with-graphics\",(481277883),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"gr__16__auto__\",\"gr__16__auto__\",(-1845213481),null)),body));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})(),(function (){var x__13164__auto__ = cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\".dispose\",\".dispose\",(-1697594101),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"gr__16__auto__\",\"gr__16__auto__\",(-1845213481),null))));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})()));\n});\n\nquil.core.do_record.cljs$lang$maxFixedArity = (3);\n\nquil.core.do_record.cljs$lang$applyTo = (function (seq631){\nvar G__632 = cljs.core.first.call(null,seq631);\nvar seq631__$1 = cljs.core.next.call(null,seq631);\nvar G__633 = cljs.core.first.call(null,seq631__$1);\nvar seq631__$2 = cljs.core.next.call(null,seq631__$1);\nvar G__634 = cljs.core.first.call(null,seq631__$2);\nvar seq631__$3 = cljs.core.next.call(null,seq631__$2);\nreturn quil.core.do_record.cljs$core$IFn$_invoke$arity$variadic(G__632,G__633,G__634,seq631__$3);\n});\n\n\nquil.core.do_record.cljs$lang$macro = true;\n/**\n * Draws an ellipse (oval) in the display window. An ellipse with an\n *   equal width and height is a circle.  The origin may be changed with\n *   the ellipse-mode function\n */\nquil.core.ellipse = (function quil$core$ellipse(x,y,width,height){\nreturn quil.core.current_graphics.call(null).ellipse(x,y,width,height);\n});\n/**\n * Modifies the origin of the ellispse according to the specified mode:\n * \n *   :center  - specifies the location of the ellipse as\n *           the center of the shape. (Default).\n *   :radius  - similar to center, but the width and height parameters to\n *           ellipse specify the radius of the ellipse, rather than the\n *           diameter.\n *   :corner  - draws the shape from the upper-left corner of its bounding\n *           box.\n *   :corners - uses the four parameters to ellipse to set two opposing\n *           corners of the ellipse's bounding box.\n */\nquil.core.ellipse_mode = (function quil$core$ellipse_mode(mode){\nvar mode__$1 = quil.util.resolve_constant_key.call(null,mode,quil.core.ellipse_modes);\nreturn quil.core.current_graphics.call(null).ellipseMode((mode__$1 | (0)));\n});\n/**\n * Sets the emissive color of the material used for drawing shapes\n *  drawn to the screen. Used in combination with ambient, specular, and\n *  shininess in setting the material properties of shapes. Converts all\n *  args to floats\n */\nquil.core.emissive_float = (function quil$core$emissive_float(var_args){\nvar args638 = [];\nvar len__13421__auto___641 = arguments.length;\nvar i__13422__auto___642 = (0);\nwhile(true){\nif((i__13422__auto___642 < len__13421__auto___641)){\nargs638.push((arguments[i__13422__auto___642]));\n\nvar G__643 = (i__13422__auto___642 + (1));\ni__13422__auto___642 = G__643;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__640 = args638.length;\nswitch (G__640) {\ncase (1):\nreturn quil.core.emissive_float.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (3):\nreturn quil.core.emissive_float.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args638.length)].join('')));\n\n}\n});\n\nquil.core.emissive_float.cljs$core$IFn$_invoke$arity$1 = (function (float_val){\nreturn quil.core.current_graphics.call(null).emissive(float_val);\n});\n\nquil.core.emissive_float.cljs$core$IFn$_invoke$arity$3 = (function (r,g,b){\nreturn quil.core.current_graphics.call(null).emissive(r,g,b);\n});\n\nquil.core.emissive_float.cljs$lang$maxFixedArity = (3);\n\n/**\n * Sets the emissive color of the material used for drawing shapes\n *   drawn to the screen. Used in combination with ambient, specular, and\n *   shininess in setting the material properties of shapes. Converts all\n *   args to ints\n */\nquil.core.emissive_int = (function quil$core$emissive_int(int_val){\nreturn quil.core.current_graphics.call(null).emissive((int_val | (0)));\n});\n/**\n * Sets the emissive color of the material used for drawing shapes\n *   drawn to the screen. Used in combination with ambient, specular, and\n *   shininess in setting the material properties of shapes.\n * \n *   If passed one arg - it is assumed to be an int (i.e. a color),\n *   multiple args are converted to floats.\n */\nquil.core.emissive = (function quil$core$emissive(var_args){\nvar args645 = [];\nvar len__13421__auto___648 = arguments.length;\nvar i__13422__auto___649 = (0);\nwhile(true){\nif((i__13422__auto___649 < len__13421__auto___648)){\nargs645.push((arguments[i__13422__auto___649]));\n\nvar G__650 = (i__13422__auto___649 + (1));\ni__13422__auto___649 = G__650;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__647 = args645.length;\nswitch (G__647) {\ncase (1):\nreturn quil.core.emissive.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (3):\nreturn quil.core.emissive.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args645.length)].join('')));\n\n}\n});\n\nquil.core.emissive.cljs$core$IFn$_invoke$arity$1 = (function (c){\nreturn quil.core.emissive_float.call(null,c);\n});\n\nquil.core.emissive.cljs$core$IFn$_invoke$arity$3 = (function (r,g,b){\nreturn quil.core.emissive_float.call(null,r,g,b);\n});\n\nquil.core.emissive.cljs$lang$maxFixedArity = (3);\n\n/**\n * Unsets the matrix mode from the camera matrix. See begin-camera.\n */\nquil.core.end_camera = (function quil$core$end_camera(){\nreturn quil.core.current_graphics.call(null).endCamera();\n});\n/**\n * Use the begin-contour and end-contour function to create negative\n *   shapes within shapes. These functions can only be within a\n *   begin-shape/end-shape pair and they only work with the :p2d and :p3d\n *   renderers.\n */\nquil.core.end_contour = (function quil$core$end_contour(){\nreturn quil.core.current_graphics.call(null).endContour();\n});\n/**\n * Complement to begin-raw; they must always be used together. See\n *   the begin-raw docstring for details.\n */\nquil.core.end_raw = (function quil$core$end_raw(){\nreturn quil.core.current_graphics.call(null).endRaw();\n});\n/**\n * May only be called after begin-shape. When end-shape is called,\n *   all of image data defined since the previous call to begin-shape is\n *   written into the image buffer. The keyword :close may be passed to\n *   close the shape (to connect the beginning and the end).\n */\nquil.core.end_shape = (function quil$core$end_shape(var_args){\nvar args652 = [];\nvar len__13421__auto___655 = arguments.length;\nvar i__13422__auto___656 = (0);\nwhile(true){\nif((i__13422__auto___656 < len__13421__auto___655)){\nargs652.push((arguments[i__13422__auto___656]));\n\nvar G__657 = (i__13422__auto___656 + (1));\ni__13422__auto___656 = G__657;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__654 = args652.length;\nswitch (G__654) {\ncase (0):\nreturn quil.core.end_shape.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase (1):\nreturn quil.core.end_shape.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args652.length)].join('')));\n\n}\n});\n\nquil.core.end_shape.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn quil.core.current_graphics.call(null).endShape();\n});\n\nquil.core.end_shape.cljs$core$IFn$_invoke$arity$1 = (function (mode){\nif(cljs.core._EQ_.call(null,new cljs.core.Keyword(null,\"close\",\"close\",(1835149582)),mode)){\n} else {\n}\n\nreturn quil.core.current_graphics.call(null).endShape((2));\n});\n\nquil.core.end_shape.cljs$lang$maxFixedArity = (1);\n\n/**\n * Quits/stops/exits the program.  Rather than terminating\n *   immediately, exit will cause the sketch to exit after draw has\n *   completed (or after setup completes if called during the setup\n *   method). \n */\nquil.core.exit = (function quil$core$exit(){\nreturn quil.sketch.current_applet.call(null).exit();\n});\n/**\n * Returns Euler's number e (2.71828...) raised to the power of the\n *   value parameter.\n */\nquil.core.exp = (function quil$core$exp(val){\nreturn quil.sketch.current_applet.call(null).exp(val);\n});\n/**\n * Sets custom property on graphcs object indicating that it has\n *   fill color.\n */\nquil.core.clear_no_fill_cljs = (function quil$core$clear_no_fill_cljs(graphics){\nreturn (graphics[quil.core.no_fill_prop] = false);\n});\n/**\n * Sets the color used to fill shapes. For example, (fill 204 102 0),\n *   will specify that all subsequent shapes will be filled with orange.\n */\nquil.core.fill_float = (function quil$core$fill_float(var_args){\nvar args659 = [];\nvar len__13421__auto___662 = arguments.length;\nvar i__13422__auto___663 = (0);\nwhile(true){\nif((i__13422__auto___663 < len__13421__auto___662)){\nargs659.push((arguments[i__13422__auto___663]));\n\nvar G__664 = (i__13422__auto___663 + (1));\ni__13422__auto___663 = G__664;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__661 = args659.length;\nswitch (G__661) {\ncase (1):\nreturn quil.core.fill_float.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core.fill_float.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core.fill_float.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core.fill_float.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args659.length)].join('')));\n\n}\n});\n\nquil.core.fill_float.cljs$core$IFn$_invoke$arity$1 = (function (gray){\nquil.core.current_graphics.call(null).fill(gray);\n\nreturn quil.core.clear_no_fill_cljs.call(null,quil.core.current_graphics.call(null));\n});\n\nquil.core.fill_float.cljs$core$IFn$_invoke$arity$2 = (function (gray,alpha){\nquil.core.current_graphics.call(null).fill(gray,alpha);\n\nreturn quil.core.clear_no_fill_cljs.call(null,quil.core.current_graphics.call(null));\n});\n\nquil.core.fill_float.cljs$core$IFn$_invoke$arity$3 = (function (r,g,b){\nquil.core.current_graphics.call(null).fill(r,g,b);\n\nreturn quil.core.clear_no_fill_cljs.call(null,quil.core.current_graphics.call(null));\n});\n\nquil.core.fill_float.cljs$core$IFn$_invoke$arity$4 = (function (r,g,b,alpha){\nquil.core.current_graphics.call(null).fill(r,g,b,alpha);\n\nreturn quil.core.clear_no_fill_cljs.call(null,quil.core.current_graphics.call(null));\n});\n\nquil.core.fill_float.cljs$lang$maxFixedArity = (4);\n\n/**\n * Sets the color used to fill shapes.\n */\nquil.core.fill_int = (function quil$core$fill_int(var_args){\nvar args666 = [];\nvar len__13421__auto___669 = arguments.length;\nvar i__13422__auto___670 = (0);\nwhile(true){\nif((i__13422__auto___670 < len__13421__auto___669)){\nargs666.push((arguments[i__13422__auto___670]));\n\nvar G__671 = (i__13422__auto___670 + (1));\ni__13422__auto___670 = G__671;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__668 = args666.length;\nswitch (G__668) {\ncase (1):\nreturn quil.core.fill_int.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core.fill_int.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args666.length)].join('')));\n\n}\n});\n\nquil.core.fill_int.cljs$core$IFn$_invoke$arity$1 = (function (rgb){\nquil.core.current_graphics.call(null).fill(cljs.core.unchecked_int.call(null,rgb));\n\nreturn quil.core.clear_no_fill_cljs.call(null,quil.core.current_graphics.call(null));\n});\n\nquil.core.fill_int.cljs$core$IFn$_invoke$arity$2 = (function (rgb,alpha){\nquil.core.current_graphics.call(null).fill(cljs.core.unchecked_int.call(null,rgb),alpha);\n\nreturn quil.core.clear_no_fill_cljs.call(null,quil.core.current_graphics.call(null));\n});\n\nquil.core.fill_int.cljs$lang$maxFixedArity = (2);\n\n/**\n * Sets the color used to fill shapes.\n */\nquil.core.fill = (function quil$core$fill(var_args){\nvar args673 = [];\nvar len__13421__auto___676 = arguments.length;\nvar i__13422__auto___677 = (0);\nwhile(true){\nif((i__13422__auto___677 < len__13421__auto___676)){\nargs673.push((arguments[i__13422__auto___677]));\n\nvar G__678 = (i__13422__auto___677 + (1));\ni__13422__auto___677 = G__678;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__675 = args673.length;\nswitch (G__675) {\ncase (1):\nreturn quil.core.fill.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core.fill.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core.fill.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core.fill.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args673.length)].join('')));\n\n}\n});\n\nquil.core.fill.cljs$core$IFn$_invoke$arity$1 = (function (rgb){\nreturn quil.core.fill_float.call(null,rgb);\n});\n\nquil.core.fill.cljs$core$IFn$_invoke$arity$2 = (function (rgb,alpha){\nreturn quil.core.fill_float.call(null,rgb,alpha);\n});\n\nquil.core.fill.cljs$core$IFn$_invoke$arity$3 = (function (r,g,b){\nreturn quil.core.fill_float.call(null,r,g,b);\n});\n\nquil.core.fill.cljs$core$IFn$_invoke$arity$4 = (function (r,g,b,a){\nreturn quil.core.fill_float.call(null,r,g,b,a);\n});\n\nquil.core.fill.cljs$lang$maxFixedArity = (4);\n\n/**\n * Originally named filter in Processing Language.\n *   Filters the display window with the specified mode and level.\n *   Level defines the quality of the filter and mode may be one of the\n *   following keywords:\n * \n *   :threshold - converts the image to black and white pixels depending\n *             if they are above or below the threshold defined by\n *             the level parameter. The level must be between\n *             0.0 (black) and 1.0 (white). If no level is specified,\n *             0.5 is used.\n *   :gray      - converts any colors in the image to grayscale\n *             equivalents. Doesn't work with level.\n *   :invert    - sets each pixel to its inverse value. Doesn't work with\n *             level.\n *   :posterize - limits each channel of the image to the number of\n *             colors specified as the level parameter. The parameter can\n *             be set to values between 2 and 255, but results are most\n *             noticeable in the lower ranges.\n *   :blur      - executes a Guassian blur with the level parameter\n *             specifying the extent of the blurring. If no level\n *             parameter is used, the blur is equivalent to Guassian\n *             blur of radius 1.\n *   :opaque    - sets the alpha channel to entirely opaque. Doesn't work\n *             with level.\n *   :erode     - reduces the light areas. Doesn't work with level.\n *   :dilate    - increases the light areas.  Doesn't work with level.\n */\nquil.core.display_filter = (function quil$core$display_filter(var_args){\nvar args680 = [];\nvar len__13421__auto___683 = arguments.length;\nvar i__13422__auto___684 = (0);\nwhile(true){\nif((i__13422__auto___684 < len__13421__auto___683)){\nargs680.push((arguments[i__13422__auto___684]));\n\nvar G__685 = (i__13422__auto___684 + (1));\ni__13422__auto___684 = G__685;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__682 = args680.length;\nswitch (G__682) {\ncase (1):\nreturn quil.core.display_filter.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core.display_filter.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args680.length)].join('')));\n\n}\n});\n\nquil.core.display_filter.cljs$core$IFn$_invoke$arity$1 = (function (mode){\nreturn quil.core.current_graphics.call(null).filter((quil.util.resolve_constant_key.call(null,mode,quil.core.filter_modes) | (0)));\n});\n\nquil.core.display_filter.cljs$core$IFn$_invoke$arity$2 = (function (mode,level){\nvar mode__$1 = quil.util.resolve_constant_key.call(null,mode,quil.core.filter_modes);\nreturn quil.core.current_graphics.call(null).filter((mode__$1 | (0)),level);\n});\n\nquil.core.display_filter.cljs$lang$maxFixedArity = (2);\n\n/**\n * Calculates the closest int value that is less than or equal to the\n *   value of the parameter. For example, (floor 9.03) returns the value 9.\n */\nquil.core.floor = (function quil$core$floor(n){\nreturn quil.sketch.current_applet.call(null).floor(n);\n});\n/**\n * Returns a boolean value representing whether the applet has focus.\n */\nquil.core.focused = (function quil$core$focused(){\nreturn quil.sketch.current_applet.call(null).focused;\n});\n/**\n * The system variable frameCount contains the number of frames\n *   displayed since the program started. Inside setup() the value is 0\n *   and after the first iteration of draw it is 1, etc.\n */\nquil.core.frame_count = (function quil$core$frame_count(){\nreturn quil.sketch.current_applet.call(null).frameCount;\n});\n/**\n * Returns the current framerate\n */\nquil.core.current_frame_rate = (function quil$core$current_frame_rate(){\nreturn quil.sketch.current_applet.call(null).__frameRate;\n});\n/**\n * Specifies a new target framerate (number of frames to be displayed every\n *   second). If the processor is not fast enough to maintain the\n *   specified rate, it will not be achieved. For example, the function\n *   call (frame-rate 30) will attempt to refresh 30 times a second. It\n *   is recommended to set the frame rate within setup. The default rate\n *   is 60 frames per second.\n */\nquil.core.frame_rate = (function quil$core$frame_rate(new_rate){\ncljs.core.reset_BANG_.call(null,quil.sketch.current_applet.call(null).target_frame_rate,new_rate);\n\nreturn quil.sketch.current_applet.call(null).frameRate(new_rate);\n});\n/**\n * Sets a perspective matrix defined through the parameters. Works\n *   like glFrustum, except it wipes out the current perspective matrix\n *   rather than muliplying itself with it.\n */\nquil.core.frustum = (function quil$core$frustum(left,right,bottom,top,near,far){\nreturn quil.core.current_graphics.call(null).frustum(left,right,bottom,top,near,far);\n});\n/**\n * Reads the color of any pixel or grabs a section of an image. If no\n *   parameters are specified, a copy of entire image is returned. Get the\n *   value of one pixel by specifying an x,y coordinate. Get a section of\n *   the image by specifying an additional width and height parameter.\n *   If the pixel requested is outside of the image window, black is returned.\n *   The numbers returned are scaled according to the current color ranges,\n *   but only RGB values are returned by this function. For example, even though\n *   you may have drawn a shape with (color-mode :hsb), the numbers returned\n *   will be in RGB.\n * \n *   Getting the color of a single pixel with (get x y) is easy, but not\n *   as fast as grabbing the data directly using the pixels fn.\n * \n *   If no img specified - current-graphics is used.\n */\nquil.core.get_pixel = (function quil$core$get_pixel(var_args){\nvar args687 = [];\nvar len__13421__auto___690 = arguments.length;\nvar i__13422__auto___691 = (0);\nwhile(true){\nif((i__13422__auto___691 < len__13421__auto___690)){\nargs687.push((arguments[i__13422__auto___691]));\n\nvar G__692 = (i__13422__auto___691 + (1));\ni__13422__auto___691 = G__692;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__689 = args687.length;\nswitch (G__689) {\ncase (0):\nreturn quil.core.get_pixel.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase (1):\nreturn quil.core.get_pixel.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core.get_pixel.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core.get_pixel.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core.get_pixel.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase (5):\nreturn quil.core.get_pixel.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args687.length)].join('')));\n\n}\n});\n\nquil.core.get_pixel.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn quil.core.get_pixel.call(null,quil.core.current_graphics.call(null));\n});\n\nquil.core.get_pixel.cljs$core$IFn$_invoke$arity$1 = (function (img){\nreturn img.get();\n});\n\nquil.core.get_pixel.cljs$core$IFn$_invoke$arity$2 = (function (x,y){\nreturn quil.core.get_pixel.call(null,quil.core.current_graphics.call(null),x,y);\n});\n\nquil.core.get_pixel.cljs$core$IFn$_invoke$arity$3 = (function (img,x,y){\nreturn img.get((x | (0)),(y | (0)));\n});\n\nquil.core.get_pixel.cljs$core$IFn$_invoke$arity$4 = (function (x,y,w,h){\nreturn quil.core.get_pixel.call(null,quil.core.current_graphics.call(null),x,y,w,h);\n});\n\nquil.core.get_pixel.cljs$core$IFn$_invoke$arity$5 = (function (img,x,y,w,h){\nreturn img.get((x | (0)),(y | (0)),(w | (0)),(h | (0)));\n});\n\nquil.core.get_pixel.cljs$lang$maxFixedArity = (5);\n\n/**\n * Extracts the green value from a color, scaled to match current\n *   color-mode. This value is always returned as a float so be careful\n *   not to assign it to an int value.\n */\nquil.core.green = (function quil$core$green(col){\nreturn quil.core.current_graphics.call(null).green(cljs.core.unchecked_int.call(null,col));\n});\n/**\n * Converts a byte, char, int, or color to a String containing the\n *   equivalent hexadecimal notation. For example color(0, 102, 153) will\n *   convert to the String \"FF006699\". This function can help make your\n *   geeky debugging sessions much happier. \n */\nquil.core.hex = (function quil$core$hex(var_args){\nvar args694 = [];\nvar len__13421__auto___697 = arguments.length;\nvar i__13422__auto___698 = (0);\nwhile(true){\nif((i__13422__auto___698 < len__13421__auto___697)){\nargs694.push((arguments[i__13422__auto___698]));\n\nvar G__699 = (i__13422__auto___698 + (1));\ni__13422__auto___698 = G__699;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__696 = args694.length;\nswitch (G__696) {\ncase (1):\nreturn quil.core.hex.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core.hex.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args694.length)].join('')));\n\n}\n});\n\nquil.core.hex.cljs$core$IFn$_invoke$arity$1 = (function (val){\nreturn quil.sketch.current_applet.call(null).hex(val);\n});\n\nquil.core.hex.cljs$core$IFn$_invoke$arity$2 = (function (val,num_digits){\nreturn quil.sketch.current_applet.call(null).hex(val,num_digits);\n});\n\nquil.core.hex.cljs$lang$maxFixedArity = (2);\n\n/**\n * Height of the display window. The value of height is zero until\n *   size is called.\n */\nquil.core.height = (function quil$core$height(){\nreturn quil.sketch.current_applet.call(null).height;\n});\n/**\n * Set various hints and hacks for the renderer. This is used to\n *   handle obscure rendering features that cannot be implemented in a\n *   consistent manner across renderers. Many options will often graduate\n *   to standard features instead of hints over time.\n * \n *   Options:\n * \n *   :enable-native-fonts - Use the native version fonts when they are\n *  installed, rather than the bitmapped version from a .vlw\n *  file. This is useful with the default (or JAVA2D) renderer\n *  setting, as it will improve font rendering speed. This is not\n *  enabled by default, because it can be misleading while testing\n *  because the type will look great on your machine (because you have\n *  the font installed) but lousy on others' machines if the identical\n *  font is unavailable. This option can only be set per-sketch, and\n *  must be called before any use of text-font.\n * \n *   :disable-native-fonts - Disables native font support.\n * \n *   :disable-depth-test - Disable the zbuffer, allowing you to draw on\n *  top of everything at will. When depth testing is disabled, items\n *  will be drawn to the screen sequentially, like a painting. This\n *  hint is most often used to draw in 3D, then draw in 2D on top of\n *  it (for instance, to draw GUI controls in 2D on top of a 3D\n *  interface). Starting in release 0149, this will also clear the\n *  depth buffer. Restore the default with :enable-depth-test\n *  but note that with the depth buffer cleared, any 3D drawing that\n *  happens later in draw will ignore existing shapes on the screen.\n * \n *   :enable-depth-test - Enables the zbuffer.\n * \n *   :enable-depth-sort - Enable primitive z-sorting of triangles and\n *  lines in :p3d and :opengl rendering modes. This can slow\n *  performance considerably, and the algorithm is not yet perfect.\n * \n *   :disable-depth-sort - Disables hint :enable-depth-sort\n * \n *   :disable-opengl-errors - Speeds up the OPENGL renderer setting\n *   by not checking for errors while running.\n * \n *   :enable-opengl-errors - Turns on OpenGL error checking\n * \n *   :enable-depth-mask\n *   :disable-depth-mask\n * \n *   :enable-optimized-stroke\n *   :disable-optimized-stroke\n *   :enable-retina-pixels\n *   :disable-retina-pixels\n *   :enable-stroke-perspective\n *   :disable-stroke-perspective\n *   :enable-stroke-pure\n *   :disable-stroke-pure\n *   :enable-texture-mipmaps\n *   :disable-texture-mipmaps\n */\nquil.core.hint = (function quil$core$hint(hint_type){\nvar hint_type__$1 = (((hint_type instanceof cljs.core.Keyword))?cljs.core.get.call(null,quil.core.hint_options,hint_type):hint_type);\nreturn quil.core.current_graphics.call(null).hint((hint_type__$1 | (0)));\n});\n/**\n * Returns the current hour as a value from 0 - 23.\n */\nquil.core.hour = (function quil$core$hour(){\nreturn quil.sketch.current_applet.call(null).hour();\n});\n/**\n * Extracts the hue value from a color.\n */\nquil.core.hue = (function quil$core$hue(col){\nreturn quil.core.current_graphics.call(null).hue(cljs.core.unchecked_int.call(null,col));\n});\n/**\n * Displays images to the screen. Processing currently works with GIF,\n *   JPEG, and Targa images. The color of an image may be modified with\n *   the tint function and if a GIF has transparency, it will maintain\n *   its transparency. The img parameter specifies the image to display\n *   and the x and y parameters define the location of the image from its\n *   upper-left corner. The image is displayed at its original size\n *   unless the width and height parameters specify a different size. The\n *   image-mode fn changes the way the parameters work. A call to\n *   (image-mode :corners) will change the width and height parameters to\n *   define the x and y values of the opposite corner of the image.\n * \n *   Starting with release 0124, when using the default (JAVA2D)\n *   renderer, smooth will also improve image quality of resized\n *   images.\n */\nquil.core.image = (function quil$core$image(var_args){\nvar args701 = [];\nvar len__13421__auto___704 = arguments.length;\nvar i__13422__auto___705 = (0);\nwhile(true){\nif((i__13422__auto___705 < len__13421__auto___704)){\nargs701.push((arguments[i__13422__auto___705]));\n\nvar G__706 = (i__13422__auto___705 + (1));\ni__13422__auto___705 = G__706;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__703 = args701.length;\nswitch (G__703) {\ncase (3):\nreturn quil.core.image.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (5):\nreturn quil.core.image.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args701.length)].join('')));\n\n}\n});\n\nquil.core.image.cljs$core$IFn$_invoke$arity$3 = (function (img,x,y){\nreturn quil.core.current_graphics.call(null).image(img,x,y);\n});\n\nquil.core.image.cljs$core$IFn$_invoke$arity$5 = (function (img,x,y,c,d){\nreturn quil.core.current_graphics.call(null).image(img,x,y,c,d);\n});\n\nquil.core.image.cljs$lang$maxFixedArity = (5);\n\n/**\n * Originally named filter in Processing Language.\n *   Filters given image with the specified mode and level.\n *   Level defines the quality of the filter and mode may be one of\n *   the following keywords:\n * \n *   :threshold - converts the image to black and white pixels depending\n *             if they are above or below the threshold defined by\n *             the level parameter. The level must be between\n *             0.0 (black) and 1.0 (white). If no level is specified,\n *             0.5 is used.\n *   :gray      - converts any colors in the image to grayscale\n *             equivalents. Doesn't work with level.\n *   :invert    - sets each pixel to its inverse value. Doesn't work with\n *             level.\n *   :posterize - limits each channel of the image to the number of\n *             colors specified as the level parameter. The parameter can\n *             be set to values between 2 and 255, but results are most\n *             noticeable in the lower ranges.\n *   :blur      - executes a Guassian blur with the level parameter\n *             specifying the extent of the blurring. If no level\n *             parameter is used, the blur is equivalent to Guassian\n *             blur of radius 1.\n *   :opaque    - sets the alpha channel to entirely opaque. Doesn't work\n *             with level.\n *   :erode     - reduces the light areas. Doesn't work with level.\n *   :dilate    - increases the light areas.  Doesn't work with level.\n */\nquil.core.image_filter = (function quil$core$image_filter(var_args){\nvar args708 = [];\nvar len__13421__auto___711 = arguments.length;\nvar i__13422__auto___712 = (0);\nwhile(true){\nif((i__13422__auto___712 < len__13421__auto___711)){\nargs708.push((arguments[i__13422__auto___712]));\n\nvar G__713 = (i__13422__auto___712 + (1));\ni__13422__auto___712 = G__713;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__710 = args708.length;\nswitch (G__710) {\ncase (2):\nreturn quil.core.image_filter.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core.image_filter.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args708.length)].join('')));\n\n}\n});\n\nquil.core.image_filter.cljs$core$IFn$_invoke$arity$2 = (function (img,mode){\nvar mode__$1 = quil.util.resolve_constant_key.call(null,mode,quil.core.filter_modes);\nreturn img.filter((mode__$1 | (0)));\n});\n\nquil.core.image_filter.cljs$core$IFn$_invoke$arity$3 = (function (img,mode,level){\nvar mode__$1 = quil.util.resolve_constant_key.call(null,mode,quil.core.filter_modes);\nreturn img.filter((mode__$1 | (0)),level);\n});\n\nquil.core.image_filter.cljs$lang$maxFixedArity = (3);\n\n/**\n * Modifies the location from which images draw. The default mode is :corner.\n * Available modes are:\n * \n *   :corner  - specifies the location to be the upper left corner and\n *           uses the fourth and fifth parameters of image to set the\n *           image's width and height.\n * \n *   :corners - uses the second and third parameters of image to set the\n *           location of one corner of the image and uses the fourth\n *           and fifth parameters to set the opposite corner.\n * \n *   :center  - draw images centered at the given x and y position.\n */\nquil.core.image_mode = (function quil$core$image_mode(mode){\nvar mode__$1 = quil.util.resolve_constant_key.call(null,mode,quil.core.image_modes);\nreturn quil.core.current_graphics.call(null).imageMode((mode__$1 | (0)));\n});\n/**\n * The variable keyCode is used to detect special keys such as the UP,\n *   DOWN, LEFT, RIGHT arrow keys and ALT, CONTROL, SHIFT. When checking\n *   for these keys, it's first necessary to check and see if the key is\n *   coded. This is done with the conditional (= (key) CODED).\n * \n *   The keys included in the ASCII specification (BACKSPACE, TAB, ENTER,\n *   RETURN, ESC, and DELETE) do not require checking to see if they key\n *   is coded, and you should simply use the key variable instead of\n *   key-code If you're making cross-platform projects, note that the\n *   ENTER key is commonly used on PCs and Unix and the RETURN key is\n *   used instead on Macintosh. Check for both ENTER and RETURN to make\n *   sure your program will work for all platforms.\n * \n *   For users familiar with Java, the values for UP and DOWN are simply\n *   shorter versions of Java's KeyEvent.VK_UP and\n *   KeyEvent.VK_DOWN. Other keyCode values can be found in the Java\n *   KeyEvent reference.\n */\nquil.core.key_code = (function quil$core$key_code(){\nreturn quil.sketch.current_applet.call(null).keyCode;\n});\n/**\n * true if any key is currently pressed, false otherwise.\n */\nquil.core.key_pressed_QMARK_ = (function quil$core$key_pressed_QMARK_(){\nreturn quil.sketch.current_applet.call(null).keyPressed;\n});\n/**\n * Sets the falloff rates for point lights, spot lights, and ambient\n *   lights. The parameters are used to determine the falloff with the\n *   following equation:\n * \n *   d = distance from light position to vertex position\n *   falloff = 1 / (CONSTANT + d * LINEAR + (d*d) * QUADRATIC)\n * \n *   Like fill, it affects only the elements which are created after it\n *   in the code. The default value is (light-falloff 1.0 0.0 0.0).\n *   Thinking about an ambient light with a falloff can be tricky. It is\n *   used, for example, if you wanted a region of your scene to be lit\n *   ambiently one color and another region to be lit ambiently by\n *   another color, you would use an ambient light with location and\n *   falloff. You can think of it as a point light that doesn't care\n *   which direction a surface is facing.\n */\nquil.core.light_falloff = (function quil$core$light_falloff(constant,linear,quadratic){\nreturn quil.core.current_graphics.call(null).lightFalloff(constant,linear,quadratic);\n});\n/**\n * Calculates a color or colors between two color at a specific\n *   increment. The amt parameter is the amount to interpolate between\n *   the two values where 0.0 equal to the first point, 0.1 is very near\n *   the first point, 0.5 is half-way in between, etc.\n */\nquil.core.lerp_color = (function quil$core$lerp_color(c1,c2,amt){\nreturn quil.core.current_graphics.call(null).lerpColor(cljs.core.unchecked_int.call(null,c1),cljs.core.unchecked_int.call(null,c2),amt);\n});\n/**\n * Calculates a number between two numbers at a specific\n *   increment. The amt parameter is the amount to interpolate between\n *   the two values where 0.0 equal to the first point, 0.1 is very near\n *   the first point, 0.5 is half-way in between, etc. The lerp function\n *   is convenient for creating motion along a straight path and for\n *   drawing dotted lines.\n */\nquil.core.lerp = (function quil$core$lerp(start,stop,amt){\nreturn quil.sketch.current_applet.call(null).lerp(start,stop,amt);\n});\n/**\n * Sets the default ambient light, directional light, falloff, and\n *   specular values. The defaults are:\n * \n *   (ambient-light 128 128 128)\n *   (directional-light 128 128 128 0 0 -1)\n *   (light-falloff 1 0 0)\n *   (light-specular 0 0 0).\n * \n *   Lights need to be included in the draw to remain persistent in a\n *   looping program. Placing them in the setup of a looping program\n *   will cause them to only have an effect the first time through the\n *   loop.\n */\nquil.core.lights = (function quil$core$lights(){\nreturn quil.core.current_graphics.call(null).lights();\n});\n/**\n * Sets the specular color for lights. Like fill, it affects only the\n *   elements which are created after it in the code. Specular refers to\n *   light which bounces off a surface in a perferred direction (rather\n *   than bouncing in all directions like a diffuse light) and is used\n *   for creating highlights. The specular quality of a light interacts\n *   with the specular material qualities set through the specular and\n *   shininess functions.\n */\nquil.core.light_specular = (function quil$core$light_specular(r,g,b){\nreturn quil.core.current_graphics.call(null).lightSpecular(r,g,b);\n});\n/**\n * Draws a line (a direct path between two points) to the screen. The\n *   version of line with four parameters draws the line in 2D. To color\n *   a line, use the stroke function. A line cannot be filled, therefore\n *   the fill method will not affect the color of a line. 2D lines are\n *   drawn with a width of one pixel by default, but this can be changed\n *   with the stroke-weight function. The version with six parameters\n *   allows the line to be placed anywhere within XYZ space. \n */\nquil.core.line = (function quil$core$line(var_args){\nvar args715 = [];\nvar len__13421__auto___718 = arguments.length;\nvar i__13422__auto___719 = (0);\nwhile(true){\nif((i__13422__auto___719 < len__13421__auto___718)){\nargs715.push((arguments[i__13422__auto___719]));\n\nvar G__720 = (i__13422__auto___719 + (1));\ni__13422__auto___719 = G__720;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__717 = args715.length;\nswitch (G__717) {\ncase (2):\nreturn quil.core.line.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (4):\nreturn quil.core.line.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase (6):\nreturn quil.core.line.cljs$core$IFn$_invoke$arity$6((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args715.length)].join('')));\n\n}\n});\n\nquil.core.line.cljs$core$IFn$_invoke$arity$2 = (function (p1,p2){\nreturn cljs.core.apply.call(null,quil.core.line,cljs.core.concat.call(null,p1,p2));\n});\n\nquil.core.line.cljs$core$IFn$_invoke$arity$4 = (function (x1,y1,x2,y2){\nreturn quil.core.current_graphics.call(null).line(x1,y1,x2,y2);\n});\n\nquil.core.line.cljs$core$IFn$_invoke$arity$6 = (function (x1,y1,z1,x2,y2,z2){\nreturn quil.core.current_graphics.call(null).line(x1,y1,z1,x2,y2,z2);\n});\n\nquil.core.line.cljs$lang$maxFixedArity = (6);\n\n/**\n * Loads a font into a variable of type PFont. To load correctly,\n *   fonts must be located in the data directory of the current sketch.\n *   To create a font to use with Processing use the create-font fn.\n * \n *   Like load-image and other methods that load data, the load-font fn\n *   should not be used inside draw, because it will slow down the sketch\n *   considerably, as the font will be re-loaded from the disk (or\n *   network) on each frame.\n * \n *   For most renderers, Processing displays fonts using the .vlw font\n *   format, which uses images for each letter, rather than defining them\n *   through vector data. When hint :enable-native-fonts is used with the\n *   JAVA2D renderer, the native version of a font will be used if it is\n *   installed on the user's machine.\n * \n *   Using create-font (instead of load-font) enables vector data to be\n *   used with the JAVA2D (default) renderer setting. This can be helpful\n *   when many font sizes are needed, or when using any renderer based on\n *   JAVA2D, such as the PDF library.\n */\nquil.core.load_font = (function quil$core$load_font(filename){\nreturn quil.sketch.current_applet.call(null).loadFont([cljs.core.str(filename)].join(''));\n});\n/**\n * Loads an image into a variable of type PImage. Four types of\n *   images ( .gif, .jpg, .tga, .png) images may be loaded. To load\n *   correctly, images must be located in the data directory of the\n *   current sketch. In most cases, load all images in setup to preload\n *   them at the start of the program. Loading images inside draw will\n *   reduce the speed of a program.\n * \n *   The filename parameter can also be a URL to a file found online.\n * \n *   If an image is not loaded successfully, the null value is returned\n *   and an error message will be printed to the console. The error\n *   message does not halt the program, however the null value may cause\n *   a NullPointerException if your code does not check whether the value\n *   returned from load-image is nil.\n * \n *   Depending on the type of error, a PImage object may still be\n *   returned, but the width and height of the image will be set to\n *   -1. This happens if bad image data is returned or cannot be decoded\n *   properly. Sometimes this happens with image URLs that produce a 403\n *   error or that redirect to a password prompt, because load-image\n *   will attempt to interpret the HTML as image data.\n */\nquil.core.load_image = (function quil$core$load_image(filename){\nreturn quil.sketch.current_applet.call(null).loadImage([cljs.core.str(filename)].join(''));\n});\n/**\n * Loads a shader into the PShader object. Shaders are compatible with the\n *   P2D and P3D renderers, but not with the default renderer.\n */\nquil.core.load_shader = (function quil$core$load_shader(var_args){\nvar args722 = [];\nvar len__13421__auto___725 = arguments.length;\nvar i__13422__auto___726 = (0);\nwhile(true){\nif((i__13422__auto___726 < len__13421__auto___725)){\nargs722.push((arguments[i__13422__auto___726]));\n\nvar G__727 = (i__13422__auto___726 + (1));\ni__13422__auto___726 = G__727;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__724 = args722.length;\nswitch (G__724) {\ncase (1):\nreturn quil.core.load_shader.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core.load_shader.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args722.length)].join('')));\n\n}\n});\n\nquil.core.load_shader.cljs$core$IFn$_invoke$arity$1 = (function (fragment_filename){\nreturn quil.core.current_graphics.call(null).loadShader(fragment_filename);\n});\n\nquil.core.load_shader.cljs$core$IFn$_invoke$arity$2 = (function (fragment_filename,vertex_filename){\nreturn quil.core.current_graphics.call(null).loadShader(fragment_filename,vertex_filename);\n});\n\nquil.core.load_shader.cljs$lang$maxFixedArity = (2);\n\n/**\n * Load a geometry from a file as a PShape.\n */\nquil.core.load_shape = (function quil$core$load_shape(filename){\nreturn quil.sketch.current_applet.call(null).loadShape(filename);\n});\n/**\n * Calculates the natural logarithm (the base-e logarithm) of a\n *   number. This function expects the values greater than 0.0.\n */\nquil.core.log = (function quil$core$log(val){\nreturn quil.sketch.current_applet.call(null).log(val);\n});\n/**\n * Calculates the magnitude (or length) of a vector. A vector is a\n *   direction in space commonly used in computer graphics and linear\n *   algebra. Because it has no start position, the magnitude of a vector\n *   can be thought of as the distance from coordinate (0,0) to its (x,y)\n *   value. Therefore, mag is a shortcut for writing (dist 0 0 x y).\n */\nquil.core.mag = (function quil$core$mag(var_args){\nvar args729 = [];\nvar len__13421__auto___732 = arguments.length;\nvar i__13422__auto___733 = (0);\nwhile(true){\nif((i__13422__auto___733 < len__13421__auto___732)){\nargs729.push((arguments[i__13422__auto___733]));\n\nvar G__734 = (i__13422__auto___733 + (1));\ni__13422__auto___733 = G__734;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__731 = args729.length;\nswitch (G__731) {\ncase (2):\nreturn quil.core.mag.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core.mag.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args729.length)].join('')));\n\n}\n});\n\nquil.core.mag.cljs$core$IFn$_invoke$arity$2 = (function (a,b){\nreturn quil.sketch.current_applet.call(null).mag(a,b);\n});\n\nquil.core.mag.cljs$core$IFn$_invoke$arity$3 = (function (a,b,c){\nreturn quil.sketch.current_applet.call(null).mag(a,b,c);\n});\n\nquil.core.mag.cljs$lang$maxFixedArity = (3);\n\n/**\n * Re-maps a number from one range to another.\n * \n *   Numbers outside the range are not clamped to 0 and 1, because\n *   out-of-range values are often intentional and useful.\n */\nquil.core.map_range = (function quil$core$map_range(val,low1,high1,low2,high2){\nreturn quil.sketch.current_applet.call(null).map(val,low1,high1,low2,high2);\n});\n/**\n * Returns the number of milliseconds (thousandths of a second) since\n *   starting the sketch. This information is often used for timing\n *   animation sequences.\n */\nquil.core.millis = (function quil$core$millis(){\nreturn quil.sketch.current_applet.call(null).millis();\n});\n/**\n * Returns the current minute as a value from 0 - 59\n */\nquil.core.minute = (function quil$core$minute(){\nreturn quil.sketch.current_applet.call(null).minute();\n});\n/**\n * Returns the three-dimensional x, y, z position in model space. This\n *   returns the x value for a given coordinate based on the current set\n *   of transformations (scale, rotate, translate, etc.) The x value can\n *   be used to place an object in space relative to the location of the\n *   original point once the transformations are no longer in use.\n */\nquil.core.model_x = (function quil$core$model_x(x,y,z){\nreturn quil.core.current_graphics.call(null).modelX(x,y,z);\n});\n/**\n * Returns the three-dimensional x, y, z position in model space. This\n *   returns the y value for a given coordinate based on the current set\n *   of transformations (scale, rotate, translate, etc.) The y value can\n *   be used to place an object in space relative to the location of the\n *   original point once the transformations are no longer in use.\n */\nquil.core.model_y = (function quil$core$model_y(x,y,z){\nreturn quil.core.current_graphics.call(null).modelY(x,y,z);\n});\n/**\n * Returns the three-dimensional x, y, z position in model space. This\n *   returns the z value for a given coordinate based on the current set\n *   of transformations (scale, rotate, translate, etc.) The z value can\n *   be used to place an object in space relative to the location of the\n *   original point once the transformations are no longer in use.\n */\nquil.core.model_z = (function quil$core$model_z(x,y,z){\nreturn quil.core.current_graphics.call(null).modelZ(x,y,z);\n});\n/**\n * Returns the current month as a value from 1 - 12.\n */\nquil.core.month = (function quil$core$month(){\nreturn quil.sketch.current_applet.call(null).month();\n});\n/**\n * The value of the system variable mouseButton is either :left, :right,\n *   or :center depending on which button is pressed. nil if no button pressed\n */\nquil.core.mouse_button = (function quil$core$mouse_button(){\nvar button_code = quil.sketch.current_applet.call(null).mouseButton;\nvar pred__739 = cljs.core._EQ_;\nvar expr__740 = button_code;\nif(cljs.core.truth_(pred__739.call(null,(37),expr__740))){\nreturn new cljs.core.Keyword(null,\"left\",\"left\",(-399115937));\n} else {\nif(cljs.core.truth_(pred__739.call(null,(39),expr__740))){\nreturn new cljs.core.Keyword(null,\"right\",\"right\",(-452581833));\n} else {\nif(cljs.core.truth_(pred__739.call(null,(3),expr__740))){\nreturn new cljs.core.Keyword(null,\"center\",\"center\",(-748944368));\n} else {\nreturn null;\n}\n}\n}\n});\n/**\n * Variable storing if a mouse button is pressed. The value of the\n *   system variable mousePressed is true if a mouse button is pressed\n *   and false if a button is not pressed.\n */\nquil.core.mouse_pressed_QMARK_ = (function quil$core$mouse_pressed_QMARK_(){\nreturn quil.sketch.current_applet.call(null).mousePressed;\n});\n/**\n * Current horizontal coordinate of the mouse.\n */\nquil.core.mouse_x = (function quil$core$mouse_x(){\nreturn quil.sketch.current_applet.call(null).mouseX;\n});\n/**\n * Current vertical coordinate of the mouse.\n */\nquil.core.mouse_y = (function quil$core$mouse_y(){\nreturn quil.sketch.current_applet.call(null).mouseY;\n});\n/**\n * Hides the cursor from view. Will not work when running the in full\n *   screen (Present) mode.\n */\nquil.core.no_cursor = (function quil$core$no_cursor(){\nreturn quil.sketch.current_applet.call(null).noCursor();\n});\n/**\n * Disables filling geometry. If both no-stroke and no-fill are called,\n *   nothing will be drawn to the screen.\n */\nquil.core.no_fill = (function quil$core$no_fill(){\nquil.core.current_graphics.call(null).noFill();\n\nreturn (quil.core.current_graphics.call(null)[quil.core.no_fill_prop] = true);\n});\n/**\n * Returns the Perlin noise value at specified coordinates. Perlin\n *   noise is a random sequence generator producing a more natural\n *   ordered, harmonic succession of numbers compared to the standard\n *   random function. It was invented by Ken Perlin in the 1980s and\n *   been used since in graphical applications to produce procedural\n *   textures, natural motion, shapes, terrains etc.\n * \n *   The main difference to the random function is that Perlin noise is\n *   defined in an infinite n-dimensional space where each pair of\n *   coordinates corresponds to a fixed semi-random value (fixed only for\n *   the lifespan of the program). The resulting value will always be\n *   between 0.0 and 1.0. Processing can compute 1D, 2D and 3D noise,\n *   depending on the number of coordinates given. The noise value can be\n *   animated by moving through the noise space and the 2nd and 3rd\n *   dimensions can also be interpreted as time.\n * \n *   The actual noise is structured similar to an audio signal, in\n *   respect to the function's use of frequencies. Similar to the concept\n *   of harmonics in physics, perlin noise is computed over several\n *   octaves which are added together for the final result.\n * \n *   Another way to adjust the character of the resulting sequence is the\n *   scale of the input coordinates. As the function works within an\n *   infinite space the value of the coordinates doesn't matter as such,\n *   only the distance between successive coordinates does (eg. when\n *   using noise within a loop). As a general rule the smaller the\n *   difference between coordinates, the smoother the resulting noise\n *   sequence will be. Steps of 0.005-0.03 work best for most\n *   applications, but this will differ depending on use.\n */\nquil.core.noise = (function quil$core$noise(var_args){\nvar args742 = [];\nvar len__13421__auto___745 = arguments.length;\nvar i__13422__auto___746 = (0);\nwhile(true){\nif((i__13422__auto___746 < len__13421__auto___745)){\nargs742.push((arguments[i__13422__auto___746]));\n\nvar G__747 = (i__13422__auto___746 + (1));\ni__13422__auto___746 = G__747;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__744 = args742.length;\nswitch (G__744) {\ncase (1):\nreturn quil.core.noise.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core.noise.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core.noise.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args742.length)].join('')));\n\n}\n});\n\nquil.core.noise.cljs$core$IFn$_invoke$arity$1 = (function (x){\nreturn quil.sketch.current_applet.call(null).noise(x);\n});\n\nquil.core.noise.cljs$core$IFn$_invoke$arity$2 = (function (x,y){\nreturn quil.sketch.current_applet.call(null).noise(x,y);\n});\n\nquil.core.noise.cljs$core$IFn$_invoke$arity$3 = (function (x,y,z){\nreturn quil.sketch.current_applet.call(null).noise(x,y,z);\n});\n\nquil.core.noise.cljs$lang$maxFixedArity = (3);\n\n/**\n * Adjusts the character and level of detail produced by the Perlin\n *   noise function. Similar to harmonics in physics, noise is computed\n *   over several octaves. Lower octaves contribute more to the output\n *   signal and as such define the overal intensity of the noise, whereas\n *   higher octaves create finer grained details in the noise\n *   sequence. By default, noise is computed over 4 octaves with each\n *   octave contributing exactly half than its predecessor, starting at\n *   50% strength for the 1st octave. This falloff amount can be changed\n *   by adding an additional function parameter. Eg. a falloff factor of\n *   0.75 means each octave will now have 75% impact (25% less) of the\n *   previous lower octave. Any value between 0.0 and 1.0 is valid,\n *   however note that values greater than 0.5 might result in greater\n *   than 1.0 values returned by noise.\n * \n *   By changing these parameters, the signal created by the noise\n *   function can be adapted to fit very specific needs and\n *   characteristics.\n */\nquil.core.noise_detail = (function quil$core$noise_detail(var_args){\nvar args749 = [];\nvar len__13421__auto___752 = arguments.length;\nvar i__13422__auto___753 = (0);\nwhile(true){\nif((i__13422__auto___753 < len__13421__auto___752)){\nargs749.push((arguments[i__13422__auto___753]));\n\nvar G__754 = (i__13422__auto___753 + (1));\ni__13422__auto___753 = G__754;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__751 = args749.length;\nswitch (G__751) {\ncase (1):\nreturn quil.core.noise_detail.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core.noise_detail.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args749.length)].join('')));\n\n}\n});\n\nquil.core.noise_detail.cljs$core$IFn$_invoke$arity$1 = (function (octaves){\nreturn quil.sketch.current_applet.call(null).noiseDetail((octaves | (0)));\n});\n\nquil.core.noise_detail.cljs$core$IFn$_invoke$arity$2 = (function (octaves,falloff){\nreturn quil.sketch.current_applet.call(null).noiseDetail((octaves | (0)),falloff);\n});\n\nquil.core.noise_detail.cljs$lang$maxFixedArity = (2);\n\n/**\n * Sets the seed value for noise. By default, noise produces different\n *   results each time the program is run. Set the value parameter to a\n *   constant to return the same pseudo-random numbers each time the\n *   software is run.\n */\nquil.core.noise_seed = (function quil$core$noise_seed(val){\nreturn quil.sketch.current_applet.call(null).noiseSeed((val | (0)));\n});\n/**\n * Disable all lighting. Lighting is turned off by default and enabled\n *   with the lights fn. This function can be used to disable lighting so\n *   that 2D geometry (which does not require lighting) can be drawn\n *   after a set of lighted 3D geometry.\n */\nquil.core.no_lights = (function quil$core$no_lights(){\nreturn quil.core.current_graphics.call(null).noLights();\n});\n/**\n * Stops Processing from continuously executing the code within\n *   draw. If start-loop is called, the code in draw will begin to run\n *   continuously again. If using no-loop in setup, it should be the last\n *   line inside the block.\n * \n *   When no-loop is used, it's not possible to manipulate or access the\n *   screen inside event handling functions such as mouse-pressed or\n *   key-pressed. Instead, use those functions to call redraw or\n *   loop which will run draw, which can update the screen\n *   properly. This means that when no-loop has been called, no drawing\n *   can happen, and functions like save-frame may not be used.\n * \n *   Note that if the sketch is resized, redraw will be called to\n *   update the sketch, even after no-oop has been\n *   specified. Otherwise, the sketch would enter an odd state until\n *   loop was called.\n */\nquil.core.no_loop = (function quil$core$no_loop(){\nreturn quil.sketch.current_applet.call(null).noLoop();\n});\n/**\n * Normalize a value to exist between 0 and 1 (inclusive).\n */\nquil.core.norm = (function quil$core$norm(val,start,stop){\nreturn quil.sketch.current_applet.call(null).norm(val,start,stop);\n});\n/**\n * Sets the current normal vector. This is for drawing three\n *   dimensional shapes and surfaces and specifies a vector perpendicular\n *   to the surface of the shape which determines how lighting affects\n *   it. Processing attempts to automatically assign normals to shapes,\n *   but since that's imperfect, this is a better option when you want\n *   more control. This function is identical to glNormal3f() in OpenGL.\n */\nquil.core.normal = (function quil$core$normal(nx,ny,nz){\nreturn quil.core.current_graphics.call(null).normal(nx,ny,nz);\n});\n/**\n * Draws all geometry with jagged (aliased) edges. Must be called inside\n *   :settings handler.\n */\nquil.core.no_smooth = (function quil$core$no_smooth(){\nreturn quil.core.current_graphics.call(null).noSmooth();\n});\n/**\n * Disables drawing the stroke (outline). If both no-stroke and\n *   no-fill are called, nothing will be drawn to the screen.\n */\nquil.core.no_stroke = (function quil$core$no_stroke(){\nreturn quil.core.current_graphics.call(null).noStroke();\n});\n/**\n * Removes the current fill value for displaying images and reverts to\n *   displaying images with their original hues.\n */\nquil.core.no_tint = (function quil$core$no_tint(){\nreturn quil.core.current_graphics.call(null).noTint();\n});\n/**\n * Sets an orthographic projection and defines a parallel clipping\n *   volume. All objects with the same dimension appear the same size,\n *   regardless of whether they are near or far from the camera. The\n *   parameters to this function specify the clipping volume where left\n *   and right are the minimum and maximum x values, top and bottom are\n *   the minimum and maximum y values, and near and far are the minimum\n *   and maximum z values. If no parameters are given, the default is\n *   used: (ortho 0 width 0 height -10 10)\n */\nquil.core.ortho = (function quil$core$ortho(var_args){\nvar args756 = [];\nvar len__13421__auto___759 = arguments.length;\nvar i__13422__auto___760 = (0);\nwhile(true){\nif((i__13422__auto___760 < len__13421__auto___759)){\nargs756.push((arguments[i__13422__auto___760]));\n\nvar G__761 = (i__13422__auto___760 + (1));\ni__13422__auto___760 = G__761;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__758 = args756.length;\nswitch (G__758) {\ncase (0):\nreturn quil.core.ortho.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase (4):\nreturn quil.core.ortho.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase (6):\nreturn quil.core.ortho.cljs$core$IFn$_invoke$arity$6((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args756.length)].join('')));\n\n}\n});\n\nquil.core.ortho.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn quil.core.current_graphics.call(null).ortho();\n});\n\nquil.core.ortho.cljs$core$IFn$_invoke$arity$4 = (function (left,right,bottom,top){\nreturn quil.core.current_graphics.call(null).ortho(left,right,bottom,top);\n});\n\nquil.core.ortho.cljs$core$IFn$_invoke$arity$6 = (function (left,right,bottom,top,near,far){\nreturn quil.core.current_graphics.call(null).ortho(left,right,bottom,top,near,far);\n});\n\nquil.core.ortho.cljs$lang$maxFixedArity = (6);\n\n/**\n * Sets a perspective projection applying foreshortening, making\n *   distant objects appear smaller than closer ones. The parameters\n *   define a viewing volume with the shape of truncated pyramid. Objects\n *   near to the front of the volume appear their actual size, while\n *   farther objects appear smaller. This projection simulates the\n *   perspective of the world more accurately than orthographic\n *   projection. The version of perspective without parameters sets the\n *   default perspective and the version with four parameters allows the\n *   programmer to set the area precisely. The default values are:\n *   perspective(PI/3.0, width/height, cameraZ/10.0, cameraZ*10.0) where\n *   cameraZ is ((height/2.0) / tan(PI*60.0/360.0));\n */\nquil.core.perspective = (function quil$core$perspective(var_args){\nvar args763 = [];\nvar len__13421__auto___766 = arguments.length;\nvar i__13422__auto___767 = (0);\nwhile(true){\nif((i__13422__auto___767 < len__13421__auto___766)){\nargs763.push((arguments[i__13422__auto___767]));\n\nvar G__768 = (i__13422__auto___767 + (1));\ni__13422__auto___767 = G__768;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__765 = args763.length;\nswitch (G__765) {\ncase (0):\nreturn quil.core.perspective.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase (4):\nreturn quil.core.perspective.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args763.length)].join('')));\n\n}\n});\n\nquil.core.perspective.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn quil.core.current_graphics.call(null).perspective();\n});\n\nquil.core.perspective.cljs$core$IFn$_invoke$arity$4 = (function (fovy,aspect,z_near,z_far){\nreturn quil.core.current_graphics.call(null).perspective(fovy,aspect,z_near,z_far);\n});\n\nquil.core.perspective.cljs$lang$maxFixedArity = (4);\n\n/**\n * Array containing the values for all the pixels in the display\n *   window or image. This array is therefore the size of the display window. If\n *   this array is modified, the update-pixels fn must be called to update\n *   the changes. Calls .loadPixels before obtaining the pixel array.\n */\nquil.core.pixels = (function quil$core$pixels(var_args){\nvar args770 = [];\nvar len__13421__auto___773 = arguments.length;\nvar i__13422__auto___774 = (0);\nwhile(true){\nif((i__13422__auto___774 < len__13421__auto___773)){\nargs770.push((arguments[i__13422__auto___774]));\n\nvar G__775 = (i__13422__auto___774 + (1));\ni__13422__auto___774 = G__775;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__772 = args770.length;\nswitch (G__772) {\ncase (0):\nreturn quil.core.pixels.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase (1):\nreturn quil.core.pixels.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args770.length)].join('')));\n\n}\n});\n\nquil.core.pixels.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn quil.core.pixels.call(null,quil.core.current_graphics.call(null));\n});\n\nquil.core.pixels.cljs$core$IFn$_invoke$arity$1 = (function (img){\nimg.loadPixels();\n\nvar pix_array = img.pixels.toArray();\nimg.stored_pix_array = pix_array;\n\nreturn pix_array;\n});\n\nquil.core.pixels.cljs$lang$maxFixedArity = (1);\n\n/**\n * Horizontal coordinate of the mouse in the previous frame\n */\nquil.core.pmouse_x = (function quil$core$pmouse_x(){\nreturn quil.sketch.current_applet.call(null).pmouseX;\n});\n/**\n * Vertical coordinate of the mouse in the previous frame\n */\nquil.core.pmouse_y = (function quil$core$pmouse_y(){\nreturn quil.sketch.current_applet.call(null).pmouseY;\n});\n/**\n * Draws a point, a coordinate in space at the dimension of one\n *   pixel. The first parameter is the horizontal value for the point,\n *   the second value is the vertical value for the point, and the\n *   optional third value is the depth value. Drawing this shape in 3D\n *   using the z parameter requires the :P3D or :opengl renderer to be\n *   used.\n */\nquil.core.point = (function quil$core$point(var_args){\nvar args777 = [];\nvar len__13421__auto___780 = arguments.length;\nvar i__13422__auto___781 = (0);\nwhile(true){\nif((i__13422__auto___781 < len__13421__auto___780)){\nargs777.push((arguments[i__13422__auto___781]));\n\nvar G__782 = (i__13422__auto___781 + (1));\ni__13422__auto___781 = G__782;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__779 = args777.length;\nswitch (G__779) {\ncase (2):\nreturn quil.core.point.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core.point.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args777.length)].join('')));\n\n}\n});\n\nquil.core.point.cljs$core$IFn$_invoke$arity$2 = (function (x,y){\nreturn quil.core.current_graphics.call(null).point(x,y);\n});\n\nquil.core.point.cljs$core$IFn$_invoke$arity$3 = (function (x,y,z){\nreturn quil.core.current_graphics.call(null).point(x,y,z);\n});\n\nquil.core.point.cljs$lang$maxFixedArity = (3);\n\n/**\n * Adds a point light. Lights need to be included in the draw() to\n *   remain persistent in a looping program. Placing them in the setup()\n *   of a looping program will cause them to only have an effect the\n *   first time through the loop. The affect of the r, g, and b\n *   parameters is determined by the current color mode. The x, y, and z\n *   parameters set the position of the light\n */\nquil.core.point_light = (function quil$core$point_light(r,g,b,x,y,z){\nreturn quil.core.current_graphics.call(null).pointLight(r,g,b,x,y,z);\n});\n/**\n * Pops the current transformation matrix off the matrix\n *   stack. Understanding pushing and popping requires understanding the\n *   concept of a matrix stack. The push-matrix fn saves the current\n *   coordinate system to the stack and pop-matrix restores the prior\n *   coordinate system. push-matrix and pop-matrix are used in conjuction\n *   with the other transformation methods and may be embedded to control\n *   the scope of the transformations.\n */\nquil.core.pop_matrix = (function quil$core$pop_matrix(){\nreturn quil.core.current_graphics.call(null).popMatrix();\n});\n/**\n * Restores the prior settings on the 'style stack'. Used in\n *   conjunction with push-style. Together they allow you to change the\n *   style settings and later return to what you had. When a new style is\n *   started with push-style, it builds on the current style information.\n *   The push-style and pop-style functions can be nested to provide more\n *   control\n */\nquil.core.pop_style = (function quil$core$pop_style(){\nreturn quil.core.current_graphics.call(null).popStyle();\n});\n/**\n * Facilitates exponential expressions. The pow() function is an\n *   efficient way of multiplying numbers by themselves (or their\n *   reciprocal) in large quantities. For example, (pow 3 5) is\n *   equivalent to the expression (* 3 3 3 3 3) and (pow 3 -5) is\n *   equivalent to (/ 1 (* 3 3 3 3 3)).\n */\nquil.core.pow = (function quil$core$pow(num,exponent){\nreturn quil.sketch.current_applet.call(null).pow(num,exponent);\n});\n/**\n * Prints the current camera matrix to std out. Useful for debugging.\n */\nquil.core.print_camera = (function quil$core$print_camera(){\nreturn quil.core.current_graphics.call(null).printCamera();\n});\n/**\n * Prints the current matrix to std out. Useful for debugging.\n */\nquil.core.print_matrix = (function quil$core$print_matrix(){\nreturn quil.core.current_graphics.call(null).printMatrix();\n});\n/**\n * Prints the current projection matrix to std out. Useful for\n *   debugging\n */\nquil.core.print_projection = (function quil$core$print_projection(){\nreturn quil.core.current_graphics.call(null).printProjection();\n});\n/**\n * Pushes the current transformation matrix onto the matrix\n *   stack. Understanding push-matrix and pop-matrix requires\n *   understanding the concept of a matrix stack. The push-matrix\n *   function saves the current coordinate system to the stack and\n *   pop-matrix restores the prior coordinate system. push-matrix and\n *   pop-matrix are used in conjuction with the other transformation\n *   methods and may be embedded to control the scope of the\n *   transformations.\n */\nquil.core.push_matrix = (function quil$core$push_matrix(){\nreturn quil.core.current_graphics.call(null).pushMatrix();\n});\n/**\n * Saves the current style settings onto a 'style stack'. Use with\n *   pop-style which restores the prior settings. Note that these\n *   functions are always used together. They allow you to change the\n *   style settings and later return to what you had. When a new style is\n *   started with push-style, it builds on the current style\n *   information. The push-style and pop-style fns can be embedded to\n *   provide more control.\n * \n *   The style information controlled by the following functions are\n *   included in the style: fill, stroke, tint, stroke-weight,\n *   stroke-cap, stroke-join, image-mode, rect-mode, ellipse-mode,\n *   shape-mode, color-mode, text-align, text-font, text-mode, text-size,\n *   text-leading, emissive, specular, shininess, and ambient\n */\nquil.core.push_style = (function quil$core$push_style(){\nreturn quil.core.current_graphics.call(null).pushStyle();\n});\n/**\n * A quad is a quadrilateral, a four sided polygon. It is similar to a\n *   rectangle, but the angles between its edges are not constrained to\n *   be ninety degrees. The first pair of parameters (x1,y1) sets the\n *   first vertex and the subsequent pairs should proceed clockwise or\n *   counter-clockwise around the defined shape.\n */\nquil.core.quad = (function quil$core$quad(x1,y1,x2,y2,x3,y3,x4,y4){\nreturn quil.core.current_graphics.call(null).quad(x1,y1,x2,y2,x3,y3,x4,y4);\n});\n/**\n * Specifies vertex coordinates for quadratic Bezier curves. Each call to\n *   quadratic-vertex defines the position of one control points and one\n *   anchor point of a Bezier curve, adding a new segment to a line or shape.\n *   The first time quadratic-vertex is used within a begin-shape call, it\n *   must be prefaced with a call to vertex to set the first anchor point.\n *   This function must be used between begin-shape and end-shape and only\n *   when there is no MODE parameter specified to begin-shape. Using the 3D\n *   version requires rendering with :p3d.\n */\nquil.core.quadratic_vertex = (function quil$core$quadratic_vertex(var_args){\nvar args784 = [];\nvar len__13421__auto___787 = arguments.length;\nvar i__13422__auto___788 = (0);\nwhile(true){\nif((i__13422__auto___788 < len__13421__auto___787)){\nargs784.push((arguments[i__13422__auto___788]));\n\nvar G__789 = (i__13422__auto___788 + (1));\ni__13422__auto___788 = G__789;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__786 = args784.length;\nswitch (G__786) {\ncase (4):\nreturn quil.core.quadratic_vertex.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase (6):\nreturn quil.core.quadratic_vertex.cljs$core$IFn$_invoke$arity$6((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args784.length)].join('')));\n\n}\n});\n\nquil.core.quadratic_vertex.cljs$core$IFn$_invoke$arity$4 = (function (cx,cy,x3,y3){\nreturn quil.core.current_graphics.call(null).quadraticVertex(cx,cy,x3,y3);\n});\n\nquil.core.quadratic_vertex.cljs$core$IFn$_invoke$arity$6 = (function (cx,cy,cz,x3,y3,z3){\nreturn quil.core.current_graphics.call(null).quadraticVertex(cx,cy,cz,x3,y3,z3);\n});\n\nquil.core.quadratic_vertex.cljs$lang$maxFixedArity = (6);\n\n/**\n * Converts a degree measurement to its corresponding value in\n *   radians. Radians and degrees are two ways of measuring the same\n *   thing. There are 360 degrees in a circle and 2*PI radians in a\n *   circle. For example, 90° = PI/2 = 1.5707964. All trigonometric\n *   methods in Processing require their parameters to be specified in\n *   radians.\n */\nquil.core.radians = (function quil$core$radians(degrees){\nreturn quil.sketch.current_applet.call(null).radians(degrees);\n});\n/**\n * Generates random numbers. Each time the random function is called,\n *   it returns an unexpected value within the specified range. If one\n *   parameter is passed to the function it will return a float between\n *   zero and the value of the high parameter. The function call (random\n *   5) returns values between 0 and 5 (starting at zero, up to but not\n *   including 5). If two parameters are passed, it will return a float\n *   with a value between the parameters. The function call\n *   (random -5 10.2) returns values starting at -5 up to (but not\n *   including) 10.2.\n */\nquil.core.random = (function quil$core$random(var_args){\nvar args791 = [];\nvar len__13421__auto___794 = arguments.length;\nvar i__13422__auto___795 = (0);\nwhile(true){\nif((i__13422__auto___795 < len__13421__auto___794)){\nargs791.push((arguments[i__13422__auto___795]));\n\nvar G__796 = (i__13422__auto___795 + (1));\ni__13422__auto___795 = G__796;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__793 = args791.length;\nswitch (G__793) {\ncase (1):\nreturn quil.core.random.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core.random.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args791.length)].join('')));\n\n}\n});\n\nquil.core.random.cljs$core$IFn$_invoke$arity$1 = (function (max){\nreturn quil.sketch.current_applet.call(null).random(max);\n});\n\nquil.core.random.cljs$core$IFn$_invoke$arity$2 = (function (min,max){\nreturn quil.sketch.current_applet.call(null).random(min,max);\n});\n\nquil.core.random.cljs$lang$maxFixedArity = (2);\n\n/**\n * Returns a float from a random series of numbers having a mean of 0 and\n *   standard deviation of 1. Each time the randomGaussian() function is called,\n *   it returns a number fitting a Gaussian, or normal, distribution.\n *   There is theoretically no minimum or maximum value that randomGaussian()\n *   might return. Rather, there is just a very low probability that values far\n *   from the mean will be returned; and a higher probability that numbers near\n *   the mean will be returned. .\n */\nquil.core.random_gaussian = (function quil$core$random_gaussian(){\nreturn quil.sketch.current_applet.call(null).randomGaussian();\n});\n/**\n * Sets the seed value for random. By default, random produces\n *   different results each time the program is run. Set the value\n *   parameter to a constant to return the same pseudo-random numbers\n *   each time the software is run.\n */\nquil.core.random_seed = (function quil$core$random_seed(w){\nreturn quil.sketch.current_applet.call(null).randomSeed(w);\n});\n/**\n * Contains the value of the most recent key on the keyboard that was\n *   used (either pressed or released).\n * \n *   For non-ASCII keys, use the keyCode variable. The keys included in\n *   the ASCII specification (BACKSPACE, TAB, ENTER, RETURN, ESC, and\n *   DELETE) do not require checking to see if they key is coded, and you\n *   should simply use the key variable instead of keyCode If you're\n *   making cross-platform projects, note that the ENTER key is commonly\n *   used on PCs and Unix and the RETURN key is used instead on\n *   Macintosh. Check for both ENTER and RETURN to make sure your program\n *   will work for all platforms.\n */\nquil.core.raw_key = (function quil$core$raw_key(){\nreturn quil.sketch.current_applet.call(null).key;\n});\n/**\n * Draws a rectangle to the screen. A rectangle is a four-sided shape\n *   with every angle at ninety degrees. By default, the first two\n *   parameters set the location of the upper-left corner, the third\n *   sets the width, and the fourth sets the height. These parameters\n *   may be changed with rect-mode.\n * \n *   To draw a rounded rectangle, add a fifth parameter, which is used as\n *   the radius value for all four corners. To use a different radius value\n *   for each corner, include eight parameters.\n */\nquil.core.rect = (function quil$core$rect(var_args){\nvar args798 = [];\nvar len__13421__auto___801 = arguments.length;\nvar i__13422__auto___802 = (0);\nwhile(true){\nif((i__13422__auto___802 < len__13421__auto___801)){\nargs798.push((arguments[i__13422__auto___802]));\n\nvar G__803 = (i__13422__auto___802 + (1));\ni__13422__auto___802 = G__803;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__800 = args798.length;\nswitch (G__800) {\ncase (4):\nreturn quil.core.rect.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase (5):\nreturn quil.core.rect.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ncase (8):\nreturn quil.core.rect.cljs$core$IFn$_invoke$arity$8((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args798.length)].join('')));\n\n}\n});\n\nquil.core.rect.cljs$core$IFn$_invoke$arity$4 = (function (x,y,width,height){\nreturn quil.core.current_graphics.call(null).rect(x,y,width,height);\n});\n\nquil.core.rect.cljs$core$IFn$_invoke$arity$5 = (function (x,y,width,height,r){\nreturn quil.core.current_graphics.call(null).rect(x,y,width,height,r);\n});\n\nquil.core.rect.cljs$core$IFn$_invoke$arity$8 = (function (x,y,width,height,top_left_r,top_right_r,bottom_right_r,bottom_left_r){\nreturn quil.core.current_graphics.call(null).rect(x,y,width,height,top_left_r,top_right_r,bottom_right_r,bottom_left_r);\n});\n\nquil.core.rect.cljs$lang$maxFixedArity = (8);\n\n/**\n * Modifies the location from which rectangles draw. The default mode\n *   is :corner. Available modes are:\n * \n * \n *   :corner  - Specifies the location to be the upper left corner of the\n *           shape and uses the third and fourth parameters of rect to\n *           specify the width and height.\n * \n *   :corners - Uses the first and second parameters of rect to set the\n *           location of one corner and uses the third and fourth\n *           parameters to set the opposite corner.\n * \n *   :center  - Draws the image from its center point and uses the third\n *           and forth parameters of rect to specify the image's width\n *           and height.\n * \n *   :radius  - Draws the image from its center point and uses the third\n *           and forth parameters of rect() to specify half of the\n *           image's width and height.\n */\nquil.core.rect_mode = (function quil$core$rect_mode(mode){\nvar mode__$1 = quil.util.resolve_constant_key.call(null,mode,quil.core.rect_modes);\nreturn quil.core.current_graphics.call(null).rectMode((mode__$1 | (0)));\n});\n/**\n * Extracts the red value from a color, scaled to match current color-mode.\n */\nquil.core.red = (function quil$core$red(c){\nreturn quil.core.current_graphics.call(null).red(cljs.core.unchecked_int.call(null,c));\n});\n/**\n * Executes the code within the draw fn one time. This functions\n *   allows the program to update the display window only when necessary,\n *   for example when an event registered by mouse-pressed or\n *   key-pressed occurs.\n * \n *   In structuring a program, it only makes sense to call redraw\n *   within events such as mouse-pressed. This is because redraw does\n *   not run draw immediately (it only sets a flag that indicates an\n *   update is needed).\n * \n *   Calling redraw within draw has no effect because draw is\n *   continuously called anyway.\n */\nquil.core.redraw = (function quil$core$redraw(){\nreturn quil.sketch.current_applet.call(null).redraw();\n});\n/**\n * This function load images on a separate thread so that your sketch\n *   does not freeze while images load during setup. While the image is\n *   loading, its width and height will be 0. If an error occurs while\n *   loading the image, its width and height will be set to -1. You'll\n *   know when the image has loaded properly because its width and height\n *   will be greater than 0. Asynchronous image loading (particularly\n *   when downloading from a server) can dramatically improve\n *   performance.\n */\nquil.core.request_image = (function quil$core$request_image(filename){\nreturn quil.sketch.current_applet.call(null).requestImage([cljs.core.str(filename)].join(''));\n});\n/**\n * Replaces the current matrix with the identity matrix. The\n *   equivalent function in OpenGL is glLoadIdentity()\n */\nquil.core.reset_matrix = (function quil$core$reset_matrix(){\nreturn quil.core.current_graphics.call(null).resetMatrix();\n});\n/**\n * Resize the image to a new width and height.\n *   To make the image scale proportionally, use 0 as the value for the wide or\n *   high parameter. For instance, to make the width of an image 150 pixels,\n *   and change the height using the same proportion, use resize(150, 0).\n * \n *   Even though a PGraphics is technically a PImage, it is not possible\n *   to rescale the image data found in a PGraphics.\n *   (It's simply not possible to do this consistently across renderers:\n *   technically infeasible with P3D, or what would it even do with PDF?)\n *   If you want to resize PGraphics content, first get a copy of its image data\n *   using the get() method, and call resize() on the PImage that is returned.\n */\nquil.core.resize = (function quil$core$resize(img,w,h){\nreturn img.resize(w,h);\n});\n/**\n * Rotates a shape the amount specified by the angle parameter. Angles\n *   should be specified in radians (values from 0 to TWO-PI) or\n *   converted to radians with the radians function.\n * \n *   Objects are always rotated around their relative position to the\n *   origin and positive numbers rotate objects in a clockwise\n *   direction. Transformations apply to everything that happens after\n *   and subsequent calls to the function accumulates the effect. For\n *   example, calling (rotate HALF-PI) and then (rotate HALF-PI) is the\n *   same as (rotate PI). All tranformations are reset when draw begins\n *   again.\n * \n *   Technically, rotate multiplies the current transformation matrix by\n *   a rotation matrix. This function can be further controlled by the\n *   push-matrix and pop-matrix.\n */\nquil.core.rotate = (function quil$core$rotate(var_args){\nvar args805 = [];\nvar len__13421__auto___808 = arguments.length;\nvar i__13422__auto___809 = (0);\nwhile(true){\nif((i__13422__auto___809 < len__13421__auto___808)){\nargs805.push((arguments[i__13422__auto___809]));\n\nvar G__810 = (i__13422__auto___809 + (1));\ni__13422__auto___809 = G__810;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__807 = args805.length;\nswitch (G__807) {\ncase (1):\nreturn quil.core.rotate.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (4):\nreturn quil.core.rotate.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args805.length)].join('')));\n\n}\n});\n\nquil.core.rotate.cljs$core$IFn$_invoke$arity$1 = (function (angle){\nreturn quil.core.current_graphics.call(null).rotate(angle);\n});\n\nquil.core.rotate.cljs$core$IFn$_invoke$arity$4 = (function (angle,vx,vy,vz){\nreturn quil.core.current_graphics.call(null).rotate(angle,vx,vy,vz);\n});\n\nquil.core.rotate.cljs$lang$maxFixedArity = (4);\n\n/**\n * Rotates a shape around the x-axis the amount specified by the angle\n *   parameter. Angles should be specified in radians (values from 0 to\n *   (* PI 2)) or converted to radians with the radians function. Objects\n *   are always rotated around their relative position to the origin and\n *   positive numbers rotate objects in a counterclockwise\n *   direction. Transformations apply to everything that happens after\n *   and subsequent calls to the function accumulates the effect. For\n *   example, calling (rotate-x HALF-PI) and then (rotate-x HALF-PI) is\n *   the same as (rotate-x PI). If rotate-x is called within the draw fn,\n *   the transformation is reset when the loop begins again. This\n *   function requires either the :p3d or :opengl renderer.\n */\nquil.core.rotate_x = (function quil$core$rotate_x(angle){\nreturn quil.core.current_graphics.call(null).rotateX(angle);\n});\n/**\n * Rotates a shape around the y-axis the amount specified by the angle\n *   parameter. Angles should be specified in radians (values from 0\n *   to (* PI 2)) or converted to radians with the radians function.\n *   Objects are always rotated around their relative position to the\n *   origin and positive numbers rotate objects in a counterclockwise\n *   direction. Transformations apply to everything that happens after\n *   and subsequent calls to the function accumulates the effect. For\n *   example, calling (rotate-y HALF-PI) and then (rotate-y HALF-PI) is\n *   the same as (rotate-y PI). If rotate-y is called within the draw fn,\n *   the transformation is reset when the loop begins again. This\n *   function requires either the :p3d or :opengl renderer.\n */\nquil.core.rotate_y = (function quil$core$rotate_y(angle){\nreturn quil.core.current_graphics.call(null).rotateY(angle);\n});\n/**\n * Rotates a shape around the z-axis the amount specified by the angle\n *   parameter. Angles should be specified in radians (values from 0\n *   to (* PI 2)) or converted to radians with the radians function.\n *   Objects are always rotated around their relative position to the\n *   origin and positive numbers rotate objects in a counterclockwise\n *   direction. Transformations apply to everything that happens after\n *   and subsequent calls to the function accumulates the effect. For\n *   example, calling (rotate-z HALF-PI) and then (rotate-z HALF-PI) is\n *   the same as (rotate-z PI). If rotate-y is called within the draw fn,\n *   the transformation is reset when the loop begins again. This\n *   function requires either the :p3d or :opengl renderer.\n */\nquil.core.rotate_z = (function quil$core$rotate_z(angle){\nreturn quil.core.current_graphics.call(null).rotateZ(angle);\n});\n/**\n * Calculates the integer closest to the value parameter. For example,\n *   (round 9.2) returns the value 9.\n */\nquil.core.round = (function quil$core$round(val){\nreturn quil.sketch.current_applet.call(null).round(val);\n});\n/**\n * Extracts the saturation value from a color.\n */\nquil.core.saturation = (function quil$core$saturation(c){\nreturn quil.core.current_graphics.call(null).saturation(cljs.core.unchecked_int.call(null,c));\n});\n/**\n * Saves an image from the display window. Images are saved in TIFF,\n *   TARGA, JPEG, and PNG format depending on the extension within the\n *   filename parameter. For example, image.tif will have a TIFF image\n *   and image.png will save a PNG image. If no extension is included in\n *   the filename, the image will save in TIFF format and .tif will be\n *   added to the name. All images saved from the main drawing window\n *   will be opaque. To save images without a background, use\n *   create-graphics.\n */\nquil.core.save = (function quil$core$save(filename){\nreturn quil.core.current_graphics.call(null).save([cljs.core.str(filename)].join(''));\n});\n/**\n * Saves an image identical to the current display window as a\n *   file. May be called multple times - each file saved will have a\n *   unique name. Name and image formate may be modified by passing a\n *   string parameter of the form \"foo-####.ext\" where foo- can be any\n *   arbitrary string, #### will be replaced with the current frame id\n *   and .ext is one of .tiff, .targa, .png, .jpeg or .jpg\n * \n *   Examples:\n *   (save-frame)\n *   (save-frame \"pretty-pic-####.jpg\")\n */\nquil.core.save_frame = (function quil$core$save_frame(var_args){\nvar args812 = [];\nvar len__13421__auto___815 = arguments.length;\nvar i__13422__auto___816 = (0);\nwhile(true){\nif((i__13422__auto___816 < len__13421__auto___815)){\nargs812.push((arguments[i__13422__auto___816]));\n\nvar G__817 = (i__13422__auto___816 + (1));\ni__13422__auto___816 = G__817;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__814 = args812.length;\nswitch (G__814) {\ncase (0):\nreturn quil.core.save_frame.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase (1):\nreturn quil.core.save_frame.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args812.length)].join('')));\n\n}\n});\n\nquil.core.save_frame.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn quil.sketch.current_applet.call(null).saveFrame();\n});\n\nquil.core.save_frame.cljs$core$IFn$_invoke$arity$1 = (function (name){\nreturn quil.sketch.current_applet.call(null).saveFrame([cljs.core.str(name)].join(''));\n});\n\nquil.core.save_frame.cljs$lang$maxFixedArity = (1);\n\n/**\n * Increases or decreases the size of a shape by expanding and\n *   contracting vertices. Objects always scale from their relative\n *   origin to the coordinate system. Scale values are specified as\n *   decimal percentages. For example, the function call (scale 2)\n *   increases the dimension of a shape by 200%. Transformations apply to\n *   everything that happens after and subsequent calls to the function\n *   multiply the effect. For example, calling (scale 2) and then\n *   (scale 1.5) is the same as (scale 3). If scale is called within\n *   draw, the transformation is reset when the loop begins again. Using\n *   this fuction with the z parameter requires specfying :p3d or :opengl\n *   as the renderer. This function can be further controlled by\n *   push-matrix and pop-matrix.\n */\nquil.core.scale = (function quil$core$scale(var_args){\nvar args819 = [];\nvar len__13421__auto___822 = arguments.length;\nvar i__13422__auto___823 = (0);\nwhile(true){\nif((i__13422__auto___823 < len__13421__auto___822)){\nargs819.push((arguments[i__13422__auto___823]));\n\nvar G__824 = (i__13422__auto___823 + (1));\ni__13422__auto___823 = G__824;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__821 = args819.length;\nswitch (G__821) {\ncase (1):\nreturn quil.core.scale.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core.scale.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core.scale.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args819.length)].join('')));\n\n}\n});\n\nquil.core.scale.cljs$core$IFn$_invoke$arity$1 = (function (s){\nreturn quil.core.current_graphics.call(null).scale(s);\n});\n\nquil.core.scale.cljs$core$IFn$_invoke$arity$2 = (function (sx,sy){\nreturn quil.core.current_graphics.call(null).scale(sx,sy);\n});\n\nquil.core.scale.cljs$core$IFn$_invoke$arity$3 = (function (sx,sy,sz){\nreturn quil.core.current_graphics.call(null).scale(sx,sy,sz);\n});\n\nquil.core.scale.cljs$lang$maxFixedArity = (3);\n\n/**\n * Takes a three-dimensional x, y, z position and returns the x value\n *   for where it will appear on a (two-dimensional) screen, once\n *   affected by translate, scale or any other transformations\n */\nquil.core.screen_x = (function quil$core$screen_x(var_args){\nvar args826 = [];\nvar len__13421__auto___829 = arguments.length;\nvar i__13422__auto___830 = (0);\nwhile(true){\nif((i__13422__auto___830 < len__13421__auto___829)){\nargs826.push((arguments[i__13422__auto___830]));\n\nvar G__831 = (i__13422__auto___830 + (1));\ni__13422__auto___830 = G__831;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__828 = args826.length;\nswitch (G__828) {\ncase (2):\nreturn quil.core.screen_x.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core.screen_x.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args826.length)].join('')));\n\n}\n});\n\nquil.core.screen_x.cljs$core$IFn$_invoke$arity$2 = (function (x,y){\nreturn quil.core.current_graphics.call(null).screenX(x,y);\n});\n\nquil.core.screen_x.cljs$core$IFn$_invoke$arity$3 = (function (x,y,z){\nreturn quil.core.current_graphics.call(null).screenX(x,y,z);\n});\n\nquil.core.screen_x.cljs$lang$maxFixedArity = (3);\n\n/**\n * Takes a three-dimensional x, y, z position and returns the y value\n *   for where it will appear on a (two-dimensional) screen, once\n *   affected by translate, scale or any other transformations\n */\nquil.core.screen_y = (function quil$core$screen_y(var_args){\nvar args833 = [];\nvar len__13421__auto___836 = arguments.length;\nvar i__13422__auto___837 = (0);\nwhile(true){\nif((i__13422__auto___837 < len__13421__auto___836)){\nargs833.push((arguments[i__13422__auto___837]));\n\nvar G__838 = (i__13422__auto___837 + (1));\ni__13422__auto___837 = G__838;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__835 = args833.length;\nswitch (G__835) {\ncase (2):\nreturn quil.core.screen_y.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core.screen_y.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args833.length)].join('')));\n\n}\n});\n\nquil.core.screen_y.cljs$core$IFn$_invoke$arity$2 = (function (x,y){\nreturn quil.core.current_graphics.call(null).screenY(x,y);\n});\n\nquil.core.screen_y.cljs$core$IFn$_invoke$arity$3 = (function (x,y,z){\nreturn quil.core.current_graphics.call(null).screenY(x,y,z);\n});\n\nquil.core.screen_y.cljs$lang$maxFixedArity = (3);\n\n/**\n * Given an x, y, z coordinate, returns its z value.\n * This value can be used to determine if an x, y, z coordinate is in\n * front or in back of another (x, y, z) coordinate. The units are\n * based on how the zbuffer is set up, and don't relate to anything\n * 'real'. They're only useful for in comparison to another value\n * obtained from screen-z, or directly out of the zbuffer\n */\nquil.core.screen_z = (function quil$core$screen_z(x,y,z){\nreturn quil.core.current_graphics.call(null).screenZ(x,y,z);\n});\n/**\n * Returns the current second as a value from 0 - 59.\n */\nquil.core.seconds = (function quil$core$seconds(){\nreturn quil.sketch.current_applet.call(null).second();\n});\n/**\n * Changes the color of any pixel in the display window. The x and y\n *   parameters specify the pixel to change and the color parameter\n *   specifies the color value. The color parameter is affected by the\n *   current color mode (the default is RGB values from 0 to 255).\n * \n *   Setting the color of a single pixel with (set x, y) is easy, but not\n *   as fast as putting the data directly into pixels[].\n * \n *   This function ignores imageMode().\n * \n *   Due to what appears to be a bug in Apple's Java implementation, the\n *   point() and set() methods are extremely slow in some circumstances\n *   when used with the default renderer. Using :p2d or :p3d will fix the\n *   problem. Grouping many calls to point or set-pixel together can also\n *   help. (Bug 1094)\n */\nquil.core.set_pixel = (function quil$core$set_pixel(var_args){\nvar args840 = [];\nvar len__13421__auto___843 = arguments.length;\nvar i__13422__auto___844 = (0);\nwhile(true){\nif((i__13422__auto___844 < len__13421__auto___843)){\nargs840.push((arguments[i__13422__auto___844]));\n\nvar G__845 = (i__13422__auto___844 + (1));\ni__13422__auto___844 = G__845;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__842 = args840.length;\nswitch (G__842) {\ncase (3):\nreturn quil.core.set_pixel.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core.set_pixel.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args840.length)].join('')));\n\n}\n});\n\nquil.core.set_pixel.cljs$core$IFn$_invoke$arity$3 = (function (x,y,c){\nreturn quil.core.set_pixel.call(null,quil.core.current_graphics.call(null),x,y,c);\n});\n\nquil.core.set_pixel.cljs$core$IFn$_invoke$arity$4 = (function (img,x,y,c){\nreturn img.set((x | (0)),(y | (0)),(c | (0)));\n});\n\nquil.core.set_pixel.cljs$lang$maxFixedArity = (4);\n\n/**\n * Writes an image directly into the display window. The x and y\n *   parameters define the coordinates for the upper-left corner of the\n *   image.\n */\nquil.core.set_image = (function quil$core$set_image(x,y,src){\nreturn quil.core.current_graphics.call(null).set((x | (0)),(y | (0)),src);\n});\n/**\n * Displays shapes to the screen. The shapes must have been loaded\n *   with load-shape. Processing currently works with SVG shapes\n *   only. The sh parameter specifies the shape to display and the x and\n *   y parameters define the location of the shape from its upper-left\n *   corner. The shape is displayed at its original size unless the width\n *   and height parameters specify a different size. The shape-mode\n *   fn changes the way the parameters work. A call to\n *   (shape-mode :corners), for example, will change the width and height\n *   parameters to define the x and y values of the opposite corner of\n *   the shape.\n * \n *   Note complex shapes may draw awkwardly with the renderers :p2d, :p3d, and\n *   :opengl. Those renderers do not yet support shapes that have holes\n *   or complicated breaks.\n */\nquil.core.shape = (function quil$core$shape(var_args){\nvar args847 = [];\nvar len__13421__auto___850 = arguments.length;\nvar i__13422__auto___851 = (0);\nwhile(true){\nif((i__13422__auto___851 < len__13421__auto___850)){\nargs847.push((arguments[i__13422__auto___851]));\n\nvar G__852 = (i__13422__auto___851 + (1));\ni__13422__auto___851 = G__852;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__849 = args847.length;\nswitch (G__849) {\ncase (1):\nreturn quil.core.shape.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (3):\nreturn quil.core.shape.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (5):\nreturn quil.core.shape.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args847.length)].join('')));\n\n}\n});\n\nquil.core.shape.cljs$core$IFn$_invoke$arity$1 = (function (sh){\nreturn quil.core.current_graphics.call(null).shape(sh);\n});\n\nquil.core.shape.cljs$core$IFn$_invoke$arity$3 = (function (sh,x,y){\nreturn quil.core.current_graphics.call(null).shape(sh,x,y);\n});\n\nquil.core.shape.cljs$core$IFn$_invoke$arity$5 = (function (sh,x,y,width,height){\nreturn quil.core.current_graphics.call(null).shape(sh,x,y,width,height);\n});\n\nquil.core.shape.cljs$lang$maxFixedArity = (5);\n\n/**\n * Shears a shape around the x-axis the amount specified by the angle\n *   parameter. Angles should be specified in radians (values from 0 to\n *   PI*2) or converted to radians with the radians() function. Objects\n *   are always sheared around their relative position to the origin and\n *   positive numbers shear objects in a clockwise direction.\n *   Transformations apply to everything that happens after and\n *   subsequent calls to the function accumulates the effect. For\n *   example, calling (shear-x (/ PI 2)) and then (shear-x (/ PI 2)) is\n *   the same as (shear-x PI). If shear-x is called within the draw fn,\n *   the transformation is reset when the loop begins again. This\n *   function works in P2D or JAVA2D mode.\n * \n *   Technically, shear-x multiplies the current transformation matrix\n *   by a rotation matrix. This function can be further controlled by the\n *   push-matrix and pop-matrix fns.\n */\nquil.core.shear_x = (function quil$core$shear_x(angle){\nreturn quil.core.current_graphics.call(null).shearX(angle);\n});\n/**\n * Shears a shape around the y-axis the amount specified by the angle\n *   parameter. Angles should be specified in radians (values from 0 to\n *   PI*2) or converted to radians with the radians() function. Objects\n *   are always sheared around their relative position to the origin and\n *   positive numbers shear objects in a clockwise direction.\n *   Transformations apply to everything that happens after and\n *   subsequent calls to the function accumulates the effect. For\n *   example, calling (shear-y (/ PI 2)) and then (shear-y (/ PI 2)) is\n *   the same as (shear-y PI). If shear-y is called within the draw fn,\n *   the transformation is reset when the loop begins again. This\n *   function works in P2D or JAVA2D mode.\n * \n *   Technically, shear-y multiplies the current transformation matrix\n *   by a rotation matrix. This function can be further controlled by the\n *   push-matrix and pop-matrix fns.\n */\nquil.core.shear_y = (function quil$core$shear_y(angle){\nreturn quil.core.current_graphics.call(null).shearY(angle);\n});\n/**\n * Modifies the location from which shapes draw. Available modes are\n *   :corner, :corners and :center. Default is :corner.\n * \n *   :corner  - specifies the location to be the upper left corner of the\n *           shape and uses the third and fourth parameters of shape\n *           to specify the width and height.\n * \n *   :corners - uses the first and second parameters of shape to set\n *           the location of one corner and uses the third and fourth\n *           parameters to set the opposite corner.\n * \n *   :center  - draws the shape from its center point and uses the third\n *           and forth parameters of shape to specify the width and\n *           height. \n */\nquil.core.shape_mode = (function quil$core$shape_mode(mode){\nvar mode__$1 = quil.util.resolve_constant_key.call(null,mode,quil.core.p_shape_modes);\nreturn quil.core.current_graphics.call(null).shapeMode((mode__$1 | (0)));\n});\n/**\n * Sets the amount of gloss in the surface of shapes. Used in\n *   combination with ambient, specular, and emissive in setting\n *   the material properties of shapes.\n */\nquil.core.shininess = (function quil$core$shininess(shine){\nreturn quil.core.current_graphics.call(null).shininess(shine);\n});\n/**\n * Calculates the sine of an angle. This function expects the values\n *   of the angle parameter to be provided in radians (values from 0 to\n *   6.28). A float within the range -1 to 1 is returned.\n */\nquil.core.sin = (function quil$core$sin(angle){\nreturn quil.sketch.current_applet.call(null).sin(angle);\n});\n/**\n * Draws all geometry with smooth (anti-aliased) edges. This will slow\n *   down the frame rate of the application, but will enhance the visual\n *   refinement.\n * \n *   Must be called inside :settings handler.\n * \n *   The level parameter (int) increases the level of smoothness with the\n *   P2D and P3D renderers. This is the level of over sampling applied to\n *   the graphics buffer. The value '2' will double the rendering size\n *   before scaling it down to the display size. This is called '2x\n *   anti-aliasing.' The value 4 is used for 4x anti-aliasing and 8 is\n *   specified for 8x anti-aliasing. If level is set to 0, it will disable\n *   all smoothing; it's the equivalent of the function noSmooth().\n *   The maximum anti-aliasing level is determined by the hardware of the\n *   machine that is running the software.\n * \n *   Note that smooth will also improve image quality of resized images.\n */\nquil.core.smooth = (function quil$core$smooth(var_args){\nvar args854 = [];\nvar len__13421__auto___857 = arguments.length;\nvar i__13422__auto___858 = (0);\nwhile(true){\nif((i__13422__auto___858 < len__13421__auto___857)){\nargs854.push((arguments[i__13422__auto___858]));\n\nvar G__859 = (i__13422__auto___858 + (1));\ni__13422__auto___858 = G__859;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__856 = args854.length;\nswitch (G__856) {\ncase (0):\nreturn quil.core.smooth.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase (1):\nreturn quil.core.smooth.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args854.length)].join('')));\n\n}\n});\n\nquil.core.smooth.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn quil.core.current_graphics.call(null).smooth();\n});\n\nquil.core.smooth.cljs$core$IFn$_invoke$arity$1 = (function (level){\nreturn quil.core.current_graphics.call(null).smooth((level | (0)));\n});\n\nquil.core.smooth.cljs$lang$maxFixedArity = (1);\n\n/**\n * Sets the specular color of the materials used for shapes drawn to\n *   the screen, which sets the color of hightlights. Specular refers to\n *   light which bounces off a surface in a perferred direction (rather\n *   than bouncing in all directions like a diffuse light). Used in\n *   combination with emissive, ambient, and shininess in setting\n *   the material properties of shapes.\n */\nquil.core.specular = (function quil$core$specular(var_args){\nvar args861 = [];\nvar len__13421__auto___864 = arguments.length;\nvar i__13422__auto___865 = (0);\nwhile(true){\nif((i__13422__auto___865 < len__13421__auto___864)){\nargs861.push((arguments[i__13422__auto___865]));\n\nvar G__866 = (i__13422__auto___865 + (1));\ni__13422__auto___865 = G__866;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__863 = args861.length;\nswitch (G__863) {\ncase (1):\nreturn quil.core.specular.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (3):\nreturn quil.core.specular.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args861.length)].join('')));\n\n}\n});\n\nquil.core.specular.cljs$core$IFn$_invoke$arity$1 = (function (gray){\nreturn quil.core.current_graphics.call(null).specular(gray);\n});\n\nquil.core.specular.cljs$core$IFn$_invoke$arity$3 = (function (x,y,z){\nreturn quil.core.current_graphics.call(null).specular(x,y,z);\n});\n\nquil.core.specular.cljs$lang$maxFixedArity = (3);\n\n/**\n * Generates a hollow ball made from tessellated triangles.\n */\nquil.core.sphere = (function quil$core$sphere(radius){\nreturn quil.core.current_graphics.call(null).sphere(radius);\n});\n/**\n * Controls the detail used to render a sphere by adjusting the number\n *   of vertices of the sphere mesh. The default resolution is 30, which\n *   creates a fairly detailed sphere definition with vertices every\n *   360/30 = 12 degrees. If you're going to render a great number of\n *   spheres per frame, it is advised to reduce the level of detail using\n *   this function. The setting stays active until sphere-detail is\n *   called again with a new parameter and so should not be called prior\n *   to every sphere statement, unless you wish to render spheres with\n *   different settings, e.g. using less detail for smaller spheres or\n *   ones further away from the camera. To controla the detail of the\n *   horizontal and vertical resolution independently, use the version of\n *   the functions with two parameters.\n */\nquil.core.sphere_detail = (function quil$core$sphere_detail(var_args){\nvar args868 = [];\nvar len__13421__auto___871 = arguments.length;\nvar i__13422__auto___872 = (0);\nwhile(true){\nif((i__13422__auto___872 < len__13421__auto___871)){\nargs868.push((arguments[i__13422__auto___872]));\n\nvar G__873 = (i__13422__auto___872 + (1));\ni__13422__auto___872 = G__873;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__870 = args868.length;\nswitch (G__870) {\ncase (1):\nreturn quil.core.sphere_detail.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core.sphere_detail.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args868.length)].join('')));\n\n}\n});\n\nquil.core.sphere_detail.cljs$core$IFn$_invoke$arity$1 = (function (res){\nreturn quil.core.current_graphics.call(null).sphereDetail((res | (0)));\n});\n\nquil.core.sphere_detail.cljs$core$IFn$_invoke$arity$2 = (function (ures,vres){\nreturn quil.core.current_graphics.call(null).sphereDetail((ures | (0)),(vres | (0)));\n});\n\nquil.core.sphere_detail.cljs$lang$maxFixedArity = (2);\n\n/**\n * Adds a spot light. Lights need to be included in the draw to\n *   remain persistent in a looping program. Placing them in the setup\n *   of a looping program will cause them to only have an effect the\n *   first time through the loop. The affect of the r, g, and b\n *   parameters is determined by the current color mode. The x, y, and z\n *   parameters specify the position of the light and nx, ny, nz specify\n *   the direction or light. The angle parameter affects angle of the\n *   spotlight cone.\n */\nquil.core.spot_light = (function quil$core$spot_light(var_args){\nvar args875 = [];\nvar len__13421__auto___890 = arguments.length;\nvar i__13422__auto___891 = (0);\nwhile(true){\nif((i__13422__auto___891 < len__13421__auto___890)){\nargs875.push((arguments[i__13422__auto___891]));\n\nvar G__892 = (i__13422__auto___891 + (1));\ni__13422__auto___891 = G__892;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__877 = args875.length;\nswitch (G__877) {\ncase (11):\nreturn quil.core.spot_light.cljs$core$IFn$_invoke$arity$11((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]),(arguments[(8)]),(arguments[(9)]),(arguments[(10)]));\n\nbreak;\ncase (5):\nreturn quil.core.spot_light.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args875.length)].join('')));\n\n}\n});\n\nquil.core.spot_light.cljs$core$IFn$_invoke$arity$11 = (function (r,g,b,x,y,z,nx,ny,nz,angle,concentration){\nreturn quil.core.current_graphics.call(null).spotLight(r,g,b,x,y,z,nx,ny,nz,angle,concentration);\n});\n\nquil.core.spot_light.cljs$core$IFn$_invoke$arity$5 = (function (p__878,p__879,p__880,angle,concentration){\nvar vec__881 = p__878;\nvar r = cljs.core.nth.call(null,vec__881,(0),null);\nvar g = cljs.core.nth.call(null,vec__881,(1),null);\nvar b = cljs.core.nth.call(null,vec__881,(2),null);\nvar vec__884 = p__879;\nvar x = cljs.core.nth.call(null,vec__884,(0),null);\nvar y = cljs.core.nth.call(null,vec__884,(1),null);\nvar z = cljs.core.nth.call(null,vec__884,(2),null);\nvar vec__887 = p__880;\nvar nx = cljs.core.nth.call(null,vec__887,(0),null);\nvar ny = cljs.core.nth.call(null,vec__887,(1),null);\nvar nz = cljs.core.nth.call(null,vec__887,(2),null);\nreturn quil.core.current_graphics.call(null).spotLight(r,g,b,x,y,z,nx,ny,nz,angle,concentration);\n});\n\nquil.core.spot_light.cljs$lang$maxFixedArity = (11);\n\n/**\n * Squares a number (multiplies a number by itself). The result is\n *   always a positive number, as multiplying two negative numbers always\n *   yields a positive result. For example, -1 * -1 = 1.\n */\nquil.core.sq = (function quil$core$sq(a){\nreturn quil.sketch.current_applet.call(null).sq(a);\n});\n/**\n * Calculates the square root of a number. The square root of a number\n *   is always positive, even though there may be a valid negative\n *   root. The square root s of number a is such that (= a (* s s)) . It\n *   is the opposite of squaring.\n */\nquil.core.sqrt = (function quil$core$sqrt(a){\nreturn quil.sketch.current_applet.call(null).sqrt(a);\n});\n/**\n * Causes Processing to continuously execute the code within\n *   draw. If no-loop is called, the code in draw stops executing.\n */\nquil.core.start_loop = (function quil$core$start_loop(){\nreturn quil.sketch.current_applet.call(null).loop();\n});\n/**\n * Sets the color used to draw lines and borders around\n *   shapes. Converts all args to floats\n */\nquil.core.stroke_float = (function quil$core$stroke_float(var_args){\nvar args894 = [];\nvar len__13421__auto___897 = arguments.length;\nvar i__13422__auto___898 = (0);\nwhile(true){\nif((i__13422__auto___898 < len__13421__auto___897)){\nargs894.push((arguments[i__13422__auto___898]));\n\nvar G__899 = (i__13422__auto___898 + (1));\ni__13422__auto___898 = G__899;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__896 = args894.length;\nswitch (G__896) {\ncase (1):\nreturn quil.core.stroke_float.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core.stroke_float.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core.stroke_float.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core.stroke_float.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args894.length)].join('')));\n\n}\n});\n\nquil.core.stroke_float.cljs$core$IFn$_invoke$arity$1 = (function (gray){\nreturn quil.core.current_graphics.call(null).stroke(gray);\n});\n\nquil.core.stroke_float.cljs$core$IFn$_invoke$arity$2 = (function (gray,alpha){\nreturn quil.core.current_graphics.call(null).stroke(gray,alpha);\n});\n\nquil.core.stroke_float.cljs$core$IFn$_invoke$arity$3 = (function (x,y,z){\nreturn quil.core.current_graphics.call(null).stroke(x,y,z);\n});\n\nquil.core.stroke_float.cljs$core$IFn$_invoke$arity$4 = (function (x,y,z,a){\nreturn quil.core.current_graphics.call(null).stroke(x,y,z,a);\n});\n\nquil.core.stroke_float.cljs$lang$maxFixedArity = (4);\n\n/**\n * Sets the color used to draw lines and borders around\n *   shapes. Converts rgb to int and alpha to a float.\n */\nquil.core.stroke_int = (function quil$core$stroke_int(var_args){\nvar args901 = [];\nvar len__13421__auto___904 = arguments.length;\nvar i__13422__auto___905 = (0);\nwhile(true){\nif((i__13422__auto___905 < len__13421__auto___904)){\nargs901.push((arguments[i__13422__auto___905]));\n\nvar G__906 = (i__13422__auto___905 + (1));\ni__13422__auto___905 = G__906;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__903 = args901.length;\nswitch (G__903) {\ncase (1):\nreturn quil.core.stroke_int.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core.stroke_int.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args901.length)].join('')));\n\n}\n});\n\nquil.core.stroke_int.cljs$core$IFn$_invoke$arity$1 = (function (rgb){\nreturn quil.core.current_graphics.call(null).stroke(cljs.core.unchecked_int.call(null,rgb));\n});\n\nquil.core.stroke_int.cljs$core$IFn$_invoke$arity$2 = (function (rgb,alpha){\nreturn quil.core.current_graphics.call(null).stroke(cljs.core.unchecked_int.call(null,rgb),alpha);\n});\n\nquil.core.stroke_int.cljs$lang$maxFixedArity = (2);\n\n/**\n * Sets the color used to draw lines and borders around shapes. This\n *   color is either specified in terms of the RGB or HSB color depending\n *   on the current color-mode (the default color space is RGB, with\n *   each value in the range from 0 to 255).\n */\nquil.core.stroke = (function quil$core$stroke(var_args){\nvar args908 = [];\nvar len__13421__auto___911 = arguments.length;\nvar i__13422__auto___912 = (0);\nwhile(true){\nif((i__13422__auto___912 < len__13421__auto___911)){\nargs908.push((arguments[i__13422__auto___912]));\n\nvar G__913 = (i__13422__auto___912 + (1));\ni__13422__auto___912 = G__913;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__910 = args908.length;\nswitch (G__910) {\ncase (1):\nreturn quil.core.stroke.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core.stroke.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core.stroke.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core.stroke.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args908.length)].join('')));\n\n}\n});\n\nquil.core.stroke.cljs$core$IFn$_invoke$arity$1 = (function (rgb){\nreturn quil.core.stroke_float.call(null,rgb);\n});\n\nquil.core.stroke.cljs$core$IFn$_invoke$arity$2 = (function (rgb,alpha){\nreturn quil.core.stroke_float.call(null,rgb,alpha);\n});\n\nquil.core.stroke.cljs$core$IFn$_invoke$arity$3 = (function (x,y,z){\nreturn quil.core.stroke_float.call(null,x,y,z);\n});\n\nquil.core.stroke.cljs$core$IFn$_invoke$arity$4 = (function (x,y,z,a){\nreturn quil.core.stroke_float.call(null,x,y,z,a);\n});\n\nquil.core.stroke.cljs$lang$maxFixedArity = (4);\n\n/**\n * Sets the style for rendering line endings. These ends are either\n *   squared, extended, or rounded and specified with the corresponding\n *   parameters :square, :project, and :round. The default cap is :round.\n */\nquil.core.stroke_cap = (function quil$core$stroke_cap(cap_mode){\nvar cap_mode__$1 = quil.util.resolve_constant_key.call(null,cap_mode,quil.core.stroke_cap_modes);\nreturn quil.core.current_graphics.call(null).strokeCap([cljs.core.str(cap_mode__$1)].join(''));\n});\n/**\n * Sets the style of the joints which connect line\n *   segments. These joints are either mitered, beveled, or rounded and\n *   specified with the corresponding parameters :miter, :bevel, and\n *   :round. The default joint is :miter.\n * \n *   This function is not available with the :p2d, :p3d, or :opengl\n *   renderers.\n */\nquil.core.stroke_join = (function quil$core$stroke_join(join_mode){\nvar join_mode__$1 = quil.util.resolve_constant_key.call(null,join_mode,quil.core.stroke_join_modes);\nreturn quil.core.current_graphics.call(null).strokeJoin([cljs.core.str(join_mode__$1)].join(''));\n});\n/**\n * Sets the width of the stroke used for lines, points, and the border\n *   around shapes. All widths are set in units of pixels. \n */\nquil.core.stroke_weight = (function quil$core$stroke_weight(weight){\nreturn quil.core.current_graphics.call(null).strokeWeight(weight);\n});\n/**\n * Calculates the ratio of the sine and cosine of an angle. This\n *   function expects the values of the angle parameter to be provided in\n *   radians (values from 0 to PI*2). Values are returned in the range\n *   infinity to -infinity.\n */\nquil.core.tan = (function quil$core$tan(angle){\nreturn quil.sketch.current_applet.call(null).tan(angle);\n});\n/**\n * Returns the target framerate specified with the fn frame-rate\n */\nquil.core.target_frame_rate = (function quil$core$target_frame_rate(){\nreturn cljs.core.deref.call(null,quil.sketch.current_applet.call(null).target_frame_rate);\n});\n/**\n * Returns whether fill is disabled for current graphics.\n */\nquil.core.no_fill_QMARK_ = (function quil$core$no_fill_QMARK_(graphics){\nreturn (graphics[quil.core.no_fill_prop]) === true;\n});\n/**\n * Draws a char to the screen in the specified position. See text fn\n *   for more details.\n */\nquil.core.text_char = (function quil$core$text_char(var_args){\nvar args915 = [];\nvar len__13421__auto___918 = arguments.length;\nvar i__13422__auto___919 = (0);\nwhile(true){\nif((i__13422__auto___919 < len__13421__auto___918)){\nargs915.push((arguments[i__13422__auto___919]));\n\nvar G__920 = (i__13422__auto___919 + (1));\ni__13422__auto___919 = G__920;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__917 = args915.length;\nswitch (G__917) {\ncase (3):\nreturn quil.core.text_char.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core.text_char.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args915.length)].join('')));\n\n}\n});\n\nquil.core.text_char.cljs$core$IFn$_invoke$arity$3 = (function (c,x,y){\nif(cljs.core.truth_(quil.core.no_fill_QMARK_.call(null,quil.core.current_graphics.call(null)))){\nreturn null;\n} else {\nreturn quil.core.current_graphics.call(null).text(cljs.core.char$.call(null,c),x,y);\n}\n});\n\nquil.core.text_char.cljs$core$IFn$_invoke$arity$4 = (function (c,x,y,z){\nif(cljs.core.truth_(quil.core.no_fill_QMARK_.call(null,quil.core.current_graphics.call(null)))){\nreturn null;\n} else {\nreturn quil.core.current_graphics.call(null).text(cljs.core.char$.call(null,c),x,y,z);\n}\n});\n\nquil.core.text_char.cljs$lang$maxFixedArity = (4);\n\n/**\n * Draws a number to the screen in the specified position. See text fn\n *   for more details.\n */\nquil.core.text_num = (function quil$core$text_num(var_args){\nvar args922 = [];\nvar len__13421__auto___925 = arguments.length;\nvar i__13422__auto___926 = (0);\nwhile(true){\nif((i__13422__auto___926 < len__13421__auto___925)){\nargs922.push((arguments[i__13422__auto___926]));\n\nvar G__927 = (i__13422__auto___926 + (1));\ni__13422__auto___926 = G__927;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__924 = args922.length;\nswitch (G__924) {\ncase (3):\nreturn quil.core.text_num.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core.text_num.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args922.length)].join('')));\n\n}\n});\n\nquil.core.text_num.cljs$core$IFn$_invoke$arity$3 = (function (num,x,y){\nif(cljs.core.truth_(quil.core.no_fill_QMARK_.call(null,quil.core.current_graphics.call(null)))){\nreturn null;\n} else {\nreturn quil.core.current_graphics.call(null).text(num,x,y);\n}\n});\n\nquil.core.text_num.cljs$core$IFn$_invoke$arity$4 = (function (num,x,y,z){\nif(cljs.core.truth_(quil.core.no_fill_QMARK_.call(null,quil.core.current_graphics.call(null)))){\nreturn null;\n} else {\nreturn quil.core.current_graphics.call(null).text(num,x,y,z);\n}\n});\n\nquil.core.text_num.cljs$lang$maxFixedArity = (4);\n\n/**\n * Draws text to the screen in the position specified by the x and y\n *   parameters and the optional z parameter. A default font will be used\n *   unless a font is set with the text-font fn. Change the color of the\n *   text with the fill fn. The text displays in relation to the\n *   text-align fn, which gives the option to draw to the left, right, and\n *   center of the coordinates.\n * \n *   The x1, y1, x2 and y2 parameters define a\n *   rectangular area to display within and may only be used with string\n *   data. For text drawn inside a rectangle, the coordinates are\n *   interpreted based on the current rect-mode setting.\n */\nquil.core.text = (function quil$core$text(var_args){\nvar args929 = [];\nvar len__13421__auto___932 = arguments.length;\nvar i__13422__auto___933 = (0);\nwhile(true){\nif((i__13422__auto___933 < len__13421__auto___932)){\nargs929.push((arguments[i__13422__auto___933]));\n\nvar G__934 = (i__13422__auto___933 + (1));\ni__13422__auto___933 = G__934;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__931 = args929.length;\nswitch (G__931) {\ncase (3):\nreturn quil.core.text.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core.text.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase (5):\nreturn quil.core.text.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args929.length)].join('')));\n\n}\n});\n\nquil.core.text.cljs$core$IFn$_invoke$arity$3 = (function (s,x,y){\nif(cljs.core.truth_(quil.core.no_fill_QMARK_.call(null,quil.core.current_graphics.call(null)))){\nreturn null;\n} else {\nreturn quil.core.current_graphics.call(null).text(s,x,y);\n}\n});\n\nquil.core.text.cljs$core$IFn$_invoke$arity$4 = (function (s,x,y,z){\nif(cljs.core.truth_(quil.core.no_fill_QMARK_.call(null,quil.core.current_graphics.call(null)))){\nreturn null;\n} else {\nreturn quil.core.current_graphics.call(null).text(s,x,y,z);\n}\n});\n\nquil.core.text.cljs$core$IFn$_invoke$arity$5 = (function (s,x1,y1,x2,y2){\nif(cljs.core.truth_(quil.core.no_fill_QMARK_.call(null,quil.core.current_graphics.call(null)))){\nreturn null;\n} else {\nreturn quil.core.current_graphics.call(null).text(s,x1,y1,x2,y2);\n}\n});\n\nquil.core.text.cljs$lang$maxFixedArity = (5);\n\n/**\n * Sets the current alignment for drawing text. Available modes are:\n * \n *   horizontal - :left, :center, and :right\n *   vertical   - :top, :bottom, :center, and :baseline\n * \n *   An optional second parameter specifies the vertical alignment\n *   mode. :baseline is the default. The :top and :center parameters are\n *   straightforward. The :bottom parameter offsets the line based on the\n *   current text-descent. For multiple lines, the final line will be\n *   aligned to the bottom, with the previous lines appearing above it.\n * \n *   When using text with width and height parameters, :baseline is\n *   ignored, and treated as :top. (Otherwise, text would by default draw\n *   outside the box, since :baseline is the default setting. :baseline is\n *   not a useful drawing mode for text drawn in a rectangle.)\n * \n *   The vertical alignment is based on the value of text-ascent, which\n *   many fonts do not specify correctly. It may be necessary to use a\n *   hack and offset by a few pixels by hand so that the offset looks\n *   correct. To do this as less of a hack, use some percentage of\n *   text-ascent or text-descent so that the hack works even if you\n *   change the size of the font.\n */\nquil.core.text_align = (function quil$core$text_align(var_args){\nvar args936 = [];\nvar len__13421__auto___939 = arguments.length;\nvar i__13422__auto___940 = (0);\nwhile(true){\nif((i__13422__auto___940 < len__13421__auto___939)){\nargs936.push((arguments[i__13422__auto___940]));\n\nvar G__941 = (i__13422__auto___940 + (1));\ni__13422__auto___940 = G__941;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__938 = args936.length;\nswitch (G__938) {\ncase (1):\nreturn quil.core.text_align.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core.text_align.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args936.length)].join('')));\n\n}\n});\n\nquil.core.text_align.cljs$core$IFn$_invoke$arity$1 = (function (align){\nvar align__$1 = quil.util.resolve_constant_key.call(null,align,quil.core.horizontal_alignment_modes);\nreturn quil.core.current_graphics.call(null).textAlign((align__$1 | (0)));\n});\n\nquil.core.text_align.cljs$core$IFn$_invoke$arity$2 = (function (align_x,align_y){\nvar align_x__$1 = quil.util.resolve_constant_key.call(null,align_x,quil.core.horizontal_alignment_modes);\nvar align_y__$1 = quil.util.resolve_constant_key.call(null,align_y,quil.core.vertical_alignment_modes);\nreturn quil.core.current_graphics.call(null).textAlign((align_x__$1 | (0)),(align_y__$1 | (0)));\n});\n\nquil.core.text_align.cljs$lang$maxFixedArity = (2);\n\n/**\n * Returns the ascent of the current font at its current size. This\n *   information is useful for determining the height of the font above\n *   the baseline. For example, adding the text-ascent and text-descent\n *   values will give you the total height of the line.\n */\nquil.core.text_ascent = (function quil$core$text_ascent(){\nreturn quil.core.current_graphics.call(null).textAscent();\n});\n/**\n * Returns descent of the current font at its current size. This\n *   information is useful for determining the height of the font below\n *   the baseline. For example, adding the text-ascent and text-descent\n *   values will give you the total height of the line.\n */\nquil.core.text_descent = (function quil$core$text_descent(){\nreturn quil.core.current_graphics.call(null).textDescent();\n});\n/**\n * Sets the current font that will be drawn with the text\n *   function. Fonts must be loaded with load-font before it can be\n *   used. This font will be used in all subsequent calls to the text\n *   function. If no size parameter is input, the font will appear at its\n *   original size until it is changed with text-size.\n * \n *   Because fonts are usually bitmaped, you should create fonts at the\n *   sizes that will be used most commonly. Using textFont without the\n *   size parameter will result in the cleanest-looking text.\n * \n *   With the default (JAVA2D) and PDF renderers, it's also possible to\n *   enable the use of native fonts via the command\n *   (hint :enable-native-fonts). This will produce vector text in JAVA2D\n *   sketches and PDF output in cases where the vector data is available:\n *   when the font is still installed, or the font is created via the\n *   create-font fn\n */\nquil.core.text_font = (function quil$core$text_font(var_args){\nvar args943 = [];\nvar len__13421__auto___946 = arguments.length;\nvar i__13422__auto___947 = (0);\nwhile(true){\nif((i__13422__auto___947 < len__13421__auto___946)){\nargs943.push((arguments[i__13422__auto___947]));\n\nvar G__948 = (i__13422__auto___947 + (1));\ni__13422__auto___947 = G__948;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__945 = args943.length;\nswitch (G__945) {\ncase (1):\nreturn quil.core.text_font.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core.text_font.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args943.length)].join('')));\n\n}\n});\n\nquil.core.text_font.cljs$core$IFn$_invoke$arity$1 = (function (font){\nreturn quil.core.current_graphics.call(null).textFont(font);\n});\n\nquil.core.text_font.cljs$core$IFn$_invoke$arity$2 = (function (font,size){\nreturn quil.core.current_graphics.call(null).textFont(font,(size | (0)));\n});\n\nquil.core.text_font.cljs$lang$maxFixedArity = (2);\n\n/**\n * Sets the spacing between lines of text in units of pixels. This\n *   setting will be used in all subsequent calls to the text function.\n */\nquil.core.text_leading = (function quil$core$text_leading(leading){\nreturn quil.core.current_graphics.call(null).textLeading(leading);\n});\n/**\n * Sets the way text draws to the screen - available modes\n *   are :model and :shape\n * \n *   In the default configuration (the :model mode), it's possible to\n *   rotate, scale, and place letters in two and three dimensional space.\n * \n *   The :shape mode draws text using the glyph outlines of individual\n *   characters rather than as textures. This mode is only supported with\n *   the PDF and OPENGL renderer settings. With the PDF renderer, you\n *   must specify the :shape text-mode before any other drawing occurs.\n *   If the outlines are not available, then :shape will be ignored and\n *   :model will be used instead.\n * \n *   The :shape option in OPENGL mode can be combined with begin-raw to\n *   write vector-accurate text to 2D and 3D output files, for instance\n *   DXF or PDF. :shape is not currently optimized for OPENGL, so if\n *   recording shape data, use :model until you're ready to capture the\n *   geometry with begin-raw.\n */\nquil.core.text_mode = (function quil$core$text_mode(mode){\nvar mode__$1 = quil.util.resolve_constant_key.call(null,mode,quil.core.text_modes);\nreturn quil.core.current_graphics.call(null).textMode((mode__$1 | (0)));\n});\n/**\n * Sets the current font size. This size will be used in all\n *   subsequent calls to the text fn. Font size is measured in\n *   units of pixels.\n */\nquil.core.text_size = (function quil$core$text_size(size){\nreturn quil.core.current_graphics.call(null).textSize(size);\n});\n/**\n * Sets a texture to be applied to vertex points. The texture fn must\n *   be called between begin-shape and end-shape and before any calls to\n *   vertex.\n * \n *   When textures are in use, the fill color is ignored. Instead, use\n *   tint to specify the color of the texture as it is applied to the\n *   shape.\n */\nquil.core.texture = (function quil$core$texture(img){\nreturn quil.core.current_graphics.call(null).texture(img);\n});\n/**\n * Sets the coordinate space for texture mapping. There are two\n *   options, :image and :normal.\n * \n *   :image refers to the actual coordinates of the image and :normal\n *   refers to a normalized space of values ranging from 0 to 1. The\n *   default mode is :image. In :image, if an image is 100 x 200 pixels,\n *   mapping the image onto the entire size of a quad would require the\n *   points (0,0) (0,100) (100,200) (0,200). The same mapping in\n *   NORMAL_SPACE is (0,0) (0,1) (1,1) (0,1).\n */\nquil.core.texture_mode = (function quil$core$texture_mode(mode){\nvar mode__$1 = quil.util.resolve_constant_key.call(null,mode,quil.core.texture_modes);\nreturn quil.core.current_graphics.call(null).textureMode((mode__$1 | (0)));\n});\n/**\n * Calculates and returns the width of any text string.\n */\nquil.core.text_width = (function quil$core$text_width(data){\nreturn quil.core.current_graphics.call(null).textWidth(data);\n});\n/**\n * Sets the fill value for displaying images. Images can be tinted to\n *   specified colors or made transparent by setting the alpha.\n * \n *   To make an image transparent, but not change it's color, use white\n *   as the tint color and specify an alpha value. For instance,\n *   tint(255, 128) will make an image 50% transparent (unless\n *   colorMode() has been used).\n * \n *   The value for the parameter gray must be less than or equal to the\n *   current maximum value as specified by colorMode(). The default\n *   maximum value is 255.\n * \n *   Also used to control the coloring of textures in 3D.\n */\nquil.core.tint_float = (function quil$core$tint_float(var_args){\nvar args950 = [];\nvar len__13421__auto___953 = arguments.length;\nvar i__13422__auto___954 = (0);\nwhile(true){\nif((i__13422__auto___954 < len__13421__auto___953)){\nargs950.push((arguments[i__13422__auto___954]));\n\nvar G__955 = (i__13422__auto___954 + (1));\ni__13422__auto___954 = G__955;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__952 = args950.length;\nswitch (G__952) {\ncase (1):\nreturn quil.core.tint_float.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core.tint_float.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core.tint_float.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core.tint_float.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args950.length)].join('')));\n\n}\n});\n\nquil.core.tint_float.cljs$core$IFn$_invoke$arity$1 = (function (gray){\nreturn quil.core.current_graphics.call(null).tint(gray);\n});\n\nquil.core.tint_float.cljs$core$IFn$_invoke$arity$2 = (function (gray,alpha){\nreturn quil.core.current_graphics.call(null).tint(gray,alpha);\n});\n\nquil.core.tint_float.cljs$core$IFn$_invoke$arity$3 = (function (r,g,b){\nreturn quil.core.current_graphics.call(null).tint(r,g,b);\n});\n\nquil.core.tint_float.cljs$core$IFn$_invoke$arity$4 = (function (r,g,b,a){\nreturn quil.core.current_graphics.call(null).tint(g,g,b,a);\n});\n\nquil.core.tint_float.cljs$lang$maxFixedArity = (4);\n\n/**\n * Sets the fill value for displaying images. Images can be tinted to\n *   specified colors or made transparent by setting the alpha.\n * \n *   To make an image transparent, but not change it's color, use white\n *   as the tint color and specify an alpha value. For instance,\n *   tint(255, 128) will make an image 50% transparent (unless\n *   colorMode() has been used).\n * \n *   The value for the parameter gray must be less than or equal to the\n *   current maximum value as specified by colorMode(). The default\n *   maximum value is 255.\n * \n *   Also used to control the coloring of textures in 3D.\n */\nquil.core.tint_int = (function quil$core$tint_int(var_args){\nvar args957 = [];\nvar len__13421__auto___960 = arguments.length;\nvar i__13422__auto___961 = (0);\nwhile(true){\nif((i__13422__auto___961 < len__13421__auto___960)){\nargs957.push((arguments[i__13422__auto___961]));\n\nvar G__962 = (i__13422__auto___961 + (1));\ni__13422__auto___961 = G__962;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__959 = args957.length;\nswitch (G__959) {\ncase (1):\nreturn quil.core.tint_int.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core.tint_int.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args957.length)].join('')));\n\n}\n});\n\nquil.core.tint_int.cljs$core$IFn$_invoke$arity$1 = (function (rgb){\nreturn quil.core.current_graphics.call(null).tint(cljs.core.unchecked_int.call(null,rgb));\n});\n\nquil.core.tint_int.cljs$core$IFn$_invoke$arity$2 = (function (rgb,alpha){\nreturn quil.core.current_graphics.call(null).tint(cljs.core.unchecked_int.call(null,rgb),alpha);\n});\n\nquil.core.tint_int.cljs$lang$maxFixedArity = (2);\n\n/**\n * Sets the fill value for displaying images. Images can be tinted to\n *   specified colors or made transparent by setting the alpha.\n * \n *   To make an image transparent, but not change it's color, use white\n *   as the tint color and specify an alpha value. For instance,\n *   tint(255, 128) will make an image 50% transparent (unless\n *   colorMode() has been used).\n * \n *   The value for the parameter gray must be less than or equal to the\n *   current maximum value as specified by colorMode(). The default\n *   maximum value is 255.\n * \n *   Also used to control the coloring of textures in 3D.\n */\nquil.core.tint = (function quil$core$tint(var_args){\nvar args964 = [];\nvar len__13421__auto___967 = arguments.length;\nvar i__13422__auto___968 = (0);\nwhile(true){\nif((i__13422__auto___968 < len__13421__auto___967)){\nargs964.push((arguments[i__13422__auto___968]));\n\nvar G__969 = (i__13422__auto___968 + (1));\ni__13422__auto___968 = G__969;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__966 = args964.length;\nswitch (G__966) {\ncase (1):\nreturn quil.core.tint.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core.tint.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core.tint.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core.tint.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args964.length)].join('')));\n\n}\n});\n\nquil.core.tint.cljs$core$IFn$_invoke$arity$1 = (function (rgb){\nreturn quil.core.current_graphics.call(null).tint(rgb);\n});\n\nquil.core.tint.cljs$core$IFn$_invoke$arity$2 = (function (rgb,alpha){\nreturn quil.core.current_graphics.call(null).tint(rgb,alpha);\n});\n\nquil.core.tint.cljs$core$IFn$_invoke$arity$3 = (function (r,g,b){\nreturn quil.core.tint_float.call(null,r,g,b);\n});\n\nquil.core.tint.cljs$core$IFn$_invoke$arity$4 = (function (r,g,b,a){\nreturn quil.core.tint_float.call(null,r,g,b,a);\n});\n\nquil.core.tint.cljs$lang$maxFixedArity = (4);\n\n/**\n * Specifies an amount to displace objects within the display\n *   window. The x parameter specifies left/right translation, the y\n *   parameter specifies up/down translation, and the z parameter\n *   specifies translations toward/away from the screen.  Transformations\n *   apply to everything that happens after and subsequent calls to the\n *   function accumulates the effect. For example, calling (translate 50\n *   0) and then (translate 20, 0) is the same as (translate 70, 0). If\n *   translate is called within draw, the transformation is reset when\n *   the loop begins again. This function can be further controlled by\n *   the push-matrix and pop-matrix.\n */\nquil.core.translate = (function quil$core$translate(var_args){\nvar args971 = [];\nvar len__13421__auto___974 = arguments.length;\nvar i__13422__auto___975 = (0);\nwhile(true){\nif((i__13422__auto___975 < len__13421__auto___974)){\nargs971.push((arguments[i__13422__auto___975]));\n\nvar G__976 = (i__13422__auto___975 + (1));\ni__13422__auto___975 = G__976;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__973 = args971.length;\nswitch (G__973) {\ncase (1):\nreturn quil.core.translate.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core.translate.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core.translate.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args971.length)].join('')));\n\n}\n});\n\nquil.core.translate.cljs$core$IFn$_invoke$arity$1 = (function (v){\nreturn cljs.core.apply.call(null,quil.core.translate,v);\n});\n\nquil.core.translate.cljs$core$IFn$_invoke$arity$2 = (function (tx,ty){\nreturn quil.core.current_graphics.call(null).translate(tx,ty);\n});\n\nquil.core.translate.cljs$core$IFn$_invoke$arity$3 = (function (tx,ty,tz){\nreturn quil.core.current_graphics.call(null).translate(tx,ty,tz);\n});\n\nquil.core.translate.cljs$lang$maxFixedArity = (3);\n\n/**\n * A triangle is a plane created by connecting three points. The first\n *   two arguments specify the first point, the middle two arguments\n *   specify the second point, and the last two arguments specify the\n *   third point.\n */\nquil.core.triangle = (function quil$core$triangle(x1,y1,x2,y2,x3,y3){\nreturn quil.core.current_graphics.call(null).triangle(x1,y1,x2,y2,x3,y3);\n});\n/**\n * Unpack a binary string to an integer. See binary for converting\n *   integers to strings.\n */\nquil.core.unbinary = (function quil$core$unbinary(str_val){\nreturn quil.sketch.current_applet.call(null).unbinary([cljs.core.str(str_val)].join(''));\n});\n/**\n * Converts a String representation of a hexadecimal number to its\n *   equivalent integer value.\n */\nquil.core.unhex = (function quil$core$unhex(hex_str){\nreturn quil.sketch.current_applet.call(null).unhex([cljs.core.str(hex_str)].join(''));\n});\n/**\n * Updates the display window or image with the data in the pixels array.\n *   Use in conjunction with (pixels). If you're only reading pixels from\n *   the array, there's no need to call update-pixels unless there are\n *   changes.\n * \n *   Certain renderers may or may not seem to require pixels or\n *   update-pixels. However, the rule is that any time you want to\n *   manipulate the pixels array, you must first call pixels, and\n *   after changes have been made, call update-pixels. Even if the\n *   renderer may not seem to use this function in the current Processing\n *   release, this will always be subject to change.\n */\nquil.core.update_pixels = (function quil$core$update_pixels(var_args){\nvar args978 = [];\nvar len__13421__auto___981 = arguments.length;\nvar i__13422__auto___982 = (0);\nwhile(true){\nif((i__13422__auto___982 < len__13421__auto___981)){\nargs978.push((arguments[i__13422__auto___982]));\n\nvar G__983 = (i__13422__auto___982 + (1));\ni__13422__auto___982 = G__983;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__980 = args978.length;\nswitch (G__980) {\ncase (0):\nreturn quil.core.update_pixels.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase (1):\nreturn quil.core.update_pixels.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args978.length)].join('')));\n\n}\n});\n\nquil.core.update_pixels.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn quil.core.update_pixels.call(null,quil.core.current_graphics.call(null));\n});\n\nquil.core.update_pixels.cljs$core$IFn$_invoke$arity$1 = (function (img){\nvar temp__10400__auto___985 = img.stored_pix_array;\nif(cljs.core.truth_(temp__10400__auto___985)){\nvar pix_array_986 = temp__10400__auto___985;\nimg.pixels.set(pix_array_986);\n\nimg.stored_pix_array = null;\n} else {\n}\n\nreturn img.updatePixels();\n});\n\nquil.core.update_pixels.cljs$lang$maxFixedArity = (1);\n\n/**\n * All shapes are constructed by connecting a series of\n *   vertices. vertex is used to specify the vertex coordinates for\n *   points, lines, triangles, quads, and polygons and is used\n *   exclusively within the begin-shape and end-shape fns.\n * \n *   Drawing a vertex in 3D using the z parameter requires the :p3d or\n *   :opengl renderers to be used.\n * \n *   This function is also used to map a texture onto the geometry. The\n *   texture fn declares the texture to apply to the geometry and the u\n *   and v coordinates set define the mapping of this texture to the\n *   form. By default, the coordinates used for u and v are specified in\n *   relation to the image's size in pixels, but this relation can be\n *   changed with texture-mode.\n */\nquil.core.vertex = (function quil$core$vertex(var_args){\nvar args987 = [];\nvar len__13421__auto___990 = arguments.length;\nvar i__13422__auto___991 = (0);\nwhile(true){\nif((i__13422__auto___991 < len__13421__auto___990)){\nargs987.push((arguments[i__13422__auto___991]));\n\nvar G__992 = (i__13422__auto___991 + (1));\ni__13422__auto___991 = G__992;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__989 = args987.length;\nswitch (G__989) {\ncase (2):\nreturn quil.core.vertex.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core.vertex.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core.vertex.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase (5):\nreturn quil.core.vertex.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args987.length)].join('')));\n\n}\n});\n\nquil.core.vertex.cljs$core$IFn$_invoke$arity$2 = (function (x,y){\nreturn quil.core.current_graphics.call(null).vertex(x,y);\n});\n\nquil.core.vertex.cljs$core$IFn$_invoke$arity$3 = (function (x,y,z){\nreturn quil.core.current_graphics.call(null).vertex(x,y,z);\n});\n\nquil.core.vertex.cljs$core$IFn$_invoke$arity$4 = (function (x,y,u,v){\nreturn quil.core.current_graphics.call(null).vertex(x,y,u,v);\n});\n\nquil.core.vertex.cljs$core$IFn$_invoke$arity$5 = (function (x,y,z,u,v){\nreturn quil.core.current_graphics.call(null).vertex(x,y,z,u,v);\n});\n\nquil.core.vertex.cljs$lang$maxFixedArity = (5);\n\n/**\n * Returns the current year as an integer (2003, 2004, 2005, etc).\n */\nquil.core.year = (function quil$core$year(){\nreturn quil.sketch.current_applet.call(null).year();\n});\n/**\n * Width of the display window. The value of width is zero until size is\n *   called.\n */\nquil.core.width = (function quil$core$width(){\nreturn quil.sketch.current_applet.call(null).width;\n});\n/**\n * Temporarily set the fill color for the body of this macro.\n * The code outside of with-fill form will have the previous fill color set.\n * \n * The fill color has to be in a vector!\n * Example: (with-fill [255] ...)\n *          (with-fill [10 80 98] ...)\n */\nquil.core.with_fill = (function quil$core$with_fill(var_args){\nvar args__13423__auto__ = [];\nvar len__13421__auto___998 = arguments.length;\nvar i__13422__auto___999 = (0);\nwhile(true){\nif((i__13422__auto___999 < len__13421__auto___998)){\nargs__13423__auto__.push((arguments[i__13422__auto___999]));\n\nvar G__1000 = (i__13422__auto___999 + (1));\ni__13422__auto___999 = G__1000;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__13424__auto__ = ((((3) < args__13423__auto__.length))?(new cljs.core.IndexedSeq(args__13423__auto__.slice((3)),(0),null)):null);\nreturn quil.core.with_fill.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__13424__auto__);\n});\n\nquil.core.with_fill.cljs$core$IFn$_invoke$arity$variadic = (function (_AMPERSAND_form,_AMPERSAND_env,fill_args,body){\nreturn cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"cljs.core\",\"let\",\"cljs.core/let\",(-308701135),null)),(function (){var x__13164__auto__ = cljs.core.vec.call(null,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"old-fill__17__auto__\",\"old-fill__17__auto__\",(1834626265),null)),(function (){var x__13164__auto__ = cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.core\",\"current-fill\",\"quil.core/current-fill\",(269663137),null))));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})())));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})(),(function (){var x__13164__auto__ = cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"cljs.core\",\"apply\",\"cljs.core/apply\",(1757277831),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.core\",\"fill\",\"quil.core/fill\",(814613078),null)),(function (){var x__13164__auto__ = fill_args;\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})()));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})(),body,(function (){var x__13164__auto__ = cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.core\",\"fill\",\"quil.core/fill\",(814613078),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"old-fill__17__auto__\",\"old-fill__17__auto__\",(1834626265),null))));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})()));\n});\n\nquil.core.with_fill.cljs$lang$maxFixedArity = (3);\n\nquil.core.with_fill.cljs$lang$applyTo = (function (seq994){\nvar G__995 = cljs.core.first.call(null,seq994);\nvar seq994__$1 = cljs.core.next.call(null,seq994);\nvar G__996 = cljs.core.first.call(null,seq994__$1);\nvar seq994__$2 = cljs.core.next.call(null,seq994__$1);\nvar G__997 = cljs.core.first.call(null,seq994__$2);\nvar seq994__$3 = cljs.core.next.call(null,seq994__$2);\nreturn quil.core.with_fill.cljs$core$IFn$_invoke$arity$variadic(G__995,G__996,G__997,seq994__$3);\n});\n\n\nquil.core.with_fill.cljs$lang$macro = true;\n/**\n * Temporarily set the stroke color for the body of this macro.\n * The code outside of with-stroke form will have the previous stroke color set.\n * \n * The stroke color has to be in a vector!\n * Example: (with-stroke [255] ...)\n *          (with-stroke [10 80 98] ...)\n */\nquil.core.with_stroke = (function quil$core$with_stroke(var_args){\nvar args__13423__auto__ = [];\nvar len__13421__auto___1005 = arguments.length;\nvar i__13422__auto___1006 = (0);\nwhile(true){\nif((i__13422__auto___1006 < len__13421__auto___1005)){\nargs__13423__auto__.push((arguments[i__13422__auto___1006]));\n\nvar G__1007 = (i__13422__auto___1006 + (1));\ni__13422__auto___1006 = G__1007;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__13424__auto__ = ((((3) < args__13423__auto__.length))?(new cljs.core.IndexedSeq(args__13423__auto__.slice((3)),(0),null)):null);\nreturn quil.core.with_stroke.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__13424__auto__);\n});\n\nquil.core.with_stroke.cljs$core$IFn$_invoke$arity$variadic = (function (_AMPERSAND_form,_AMPERSAND_env,stroke_args,body){\nreturn cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"cljs.core\",\"let\",\"cljs.core/let\",(-308701135),null)),(function (){var x__13164__auto__ = cljs.core.vec.call(null,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"old-stroke__18__auto__\",\"old-stroke__18__auto__\",(-699469010),null)),(function (){var x__13164__auto__ = cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.core\",\"current-stroke\",\"quil.core/current-stroke\",(-1148124489),null))));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})())));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})(),(function (){var x__13164__auto__ = cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"cljs.core\",\"apply\",\"cljs.core/apply\",(1757277831),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.core\",\"stroke\",\"quil.core/stroke\",(577473004),null)),(function (){var x__13164__auto__ = stroke_args;\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})()));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})(),body,(function (){var x__13164__auto__ = cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.core\",\"stroke\",\"quil.core/stroke\",(577473004),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"old-stroke__18__auto__\",\"old-stroke__18__auto__\",(-699469010),null))));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})()));\n});\n\nquil.core.with_stroke.cljs$lang$maxFixedArity = (3);\n\nquil.core.with_stroke.cljs$lang$applyTo = (function (seq1001){\nvar G__1002 = cljs.core.first.call(null,seq1001);\nvar seq1001__$1 = cljs.core.next.call(null,seq1001);\nvar G__1003 = cljs.core.first.call(null,seq1001__$1);\nvar seq1001__$2 = cljs.core.next.call(null,seq1001__$1);\nvar G__1004 = cljs.core.first.call(null,seq1001__$2);\nvar seq1001__$3 = cljs.core.next.call(null,seq1001__$2);\nreturn quil.core.with_stroke.cljs$core$IFn$_invoke$arity$variadic(G__1002,G__1003,G__1004,seq1001__$3);\n});\n\n\nquil.core.with_stroke.cljs$lang$macro = true;\n/**\n * Performs body with translation, restores current transformation on\n *   exit.\n */\nquil.core.with_translation = (function quil$core$with_translation(var_args){\nvar args__13423__auto__ = [];\nvar len__13421__auto___1012 = arguments.length;\nvar i__13422__auto___1013 = (0);\nwhile(true){\nif((i__13422__auto___1013 < len__13421__auto___1012)){\nargs__13423__auto__.push((arguments[i__13422__auto___1013]));\n\nvar G__1014 = (i__13422__auto___1013 + (1));\ni__13422__auto___1013 = G__1014;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__13424__auto__ = ((((3) < args__13423__auto__.length))?(new cljs.core.IndexedSeq(args__13423__auto__.slice((3)),(0),null)):null);\nreturn quil.core.with_translation.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__13424__auto__);\n});\n\nquil.core.with_translation.cljs$core$IFn$_invoke$arity$variadic = (function (_AMPERSAND_form,_AMPERSAND_env,translation_vector,body){\nreturn cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"cljs.core\",\"let\",\"cljs.core/let\",(-308701135),null)),(function (){var x__13164__auto__ = cljs.core.vec.call(null,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"tr__19__auto__\",\"tr__19__auto__\",(740010118),null)),(function (){var x__13164__auto__ = translation_vector;\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})())));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})(),(function (){var x__13164__auto__ = cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.core\",\"push-matrix\",\"quil.core/push-matrix\",(1356326676),null))));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})(),(function (){var x__13164__auto__ = cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"try\",\"try\",(-1273693247),null)),(function (){var x__13164__auto__ = cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.core\",\"translate\",\"quil.core/translate\",(150889028),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"tr__19__auto__\",\"tr__19__auto__\",(740010118),null))));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})(),body,(function (){var x__13164__auto__ = cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"finally\",\"finally\",(-1065347064),null)),(function (){var x__13164__auto__ = cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.core\",\"pop-matrix\",\"quil.core/pop-matrix\",(310892617),null))));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})()));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})()));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})()));\n});\n\nquil.core.with_translation.cljs$lang$maxFixedArity = (3);\n\nquil.core.with_translation.cljs$lang$applyTo = (function (seq1008){\nvar G__1009 = cljs.core.first.call(null,seq1008);\nvar seq1008__$1 = cljs.core.next.call(null,seq1008);\nvar G__1010 = cljs.core.first.call(null,seq1008__$1);\nvar seq1008__$2 = cljs.core.next.call(null,seq1008__$1);\nvar G__1011 = cljs.core.first.call(null,seq1008__$2);\nvar seq1008__$3 = cljs.core.next.call(null,seq1008__$2);\nreturn quil.core.with_translation.cljs$core$IFn$_invoke$arity$variadic(G__1009,G__1010,G__1011,seq1008__$3);\n});\n\n\nquil.core.with_translation.cljs$lang$macro = true;\n/**\n * Performs body with rotation, restores current transformation on exit.\n *   Accepts a vector [angle] or [angle x-axis y-axis z-axis].\n * \n *   Example:\n *  (with-rotation [angle]\n *    (vertex 1 2))\n */\nquil.core.with_rotation = (function quil$core$with_rotation(var_args){\nvar args__13423__auto__ = [];\nvar len__13421__auto___1019 = arguments.length;\nvar i__13422__auto___1020 = (0);\nwhile(true){\nif((i__13422__auto___1020 < len__13421__auto___1019)){\nargs__13423__auto__.push((arguments[i__13422__auto___1020]));\n\nvar G__1021 = (i__13422__auto___1020 + (1));\ni__13422__auto___1020 = G__1021;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__13424__auto__ = ((((3) < args__13423__auto__.length))?(new cljs.core.IndexedSeq(args__13423__auto__.slice((3)),(0),null)):null);\nreturn quil.core.with_rotation.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__13424__auto__);\n});\n\nquil.core.with_rotation.cljs$core$IFn$_invoke$arity$variadic = (function (_AMPERSAND_form,_AMPERSAND_env,rotation,body){\nreturn cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"cljs.core\",\"let\",\"cljs.core/let\",(-308701135),null)),(function (){var x__13164__auto__ = cljs.core.vec.call(null,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"tr__20__auto__\",\"tr__20__auto__\",(1374510188),null)),(function (){var x__13164__auto__ = rotation;\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})())));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})(),(function (){var x__13164__auto__ = cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.core\",\"push-matrix\",\"quil.core/push-matrix\",(1356326676),null))));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})(),(function (){var x__13164__auto__ = cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"try\",\"try\",(-1273693247),null)),(function (){var x__13164__auto__ = cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"cljs.core\",\"apply\",\"cljs.core/apply\",(1757277831),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.core\",\"rotate\",\"quil.core/rotate\",(-1944995048),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"tr__20__auto__\",\"tr__20__auto__\",(1374510188),null))));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})(),body,(function (){var x__13164__auto__ = cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"finally\",\"finally\",(-1065347064),null)),(function (){var x__13164__auto__ = cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.core\",\"pop-matrix\",\"quil.core/pop-matrix\",(310892617),null))));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})()));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})()));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})()));\n});\n\nquil.core.with_rotation.cljs$lang$maxFixedArity = (3);\n\nquil.core.with_rotation.cljs$lang$applyTo = (function (seq1015){\nvar G__1016 = cljs.core.first.call(null,seq1015);\nvar seq1015__$1 = cljs.core.next.call(null,seq1015);\nvar G__1017 = cljs.core.first.call(null,seq1015__$1);\nvar seq1015__$2 = cljs.core.next.call(null,seq1015__$1);\nvar G__1018 = cljs.core.first.call(null,seq1015__$2);\nvar seq1015__$3 = cljs.core.next.call(null,seq1015__$2);\nreturn quil.core.with_rotation.cljs$core$IFn$_invoke$arity$variadic(G__1016,G__1017,G__1018,seq1015__$3);\n});\n\n\nquil.core.with_rotation.cljs$lang$macro = true;\n/**\n * All subsequent calls of any drawing function will draw on given\n *   graphics. 'with-graphics' cannot be nested (you can draw simultaneously\n *   only on 1 graphics)\n */\nquil.core.with_graphics = (function quil$core$with_graphics(var_args){\nvar args__13423__auto__ = [];\nvar len__13421__auto___1026 = arguments.length;\nvar i__13422__auto___1027 = (0);\nwhile(true){\nif((i__13422__auto___1027 < len__13421__auto___1026)){\nargs__13423__auto__.push((arguments[i__13422__auto___1027]));\n\nvar G__1028 = (i__13422__auto___1027 + (1));\ni__13422__auto___1027 = G__1028;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__13424__auto__ = ((((3) < args__13423__auto__.length))?(new cljs.core.IndexedSeq(args__13423__auto__.slice((3)),(0),null)):null);\nreturn quil.core.with_graphics.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__13424__auto__);\n});\n\nquil.core.with_graphics.cljs$core$IFn$_invoke$arity$variadic = (function (_AMPERSAND_form,_AMPERSAND_env,graphics,body){\nreturn cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"cljs.core\",\"let\",\"cljs.core/let\",(-308701135),null)),(function (){var x__13164__auto__ = cljs.core.vec.call(null,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"gr__21__auto__\",\"gr__21__auto__\",(-1979290458),null)),(function (){var x__13164__auto__ = graphics;\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})())));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})(),(function (){var x__13164__auto__ = cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"cljs.core\",\"binding\",\"cljs.core/binding\",(2050379843),null)),(function (){var x__13164__auto__ = cljs.core.vec.call(null,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.core\",\"*graphics*\",\"quil.core/*graphics*\",(-1088142302),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"gr__21__auto__\",\"gr__21__auto__\",(-1979290458),null)))));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})(),(function (){var x__13164__auto__ = cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\".beginDraw\",\".beginDraw\",(1110767550),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"gr__21__auto__\",\"gr__21__auto__\",(-1979290458),null))));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})(),body,(function (){var x__13164__auto__ = cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\".endDraw\",\".endDraw\",(795589408),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"gr__21__auto__\",\"gr__21__auto__\",(-1979290458),null))));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})()));\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})()));\n});\n\nquil.core.with_graphics.cljs$lang$maxFixedArity = (3);\n\nquil.core.with_graphics.cljs$lang$applyTo = (function (seq1022){\nvar G__1023 = cljs.core.first.call(null,seq1022);\nvar seq1022__$1 = cljs.core.next.call(null,seq1022);\nvar G__1024 = cljs.core.first.call(null,seq1022__$1);\nvar seq1022__$2 = cljs.core.next.call(null,seq1022__$1);\nvar G__1025 = cljs.core.first.call(null,seq1022__$2);\nvar seq1022__$3 = cljs.core.next.call(null,seq1022__$2);\nreturn quil.core.with_graphics.cljs$core$IFn$_invoke$arity$variadic(G__1023,G__1024,G__1025,seq1022__$3);\n});\n\n\nquil.core.with_graphics.cljs$lang$macro = true;\n/**\n * Create and start a new visualisation applet. Can be used to create\n *   new sketches programmatically. See documentation for 'defsketch' for\n *   list of available options.\n */\nquil.core.sketch = (function quil$core$sketch(var_args){\nvar args__13423__auto__ = [];\nvar len__13421__auto___1030 = arguments.length;\nvar i__13422__auto___1031 = (0);\nwhile(true){\nif((i__13422__auto___1031 < len__13421__auto___1030)){\nargs__13423__auto__.push((arguments[i__13422__auto___1031]));\n\nvar G__1032 = (i__13422__auto___1031 + (1));\ni__13422__auto___1031 = G__1032;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__13424__auto__ = ((((0) < args__13423__auto__.length))?(new cljs.core.IndexedSeq(args__13423__auto__.slice((0)),(0),null)):null);\nreturn quil.core.sketch.cljs$core$IFn$_invoke$arity$variadic(argseq__13424__auto__);\n});\n\nquil.core.sketch.cljs$core$IFn$_invoke$arity$variadic = (function (opts){\nreturn cljs.core.apply.call(null,quil.sketch.sketch,opts);\n});\n\nquil.core.sketch.cljs$lang$maxFixedArity = (0);\n\nquil.core.sketch.cljs$lang$applyTo = (function (seq1029){\nreturn quil.core.sketch.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq.call(null,seq1029));\n});\n\n/**\n * Define and start a sketch and bind it to a var with the symbol\n *   app-name. If any of the options to the various callbacks are\n *   symbols, it wraps them in a call to var to ensure they aren't\n *   inlined and that redefinitions to the original fns are reflected in\n *   the visualisation.\n * \n *   Available options:\n * \n * :size           - A vector of width and height for the sketch or :fullscreen.\n *                   Defaults to [500 300]. If you're using :fullscreen you may\n *                   want to enable present mode - :features [:present]\n * \n * :renderer       - Specifies the renderer type. One of :p2d, :p3d, :java2d,\n *                   :opengl, :pdf). Defaults to :java2d. :dxf renderer\n *                   can't be used as sketch renderer. Use begin-raw method\n *                   instead. In clojurescript only :p2d and :p3d renderers\n *                   are supported.\n * \n * :output-file    - Specifies an output file path. Only used in :pdf mode.\n *                   Not supported in clojurescript.\n * \n * :title          - A string which will be displayed at the top of\n *                   the sketch window. Not supported in clojurescript.\n * \n * :features       - A vector of keywords customizing sketch behaviour.\n *                   Supported features:\n * \n *                   :keep-on-top - Sketch window will always be above other\n *                                  windows. Note: some platforms might not\n *                                  support always-on-top windows.\n *                                  Not supported in clojurescript.\n * \n *                   :exit-on-close - Shutdown JVM  when sketch is closed.\n *                                    Not supported in clojurescript.\n * \n *                   :resizable - Makes sketch resizable.\n *                                Not supported in clojurescript.\n * \n *                   :no-safe-fns - Do not catch and print exceptions thrown\n *                                  inside functions provided to sketch (like\n *                                  draw, mouse-click, key-pressed and\n *                                  other). By default all exceptions thrown\n *                                  inside these functions are catched. This\n *                                  prevents sketch from breaking when bad\n *                                  function was provided and allows you to\n *                                  fix it and reload it on fly. You can\n *                                  disable this behaviour by enabling\n *                                  :no-safe-fns feature.\n *                                  Not supported in clojurescript.\n * \n *                   :present - Switch to present mode (fullscreen without\n *                              borders, OS panels). You may want to use\n *                              this feature together with :size :fullscreen.\n *                              Not supported in clojurescript.\n * \n *                   :no-start - Disables autostart if sketch was created using\n *                               defsketch macro. To start sketch you have to\n *                               call function created defsketch.\n *                               Supported only in clojurescript.\n * \n *                   :global-key-events - Allows a sketch to receive any\n *                                        keyboard event sent to the page,\n *                                        regardless of whether the canvas it is\n *                                        loaded in has focus or not.\n *                                        Supported only in clojurescript.\n * \n *                   Usage example: :features [:keep-on-top :present]\n * \n * :bgcolor        - Sets background color for unused space in present mode.\n *                   Color is specified in hex format: #XXXXXX.\n *                   Example: :bgcolor \"#00FFFF\" (cyan background)\n *                   Not supported in clojurescript.\n * \n * :display        - Sets what display should be used by this sketch.\n *                   Displays are numbered starting from 0. Example: :display 1.\n *                   Not supported in clojurescript.\n * \n * :setup          - A function to be called once when setting the sketch up.\n * \n * :draw           - A function to be repeatedly called at most n times per\n *                   second where n is the target frame-rate set for\n *                   the visualisation.\n * \n * :host           - String id of canvas element or DOM element itself.\n *                   Specifies host for the sketch. Must be specified in sketch,\n *                   may be omitted in defsketch. If ommitted in defsketch,\n *                   :host is set to the name of the sketch. If element with\n *                   specified id is not found on the page and page is empty -\n *                   new canvas element will be created. Used in clojurescript.\n * \n * :focus-gained   - Called when the sketch gains focus.\n *                   Not supported in clojurescript.\n * \n * :focus-lost     - Called when the sketch loses focus.\n *                   Not supported in clojurescript.\n * \n * :mouse-entered  - Called when the mouse enters the sketch window.\n * \n * :mouse-exited   - Called when the mouse leaves the sketch window\n * \n * :mouse-pressed  - Called every time a mouse button is pressed.\n * \n * :mouse-released - Called every time a mouse button is released.\n * \n * :mouse-clicked  - called once after a mouse button has been pressed\n *                   and then released.\n * \n * :mouse-moved    - Called every time the mouse moves and a button is\n *                   not pressed.\n * \n * :mouse-dragged  - Called every time the mouse moves and a button is\n *                   pressed.\n * \n * :mouse-wheel    - Called every time mouse wheel is rotated.\n *                   Takes 1 argument - wheel rotation, an int.\n *                   Negative values if the mouse wheel was rotated\n *                   up/away from the user, and positive values\n *                   if the mouse wheel was rotated down/ towards the user\n * \n * :key-pressed    - Called every time any key is pressed.\n * \n * :key-released   - Called every time any key is released.\n * \n * :key-typed      - Called once every time non-modifier keys are\n *                   pressed.\n * \n * :on-close       - Called once, when sketch is closed\n *                   Not supported in clojurescript.\n * \n * :middleware     - Vector of middleware to be applied to the sketch.\n *                   Middleware will be applied in the same order as in comp\n *                   function: [f g] will be applied as (f (g options)).\n * \n * :settings       - cousin of :setup. A function to be called once when\n *                   setting sketch up. Should be used only for (smooth) and\n *                   (no-smooth). Due to Processing limitations these functions\n *                   cannot be used neither in :setup nor in :draw.\n */\nquil.core.defsketch = (function quil$core$defsketch(var_args){\nvar args__13423__auto__ = [];\nvar len__13421__auto___1037 = arguments.length;\nvar i__13422__auto___1038 = (0);\nwhile(true){\nif((i__13422__auto___1038 < len__13421__auto___1037)){\nargs__13423__auto__.push((arguments[i__13422__auto___1038]));\n\nvar G__1039 = (i__13422__auto___1038 + (1));\ni__13422__auto___1038 = G__1039;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__13424__auto__ = ((((3) < args__13423__auto__.length))?(new cljs.core.IndexedSeq(args__13423__auto__.slice((3)),(0),null)):null);\nreturn quil.core.defsketch.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__13424__auto__);\n});\n\nquil.core.defsketch.cljs$core$IFn$_invoke$arity$variadic = (function (_AMPERSAND_form,_AMPERSAND_env,app_name,options){\nreturn cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.sketch\",\"defsketch\",\"quil.sketch/defsketch\",(495366770),null)),(function (){var x__13164__auto__ = app_name;\nreturn cljs.core._conj.call(null,cljs.core.List.EMPTY,x__13164__auto__);\n})(),options));\n});\n\nquil.core.defsketch.cljs$lang$maxFixedArity = (3);\n\nquil.core.defsketch.cljs$lang$applyTo = (function (seq1033){\nvar G__1034 = cljs.core.first.call(null,seq1033);\nvar seq1033__$1 = cljs.core.next.call(null,seq1033);\nvar G__1035 = cljs.core.first.call(null,seq1033__$1);\nvar seq1033__$2 = cljs.core.next.call(null,seq1033__$1);\nvar G__1036 = cljs.core.first.call(null,seq1033__$2);\nvar seq1033__$3 = cljs.core.next.call(null,seq1033__$2);\nreturn quil.core.defsketch.cljs$core$IFn$_invoke$arity$variadic(G__1034,G__1035,G__1036,seq1033__$3);\n});\n\n\nquil.core.defsketch.cljs$lang$macro = true;\n/**\n * Returns true if char c is a 'coded' char i.e. it is necessary to\n *   fetch the key-code as an integer and use that to determine the\n *   specific key pressed. See key-keyword.\n */\nquil.core.key_coded_QMARK_ = (function quil$core$key_coded_QMARK_(c){\nreturn cljs.core._EQ_.call(null,(65535),String(c).charCodeAt());\n});\n/**\n * Returns a keyword representing the currently pressed key. Modifier\n *   keys are represented as: :up, :down, :left, :right, :alt, :control,\n *   :shift, :command, :f1-24\n */\nquil.core.key_as_keyword = (function quil$core$key_as_keyword(){\nvar key_char = quil.core.raw_key.call(null);\nvar code = quil.core.key_code.call(null);\nif(cljs.core.truth_(quil.core.key_coded_QMARK_.call(null,key_char))){\nreturn cljs.core.get.call(null,quil.core.KEY_CODES,code,new cljs.core.Keyword(null,\"unknown-key\",\"unknown-key\",(255305911)));\n} else {\nreturn cljs.core.keyword.call(null,String(key_char));\n}\n});\n","quil/core$macros.cache.json":"[\"^ \",\"~:rename-macros\",[\"^ \"],\"~:renames\",[\"^ \"],\"~:use-macros\",[\"^ \"],\"~:excludes\",[\"~#set\",[]],\"~:name\",\"~$quil.core$macros\",\"~:imports\",null,\"~:requires\",[\"^ \",\"~$clojure.string\",\"^9\",\"~$org.processingjs.Processing\",\"^:\",\"~$ap\",\"~$quil.sketch\",\"^<\",\"^<\",\"~$u\",\"~$quil.util\",\"^=\",\"^=\"],\"~:uses\",null,\"~:defs\",[\"^ \",\"~$rotate-x\",[\"^ \",\"~:category\",\"Transform\",\"~:protocol-inline\",null,\"~:meta\",[\"^ \",\"^A\",\"Transform\",\"~:added\",\"1.0\",\"~:subcategory\",null,\"~:file\",\"~$quil.core\",\"~:end-column\",11,\"~:processing-name\",\"rotateX()\",\"~:column\",3,\"~:requires-bindings\",true,\"~:line\",3436,\"~:end-line\",3436,\"~:arglists\",[\"~#list\",[\"~$quote\",[\"^O\",[[\"~$angle\"]]]]],\"~:doc\",\"Rotates a shape around the x-axis the amount specified by the angle\\n  parameter. Angles should be specified in radians (values from 0 to\\n  (* PI 2)) or converted to radians with the radians function. Objects\\n  are always rotated around their relative position to the origin and\\n  positive numbers rotate objects in a counterclockwise\\n  direction. Transformations apply to everything that happens after\\n  and subsequent calls to the function accumulates the effect. For\\n  example, calling (rotate-x HALF-PI) and then (rotate-x HALF-PI) is\\n  the same as (rotate-x PI). If rotate-x is called within the draw fn,\\n  the transformation is reset when the loop begins again. This\\n  function requires either the :p3d or :opengl renderer.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/rotate-x\",\"~:variadic\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^H\",11,\"^I\",\"rotateX()\",\"~:method-params\",[\"^O\",[[\"^Q\"]]],\"~:protocol-impl\",null,\"~:arglists-meta\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",3430,\"^M\",3436,\"~:max-fixed-arity\",1,\"~:fn-var\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^Q\"]]]]],\"^R\",\"Rotates a shape around the x-axis the amount specified by the angle\\n  parameter. Angles should be specified in radians (values from 0 to\\n  (* PI 2)) or converted to radians with the radians function. Objects\\n  are always rotated around their relative position to the origin and\\n  positive numbers rotate objects in a counterclockwise\\n  direction. Transformations apply to everything that happens after\\n  and subsequent calls to the function accumulates the effect. For\\n  example, calling (rotate-x HALF-PI) and then (rotate-x HALF-PI) is\\n  the same as (rotate-x PI). If rotate-x is called within the draw fn,\\n  the transformation is reset when the loop begins again. This\\n  function requires either the :p3d or :opengl renderer.\"],\"~$text-modes\",[\"^ \",\"^5\",\"~$quil.core$macros/text-modes\",\"^F\",\"quil/core.cljc\",\"^L\",45,\"^J\",1,\"^M\",68,\"^H\",12,\"^C\",[\"^ \",\"^F\",\"^G\",\"^L\",68,\"^J\",2,\"^M\",68,\"^H\",12]],\"~$print-projection\",[\"^ \",\"^A\",\"Lights, Camera\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Lights, Camera\",\"^D\",\"1.0\",\"^E\",\"Camera\",\"^F\",\"^G\",\"^H\",19,\"^I\",\"printProjection()\",\"^J\",3,\"^K\",true,\"^L\",3070,\"^M\",3070,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Prints the current projection matrix to std out. Useful for\\n  debugging\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/print-projection\",\"^T\",false,\"^E\",\"Camera\",\"^F\",\"quil/core.cljc\",\"^H\",19,\"^I\",\"printProjection()\",\"^U\",[\"^O\",[[]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",3064,\"^M\",3070,\"^X\",0,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Prints the current projection matrix to std out. Useful for\\n  debugging\"],\"~$raw-key\",[\"^ \",\"^A\",\"Input\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Input\",\"^D\",\"1.0\",\"^E\",\"Keyboard\",\"^F\",\"^G\",\"^H\",10,\"^I\",\"key\",\"^J\",3,\"^K\",true,\"^L\",3229,\"^M\",3229,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Contains the value of the most recent key on the keyboard that was\\n  used (either pressed or released).\\n\\n  For non-ASCII keys, use the keyCode variable. The keys included in\\n  the ASCII specification (BACKSPACE, TAB, ENTER, RETURN, ESC, and\\n  DELETE) do not require checking to see if they key is coded, and you\\n  should simply use the key variable instead of keyCode If you're\\n  making cross-platform projects, note that the ENTER key is commonly\\n  used on PCs and Unix and the RETURN key is used instead on\\n  Macintosh. Check for both ENTER and RETURN to make sure your program\\n  will work for all platforms.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/raw-key\",\"^T\",false,\"^E\",\"Keyboard\",\"^F\",\"quil/core.cljc\",\"^H\",10,\"^I\",\"key\",\"^U\",[\"^O\",[[]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",3223,\"^M\",3229,\"^X\",0,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Contains the value of the most recent key on the keyboard that was\\n  used (either pressed or released).\\n\\n  For non-ASCII keys, use the keyCode variable. The keys included in\\n  the ASCII specification (BACKSPACE, TAB, ENTER, RETURN, ESC, and\\n  DELETE) do not require checking to see if they key is coded, and you\\n  should simply use the key variable instead of keyCode If you're\\n  making cross-platform projects, note that the ENTER key is commonly\\n  used on PCs and Unix and the RETURN key is used instead on\\n  Macintosh. Check for both ENTER and RETURN to make sure your program\\n  will work for all platforms.\"],\"~$text-char\",[\"^ \",\"^A\",\"Typography\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Typography\",\"^D\",\"1.0\",\"^E\",\"Loading & Displaying\",\"^F\",\"^G\",\"^H\",12,\"~:top-fn\",[\"^ \",\"^T\",false,\"^X\",4,\"^U\",[\"^O\",[[\"~$c\",\"~$x\",\"~$y\"],[\"~$c\",\"~$x\",\"~$y\",\"~$z\"]]],\"^N\",[\"^O\",[[\"~$c\",\"~$x\",\"~$y\"],[\"~$c\",\"~$x\",\"~$y\",\"~$z\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"text()\",\"^J\",3,\"^K\",true,\"^L\",4116,\"^M\",4116,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$c\",\"~$x\",\"~$y\"],[\"~$c\",\"~$x\",\"~$y\",\"~$z\"]]]]],\"^R\",\"Draws a char to the screen in the specified position. See text fn\\n  for more details.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/text-char\",\"^T\",false,\"^E\",\"Loading & Displaying\",\"^F\",\"quil/core.cljc\",\"^H\",12,\"^15\",[\"^ \",\"^T\",false,\"^X\",4,\"^U\",[\"^O\",[[\"~$c\",\"~$x\",\"~$y\"],[\"~$c\",\"~$x\",\"~$y\",\"~$z\"]]],\"^N\",[\"^O\",[[\"~$c\",\"~$x\",\"~$y\"],[\"~$c\",\"~$x\",\"~$y\",\"~$z\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"text()\",\"^U\",[\"^O\",[[\"~$c\",\"~$x\",\"~$y\"],[\"~$c\",\"~$x\",\"~$y\",\"~$z\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",4110,\"^M\",4116,\"^X\",4,\"^Y\",true,\"^N\",[\"^O\",[[\"~$c\",\"~$x\",\"~$y\"],[\"~$c\",\"~$x\",\"~$y\",\"~$z\"]]],\"^R\",\"Draws a char to the screen in the specified position. See text fn\\n  for more details.\"],\"~$display-filter\",[\"^ \",\"^A\",\"Image\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Image\",\"^D\",\"1.0\",\"^E\",\"Pixels\",\"^F\",\"^G\",\"^H\",17,\"^15\",[\"^ \",\"^T\",false,\"^X\",2,\"^U\",[\"^O\",[[\"~$mode\"],[\"^18\",\"~$level\"]]],\"^N\",[\"^O\",[[\"^18\"],[\"^18\",\"^19\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"filter()\",\"^J\",3,\"^K\",true,\"^L\",1777,\"^M\",1777,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^18\"],[\"^18\",\"^19\"]]]]],\"^R\",\"Originally named filter in Processing Language.\\n  Filters the display window with the specified mode and level.\\n  Level defines the quality of the filter and mode may be one of the\\n  following keywords:\\n\\n  :threshold - converts the image to black and white pixels depending\\n               if they are above or below the threshold defined by\\n               the level parameter. The level must be between\\n               0.0 (black) and 1.0 (white). If no level is specified,\\n               0.5 is used.\\n  :gray      - converts any colors in the image to grayscale\\n               equivalents. Doesn't work with level.\\n  :invert    - sets each pixel to its inverse value. Doesn't work with\\n               level.\\n  :posterize - limits each channel of the image to the number of\\n               colors specified as the level parameter. The parameter can\\n               be set to values between 2 and 255, but results are most\\n               noticeable in the lower ranges.\\n  :blur      - executes a Guassian blur with the level parameter\\n               specifying the extent of the blurring. If no level\\n               parameter is used, the blur is equivalent to Guassian\\n               blur of radius 1.\\n  :opaque    - sets the alpha channel to entirely opaque. Doesn't work\\n               with level.\\n  :erode     - reduces the light areas. Doesn't work with level.\\n  :dilate    - increases the light areas.  Doesn't work with level.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/display-filter\",\"^T\",false,\"^E\",\"Pixels\",\"^F\",\"quil/core.cljc\",\"^H\",17,\"^15\",[\"^ \",\"^T\",false,\"^X\",2,\"^U\",[\"^O\",[[\"^18\"],[\"^18\",\"^19\"]]],\"^N\",[\"^O\",[[\"^18\"],[\"^18\",\"^19\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"filter()\",\"^U\",[\"^O\",[[\"^18\"],[\"^18\",\"^19\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",1771,\"^M\",1777,\"^X\",2,\"^Y\",true,\"^N\",[\"^O\",[[\"^18\"],[\"^18\",\"^19\"]]],\"^R\",\"Originally named filter in Processing Language.\\n  Filters the display window with the specified mode and level.\\n  Level defines the quality of the filter and mode may be one of the\\n  following keywords:\\n\\n  :threshold - converts the image to black and white pixels depending\\n               if they are above or below the threshold defined by\\n               the level parameter. The level must be between\\n               0.0 (black) and 1.0 (white). If no level is specified,\\n               0.5 is used.\\n  :gray      - converts any colors in the image to grayscale\\n               equivalents. Doesn't work with level.\\n  :invert    - sets each pixel to its inverse value. Doesn't work with\\n               level.\\n  :posterize - limits each channel of the image to the number of\\n               colors specified as the level parameter. The parameter can\\n               be set to values between 2 and 255, but results are most\\n               noticeable in the lower ranges.\\n  :blur      - executes a Guassian blur with the level parameter\\n               specifying the extent of the blurring. If no level\\n               parameter is used, the blur is equivalent to Guassian\\n               blur of radius 1.\\n  :opaque    - sets the alpha channel to entirely opaque. Doesn't work\\n               with level.\\n  :erode     - reduces the light areas. Doesn't work with level.\\n  :dilate    - increases the light areas.  Doesn't work with level.\"],\"~$rotate-z\",[\"^ \",\"^A\",\"Transform\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Transform\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^G\",\"^H\",11,\"^I\",\"rotateZ()\",\"^J\",3,\"^K\",true,\"^L\",3478,\"^M\",3478,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^Q\"]]]]],\"^R\",\"Rotates a shape around the z-axis the amount specified by the angle\\n  parameter. Angles should be specified in radians (values from 0\\n  to (* PI 2)) or converted to radians with the radians function.\\n  Objects are always rotated around their relative position to the\\n  origin and positive numbers rotate objects in a counterclockwise\\n  direction. Transformations apply to everything that happens after\\n  and subsequent calls to the function accumulates the effect. For\\n  example, calling (rotate-z HALF-PI) and then (rotate-z HALF-PI) is\\n  the same as (rotate-z PI). If rotate-y is called within the draw fn,\\n  the transformation is reset when the loop begins again. This\\n  function requires either the :p3d or :opengl renderer.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/rotate-z\",\"^T\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^H\",11,\"^I\",\"rotateZ()\",\"^U\",[\"^O\",[[\"^Q\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",3472,\"^M\",3478,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^Q\"]]]]],\"^R\",\"Rotates a shape around the z-axis the amount specified by the angle\\n  parameter. Angles should be specified in radians (values from 0\\n  to (* PI 2)) or converted to radians with the radians function.\\n  Objects are always rotated around their relative position to the\\n  origin and positive numbers rotate objects in a counterclockwise\\n  direction. Transformations apply to everything that happens after\\n  and subsequent calls to the function accumulates the effect. For\\n  example, calling (rotate-z HALF-PI) and then (rotate-z HALF-PI) is\\n  the same as (rotate-z PI). If rotate-y is called within the draw fn,\\n  the transformation is reset when the loop begins again. This\\n  function requires either the :p3d or :opengl renderer.\"],\"~$random-gaussian\",[\"^ \",\"^A\",\"Math\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Math\",\"^D\",\"2.0\",\"^E\",\"Random\",\"^F\",\"^G\",\"^H\",18,\"^I\",\"randomGaussian()\",\"^J\",3,\"^K\",true,\"^L\",3198,\"^M\",3198,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Returns a float from a random series of numbers having a mean of 0 and\\n  standard deviation of 1. Each time the randomGaussian() function is called,\\n  it returns a number fitting a Gaussian, or normal, distribution.\\n  There is theoretically no minimum or maximum value that randomGaussian()\\n  might return. Rather, there is just a very low probability that values far\\n  from the mean will be returned; and a higher probability that numbers near\\n  the mean will be returned. .\"],\"^D\",\"2.0\",\"^5\",\"~$quil.core$macros/random-gaussian\",\"^T\",false,\"^E\",\"Random\",\"^F\",\"quil/core.cljc\",\"^H\",18,\"^I\",\"randomGaussian()\",\"^U\",[\"^O\",[[]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",3192,\"^M\",3198,\"^X\",0,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Returns a float from a random series of numbers having a mean of 0 and\\n  standard deviation of 1. Each time the randomGaussian() function is called,\\n  it returns a number fitting a Gaussian, or normal, distribution.\\n  There is theoretically no minimum or maximum value that randomGaussian()\\n  might return. Rather, there is just a very low probability that values far\\n  from the mean will be returned; and a higher probability that numbers near\\n  the mean will be returned. .\"],\"~$blend\",[\"^ \",\"^A\",\"Image\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Image\",\"^D\",\"1.0\",\"^E\",\"Pixels\",\"^F\",\"^G\",\"^H\",8,\"^15\",[\"^ \",\"^T\",false,\"^X\",11,\"^U\",[\"^O\",[[\"~$x\",\"~$y\",\"~$width\",\"~$height\",\"~$dx\",\"~$dy\",\"~$dwidth\",\"~$dheight\",\"^18\"],[\"~$src-img\",\"~$x\",\"~$y\",\"^1@\",\"^1A\",\"^1B\",\"^1C\",\"^1D\",\"^1E\",\"^18\"],[\"^1F\",\"~$dest-img\",\"~$x\",\"~$y\",\"^1@\",\"^1A\",\"^1B\",\"^1C\",\"^1D\",\"^1E\",\"^18\"]]],\"^N\",[\"^O\",[[\"~$x\",\"~$y\",\"^1@\",\"^1A\",\"^1B\",\"^1C\",\"^1D\",\"^1E\",\"^18\"],[\"^1F\",\"~$x\",\"~$y\",\"^1@\",\"^1A\",\"^1B\",\"^1C\",\"^1D\",\"^1E\",\"^18\"],[\"^1F\",\"^1G\",\"~$x\",\"~$y\",\"^1@\",\"^1A\",\"^1B\",\"^1C\",\"^1D\",\"^1E\",\"^18\"]]],\"^W\",[\"^O\",[null,null,null]]],\"^I\",\"blend()\",\"^J\",3,\"^K\",true,\"^L\",778,\"^M\",778,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$x\",\"~$y\",\"^1@\",\"^1A\",\"^1B\",\"^1C\",\"^1D\",\"^1E\",\"^18\"],[\"^1F\",\"~$x\",\"~$y\",\"^1@\",\"^1A\",\"^1B\",\"^1C\",\"^1D\",\"^1E\",\"^18\"],[\"^1F\",\"^1G\",\"~$x\",\"~$y\",\"^1@\",\"^1A\",\"^1B\",\"^1C\",\"^1D\",\"^1E\",\"^18\"]]]]],\"^R\",\"Blends a region of pixels from one image into another with full alpha\\n  channel support. If src is not specified it defaults to current-graphics.\\n  If dest is not specified it defaults to current-graphics.\\n\\n  Note: blend-mode function is recommended to use instead of this one.\\n\\n  Available blend modes are:\\n\\n  :blend      - linear interpolation of colours: C = A*factor + B\\n  :add        - additive blending with white clip:\\n                                            C = min(A*factor + B, 255)\\n  :subtract   - subtractive blending with black clip:\\n                                            C = max(B - A*factor, 0)\\n  :darkest    - only the darkest colour succeeds:\\n                                            C = min(A*factor, B)\\n  :lightest   - only the lightest colour succeeds:\\n                                            C = max(A*factor, B)\\n  :difference - subtract colors from underlying image.\\n  :exclusion  - similar to :difference, but less extreme.\\n  :multiply   - Multiply the colors, result will always be darker.\\n  :screen     - Opposite multiply, uses inverse values of the colors.\\n  :overlay    - A mix of :multiply and :screen. Multiplies dark values\\n                and screens light values.\\n  :hard-light - :screen when greater than 50% gray, :multiply when\\n                lower.\\n  :soft-light - Mix of :darkest and :lightest. Works like :overlay,\\n                but not as harsh.\\n  :dodge      - Lightens light tones and increases contrast, ignores\\n                darks.\\n                Called \\\"Color Dodge\\\" in Illustrator and Photoshop.\\n  :burn       - Darker areas are applied, increasing contrast, ignores\\n                lights. Called \\\"Color Burn\\\" in Illustrator and\\n                Photoshop.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/blend\",\"^T\",false,\"^E\",\"Pixels\",\"^F\",\"quil/core.cljc\",\"^H\",8,\"^15\",[\"^ \",\"^T\",false,\"^X\",11,\"^U\",[\"^O\",[[\"~$x\",\"~$y\",\"^1@\",\"^1A\",\"^1B\",\"^1C\",\"^1D\",\"^1E\",\"^18\"],[\"^1F\",\"~$x\",\"~$y\",\"^1@\",\"^1A\",\"^1B\",\"^1C\",\"^1D\",\"^1E\",\"^18\"],[\"^1F\",\"^1G\",\"~$x\",\"~$y\",\"^1@\",\"^1A\",\"^1B\",\"^1C\",\"^1D\",\"^1E\",\"^18\"]]],\"^N\",[\"^O\",[[\"~$x\",\"~$y\",\"^1@\",\"^1A\",\"^1B\",\"^1C\",\"^1D\",\"^1E\",\"^18\"],[\"^1F\",\"~$x\",\"~$y\",\"^1@\",\"^1A\",\"^1B\",\"^1C\",\"^1D\",\"^1E\",\"^18\"],[\"^1F\",\"^1G\",\"~$x\",\"~$y\",\"^1@\",\"^1A\",\"^1B\",\"^1C\",\"^1D\",\"^1E\",\"^18\"]]],\"^W\",[\"^O\",[null,null,null]]],\"^I\",\"blend()\",\"^U\",[\"^O\",[[\"~$x\",\"~$y\",\"^1@\",\"^1A\",\"^1B\",\"^1C\",\"^1D\",\"^1E\",\"^18\"],[\"^1F\",\"~$x\",\"~$y\",\"^1@\",\"^1A\",\"^1B\",\"^1C\",\"^1D\",\"^1E\",\"^18\"],[\"^1F\",\"^1G\",\"~$x\",\"~$y\",\"^1@\",\"^1A\",\"^1B\",\"^1C\",\"^1D\",\"^1E\",\"^18\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null,null]],\"^J\",1,\"^K\",true,\"^L\",772,\"^M\",778,\"^X\",11,\"^Y\",true,\"^N\",[\"^O\",[[\"~$x\",\"~$y\",\"^1@\",\"^1A\",\"^1B\",\"^1C\",\"^1D\",\"^1E\",\"^18\"],[\"^1F\",\"~$x\",\"~$y\",\"^1@\",\"^1A\",\"^1B\",\"^1C\",\"^1D\",\"^1E\",\"^18\"],[\"^1F\",\"^1G\",\"~$x\",\"~$y\",\"^1@\",\"^1A\",\"^1B\",\"^1C\",\"^1D\",\"^1E\",\"^18\"]]],\"^R\",\"Blends a region of pixels from one image into another with full alpha\\n  channel support. If src is not specified it defaults to current-graphics.\\n  If dest is not specified it defaults to current-graphics.\\n\\n  Note: blend-mode function is recommended to use instead of this one.\\n\\n  Available blend modes are:\\n\\n  :blend      - linear interpolation of colours: C = A*factor + B\\n  :add        - additive blending with white clip:\\n                                            C = min(A*factor + B, 255)\\n  :subtract   - subtractive blending with black clip:\\n                                            C = max(B - A*factor, 0)\\n  :darkest    - only the darkest colour succeeds:\\n                                            C = min(A*factor, B)\\n  :lightest   - only the lightest colour succeeds:\\n                                            C = max(A*factor, B)\\n  :difference - subtract colors from underlying image.\\n  :exclusion  - similar to :difference, but less extreme.\\n  :multiply   - Multiply the colors, result will always be darker.\\n  :screen     - Opposite multiply, uses inverse values of the colors.\\n  :overlay    - A mix of :multiply and :screen. Multiplies dark values\\n                and screens light values.\\n  :hard-light - :screen when greater than 50% gray, :multiply when\\n                lower.\\n  :soft-light - Mix of :darkest and :lightest. Works like :overlay,\\n                but not as harsh.\\n  :dodge      - Lightens light tones and increases contrast, ignores\\n                darks.\\n                Called \\\"Color Dodge\\\" in Illustrator and Photoshop.\\n  :burn       - Darker areas are applied, increasing contrast, ignores\\n                lights. Called \\\"Color Burn\\\" in Illustrator and\\n                Photoshop.\"],\"~$frame-count\",[\"^ \",\"^A\",\"Environment\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Environment\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^G\",\"^H\",14,\"^I\",\"frameCount\",\"^J\",3,\"^K\",true,\"^L\",1853,\"^M\",1853,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"The system variable frameCount contains the number of frames\\n  displayed since the program started. Inside setup() the value is 0\\n  and after the first iteration of draw it is 1, etc.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/frame-count\",\"^T\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^H\",14,\"^I\",\"frameCount\",\"^U\",[\"^O\",[[]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",1847,\"^M\",1853,\"^X\",0,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"The system variable frameCount contains the number of frames\\n  displayed since the program started. Inside setup() the value is 0\\n  and after the first iteration of draw it is 1, etc.\"],\"~$with-graphics\",[\"^ \",\"^A\",\"Rendering\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Rendering\",\"^D\",\"1.7\",\"^F\",\"^G\",\"^H\",16,\"^15\",[\"^ \",\"^T\",true,\"^X\",3,\"^U\",[[\"^O\",[\"~$&form\",\"~$&env\",\"~$graphics\",\"~$body\"]]],\"^N\",[\"^O\",[[\"^1L\",\"^1M\",\"^1N\",\"~$&\",\"^1O\"]]],\"^W\",[\"^O\",[null]]],\"^I\",null,\"^J\",3,\"^K\",true,\"^L\",4681,\"~:macro\",true,\"^M\",4681,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^1N\",\"~$&\",\"^1O\"]]]]],\"^R\",\"All subsequent calls of any drawing function will draw on given\\n  graphics. 'with-graphics' cannot be nested (you can draw simultaneously\\n  only on 1 graphics)\"],\"^D\",\"1.7\",\"^5\",\"~$quil.core$macros/with-graphics\",\"^T\",true,\"^F\",\"quil/core.cljc\",\"^H\",16,\"^15\",[\"^ \",\"^T\",true,\"^X\",3,\"^U\",[[\"^O\",[\"^1L\",\"^1M\",\"^1N\",\"^1O\"]]],\"^N\",[\"^O\",[[\"^1L\",\"^1M\",\"^1N\",\"~$&\",\"^1O\"]]],\"^W\",[\"^O\",[null]]],\"^I\",null,\"^U\",[[\"^O\",[\"^1L\",\"^1M\",\"^1N\",\"^1O\"]]],\"^V\",null,\"^W\",[\"^O\",[null]],\"^J\",1,\"^K\",true,\"^L\",4676,\"^1P\",true,\"^M\",4681,\"^X\",3,\"^Y\",false,\"^N\",[\"^O\",[[\"^1L\",\"^1M\",\"^1N\",\"~$&\",\"^1O\"]]],\"^R\",\"All subsequent calls of any drawing function will draw on given\\n  graphics. 'with-graphics' cannot be nested (you can draw simultaneously\\n  only on 1 graphics)\"],\"~$model-y\",[\"^ \",\"^A\",\"Lights, Camera\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Lights, Camera\",\"^D\",\"1.0\",\"^E\",\"Coordinates\",\"^F\",\"^G\",\"^H\",10,\"^I\",\"modelY()\",\"^J\",3,\"^K\",true,\"^L\",2538,\"^M\",2538,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$x\",\"~$y\",\"~$z\"]]]]],\"^R\",\"Returns the three-dimensional x, y, z position in model space. This\\n  returns the y value for a given coordinate based on the current set\\n  of transformations (scale, rotate, translate, etc.) The y value can\\n  be used to place an object in space relative to the location of the\\n  original point once the transformations are no longer in use.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/model-y\",\"^T\",false,\"^E\",\"Coordinates\",\"^F\",\"quil/core.cljc\",\"^H\",10,\"^I\",\"modelY()\",\"^U\",[\"^O\",[[\"~$x\",\"~$y\",\"~$z\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",2532,\"^M\",2538,\"^X\",3,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$x\",\"~$y\",\"~$z\"]]]]],\"^R\",\"Returns the three-dimensional x, y, z position in model space. This\\n  returns the y value for a given coordinate based on the current set\\n  of transformations (scale, rotate, translate, etc.) The y value can\\n  be used to place an object in space relative to the location of the\\n  original point once the transformations are no longer in use.\"],\"~$set-image\",[\"^ \",\"^A\",\"Image\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Image\",\"^D\",\"1.0\",\"^E\",\"Pixels\",\"^F\",\"^G\",\"^H\",12,\"^I\",\"set()\",\"^J\",3,\"^K\",true,\"^L\",3694,\"^M\",3694,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$x\",\"~$y\",\"~$src\"]]]]],\"^R\",\"Writes an image directly into the display window. The x and y\\n  parameters define the coordinates for the upper-left corner of the\\n  image.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/set-image\",\"^T\",false,\"^E\",\"Pixels\",\"^F\",\"quil/core.cljc\",\"^H\",12,\"^I\",\"set()\",\"^U\",[\"^O\",[[\"~$x\",\"~$y\",\"^1U\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",3688,\"^M\",3694,\"^X\",3,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$x\",\"~$y\",\"^1U\"]]]]],\"^R\",\"Writes an image directly into the display window. The x and y\\n  parameters define the coordinates for the upper-left corner of the\\n  image.\"],\"~$shape-mode\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"Loading & Displaying\",\"^F\",\"^G\",\"^H\",13,\"^I\",\"shapeMode()\",\"^J\",3,\"^K\",true,\"^L\",3797,\"^M\",3797,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^18\"]]]]],\"^R\",\"Modifies the location from which shapes draw. Available modes are\\n  :corner, :corners and :center. Default is :corner.\\n\\n  :corner  - specifies the location to be the upper left corner of the\\n             shape and uses the third and fourth parameters of shape\\n             to specify the width and height.\\n\\n  :corners - uses the first and second parameters of shape to set\\n             the location of one corner and uses the third and fourth\\n             parameters to set the opposite corner.\\n\\n  :center  - draws the shape from its center point and uses the third\\n             and forth parameters of shape to specify the width and\\n             height. \"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/shape-mode\",\"^T\",false,\"^E\",\"Loading & Displaying\",\"^F\",\"quil/core.cljc\",\"^H\",13,\"^I\",\"shapeMode()\",\"^U\",[\"^O\",[[\"^18\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",3792,\"^M\",3797,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^18\"]]]]],\"^R\",\"Modifies the location from which shapes draw. Available modes are\\n  :corner, :corners and :center. Default is :corner.\\n\\n  :corner  - specifies the location to be the upper left corner of the\\n             shape and uses the third and fourth parameters of shape\\n             to specify the width and height.\\n\\n  :corners - uses the first and second parameters of shape to set\\n             the location of one corner and uses the third and fourth\\n             parameters to set the opposite corner.\\n\\n  :center  - draws the shape from its center point and uses the third\\n             and forth parameters of shape to specify the width and\\n             height. \"],\"~$cursor-image\",[\"^ \",\"^A\",\"Environment\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Environment\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^G\",\"^H\",17,\"^15\",[\"^ \",\"^T\",false,\"^X\",3,\"^U\",[\"^O\",[[\"~$img\"],[\"^1Z\",\"~$hx\",\"~$hy\"]]],\"^N\",[\"^O\",[[\"^1Z\"],[\"^1Z\",\"^1[\",\"^20\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"cursor()\",\"^J\",5,\"^K\",true,\"^L\",1307,\"^M\",1307,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^1Z\"],[\"^1Z\",\"^1[\",\"^20\"]]]]],\"^R\",\"Set the cursor to a predefined image. The horizontal and vertical\\n  active spots of the cursor may be specified with hx and hy.\\n  It is recommended to make the size 16x16 or 32x32 pixels.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/cursor-image\",\"^T\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^H\",17,\"^15\",[\"^ \",\"^T\",false,\"^X\",3,\"^U\",[\"^O\",[[\"^1Z\"],[\"^1Z\",\"^1[\",\"^20\"]]],\"^N\",[\"^O\",[[\"^1Z\"],[\"^1Z\",\"^1[\",\"^20\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"cursor()\",\"^U\",[\"^O\",[[\"^1Z\"],[\"^1Z\",\"^1[\",\"^20\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",1301,\"^M\",1307,\"^X\",3,\"^Y\",true,\"^N\",[\"^O\",[[\"^1Z\"],[\"^1Z\",\"^1[\",\"^20\"]]],\"^R\",\"Set the cursor to a predefined image. The horizontal and vertical\\n  active spots of the cursor may be specified with hx and hy.\\n  It is recommended to make the size 16x16 or 32x32 pixels.\"],\"~$create-graphics\",[\"^ \",\"^A\",\"Image\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Image\",\"^D\",\"1.0\",\"^E\",\"Rendering\",\"^F\",\"^G\",\"^H\",18,\"^15\",[\"^ \",\"^T\",false,\"^X\",4,\"^U\",[\"^O\",[[\"~$w\",\"~$h\"],[\"~$w\",\"~$h\",\"~$renderer\"],[\"~$w\",\"~$h\",\"^23\",\"~$path\"]]],\"^N\",[\"^O\",[[\"~$w\",\"~$h\"],[\"~$w\",\"~$h\",\"^23\"],[\"~$w\",\"~$h\",\"^23\",\"^24\"]]],\"^W\",[\"^O\",[null,null,null]]],\"^I\",\"createGraphics()\",\"^J\",3,\"^K\",true,\"^L\",1204,\"^M\",1204,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$w\",\"~$h\"],[\"~$w\",\"~$h\",\"^23\"],[\"~$w\",\"~$h\",\"^23\",\"^24\"]]]]],\"^R\",\"Creates and returns a new PGraphics object of the types :p2d, :p3d,\\n  :java2d, :pdf. By default :java2d is used. Use this class if you\\n  need to draw into an off-screen graphics buffer. It's not possible\\n  to use create-graphics with the :opengl renderer, because it doesn't\\n  allow offscreen use. The :pdf renderer requires the filename parameter.\\n\\n  Note: don't use create-graphics in draw in clojurescript, it leaks memory.\\n  You should create graphic in setup and reuse it in draw instead of creating\\n  a new one.\\n\\n  It's important to call any drawing commands between (.beginDraw graphics) and\\n  (.endDraw graphics) statements or use with-graphics macro. This is also true\\n  for any commands that affect drawing, such as smooth or color-mode.\\n\\n  If you're using :pdf renderer - don't forget to call (.dispose graphics)\\n  as last command inside with-graphics macro, otherwise graphics won't be\\n  saved.\\n\\n  Unlike the main drawing surface which is completely opaque, surfaces\\n  created with create-graphics can have transparency. This makes it\\n  possible to draw into a graphics and maintain the alpha channel. By\\n  using save to write a PNG or TGA file, the transparency of the\\n  graphics object will be honored.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/create-graphics\",\"^T\",false,\"^E\",\"Rendering\",\"^F\",\"quil/core.cljc\",\"^H\",18,\"^15\",[\"^ \",\"^T\",false,\"^X\",4,\"^U\",[\"^O\",[[\"~$w\",\"~$h\"],[\"~$w\",\"~$h\",\"^23\"],[\"~$w\",\"~$h\",\"^23\",\"^24\"]]],\"^N\",[\"^O\",[[\"~$w\",\"~$h\"],[\"~$w\",\"~$h\",\"^23\"],[\"~$w\",\"~$h\",\"^23\",\"^24\"]]],\"^W\",[\"^O\",[null,null,null]]],\"^I\",\"createGraphics()\",\"^U\",[\"^O\",[[\"~$w\",\"~$h\"],[\"~$w\",\"~$h\",\"^23\"],[\"~$w\",\"~$h\",\"^23\",\"^24\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null,null]],\"^J\",1,\"^K\",true,\"^L\",1198,\"^M\",1204,\"^X\",4,\"^Y\",true,\"^N\",[\"^O\",[[\"~$w\",\"~$h\"],[\"~$w\",\"~$h\",\"^23\"],[\"~$w\",\"~$h\",\"^23\",\"^24\"]]],\"^R\",\"Creates and returns a new PGraphics object of the types :p2d, :p3d,\\n  :java2d, :pdf. By default :java2d is used. Use this class if you\\n  need to draw into an off-screen graphics buffer. It's not possible\\n  to use create-graphics with the :opengl renderer, because it doesn't\\n  allow offscreen use. The :pdf renderer requires the filename parameter.\\n\\n  Note: don't use create-graphics in draw in clojurescript, it leaks memory.\\n  You should create graphic in setup and reuse it in draw instead of creating\\n  a new one.\\n\\n  It's important to call any drawing commands between (.beginDraw graphics) and\\n  (.endDraw graphics) statements or use with-graphics macro. This is also true\\n  for any commands that affect drawing, such as smooth or color-mode.\\n\\n  If you're using :pdf renderer - don't forget to call (.dispose graphics)\\n  as last command inside with-graphics macro, otherwise graphics won't be\\n  saved.\\n\\n  Unlike the main drawing surface which is completely opaque, surfaces\\n  created with create-graphics can have transparency. This makes it\\n  possible to draw into a graphics and maintain the alpha channel. By\\n  using save to write a PNG or TGA file, the transparency of the\\n  graphics object will be honored.\"],\"~$update-pixels\",[\"^ \",\"^A\",\"Image\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Image\",\"^D\",\"1.0\",\"^E\",\"Pixels\",\"^F\",\"^G\",\"^H\",16,\"^15\",[\"^ \",\"^T\",false,\"^X\",1,\"^U\",[\"^O\",[[],[\"^1Z\"]]],\"^N\",[\"^O\",[[],[\"^1Z\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"updatePixels()\",\"^J\",3,\"^K\",true,\"^L\",4523,\"^M\",4523,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[],[\"^1Z\"]]]]],\"^R\",\"Updates the display window or image with the data in the pixels array.\\n  Use in conjunction with (pixels). If you're only reading pixels from\\n  the array, there's no need to call update-pixels unless there are\\n  changes.\\n\\n  Certain renderers may or may not seem to require pixels or\\n  update-pixels. However, the rule is that any time you want to\\n  manipulate the pixels array, you must first call pixels, and\\n  after changes have been made, call update-pixels. Even if the\\n  renderer may not seem to use this function in the current Processing\\n  release, this will always be subject to change.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/update-pixels\",\"^T\",false,\"^E\",\"Pixels\",\"^F\",\"quil/core.cljc\",\"^H\",16,\"^15\",[\"^ \",\"^T\",false,\"^X\",1,\"^U\",[\"^O\",[[],[\"^1Z\"]]],\"^N\",[\"^O\",[[],[\"^1Z\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"updatePixels()\",\"^U\",[\"^O\",[[],[\"^1Z\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",4517,\"^M\",4523,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[[],[\"^1Z\"]]],\"^R\",\"Updates the display window or image with the data in the pixels array.\\n  Use in conjunction with (pixels). If you're only reading pixels from\\n  the array, there's no need to call update-pixels unless there are\\n  changes.\\n\\n  Certain renderers may or may not seem to require pixels or\\n  update-pixels. However, the rule is that any time you want to\\n  manipulate the pixels array, you must first call pixels, and\\n  after changes have been made, call update-pixels. Even if the\\n  renderer may not seem to use this function in the current Processing\\n  release, this will always be subject to change.\"],\"~$text-size\",[\"^ \",\"^A\",\"Typography\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Typography\",\"^D\",\"1.0\",\"^E\",\"Attributes\",\"^F\",\"^G\",\"^H\",12,\"^I\",\"textSize()\",\"^J\",3,\"^K\",true,\"^L\",4308,\"^M\",4308,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$size\"]]]]],\"^R\",\"Sets the current font size. This size will be used in all\\n  subsequent calls to the text fn. Font size is measured in\\n  units of pixels.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/text-size\",\"^T\",false,\"^E\",\"Attributes\",\"^F\",\"quil/core.cljc\",\"^H\",12,\"^I\",\"textSize()\",\"^U\",[\"^O\",[[\"^29\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",4302,\"^M\",4308,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^29\"]]]]],\"^R\",\"Sets the current font size. This size will be used in all\\n  subsequent calls to the text fn. Font size is measured in\\n  units of pixels.\"],\"~$pixels\",[\"^ \",\"^A\",\"Image\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Image\",\"^D\",\"1.0\",\"^E\",\"Pixels\",\"^F\",\"^G\",\"^H\",9,\"^15\",[\"^ \",\"^T\",false,\"^X\",1,\"^U\",[\"^O\",[[],[\"^1Z\"]]],\"^N\",[\"^O\",[[],[\"^1Z\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"pixels[]\",\"^J\",3,\"^K\",true,\"^L\",2920,\"^M\",2920,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[],[\"^1Z\"]]]]],\"^R\",\"Array containing the values for all the pixels in the display\\n  window or image. This array is therefore the size of the display window. If\\n  this array is modified, the update-pixels fn must be called to update\\n  the changes. Calls .loadPixels before obtaining the pixel array.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/pixels\",\"^T\",false,\"^E\",\"Pixels\",\"^F\",\"quil/core.cljc\",\"^H\",9,\"^15\",[\"^ \",\"^T\",false,\"^X\",1,\"^U\",[\"^O\",[[],[\"^1Z\"]]],\"^N\",[\"^O\",[[],[\"^1Z\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"pixels[]\",\"^U\",[\"^O\",[[],[\"^1Z\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",2914,\"^M\",2920,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[[],[\"^1Z\"]]],\"^R\",\"Array containing the values for all the pixels in the display\\n  window or image. This array is therefore the size of the display window. If\\n  this array is modified, the update-pixels fn must be called to update\\n  the changes. Calls .loadPixels before obtaining the pixel array.\"],\"~$stroke-float\",[\"^ \",\"^A\",\"Color\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Color\",\"^D\",\"1.0\",\"^E\",\"Setting\",\"^F\",\"^G\",\"^H\",15,\"^15\",[\"^ \",\"^T\",false,\"^X\",4,\"^U\",[\"^O\",[[\"~$gray\"],[\"^2>\",\"~$alpha\"],[\"~$x\",\"~$y\",\"~$z\"],[\"~$x\",\"~$y\",\"~$z\",\"~$a\"]]],\"^N\",[\"^O\",[[\"^2>\"],[\"^2>\",\"^2?\"],[\"~$x\",\"~$y\",\"~$z\"],[\"~$x\",\"~$y\",\"~$z\",\"~$a\"]]],\"^W\",[\"^O\",[null,null,null,null]]],\"^I\",\"stroke()\",\"^J\",3,\"^K\",true,\"^L\",3988,\"^M\",3988,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^2>\"],[\"^2>\",\"^2?\"],[\"~$x\",\"~$y\",\"~$z\"],[\"~$x\",\"~$y\",\"~$z\",\"~$a\"]]]]],\"^R\",\"Sets the color used to draw lines and borders around\\n  shapes. Converts all args to floats\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/stroke-float\",\"^T\",false,\"^E\",\"Setting\",\"^F\",\"quil/core.cljc\",\"^H\",15,\"^15\",[\"^ \",\"^T\",false,\"^X\",4,\"^U\",[\"^O\",[[\"^2>\"],[\"^2>\",\"^2?\"],[\"~$x\",\"~$y\",\"~$z\"],[\"~$x\",\"~$y\",\"~$z\",\"~$a\"]]],\"^N\",[\"^O\",[[\"^2>\"],[\"^2>\",\"^2?\"],[\"~$x\",\"~$y\",\"~$z\"],[\"~$x\",\"~$y\",\"~$z\",\"~$a\"]]],\"^W\",[\"^O\",[null,null,null,null]]],\"^I\",\"stroke()\",\"^U\",[\"^O\",[[\"^2>\"],[\"^2>\",\"^2?\"],[\"~$x\",\"~$y\",\"~$z\"],[\"~$x\",\"~$y\",\"~$z\",\"~$a\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null,null,null]],\"^J\",1,\"^K\",true,\"^L\",3982,\"^M\",3988,\"^X\",4,\"^Y\",true,\"^N\",[\"^O\",[[\"^2>\"],[\"^2>\",\"^2?\"],[\"~$x\",\"~$y\",\"~$z\"],[\"~$x\",\"~$y\",\"~$z\",\"~$a\"]]],\"^R\",\"Sets the color used to draw lines and borders around\\n  shapes. Converts all args to floats\"],\"~$constrain\",[\"^ \",\"^A\",\"Math\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Math\",\"^D\",\"1.0\",\"^E\",\"Calculation\",\"^F\",\"^G\",\"^H\",12,\"^I\",\"constrain()\",\"^J\",3,\"^K\",false,\"^L\",1097,\"^M\",1097,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$amt\",\"~$low\",\"~$high\"]]]]],\"^R\",\"Constrains a value to not exceed a maximum and minimum value.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/constrain\",\"^T\",false,\"^E\",\"Calculation\",\"^F\",\"quil/core.cljc\",\"^H\",12,\"^I\",\"constrain()\",\"^U\",[\"^O\",[[\"^2B\",\"^2C\",\"^2D\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",false,\"^L\",1091,\"^M\",1097,\"^X\",3,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^2B\",\"^2C\",\"^2D\"]]]]],\"^R\",\"Constrains a value to not exceed a maximum and minimum value.\"],\"~$screen-y\",[\"^ \",\"^A\",\"Lights, Camera\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Lights, Camera\",\"^D\",\"1.0\",\"^E\",\"Coordinates\",\"^F\",\"^G\",\"^H\",11,\"^15\",[\"^ \",\"^T\",false,\"^X\",3,\"^U\",[\"^O\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^N\",[\"^O\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"screenY()\",\"^J\",3,\"^K\",true,\"^L\",3627,\"^M\",3627,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]]]],\"^R\",\"Takes a three-dimensional x, y, z position and returns the y value\\n  for where it will appear on a (two-dimensional) screen, once\\n  affected by translate, scale or any other transformations\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/screen-y\",\"^T\",false,\"^E\",\"Coordinates\",\"^F\",\"quil/core.cljc\",\"^H\",11,\"^15\",[\"^ \",\"^T\",false,\"^X\",3,\"^U\",[\"^O\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^N\",[\"^O\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"screenY()\",\"^U\",[\"^O\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",3621,\"^M\",3627,\"^X\",3,\"^Y\",true,\"^N\",[\"^O\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^R\",\"Takes a three-dimensional x, y, z position and returns the y value\\n  for where it will appear on a (two-dimensional) screen, once\\n  affected by translate, scale or any other transformations\"],\"~$fill-float\",[\"^ \",\"^A\",\"Color\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Color\",\"^D\",\"1.0\",\"^E\",\"Setting\",\"^F\",\"^G\",\"^H\",13,\"^15\",[\"^ \",\"^T\",false,\"^X\",4,\"^U\",[\"^O\",[[\"^2>\"],[\"^2>\",\"^2?\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"^2?\"]]],\"^N\",[\"^O\",[[\"^2>\"],[\"^2>\",\"^2?\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"^2?\"]]],\"^W\",[\"^O\",[null,null,null,null]]],\"^I\",\"fill()\",\"^J\",3,\"^K\",true,\"^L\",1705,\"^M\",1705,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^2>\"],[\"^2>\",\"^2?\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"^2?\"]]]]],\"^R\",\"Sets the color used to fill shapes. For example, (fill 204 102 0),\\n  will specify that all subsequent shapes will be filled with orange.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/fill-float\",\"^T\",false,\"^E\",\"Setting\",\"^F\",\"quil/core.cljc\",\"^H\",13,\"^15\",[\"^ \",\"^T\",false,\"^X\",4,\"^U\",[\"^O\",[[\"^2>\"],[\"^2>\",\"^2?\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"^2?\"]]],\"^N\",[\"^O\",[[\"^2>\"],[\"^2>\",\"^2?\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"^2?\"]]],\"^W\",[\"^O\",[null,null,null,null]]],\"^I\",\"fill()\",\"^U\",[\"^O\",[[\"^2>\"],[\"^2>\",\"^2?\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"^2?\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null,null,null]],\"^J\",1,\"^K\",true,\"^L\",1699,\"^M\",1705,\"^X\",4,\"^Y\",true,\"^N\",[\"^O\",[[\"^2>\"],[\"^2>\",\"^2?\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"^2?\"]]],\"^R\",\"Sets the color used to fill shapes. For example, (fill 204 102 0),\\n  will specify that all subsequent shapes will be filled with orange.\"],\"~$rect\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"2D Primitives\",\"^F\",\"^G\",\"^H\",7,\"^15\",[\"^ \",\"^T\",false,\"^X\",8,\"^U\",[\"^O\",[[\"~$x\",\"~$y\",\"^1@\",\"^1A\"],[\"~$x\",\"~$y\",\"^1@\",\"^1A\",\"~$r\"],[\"~$x\",\"~$y\",\"^1@\",\"^1A\",\"~$top-left-r\",\"~$top-right-r\",\"~$bottom-right-r\",\"~$bottom-left-r\"]]],\"^N\",[\"^O\",[[\"~$x\",\"~$y\",\"^1@\",\"^1A\"],[\"~$x\",\"~$y\",\"^1@\",\"^1A\",\"~$r\"],[\"~$x\",\"~$y\",\"^1@\",\"^1A\",\"^2K\",\"^2L\",\"^2M\",\"^2N\"]]],\"^W\",[\"^O\",[null,null,null]]],\"^I\",\"rect()\",\"^J\",3,\"^K\",true,\"^L\",3250,\"^M\",3250,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$x\",\"~$y\",\"^1@\",\"^1A\"],[\"~$x\",\"~$y\",\"^1@\",\"^1A\",\"~$r\"],[\"~$x\",\"~$y\",\"^1@\",\"^1A\",\"^2K\",\"^2L\",\"^2M\",\"^2N\"]]]]],\"^R\",\"Draws a rectangle to the screen. A rectangle is a four-sided shape\\n  with every angle at ninety degrees. By default, the first two\\n  parameters set the location of the upper-left corner, the third\\n  sets the width, and the fourth sets the height. These parameters\\n  may be changed with rect-mode.\\n\\n  To draw a rounded rectangle, add a fifth parameter, which is used as\\n  the radius value for all four corners. To use a different radius value\\n  for each corner, include eight parameters.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/rect\",\"^T\",false,\"^E\",\"2D Primitives\",\"^F\",\"quil/core.cljc\",\"^H\",7,\"^15\",[\"^ \",\"^T\",false,\"^X\",8,\"^U\",[\"^O\",[[\"~$x\",\"~$y\",\"^1@\",\"^1A\"],[\"~$x\",\"~$y\",\"^1@\",\"^1A\",\"~$r\"],[\"~$x\",\"~$y\",\"^1@\",\"^1A\",\"^2K\",\"^2L\",\"^2M\",\"^2N\"]]],\"^N\",[\"^O\",[[\"~$x\",\"~$y\",\"^1@\",\"^1A\"],[\"~$x\",\"~$y\",\"^1@\",\"^1A\",\"~$r\"],[\"~$x\",\"~$y\",\"^1@\",\"^1A\",\"^2K\",\"^2L\",\"^2M\",\"^2N\"]]],\"^W\",[\"^O\",[null,null,null]]],\"^I\",\"rect()\",\"^U\",[\"^O\",[[\"~$x\",\"~$y\",\"^1@\",\"^1A\"],[\"~$x\",\"~$y\",\"^1@\",\"^1A\",\"~$r\"],[\"~$x\",\"~$y\",\"^1@\",\"^1A\",\"^2K\",\"^2L\",\"^2M\",\"^2N\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null,null]],\"^J\",1,\"^K\",true,\"^L\",3244,\"^M\",3250,\"^X\",8,\"^Y\",true,\"^N\",[\"^O\",[[\"~$x\",\"~$y\",\"^1@\",\"^1A\"],[\"~$x\",\"~$y\",\"^1@\",\"^1A\",\"~$r\"],[\"~$x\",\"~$y\",\"^1@\",\"^1A\",\"^2K\",\"^2L\",\"^2M\",\"^2N\"]]],\"^R\",\"Draws a rectangle to the screen. A rectangle is a four-sided shape\\n  with every angle at ninety degrees. By default, the first two\\n  parameters set the location of the upper-left corner, the third\\n  sets the width, and the fourth sets the height. These parameters\\n  may be changed with rect-mode.\\n\\n  To draw a rounded rectangle, add a fifth parameter, which is used as\\n  the radius value for all four corners. To use a different radius value\\n  for each corner, include eight parameters.\"],\"~$log\",[\"^ \",\"^A\",\"Math\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Math\",\"^D\",\"1.0\",\"^E\",\"Calculation\",\"^F\",\"^G\",\"^H\",6,\"^I\",\"log()\",\"^J\",3,\"^K\",false,\"^L\",2428,\"^M\",2428,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$val\"]]]]],\"^R\",\"Calculates the natural logarithm (the base-e logarithm) of a\\n  number. This function expects the values greater than 0.0.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/log\",\"^T\",false,\"^E\",\"Calculation\",\"^F\",\"quil/core.cljc\",\"^H\",6,\"^I\",\"log()\",\"^U\",[\"^O\",[[\"^2Q\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",false,\"^L\",2422,\"^M\",2428,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^2Q\"]]]]],\"^R\",\"Calculates the natural logarithm (the base-e logarithm) of a\\n  number. This function expects the values greater than 0.0.\"],\"~$with-stroke\",[\"^ \",\"^A\",\"Color\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Color\",\"^D\",\"1.7\",\"^E\",\"Utility Macros\",\"^F\",\"^G\",\"^H\",15,\"^15\",[\"^ \",\"^T\",true,\"^X\",3,\"^U\",[[\"^O\",[\"^1L\",\"^1M\",\"~$stroke-args\",\"^1O\"]]],\"^N\",[\"^O\",[[\"^1L\",\"^1M\",\"^2T\",\"~$&\",\"^1O\"]]],\"^W\",[\"^O\",[null]]],\"^I\",null,\"^J\",4,\"^K\",true,\"^L\",4623,\"^1P\",true,\"^M\",4623,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^2T\",\"~$&\",\"^1O\"]]]]],\"^R\",\"Temporarily set the stroke color for the body of this macro.\\n   The code outside of with-stroke form will have the previous stroke color set.\\n\\n   The stroke color has to be in a vector!\\n   Example: (with-stroke [255] ...)\\n            (with-stroke [10 80 98] ...)\"],\"^D\",\"1.7\",\"^5\",\"~$quil.core$macros/with-stroke\",\"^T\",true,\"^E\",\"Utility Macros\",\"^F\",\"quil/core.cljc\",\"^H\",15,\"^15\",[\"^ \",\"^T\",true,\"^X\",3,\"^U\",[[\"^O\",[\"^1L\",\"^1M\",\"^2T\",\"^1O\"]]],\"^N\",[\"^O\",[[\"^1L\",\"^1M\",\"^2T\",\"~$&\",\"^1O\"]]],\"^W\",[\"^O\",[null]]],\"^I\",null,\"^U\",[[\"^O\",[\"^1L\",\"^1M\",\"^2T\",\"^1O\"]]],\"^V\",null,\"^W\",[\"^O\",[null]],\"^J\",1,\"^K\",true,\"^L\",4617,\"^1P\",true,\"^M\",4623,\"^X\",3,\"^Y\",false,\"^N\",[\"^O\",[[\"^1L\",\"^1M\",\"^2T\",\"~$&\",\"^1O\"]]],\"^R\",\"Temporarily set the stroke color for the body of this macro.\\n   The code outside of with-stroke form will have the previous stroke color set.\\n\\n   The stroke color has to be in a vector!\\n   Example: (with-stroke [255] ...)\\n            (with-stroke [10 80 98] ...)\"],\"~$ambient-float\",[\"^ \",\"^A\",\"Lights, Camera\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Lights, Camera\",\"^D\",\"1.0\",\"^E\",\"Material Properties\",\"^F\",\"^G\",\"^H\",16,\"^15\",[\"^ \",\"^T\",false,\"^X\",3,\"^U\",[\"^O\",[[\"^2>\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^N\",[\"^O\",[[\"^2>\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"ambient()\",\"^J\",3,\"^K\",true,\"^L\",324,\"^M\",324,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^2>\"],[\"~$x\",\"~$y\",\"~$z\"]]]]],\"^R\",\"Sets the ambient reflectance for shapes drawn to the screen. This\\n  is combined with the ambient light component of environment. The\\n  color components set through the parameters define the\\n  reflectance. For example in the default color mode, setting x=255,\\n  y=126, z=0, would cause all the red light to reflect and half of the\\n  green light to reflect. Used in combination with emissive, specular,\\n  and shininess in setting the material properties of shapes.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/ambient-float\",\"^T\",false,\"^E\",\"Material Properties\",\"^F\",\"quil/core.cljc\",\"^H\",16,\"^15\",[\"^ \",\"^T\",false,\"^X\",3,\"^U\",[\"^O\",[[\"^2>\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^N\",[\"^O\",[[\"^2>\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"ambient()\",\"^U\",[\"^O\",[[\"^2>\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",318,\"^M\",324,\"^X\",3,\"^Y\",true,\"^N\",[\"^O\",[[\"^2>\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^R\",\"Sets the ambient reflectance for shapes drawn to the screen. This\\n  is combined with the ambient light component of environment. The\\n  color components set through the parameters define the\\n  reflectance. For example in the default color mode, setting x=255,\\n  y=126, z=0, would cause all the red light to reflect and half of the\\n  green light to reflect. Used in combination with emissive, specular,\\n  and shininess in setting the material properties of shapes.\"],\"~$end-raw\",[\"^ \",\"^A\",\"Output\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Output\",\"^D\",\"1.0\",\"^E\",\"Files\",\"^F\",\"^G\",\"^H\",10,\"^I\",\"endRaw()\",\"^J\",3,\"^K\",true,\"^L\",1638,\"^M\",1638,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Complement to begin-raw; they must always be used together. See\\n  the begin-raw docstring for details.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/end-raw\",\"^T\",false,\"^E\",\"Files\",\"^F\",\"quil/core.cljc\",\"^H\",10,\"^I\",\"endRaw()\",\"^U\",[\"^O\",[[]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",1632,\"^M\",1638,\"^X\",0,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Complement to begin-raw; they must always be used together. See\\n  the begin-raw docstring for details.\"],\"~$radians\",[\"^ \",\"^A\",\"Math\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Math\",\"^D\",\"1.0\",\"^E\",\"Trigonometry\",\"^F\",\"^G\",\"^H\",10,\"^I\",\"radians()\",\"^J\",3,\"^K\",false,\"^L\",3162,\"^M\",3162,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$degrees\"]]]]],\"^R\",\"Converts a degree measurement to its corresponding value in\\n  radians. Radians and degrees are two ways of measuring the same\\n  thing. There are 360 degrees in a circle and 2*PI radians in a\\n  circle. For example, 90° = PI/2 = 1.5707964. All trigonometric\\n  methods in Processing require their parameters to be specified in\\n  radians.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/radians\",\"^T\",false,\"^E\",\"Trigonometry\",\"^F\",\"quil/core.cljc\",\"^H\",10,\"^I\",\"radians()\",\"^U\",[\"^O\",[[\"^2[\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",false,\"^L\",3156,\"^M\",3162,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^2[\"]]]]],\"^R\",\"Converts a degree measurement to its corresponding value in\\n  radians. Radians and degrees are two ways of measuring the same\\n  thing. There are 360 degrees in a circle and 2*PI radians in a\\n  circle. For example, 90° = PI/2 = 1.5707964. All trigonometric\\n  methods in Processing require their parameters to be specified in\\n  radians.\"],\"^2[\",[\"^ \",\"^A\",\"Math\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Math\",\"^D\",\"1.0\",\"^E\",\"Trigonometry\",\"^F\",\"^G\",\"^H\",10,\"^I\",\"degrees()\",\"^J\",3,\"^K\",false,\"^L\",1438,\"^M\",1438,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^2Z\"]]]]],\"^R\",\"Converts a radian measurement to its corresponding value in\\n  degrees. Radians and degrees are two ways of measuring the same\\n  thing. There are 360 degrees in a circle and (* 2 Math/PI) radians\\n  in a circle. For example, (= 90° (/ Math/PI 2) 1.5707964). All\\n  trigonometric methods in Processing require their parameters to be\\n  specified in radians.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/degrees\",\"^T\",false,\"^E\",\"Trigonometry\",\"^F\",\"quil/core.cljc\",\"^H\",10,\"^I\",\"degrees()\",\"^U\",[\"^O\",[[\"^2Z\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",false,\"^L\",1432,\"^M\",1438,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^2Z\"]]]]],\"^R\",\"Converts a radian measurement to its corresponding value in\\n  degrees. Radians and degrees are two ways of measuring the same\\n  thing. There are 360 degrees in a circle and (* 2 Math/PI) radians\\n  in a circle. For example, (= 90° (/ Math/PI 2) 1.5707964). All\\n  trigonometric methods in Processing require their parameters to be\\n  specified in radians.\"],\"~$acos\",[\"^ \",\"^A\",\"Math\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Math\",\"^D\",\"1.0\",\"^E\",\"Trigonometry\",\"^F\",\"^G\",\"^H\",7,\"^I\",\"acos()\",\"^J\",3,\"^K\",false,\"^L\",299,\"^M\",299,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$n\"]]]]],\"^R\",\"The inverse of cos, returns the arc cosine of a value. This\\n  function expects the values in the range of -1 to 1 and values are\\n  returned in the range 0 to Math/PI (3.1415927).\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/acos\",\"^T\",false,\"^E\",\"Trigonometry\",\"^F\",\"quil/core.cljc\",\"^H\",7,\"^I\",\"acos()\",\"^U\",[\"^O\",[[\"~$n\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",false,\"^L\",293,\"^M\",299,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$n\"]]]]],\"^R\",\"The inverse of cos, returns the arc cosine of a value. This\\n  function expects the values in the range of -1 to 1 and values are\\n  returned in the range 0 to Math/PI (3.1415927).\"],\"~$bezier-detail\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"Curves\",\"^F\",\"^G\",\"^H\",16,\"^I\",\"bezierDetail()\",\"^J\",3,\"^K\",true,\"^L\",692,\"^M\",692,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$detail\"]]]]],\"^R\",\"Sets the resolution at which Beziers display. The default value is\\n  20. This function is only useful when using the :p3d or :opengl\\n  renderer as the default (:java2d) renderer does not use this\\n  information.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/bezier-detail\",\"^T\",false,\"^E\",\"Curves\",\"^F\",\"quil/core.cljc\",\"^H\",16,\"^I\",\"bezierDetail()\",\"^U\",[\"^O\",[[\"^35\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",686,\"^M\",692,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^35\"]]]]],\"^R\",\"Sets the resolution at which Beziers display. The default value is\\n  20. This function is only useful when using the :p3d or :opengl\\n  renderer as the default (:java2d) renderer does not use this\\n  information.\"],\"~$texture\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"Vertex\",\"^F\",\"^G\",\"^H\",10,\"^I\",\"texture()\",\"^J\",3,\"^K\",true,\"^L\",4321,\"^M\",4321,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^1Z\"]]]]],\"^R\",\"Sets a texture to be applied to vertex points. The texture fn must\\n  be called between begin-shape and end-shape and before any calls to\\n  vertex.\\n\\n  When textures are in use, the fill color is ignored. Instead, use\\n  tint to specify the color of the texture as it is applied to the\\n  shape.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/texture\",\"^T\",false,\"^E\",\"Vertex\",\"^F\",\"quil/core.cljc\",\"^H\",10,\"^I\",\"texture()\",\"^U\",[\"^O\",[[\"^1Z\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",4315,\"^M\",4321,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^1Z\"]]]]],\"^R\",\"Sets a texture to be applied to vertex points. The texture fn must\\n  be called between begin-shape and end-shape and before any calls to\\n  vertex.\\n\\n  When textures are in use, the fill color is ignored. Instead, use\\n  tint to specify the color of the texture as it is applied to the\\n  shape.\"],\"~$stroke-int\",[\"^ \",\"^A\",\"Color\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Color\",\"^D\",\"1.0\",\"^E\",\"Setting\",\"^F\",\"^G\",\"^H\",13,\"^15\",[\"^ \",\"^T\",false,\"^X\",2,\"^U\",[\"^O\",[[\"~$rgb\"],[\"^3:\",\"^2?\"]]],\"^N\",[\"^O\",[[\"^3:\"],[\"^3:\",\"^2?\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"stroke()\",\"^J\",3,\"^K\",true,\"^L\",4002,\"^M\",4002,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^3:\"],[\"^3:\",\"^2?\"]]]]],\"^R\",\"Sets the color used to draw lines and borders around\\n  shapes. Converts rgb to int and alpha to a float.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/stroke-int\",\"^T\",false,\"^E\",\"Setting\",\"^F\",\"quil/core.cljc\",\"^H\",13,\"^15\",[\"^ \",\"^T\",false,\"^X\",2,\"^U\",[\"^O\",[[\"^3:\"],[\"^3:\",\"^2?\"]]],\"^N\",[\"^O\",[[\"^3:\"],[\"^3:\",\"^2?\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"stroke()\",\"^U\",[\"^O\",[[\"^3:\"],[\"^3:\",\"^2?\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",3996,\"^M\",4002,\"^X\",2,\"^Y\",true,\"^N\",[\"^O\",[[\"^3:\"],[\"^3:\",\"^2?\"]]],\"^R\",\"Sets the color used to draw lines and borders around\\n  shapes. Converts rgb to int and alpha to a float.\"],\"~$print-camera\",[\"^ \",\"^A\",\"Lights, Camera\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Lights, Camera\",\"^D\",\"1.0\",\"^E\",\"Camera\",\"^F\",\"^G\",\"^H\",15,\"^I\",\"printCamera()\",\"^J\",3,\"^K\",true,\"^L\",3048,\"^M\",3048,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Prints the current camera matrix to std out. Useful for debugging.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/print-camera\",\"^T\",false,\"^E\",\"Camera\",\"^F\",\"quil/core.cljc\",\"^H\",15,\"^I\",\"printCamera()\",\"^U\",[\"^O\",[[]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",3042,\"^M\",3048,\"^X\",0,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Prints the current camera matrix to std out. Useful for debugging.\"],\"~$floor\",[\"^ \",\"^A\",\"Math\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Math\",\"^D\",\"2.0\",\"^E\",\"Calculation\",\"^F\",\"^G\",\"^H\",8,\"^I\",\"floor()\",\"^J\",3,\"^K\",false,\"^L\",1830,\"^M\",1830,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$n\"]]]]],\"^R\",\"Calculates the closest int value that is less than or equal to the\\n  value of the parameter. For example, (floor 9.03) returns the value 9.\"],\"^D\",\"2.0\",\"^5\",\"~$quil.core$macros/floor\",\"^T\",false,\"^E\",\"Calculation\",\"^F\",\"quil/core.cljc\",\"^H\",8,\"^I\",\"floor()\",\"^U\",[\"^O\",[[\"~$n\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",false,\"^L\",1824,\"^M\",1830,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$n\"]]]]],\"^R\",\"Calculates the closest int value that is less than or equal to the\\n  value of the parameter. For example, (floor 9.03) returns the value 9.\"],\"~$atan2\",[\"^ \",\"^A\",\"Math\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Math\",\"^D\",\"1.0\",\"^E\",\"Trigonometry\",\"^F\",\"^G\",\"^H\",8,\"^I\",\"atan2()\",\"^J\",3,\"^K\",false,\"^L\",473,\"^M\",473,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$y\",\"~$x\"]]]]],\"^R\",\"Calculates the angle (in radians) from a specified point to the\\n  coordinate origin as measured from the positive x-axis. Values are\\n  returned as a float in the range from PI to -PI. The atan2 function\\n  is most often used for orienting geometry to the position of the\\n  cursor. Note: The y-coordinate of the point is the first parameter\\n  and the x-coordinate is the second due to the structure of\\n  calculating the tangent.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/atan2\",\"^T\",false,\"^E\",\"Trigonometry\",\"^F\",\"quil/core.cljc\",\"^H\",8,\"^I\",\"atan2()\",\"^U\",[\"^O\",[[\"~$y\",\"~$x\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",false,\"^L\",467,\"^M\",473,\"^X\",2,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$y\",\"~$x\"]]]]],\"^R\",\"Calculates the angle (in radians) from a specified point to the\\n  coordinate origin as measured from the positive x-axis. Values are\\n  returned as a float in the range from PI to -PI. The atan2 function\\n  is most often used for orienting geometry to the position of the\\n  cursor. Note: The y-coordinate of the point is the first parameter\\n  and the x-coordinate is the second due to the structure of\\n  calculating the tangent.\"],\"~$millis\",[\"^ \",\"^A\",\"Input\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Input\",\"^D\",\"1.0\",\"^E\",\"Time & Date\",\"^F\",\"^G\",\"^H\",9,\"^I\",\"millis()\",\"^J\",3,\"^K\",true,\"^L\",2498,\"^M\",2498,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Returns the number of milliseconds (thousandths of a second) since\\n  starting the sketch. This information is often used for timing\\n  animation sequences.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/millis\",\"^T\",false,\"^E\",\"Time & Date\",\"^F\",\"quil/core.cljc\",\"^H\",9,\"^I\",\"millis()\",\"^U\",[\"^O\",[[]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",2492,\"^M\",2498,\"^X\",0,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Returns the number of milliseconds (thousandths of a second) since\\n  starting the sketch. This information is often used for timing\\n  animation sequences.\"],\"~$lerp-color\",[\"^ \",\"^A\",\"Color\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Color\",\"^D\",\"1.0\",\"^E\",\"Creating & Reading\",\"^F\",\"^G\",\"^H\",13,\"^I\",\"lerpColor()\",\"^J\",3,\"^K\",true,\"^L\",2253,\"^M\",2253,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$c1\",\"~$c2\",\"^2B\"]]]]],\"^R\",\"Calculates a color or colors between two color at a specific\\n  increment. The amt parameter is the amount to interpolate between\\n  the two values where 0.0 equal to the first point, 0.1 is very near\\n  the first point, 0.5 is half-way in between, etc.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/lerp-color\",\"^T\",false,\"^E\",\"Creating & Reading\",\"^F\",\"quil/core.cljc\",\"^H\",13,\"^I\",\"lerpColor()\",\"^U\",[\"^O\",[[\"^3E\",\"^3F\",\"^2B\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",2247,\"^M\",2253,\"^X\",3,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^3E\",\"^3F\",\"^2B\"]]]]],\"^R\",\"Calculates a color or colors between two color at a specific\\n  increment. The amt parameter is the amount to interpolate between\\n  the two values where 0.0 equal to the first point, 0.1 is very near\\n  the first point, 0.5 is half-way in between, etc.\"],\"~$image-modes\",[\"^ \",\"^5\",\"~$quil.core$macros/image-modes\",\"^F\",\"quil/core.cljc\",\"^L\",45,\"^J\",1,\"^M\",61,\"^H\",13,\"^C\",[\"^ \",\"^F\",\"^G\",\"^L\",61,\"^J\",2,\"^M\",61,\"^H\",13]],\"~$no-fill-prop\",[\"^ \",\"^5\",\"~$quil.core$macros/no-fill-prop\",\"^F\",\"quil/core.cljc\",\"^L\",24,\"^J\",1,\"^M\",24,\"^H\",35,\"~:private\",true,\"^C\",[\"^ \",\"^F\",\"^G\",\"^L\",24,\"^J\",23,\"^M\",24,\"^H\",35,\"^3L\",true]],\"~$color-mode\",[\"^ \",\"^A\",\"Color\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Color\",\"^D\",\"1.0\",\"^E\",\"Creating & Reading\",\"^F\",\"^G\",\"^H\",13,\"^15\",[\"^ \",\"^T\",false,\"^X\",5,\"^U\",[\"^O\",[[\"^18\"],[\"^18\",\"~$max\"],[\"^18\",\"~$max-x\",\"~$max-y\",\"~$max-z\"],[\"^18\",\"^3O\",\"^3P\",\"^3Q\",\"~$max-a\"]]],\"^N\",[\"^O\",[[\"^18\"],[\"^18\",\"^3N\"],[\"^18\",\"^3O\",\"^3P\",\"^3Q\"],[\"^18\",\"^3O\",\"^3P\",\"^3Q\",\"^3R\"]]],\"^W\",[\"^O\",[null,null,null,null]]],\"^I\",\"colorMode()\",\"^J\",3,\"^K\",true,\"^L\",1041,\"^M\",1041,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^18\"],[\"^18\",\"^3N\"],[\"^18\",\"^3O\",\"^3P\",\"^3Q\"],[\"^18\",\"^3O\",\"^3P\",\"^3Q\",\"^3R\"]]]]],\"^R\",\"Changes the way Processing interprets color data. Available modes\\n  are :rgb and :hsb.By default, the parameters for fill, stroke,\\n  background, and color are defined by values between 0 and 255 using\\n  the :rgb color model. The color-mode fn is used to change the\\n  numerical range used for specifying colors and to switch color\\n  systems. For example, calling\\n  (color-mode :rgb 1.0) will specify that values are specified between\\n  0 and 1. The limits for defining colors are altered by setting the\\n  parameters range1, range2, range3, and range 4.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/color-mode\",\"^T\",false,\"^E\",\"Creating & Reading\",\"^F\",\"quil/core.cljc\",\"^H\",13,\"^15\",[\"^ \",\"^T\",false,\"^X\",5,\"^U\",[\"^O\",[[\"^18\"],[\"^18\",\"^3N\"],[\"^18\",\"^3O\",\"^3P\",\"^3Q\"],[\"^18\",\"^3O\",\"^3P\",\"^3Q\",\"^3R\"]]],\"^N\",[\"^O\",[[\"^18\"],[\"^18\",\"^3N\"],[\"^18\",\"^3O\",\"^3P\",\"^3Q\"],[\"^18\",\"^3O\",\"^3P\",\"^3Q\",\"^3R\"]]],\"^W\",[\"^O\",[null,null,null,null]]],\"^I\",\"colorMode()\",\"^U\",[\"^O\",[[\"^18\"],[\"^18\",\"^3N\"],[\"^18\",\"^3O\",\"^3P\",\"^3Q\"],[\"^18\",\"^3O\",\"^3P\",\"^3Q\",\"^3R\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null,null,null]],\"^J\",1,\"^K\",true,\"^L\",1035,\"^M\",1041,\"^X\",5,\"^Y\",true,\"^N\",[\"^O\",[[\"^18\"],[\"^18\",\"^3N\"],[\"^18\",\"^3O\",\"^3P\",\"^3Q\"],[\"^18\",\"^3O\",\"^3P\",\"^3Q\",\"^3R\"]]],\"^R\",\"Changes the way Processing interprets color data. Available modes\\n  are :rgb and :hsb.By default, the parameters for fill, stroke,\\n  background, and color are defined by values between 0 and 255 using\\n  the :rgb color model. The color-mode fn is used to change the\\n  numerical range used for specifying colors and to switch color\\n  systems. For example, calling\\n  (color-mode :rgb 1.0) will specify that values are specified between\\n  0 and 1. The limits for defining colors are altered by setting the\\n  parameters range1, range2, range3, and range 4.\"],\"~$create-image\",[\"^ \",\"^A\",\"Image\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Image\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^G\",\"^H\",15,\"^I\",\"createImage()\",\"^J\",3,\"^K\",true,\"^L\",1243,\"^M\",1243,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$w\",\"~$h\",\"~$format\"]]]]],\"^R\",\"Creates a new PImage (the datatype for storing images). This\\n  provides a fresh buffer of pixels to play with. Set the size of the\\n  buffer with the width and height parameters. The format parameter\\n  defines how the pixels are stored. See the PImage reference for more\\n  information.\\n\\n  Possible formats: :rgb, :argb, :alpha (grayscale alpha channel)\\n\\n  Prefer using create-image over initialising new PImage instances\\n  directly.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/create-image\",\"^T\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^H\",15,\"^I\",\"createImage()\",\"^U\",[\"^O\",[[\"~$w\",\"~$h\",\"^3U\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",1237,\"^M\",1243,\"^X\",3,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$w\",\"~$h\",\"^3U\"]]]]],\"^R\",\"Creates a new PImage (the datatype for storing images). This\\n  provides a fresh buffer of pixels to play with. Set the size of the\\n  buffer with the width and height parameters. The format parameter\\n  defines how the pixels are stored. See the PImage reference for more\\n  information.\\n\\n  Possible formats: :rgb, :argb, :alpha (grayscale alpha channel)\\n\\n  Prefer using create-image over initialising new PImage instances\\n  directly.\"],\"~$sq\",[\"^ \",\"^A\",\"Math\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Math\",\"^D\",\"1.0\",\"^E\",\"Calculation\",\"^F\",\"^G\",\"^H\",5,\"^I\",\"sq()\",\"^J\",3,\"^K\",false,\"^L\",3947,\"^M\",3947,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$a\"]]]]],\"^R\",\"Squares a number (multiplies a number by itself). The result is\\n  always a positive number, as multiplying two negative numbers always\\n  yields a positive result. For example, -1 * -1 = 1.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/sq\",\"^T\",false,\"^E\",\"Calculation\",\"^F\",\"quil/core.cljc\",\"^H\",5,\"^I\",\"sq()\",\"^U\",[\"^O\",[[\"~$a\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",false,\"^L\",3941,\"^M\",3947,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$a\"]]]]],\"^R\",\"Squares a number (multiplies a number by itself). The result is\\n  always a positive number, as multiplying two negative numbers always\\n  yields a positive result. For example, -1 * -1 = 1.\"],\"^1A\",[\"^ \",\"^A\",\"Environment\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Environment\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^G\",\"^H\",9,\"^I\",\"getHeight()\",\"^J\",3,\"~:processing-link\",null,\"^K\",true,\"^L\",1970,\"^M\",1970,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Height of the display window. The value of height is zero until\\n  size is called.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/height\",\"^T\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^H\",9,\"^I\",\"getHeight()\",\"^U\",[\"^O\",[[]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^3Y\",null,\"^K\",true,\"^L\",1963,\"^M\",1970,\"^X\",0,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Height of the display window. The value of height is zero until\\n  size is called.\"],\"~$no-loop\",[\"^ \",\"^A\",\"Structure\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Structure\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^G\",\"^H\",10,\"^I\",\"noLoop()\",\"^J\",3,\"^K\",true,\"^L\",2771,\"^M\",2771,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Stops Processing from continuously executing the code within\\n  draw. If start-loop is called, the code in draw will begin to run\\n  continuously again. If using no-loop in setup, it should be the last\\n  line inside the block.\\n\\n  When no-loop is used, it's not possible to manipulate or access the\\n  screen inside event handling functions such as mouse-pressed or\\n  key-pressed. Instead, use those functions to call redraw or\\n  loop which will run draw, which can update the screen\\n  properly. This means that when no-loop has been called, no drawing\\n  can happen, and functions like save-frame may not be used.\\n\\n  Note that if the sketch is resized, redraw will be called to\\n  update the sketch, even after no-oop has been\\n  specified. Otherwise, the sketch would enter an odd state until\\n  loop was called.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/no-loop\",\"^T\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^H\",10,\"^I\",\"noLoop()\",\"^U\",[\"^O\",[[]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",2765,\"^M\",2771,\"^X\",0,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Stops Processing from continuously executing the code within\\n  draw. If start-loop is called, the code in draw will begin to run\\n  continuously again. If using no-loop in setup, it should be the last\\n  line inside the block.\\n\\n  When no-loop is used, it's not possible to manipulate or access the\\n  screen inside event handling functions such as mouse-pressed or\\n  key-pressed. Instead, use those functions to call redraw or\\n  loop which will run draw, which can update the screen\\n  properly. This means that when no-loop has been called, no drawing\\n  can happen, and functions like save-frame may not be used.\\n\\n  Note that if the sketch is resized, redraw will be called to\\n  update the sketch, even after no-oop has been\\n  specified. Otherwise, the sketch would enter an odd state until\\n  loop was called.\"],\"~$minute\",[\"^ \",\"^A\",\"Input\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Input\",\"^D\",\"1.0\",\"^E\",\"Time & Date\",\"^F\",\"^G\",\"^H\",9,\"^I\",\"minute()\",\"^J\",3,\"^K\",false,\"^L\",2511,\"^M\",2511,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Returns the current minute as a value from 0 - 59\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/minute\",\"^T\",false,\"^E\",\"Time & Date\",\"^F\",\"quil/core.cljc\",\"^H\",9,\"^I\",\"minute()\",\"^U\",[\"^O\",[[]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",false,\"^L\",2505,\"^M\",2511,\"^X\",0,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Returns the current minute as a value from 0 - 59\"],\"~$text\",[\"^ \",\"^A\",\"Typography\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Typography\",\"^D\",\"1.0\",\"^E\",\"Loading & Displaying\",\"^F\",\"^G\",\"^H\",7,\"^15\",[\"^ \",\"^T\",false,\"^X\",5,\"^U\",[\"^O\",[[\"~$s\",\"~$x\",\"~$y\"],[\"~$s\",\"~$x\",\"~$y\",\"~$z\"],[\"~$s\",\"~$x1\",\"~$y1\",\"~$x2\",\"~$y2\"]]],\"^N\",[\"^O\",[[\"~$s\",\"~$x\",\"~$y\"],[\"~$s\",\"~$x\",\"~$y\",\"~$z\"],[\"~$s\",\"^44\",\"^45\",\"^46\",\"^47\"]]],\"^W\",[\"^O\",[null,null,null]]],\"^I\",\"text()\",\"^J\",3,\"^K\",true,\"^L\",4148,\"^M\",4148,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$s\",\"~$x\",\"~$y\"],[\"~$s\",\"~$x\",\"~$y\",\"~$z\"],[\"~$s\",\"^44\",\"^45\",\"^46\",\"^47\"]]]]],\"^R\",\"Draws text to the screen in the position specified by the x and y\\n  parameters and the optional z parameter. A default font will be used\\n  unless a font is set with the text-font fn. Change the color of the\\n  text with the fill fn. The text displays in relation to the\\n  text-align fn, which gives the option to draw to the left, right, and\\n  center of the coordinates.\\n\\n  The x1, y1, x2 and y2 parameters define a\\n  rectangular area to display within and may only be used with string\\n  data. For text drawn inside a rectangle, the coordinates are\\n  interpreted based on the current rect-mode setting.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/text\",\"^T\",false,\"^E\",\"Loading & Displaying\",\"^F\",\"quil/core.cljc\",\"^H\",7,\"^15\",[\"^ \",\"^T\",false,\"^X\",5,\"^U\",[\"^O\",[[\"~$s\",\"~$x\",\"~$y\"],[\"~$s\",\"~$x\",\"~$y\",\"~$z\"],[\"~$s\",\"^44\",\"^45\",\"^46\",\"^47\"]]],\"^N\",[\"^O\",[[\"~$s\",\"~$x\",\"~$y\"],[\"~$s\",\"~$x\",\"~$y\",\"~$z\"],[\"~$s\",\"^44\",\"^45\",\"^46\",\"^47\"]]],\"^W\",[\"^O\",[null,null,null]]],\"^I\",\"text()\",\"^U\",[\"^O\",[[\"~$s\",\"~$x\",\"~$y\"],[\"~$s\",\"~$x\",\"~$y\",\"~$z\"],[\"~$s\",\"^44\",\"^45\",\"^46\",\"^47\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null,null]],\"^J\",1,\"^K\",true,\"^L\",4142,\"^M\",4148,\"^X\",5,\"^Y\",true,\"^N\",[\"^O\",[[\"~$s\",\"~$x\",\"~$y\"],[\"~$s\",\"~$x\",\"~$y\",\"~$z\"],[\"~$s\",\"^44\",\"^45\",\"^46\",\"^47\"]]],\"^R\",\"Draws text to the screen in the position specified by the x and y\\n  parameters and the optional z parameter. A default font will be used\\n  unless a font is set with the text-font fn. Change the color of the\\n  text with the fill fn. The text displays in relation to the\\n  text-align fn, which gives the option to draw to the left, right, and\\n  center of the coordinates.\\n\\n  The x1, y1, x2 and y2 parameters define a\\n  rectangular area to display within and may only be used with string\\n  data. For text drawn inside a rectangle, the coordinates are\\n  interpreted based on the current rect-mode setting.\"],\"~$available-fonts\",[\"^ \",\"^A\",\"Typography\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Typography\",\"^D\",\"1.0\",\"^E\",\"Loading & Displaying\",\"^F\",\"^G\",\"^H\",18,\"^I\",\"PFont.list()\",\"^J\",3,\"^K\",false,\"^L\",491,\"^M\",491,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"A sequence of strings representing the fonts on this system\\n  available for use.\\n\\n  Because of limitations in Java, not all fonts can be used and some\\n  might work with one operating system and not others. When sharing a\\n  sketch with other people or posting it on the web, you may need to\\n  include a .ttf or .otf version of your font in the data directory of\\n  the sketch because other people might not have the font installed on\\n  their computer. Only fonts that can legally be distributed should be\\n  included with a sketch.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/available-fonts\",\"^T\",false,\"^E\",\"Loading & Displaying\",\"^F\",\"quil/core.cljc\",\"^H\",18,\"^I\",\"PFont.list()\",\"^U\",[\"^O\",[[]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",false,\"^L\",485,\"^M\",491,\"^X\",0,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"A sequence of strings representing the fonts on this system\\n  available for use.\\n\\n  Because of limitations in Java, not all fonts can be used and some\\n  might work with one operating system and not others. When sharing a\\n  sketch with other people or posting it on the web, you may need to\\n  include a .ttf or .otf version of your font in the data directory of\\n  the sketch because other people might not have the font installed on\\n  their computer. Only fonts that can legally be distributed should be\\n  included with a sketch.\"],\"~$rect-modes\",[\"^ \",\"^5\",\"~$quil.core$macros/rect-modes\",\"^F\",\"quil/core.cljc\",\"^L\",45,\"^J\",1,\"^M\",62,\"^H\",12,\"^C\",[\"^ \",\"^F\",\"^G\",\"^L\",62,\"^J\",2,\"^M\",62,\"^H\",12]],\"~$THIRD-PI\",[\"^ \",\"^5\",\"~$quil.core$macros/THIRD-PI\",\"^F\",\"quil/core.cljc\",\"^L\",78,\"^J\",1,\"^M\",78,\"^H\",14,\"^C\",[\"^ \",\"^F\",\"^G\",\"^L\",78,\"^J\",6,\"^M\",78,\"^H\",14]],\"~$binary\",[\"^ \",\"^A\",\"Data\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Data\",\"~:require-binding\",false,\"^D\",\"1.0\",\"^E\",\"Conversion\",\"^F\",\"^G\",\"^H\",9,\"^15\",[\"^ \",\"^T\",false,\"^X\",2,\"^U\",[\"^O\",[[\"^2Q\"],[\"^2Q\",\"~$num-digits\"]]],\"^N\",[\"^O\",[[\"^2Q\"],[\"^2Q\",\"^4A\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"binary()\",\"^J\",3,\"^L\",761,\"^M\",761,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^2Q\"],[\"^2Q\",\"^4A\"]]]]],\"^R\",\"Returns a string representing the binary value of an int, char or\\n  byte. When converting an int to a string, it is possible to specify\\n  the number of digits used.\"],\"^4@\",false,\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/binary\",\"^T\",false,\"^E\",\"Conversion\",\"^F\",\"quil/core.cljc\",\"^H\",9,\"^15\",[\"^ \",\"^T\",false,\"^X\",2,\"^U\",[\"^O\",[[\"^2Q\"],[\"^2Q\",\"^4A\"]]],\"^N\",[\"^O\",[[\"^2Q\"],[\"^2Q\",\"^4A\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"binary()\",\"^U\",[\"^O\",[[\"^2Q\"],[\"^2Q\",\"^4A\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^L\",755,\"^M\",761,\"^X\",2,\"^Y\",true,\"^N\",[\"^O\",[[\"^2Q\"],[\"^2Q\",\"^4A\"]]],\"^R\",\"Returns a string representing the binary value of an int, char or\\n  byte. When converting an int to a string, it is possible to specify\\n  the number of digits used.\"],\"~$pop-matrix\",[\"^ \",\"^A\",\"Transform\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Transform\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^G\",\"^H\",13,\"^I\",\"popMatrix()\",\"^J\",3,\"^K\",true,\"^L\",2999,\"^M\",2999,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Pops the current transformation matrix off the matrix\\n  stack. Understanding pushing and popping requires understanding the\\n  concept of a matrix stack. The push-matrix fn saves the current\\n  coordinate system to the stack and pop-matrix restores the prior\\n  coordinate system. push-matrix and pop-matrix are used in conjuction\\n  with the other transformation methods and may be embedded to control\\n  the scope of the transformations.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/pop-matrix\",\"^T\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^H\",13,\"^I\",\"popMatrix()\",\"^U\",[\"^O\",[[]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",2993,\"^M\",2999,\"^X\",0,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Pops the current transformation matrix off the matrix\\n  stack. Understanding pushing and popping requires understanding the\\n  concept of a matrix stack. The push-matrix fn saves the current\\n  coordinate system to the stack and pop-matrix restores the prior\\n  coordinate system. push-matrix and pop-matrix are used in conjuction\\n  with the other transformation methods and may be embedded to control\\n  the scope of the transformations.\"],\"~$ceil\",[\"^ \",\"^A\",\"Math\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Math\",\"^D\",\"1.0\",\"^E\",\"Calculation\",\"^F\",\"^G\",\"^H\",7,\"^I\",\"ceil()\",\"^J\",3,\"^K\",false,\"^L\",972,\"^M\",972,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$n\"]]]]],\"^R\",\"Calculates the closest int value that is greater than or equal to\\n  the value of the parameter. For example, (ceil 9.03) returns the\\n  value 10.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/ceil\",\"^T\",false,\"^E\",\"Calculation\",\"^F\",\"quil/core.cljc\",\"^H\",7,\"^I\",\"ceil()\",\"^U\",[\"^O\",[[\"~$n\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",false,\"^L\",966,\"^M\",972,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$n\"]]]]],\"^R\",\"Calculates the closest int value that is greater than or equal to\\n  the value of the parameter. For example, (ceil 9.03) returns the\\n  value 10.\"],\"~$key-code\",[\"^ \",\"^A\",\"Input\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Input\",\"^D\",\"1.0\",\"^E\",\"Keyboard\",\"^F\",\"^G\",\"^H\",11,\"^I\",\"keyCode\",\"^J\",3,\"^K\",true,\"^L\",2168,\"^M\",2168,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"The variable keyCode is used to detect special keys such as the UP,\\n  DOWN, LEFT, RIGHT arrow keys and ALT, CONTROL, SHIFT. When checking\\n  for these keys, it's first necessary to check and see if the key is\\n  coded. This is done with the conditional (= (key) CODED).\\n\\n  The keys included in the ASCII specification (BACKSPACE, TAB, ENTER,\\n  RETURN, ESC, and DELETE) do not require checking to see if they key\\n  is coded, and you should simply use the key variable instead of\\n  key-code If you're making cross-platform projects, note that the\\n  ENTER key is commonly used on PCs and Unix and the RETURN key is\\n  used instead on Macintosh. Check for both ENTER and RETURN to make\\n  sure your program will work for all platforms.\\n\\n  For users familiar with Java, the values for UP and DOWN are simply\\n  shorter versions of Java's KeyEvent.VK_UP and\\n  KeyEvent.VK_DOWN. Other keyCode values can be found in the Java\\n  KeyEvent reference.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/key-code\",\"^T\",false,\"^E\",\"Keyboard\",\"^F\",\"quil/core.cljc\",\"^H\",11,\"^I\",\"keyCode\",\"^U\",[\"^O\",[[]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",2162,\"^M\",2168,\"^X\",0,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"The variable keyCode is used to detect special keys such as the UP,\\n  DOWN, LEFT, RIGHT arrow keys and ALT, CONTROL, SHIFT. When checking\\n  for these keys, it's first necessary to check and see if the key is\\n  coded. This is done with the conditional (= (key) CODED).\\n\\n  The keys included in the ASCII specification (BACKSPACE, TAB, ENTER,\\n  RETURN, ESC, and DELETE) do not require checking to see if they key\\n  is coded, and you should simply use the key variable instead of\\n  key-code If you're making cross-platform projects, note that the\\n  ENTER key is commonly used on PCs and Unix and the RETURN key is\\n  used instead on Macintosh. Check for both ENTER and RETURN to make\\n  sure your program will work for all platforms.\\n\\n  For users familiar with Java, the values for UP and DOWN are simply\\n  shorter versions of Java's KeyEvent.VK_UP and\\n  KeyEvent.VK_DOWN. Other keyCode values can be found in the Java\\n  KeyEvent reference.\"],\"~$sphere\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"3D Primitives\",\"^F\",\"^G\",\"^H\",9,\"^I\",\"sphere()\",\"^J\",3,\"^K\",true,\"^L\",3895,\"^M\",3895,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$radius\"]]]]],\"^R\",\"Generates a hollow ball made from tessellated triangles.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/sphere\",\"^T\",false,\"^E\",\"3D Primitives\",\"^F\",\"quil/core.cljc\",\"^H\",9,\"^I\",\"sphere()\",\"^U\",[\"^O\",[[\"^4J\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",3889,\"^M\",3895,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^4J\"]]]]],\"^R\",\"Generates a hollow ball made from tessellated triangles.\"],\"~$request-image\",[\"^ \",\"^A\",\"Image\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Image\",\"^D\",\"1.0\",\"^E\",\"Loading & Displaying\",\"^F\",\"^G\",\"^H\",16,\"^I\",\"requestImage()\",\"^J\",3,\"^K\",true,\"^L\",3338,\"^M\",3338,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$filename\"]]]]],\"^R\",\"This function load images on a separate thread so that your sketch\\n  does not freeze while images load during setup. While the image is\\n  loading, its width and height will be 0. If an error occurs while\\n  loading the image, its width and height will be set to -1. You'll\\n  know when the image has loaded properly because its width and height\\n  will be greater than 0. Asynchronous image loading (particularly\\n  when downloading from a server) can dramatically improve\\n  performance.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/request-image\",\"^T\",false,\"^E\",\"Loading & Displaying\",\"^F\",\"quil/core.cljc\",\"^H\",16,\"^I\",\"requestImage()\",\"^U\",[\"^O\",[[\"^4M\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",3332,\"^M\",3338,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^4M\"]]]]],\"^R\",\"This function load images on a separate thread so that your sketch\\n  does not freeze while images load during setup. While the image is\\n  loading, its width and height will be 0. If an error occurs while\\n  loading the image, its width and height will be set to -1. You'll\\n  know when the image has loaded properly because its width and height\\n  will be greater than 0. Asynchronous image loading (particularly\\n  when downloading from a server) can dramatically improve\\n  performance.\"],\"~$hue\",[\"^ \",\"^A\",\"Color\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Color\",\"^D\",\"1.0\",\"^E\",\"Creating & Reading\",\"^F\",\"^G\",\"^H\",6,\"^I\",\"hue()\",\"^J\",3,\"^K\",true,\"^L\",2064,\"^M\",2064,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$col\"]]]]],\"^R\",\"Extracts the hue value from a color.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/hue\",\"^T\",false,\"^E\",\"Creating & Reading\",\"^F\",\"quil/core.cljc\",\"^H\",6,\"^I\",\"hue()\",\"^U\",[\"^O\",[[\"^4P\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",2058,\"^M\",2064,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^4P\"]]]]],\"^R\",\"Extracts the hue value from a color.\"],\"~$background-int\",[\"^ \",\"^A\",\"Color\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Color\",\"^D\",\"1.0\",\"^E\",\"Setting\",\"^F\",\"^G\",\"^H\",17,\"^15\",[\"^ \",\"^T\",false,\"^X\",2,\"^U\",[\"^O\",[[\"^3:\"],[\"^3:\",\"^2?\"]]],\"^N\",[\"^O\",[[\"^3:\"],[\"^3:\",\"^2?\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"background()\",\"^J\",3,\"^K\",true,\"^L\",532,\"^M\",532,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^3:\"],[\"^3:\",\"^2?\"]]]]],\"^R\",\"Sets the color used for the background of the Processing\\n  window. The default background is light gray. In the draw function,\\n  the background color is used to clear the display window at the\\n  beginning of each frame.\\n\\n  It is not possible to use transparency (alpha) in background colors\\n  with the main drawing surface, however they will work properly with\\n  create-graphics. Converts rgb to an int and alpha to a float.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/background-int\",\"^T\",false,\"^E\",\"Setting\",\"^F\",\"quil/core.cljc\",\"^H\",17,\"^15\",[\"^ \",\"^T\",false,\"^X\",2,\"^U\",[\"^O\",[[\"^3:\"],[\"^3:\",\"^2?\"]]],\"^N\",[\"^O\",[[\"^3:\"],[\"^3:\",\"^2?\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"background()\",\"^U\",[\"^O\",[[\"^3:\"],[\"^3:\",\"^2?\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",526,\"^M\",532,\"^X\",2,\"^Y\",true,\"^N\",[\"^O\",[[\"^3:\"],[\"^3:\",\"^2?\"]]],\"^R\",\"Sets the color used for the background of the Processing\\n  window. The default background is light gray. In the draw function,\\n  the background color is used to clear the display window at the\\n  beginning of each frame.\\n\\n  It is not possible to use transparency (alpha) in background colors\\n  with the main drawing surface, however they will work properly with\\n  create-graphics. Converts rgb to an int and alpha to a float.\"],\"~$start-loop\",[\"^ \",\"^A\",\"Structure\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Structure\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^G\",\"^H\",13,\"^I\",\"loop()\",\"^J\",3,\"^K\",true,\"^L\",3976,\"^M\",3976,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Causes Processing to continuously execute the code within\\n  draw. If no-loop is called, the code in draw stops executing.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/start-loop\",\"^T\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^H\",13,\"^I\",\"loop()\",\"^U\",[\"^O\",[[]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",3970,\"^M\",3976,\"^X\",0,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Causes Processing to continuously execute the code within\\n  draw. If no-loop is called, the code in draw stops executing.\"],\"~$no-fill?\",[\"^ \",\"^B\",null,\"^C\",[\"^ \",\"^F\",\"^G\",\"^L\",4104,\"^J\",8,\"^M\",4104,\"^H\",16,\"^3L\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^1N\"]]]]],\"^R\",\"Returns whether fill is disabled for current graphics.\"],\"^3L\",true,\"^5\",\"~$quil.core$macros/no-fill?\",\"^T\",false,\"^F\",\"quil/core.cljc\",\"^H\",16,\"^U\",[\"^O\",[[\"^1N\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^L\",4104,\"^M\",4104,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^1N\"]]]]],\"^R\",\"Returns whether fill is disabled for current graphics.\"],\"~$curve-vertex\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"Vertex\",\"^F\",\"^G\",\"^H\",15,\"^15\",[\"^ \",\"^T\",false,\"^X\",3,\"^U\",[\"^O\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^N\",[\"^O\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"curveVertex()\",\"^J\",3,\"^K\",true,\"^L\",1407,\"^M\",1407,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]]]],\"^R\",\"Specifies vertex coordinates for curves. This function may only be\\n  used between begin-shape and end-shape and only when there is no\\n  mode keyword specified to begin-shape. The first and last points in a\\n  series of curve-vertex lines will be used to guide the beginning and\\n  end of a the curve. A minimum of four points is required to draw a\\n  tiny curve between the second and third points. Adding a fifth point\\n  with curve-vertex will draw the curve between the second, third, and\\n  fourth points. The curve-vertex function is an implementation of\\n  Catmull-Rom splines.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/curve-vertex\",\"^T\",false,\"^E\",\"Vertex\",\"^F\",\"quil/core.cljc\",\"^H\",15,\"^15\",[\"^ \",\"^T\",false,\"^X\",3,\"^U\",[\"^O\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^N\",[\"^O\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"curveVertex()\",\"^U\",[\"^O\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",1401,\"^M\",1407,\"^X\",3,\"^Y\",true,\"^N\",[\"^O\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^R\",\"Specifies vertex coordinates for curves. This function may only be\\n  used between begin-shape and end-shape and only when there is no\\n  mode keyword specified to begin-shape. The first and last points in a\\n  series of curve-vertex lines will be used to guide the beginning and\\n  end of a the curve. A minimum of four points is required to draw a\\n  tiny curve between the second and third points. Adding a fifth point\\n  with curve-vertex will draw the curve between the second, third, and\\n  fourth points. The curve-vertex function is an implementation of\\n  Catmull-Rom splines.\"],\"~$state-atom\",[\"^ \",\"^A\",\"State\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"State\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^G\",\"^H\",13,\"^J\",3,\"^K\",true,\"^L\",199,\"^M\",199,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Retrieve sketch-specific state-atom. All changes to the\\n  atom will be reflected in the state.\\n\\n  (set-state! :foo 1)\\n  (state :foo) ;=> 1\\n  (swap! (state-atom) update-in [:foo] inc)\\n  (state :foo) ;=> 2\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/state-atom\",\"^T\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^H\",13,\"^U\",[\"^O\",[[]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",194,\"^M\",199,\"^X\",0,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Retrieve sketch-specific state-atom. All changes to the\\n  atom will be reflected in the state.\\n\\n  (set-state! :foo 1)\\n  (state :foo) ;=> 1\\n  (swap! (state-atom) update-in [:foo] inc)\\n  (state :foo) ;=> 2\"],\"~$load-image\",[\"^ \",\"^A\",\"Image\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Image\",\"^D\",\"1.0\",\"^E\",\"Loading & Displaying\",\"^F\",\"^G\",\"^H\",13,\"^I\",\"loadImage()\",\"^J\",3,\"^K\",true,\"^L\",2372,\"^M\",2372,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^4M\"]]]]],\"^R\",\"Loads an image into a variable of type PImage. Four types of\\n  images ( .gif, .jpg, .tga, .png) images may be loaded. To load\\n  correctly, images must be located in the data directory of the\\n  current sketch. In most cases, load all images in setup to preload\\n  them at the start of the program. Loading images inside draw will\\n  reduce the speed of a program.\\n\\n  The filename parameter can also be a URL to a file found online.\\n\\n  If an image is not loaded successfully, the null value is returned\\n  and an error message will be printed to the console. The error\\n  message does not halt the program, however the null value may cause\\n  a NullPointerException if your code does not check whether the value\\n  returned from load-image is nil.\\n\\n  Depending on the type of error, a PImage object may still be\\n  returned, but the width and height of the image will be set to\\n  -1. This happens if bad image data is returned or cannot be decoded\\n  properly. Sometimes this happens with image URLs that produce a 403\\n  error or that redirect to a password prompt, because load-image\\n  will attempt to interpret the HTML as image data.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/load-image\",\"^T\",false,\"^E\",\"Loading & Displaying\",\"^F\",\"quil/core.cljc\",\"^H\",13,\"^I\",\"loadImage()\",\"^U\",[\"^O\",[[\"^4M\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",2366,\"^M\",2372,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^4M\"]]]]],\"^R\",\"Loads an image into a variable of type PImage. Four types of\\n  images ( .gif, .jpg, .tga, .png) images may be loaded. To load\\n  correctly, images must be located in the data directory of the\\n  current sketch. In most cases, load all images in setup to preload\\n  them at the start of the program. Loading images inside draw will\\n  reduce the speed of a program.\\n\\n  The filename parameter can also be a URL to a file found online.\\n\\n  If an image is not loaded successfully, the null value is returned\\n  and an error message will be printed to the console. The error\\n  message does not halt the program, however the null value may cause\\n  a NullPointerException if your code does not check whether the value\\n  returned from load-image is nil.\\n\\n  Depending on the type of error, a PImage object may still be\\n  returned, but the width and height of the image will be set to\\n  -1. This happens if bad image data is returned or cannot be decoded\\n  properly. Sometimes this happens with image URLs that produce a 403\\n  error or that redirect to a password prompt, because load-image\\n  will attempt to interpret the HTML as image data.\"],\"~$bezier\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"Curves\",\"^F\",\"^G\",\"^H\",9,\"^15\",[\"^ \",\"^T\",false,\"^X\",12,\"^U\",[\"^O\",[[\"^44\",\"^45\",\"~$cx1\",\"~$cy1\",\"~$cx2\",\"~$cy2\",\"^46\",\"^47\"],[\"^44\",\"^45\",\"~$z1\",\"^53\",\"^54\",\"~$cz1\",\"^55\",\"^56\",\"~$cz2\",\"^46\",\"^47\",\"~$z2\"]]],\"^N\",[\"^O\",[[\"^44\",\"^45\",\"^53\",\"^54\",\"^55\",\"^56\",\"^46\",\"^47\"],[\"^44\",\"^45\",\"^57\",\"^53\",\"^54\",\"^58\",\"^55\",\"^56\",\"^59\",\"^46\",\"^47\",\"^5:\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"bezier()\",\"^J\",3,\"^K\",true,\"^L\",667,\"^M\",667,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^44\",\"^45\",\"^53\",\"^54\",\"^55\",\"^56\",\"^46\",\"^47\"],[\"^44\",\"^45\",\"^57\",\"^53\",\"^54\",\"^58\",\"^55\",\"^56\",\"^59\",\"^46\",\"^47\",\"^5:\"]]]]],\"^R\",\"Draws a Bezier curve on the screen. These curves are defined by a\\n  series of anchor and control points. The first two parameters\\n  specify the first anchor point and the last two parameters specify\\n  the other anchor point. The middle parameters specify the control\\n  points which define the shape of the curve.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/bezier\",\"^T\",false,\"^E\",\"Curves\",\"^F\",\"quil/core.cljc\",\"^H\",9,\"^15\",[\"^ \",\"^T\",false,\"^X\",12,\"^U\",[\"^O\",[[\"^44\",\"^45\",\"^53\",\"^54\",\"^55\",\"^56\",\"^46\",\"^47\"],[\"^44\",\"^45\",\"^57\",\"^53\",\"^54\",\"^58\",\"^55\",\"^56\",\"^59\",\"^46\",\"^47\",\"^5:\"]]],\"^N\",[\"^O\",[[\"^44\",\"^45\",\"^53\",\"^54\",\"^55\",\"^56\",\"^46\",\"^47\"],[\"^44\",\"^45\",\"^57\",\"^53\",\"^54\",\"^58\",\"^55\",\"^56\",\"^59\",\"^46\",\"^47\",\"^5:\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"bezier()\",\"^U\",[\"^O\",[[\"^44\",\"^45\",\"^53\",\"^54\",\"^55\",\"^56\",\"^46\",\"^47\"],[\"^44\",\"^45\",\"^57\",\"^53\",\"^54\",\"^58\",\"^55\",\"^56\",\"^59\",\"^46\",\"^47\",\"^5:\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",661,\"^M\",667,\"^X\",12,\"^Y\",true,\"^N\",[\"^O\",[[\"^44\",\"^45\",\"^53\",\"^54\",\"^55\",\"^56\",\"^46\",\"^47\"],[\"^44\",\"^45\",\"^57\",\"^53\",\"^54\",\"^58\",\"^55\",\"^56\",\"^59\",\"^46\",\"^47\",\"^5:\"]]],\"^R\",\"Draws a Bezier curve on the screen. These curves are defined by a\\n  series of anchor and control points. The first two parameters\\n  specify the first anchor point and the last two parameters specify\\n  the other anchor point. The middle parameters specify the control\\n  points which define the shape of the curve.\"],\"~$smooth\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"Attributes\",\"^F\",\"^G\",\"^H\",9,\"^15\",[\"^ \",\"^T\",false,\"^X\",1,\"^U\",[\"^O\",[[],[\"^19\"]]],\"^N\",[\"^O\",[[],[\"^19\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"smooth()\",\"^J\",3,\"^K\",true,\"^L\",3849,\"^M\",3849,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[],[\"^19\"]]]]],\"^R\",\"Draws all geometry with smooth (anti-aliased) edges. This will slow\\n  down the frame rate of the application, but will enhance the visual\\n  refinement.\\n\\n  Must be called inside :settings handler.\\n\\n  The level parameter (int) increases the level of smoothness with the\\n  P2D and P3D renderers. This is the level of over sampling applied to\\n  the graphics buffer. The value '2' will double the rendering size\\n  before scaling it down to the display size. This is called '2x\\n  anti-aliasing.' The value 4 is used for 4x anti-aliasing and 8 is\\n  specified for 8x anti-aliasing. If level is set to 0, it will disable\\n  all smoothing; it's the equivalent of the function noSmooth().\\n  The maximum anti-aliasing level is determined by the hardware of the\\n  machine that is running the software.\\n\\n  Note that smooth will also improve image quality of resized images.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/smooth\",\"^T\",false,\"^E\",\"Attributes\",\"^F\",\"quil/core.cljc\",\"^H\",9,\"^15\",[\"^ \",\"^T\",false,\"^X\",1,\"^U\",[\"^O\",[[],[\"^19\"]]],\"^N\",[\"^O\",[[],[\"^19\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"smooth()\",\"^U\",[\"^O\",[[],[\"^19\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",3843,\"^M\",3849,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[[],[\"^19\"]]],\"^R\",\"Draws all geometry with smooth (anti-aliased) edges. This will slow\\n  down the frame rate of the application, but will enhance the visual\\n  refinement.\\n\\n  Must be called inside :settings handler.\\n\\n  The level parameter (int) increases the level of smoothness with the\\n  P2D and P3D renderers. This is the level of over sampling applied to\\n  the graphics buffer. The value '2' will double the rendering size\\n  before scaling it down to the display size. This is called '2x\\n  anti-aliasing.' The value 4 is used for 4x anti-aliasing and 8 is\\n  specified for 8x anti-aliasing. If level is set to 0, it will disable\\n  all smoothing; it's the equivalent of the function noSmooth().\\n  The maximum anti-aliasing level is determined by the hardware of the\\n  machine that is running the software.\\n\\n  Note that smooth will also improve image quality of resized images.\"],\"~$filter-modes\",[\"^ \",\"^5\",\"~$quil.core$macros/filter-modes\",\"^F\",\"quil/core.cljc\",\"^L\",45,\"^J\",1,\"^M\",71,\"^H\",14,\"^C\",[\"^ \",\"^F\",\"^G\",\"^L\",71,\"^J\",2,\"^M\",71,\"^H\",14]],\"~$shear-x\",[\"^ \",\"^A\",\"Transform\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Transform\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^G\",\"^H\",10,\"^I\",\"shearX()\",\"^J\",3,\"^K\",true,\"^L\",3748,\"^M\",3748,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^Q\"]]]]],\"^R\",\"Shears a shape around the x-axis the amount specified by the angle\\n  parameter. Angles should be specified in radians (values from 0 to\\n  PI*2) or converted to radians with the radians() function. Objects\\n  are always sheared around their relative position to the origin and\\n  positive numbers shear objects in a clockwise direction.\\n  Transformations apply to everything that happens after and\\n  subsequent calls to the function accumulates the effect. For\\n  example, calling (shear-x (/ PI 2)) and then (shear-x (/ PI 2)) is\\n  the same as (shear-x PI). If shear-x is called within the draw fn,\\n  the transformation is reset when the loop begins again. This\\n  function works in P2D or JAVA2D mode.\\n\\n  Technically, shear-x multiplies the current transformation matrix\\n  by a rotation matrix. This function can be further controlled by the\\n  push-matrix and pop-matrix fns.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/shear-x\",\"^T\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^H\",10,\"^I\",\"shearX()\",\"^U\",[\"^O\",[[\"^Q\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",3742,\"^M\",3748,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^Q\"]]]]],\"^R\",\"Shears a shape around the x-axis the amount specified by the angle\\n  parameter. Angles should be specified in radians (values from 0 to\\n  PI*2) or converted to radians with the radians() function. Objects\\n  are always sheared around their relative position to the origin and\\n  positive numbers shear objects in a clockwise direction.\\n  Transformations apply to everything that happens after and\\n  subsequent calls to the function accumulates the effect. For\\n  example, calling (shear-x (/ PI 2)) and then (shear-x (/ PI 2)) is\\n  the same as (shear-x PI). If shear-x is called within the draw fn,\\n  the transformation is reset when the loop begins again. This\\n  function works in P2D or JAVA2D mode.\\n\\n  Technically, shear-x multiplies the current transformation matrix\\n  by a rotation matrix. This function can be further controlled by the\\n  push-matrix and pop-matrix fns.\"],\"~$stroke-weight\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"Attributes\",\"^F\",\"^G\",\"^H\",16,\"^I\",\"strokeWeight()\",\"^J\",3,\"^K\",true,\"^L\",4072,\"^M\",4072,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$weight\"]]]]],\"^R\",\"Sets the width of the stroke used for lines, points, and the border\\n  around shapes. All widths are set in units of pixels. \"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/stroke-weight\",\"^T\",false,\"^E\",\"Attributes\",\"^F\",\"quil/core.cljc\",\"^H\",16,\"^I\",\"strokeWeight()\",\"^U\",[\"^O\",[[\"^5C\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",4066,\"^M\",4072,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^5C\"]]]]],\"^R\",\"Sets the width of the stroke used for lines, points, and the border\\n  around shapes. All widths are set in units of pixels. \"],\"~$directional-light\",[\"^ \",\"^A\",\"Lights, Camera\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Lights, Camera\",\"^D\",\"1.0\",\"^E\",\"Lights\",\"^F\",\"^G\",\"^H\",20,\"^I\",\"directionalLight()\",\"^J\",3,\"^K\",true,\"^L\",1473,\"^M\",1473,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$r\",\"~$g\",\"~$b\",\"~$nx\",\"~$ny\",\"~$nz\"]]]]],\"^R\",\"Adds a directional light. Directional light comes from one\\n  direction and is stronger when hitting a surface squarely and weaker\\n  if it hits at a gentle angle. After hitting a surface, a\\n  directional lights scatters in all directions. Lights need to be\\n  included in the draw fn to remain persistent in a looping\\n  program. Placing them in the setup fn of a looping program will cause\\n  them to only have an effect the first time through the loop. The\\n  affect of the r, g, and b parameters is determined by the current\\n  color mode. The nx, ny, and nz parameters specify the direction the\\n  light is facing. For example, setting ny to -1 will cause the\\n  geometry to be lit from below (the light is facing directly upward)\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/directional-light\",\"^T\",false,\"^E\",\"Lights\",\"^F\",\"quil/core.cljc\",\"^H\",20,\"^I\",\"directionalLight()\",\"^U\",[\"^O\",[[\"~$r\",\"~$g\",\"~$b\",\"^5F\",\"^5G\",\"^5H\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",1467,\"^M\",1473,\"^X\",6,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$r\",\"~$g\",\"~$b\",\"^5F\",\"^5G\",\"^5H\"]]]]],\"^R\",\"Adds a directional light. Directional light comes from one\\n  direction and is stronger when hitting a surface squarely and weaker\\n  if it hits at a gentle angle. After hitting a surface, a\\n  directional lights scatters in all directions. Lights need to be\\n  included in the draw fn to remain persistent in a looping\\n  program. Placing them in the setup fn of a looping program will cause\\n  them to only have an effect the first time through the loop. The\\n  affect of the r, g, and b parameters is determined by the current\\n  color mode. The nx, ny, and nz parameters specify the direction the\\n  light is facing. For example, setting ny to -1 will cause the\\n  geometry to be lit from below (the light is facing directly upward)\"],\"~$frame-rate\",[\"^ \",\"^A\",\"Environment\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Environment\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^G\",\"^H\",13,\"^I\",\"frameRate()\",\"^J\",3,\"^K\",true,\"^L\",1879,\"^M\",1879,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$new-rate\"]]]]],\"^R\",\"Specifies a new target framerate (number of frames to be displayed every\\n  second). If the processor is not fast enough to maintain the\\n  specified rate, it will not be achieved. For example, the function\\n  call (frame-rate 30) will attempt to refresh 30 times a second. It\\n  is recommended to set the frame rate within setup. The default rate\\n  is 60 frames per second.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/frame-rate\",\"^T\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^H\",13,\"^I\",\"frameRate()\",\"^U\",[\"^O\",[[\"^5K\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",1873,\"^M\",1879,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^5K\"]]]]],\"^R\",\"Specifies a new target framerate (number of frames to be displayed every\\n  second). If the processor is not fast enough to maintain the\\n  specified rate, it will not be achieved. For example, the function\\n  call (frame-rate 30) will attempt to refresh 30 times a second. It\\n  is recommended to set the frame rate within setup. The default rate\\n  is 60 frames per second.\"],\"~$hour\",[\"^ \",\"^A\",\"Input\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Input\",\"^D\",\"1.0\",\"^E\",\"Time & Date\",\"^F\",\"^G\",\"^H\",7,\"^I\",\"hour()\",\"^J\",3,\"^K\",false,\"^L\",2052,\"^M\",2052,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Returns the current hour as a value from 0 - 23.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/hour\",\"^T\",false,\"^E\",\"Time & Date\",\"^F\",\"quil/core.cljc\",\"^H\",7,\"^I\",\"hour()\",\"^U\",[\"^O\",[[]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",false,\"^L\",2046,\"^M\",2052,\"^X\",0,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Returns the current hour as a value from 0 - 23.\"],\"~$fill-int\",[\"^ \",\"^A\",\"Color\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Color\",\"^D\",\"1.0\",\"^E\",\"Setting\",\"^F\",\"^G\",\"^H\",11,\"^15\",[\"^ \",\"^T\",false,\"^X\",2,\"^U\",[\"^O\",[[\"^3:\"],[\"^3:\",\"^2?\"]]],\"^N\",[\"^O\",[[\"^3:\"],[\"^3:\",\"^2?\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"fill()\",\"^J\",3,\"^K\",true,\"^L\",1727,\"^M\",1727,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^3:\"],[\"^3:\",\"^2?\"]]]]],\"^R\",\"Sets the color used to fill shapes.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/fill-int\",\"^T\",false,\"^E\",\"Setting\",\"^F\",\"quil/core.cljc\",\"^H\",11,\"^15\",[\"^ \",\"^T\",false,\"^X\",2,\"^U\",[\"^O\",[[\"^3:\"],[\"^3:\",\"^2?\"]]],\"^N\",[\"^O\",[[\"^3:\"],[\"^3:\",\"^2?\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"fill()\",\"^U\",[\"^O\",[[\"^3:\"],[\"^3:\",\"^2?\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",1721,\"^M\",1727,\"^X\",2,\"^Y\",true,\"^N\",[\"^O\",[[\"^3:\"],[\"^3:\",\"^2?\"]]],\"^R\",\"Sets the color used to fill shapes.\"],\"~$atan\",[\"^ \",\"^A\",\"Math\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Math\",\"^D\",\"1.0\",\"^E\",\"Trigonometry\",\"^F\",\"^G\",\"^H\",7,\"^I\",\"atan()\",\"^J\",3,\"^K\",false,\"^L\",458,\"^M\",458,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$n\"]]]]],\"^R\",\"The inverse of tan, returns the arc tangent of a value. This\\n  function expects the values in the range of -Infinity to\\n  Infinity (exclusive) and values are returned in the range -PI/2 to\\n  PI/2 .\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/atan\",\"^T\",false,\"^E\",\"Trigonometry\",\"^F\",\"quil/core.cljc\",\"^H\",7,\"^I\",\"atan()\",\"^U\",[\"^O\",[[\"~$n\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",false,\"^L\",452,\"^M\",458,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$n\"]]]]],\"^R\",\"The inverse of tan, returns the arc tangent of a value. This\\n  function expects the values in the range of -Infinity to\\n  Infinity (exclusive) and values are returned in the range -PI/2 to\\n  PI/2 .\"],\"~$stroke-join-modes\",[\"^ \",\"^5\",\"~$quil.core$macros/stroke-join-modes\",\"^F\",\"quil/core.cljc\",\"^L\",45,\"^J\",1,\"^M\",65,\"^H\",19,\"^C\",[\"^ \",\"^F\",\"^G\",\"^L\",65,\"^J\",2,\"^M\",65,\"^H\",19]],\"~$rotate-y\",[\"^ \",\"^A\",\"Transform\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Transform\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^G\",\"^H\",11,\"^I\",\"rotateY()\",\"^J\",3,\"^K\",true,\"^L\",3457,\"^M\",3457,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^Q\"]]]]],\"^R\",\"Rotates a shape around the y-axis the amount specified by the angle\\n  parameter. Angles should be specified in radians (values from 0\\n  to (* PI 2)) or converted to radians with the radians function.\\n  Objects are always rotated around their relative position to the\\n  origin and positive numbers rotate objects in a counterclockwise\\n  direction. Transformations apply to everything that happens after\\n  and subsequent calls to the function accumulates the effect. For\\n  example, calling (rotate-y HALF-PI) and then (rotate-y HALF-PI) is\\n  the same as (rotate-y PI). If rotate-y is called within the draw fn,\\n  the transformation is reset when the loop begins again. This\\n  function requires either the :p3d or :opengl renderer.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/rotate-y\",\"^T\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^H\",11,\"^I\",\"rotateY()\",\"^U\",[\"^O\",[[\"^Q\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",3451,\"^M\",3457,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^Q\"]]]]],\"^R\",\"Rotates a shape around the y-axis the amount specified by the angle\\n  parameter. Angles should be specified in radians (values from 0\\n  to (* PI 2)) or converted to radians with the radians function.\\n  Objects are always rotated around their relative position to the\\n  origin and positive numbers rotate objects in a counterclockwise\\n  direction. Transformations apply to everything that happens after\\n  and subsequent calls to the function accumulates the effect. For\\n  example, calling (rotate-y HALF-PI) and then (rotate-y HALF-PI) is\\n  the same as (rotate-y PI). If rotate-y is called within the draw fn,\\n  the transformation is reset when the loop begins again. This\\n  function requires either the :p3d or :opengl renderer.\"],\"~$day\",[\"^ \",\"^A\",\"Input\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Input\",\"^D\",\"1.0\",\"^E\",\"Time & Date\",\"^F\",\"^G\",\"^H\",6,\"^I\",\"day()\",\"^J\",3,\"^K\",false,\"^L\",1426,\"^M\",1426,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Get the current day of the month (1 through 31).\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/day\",\"^T\",false,\"^E\",\"Time & Date\",\"^F\",\"quil/core.cljc\",\"^H\",6,\"^I\",\"day()\",\"^U\",[\"^O\",[[]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",false,\"^L\",1420,\"^M\",1426,\"^X\",0,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Get the current day of the month (1 through 31).\"],\"~$point-light\",[\"^ \",\"^A\",\"Lights, Camera\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Lights, Camera\",\"^D\",\"1.0\",\"^E\",\"Lights\",\"^F\",\"^G\",\"^H\",14,\"^I\",\"pointLight()\",\"^J\",3,\"^K\",true,\"^L\",2983,\"^M\",2983,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$r\",\"~$g\",\"~$b\",\"~$x\",\"~$y\",\"~$z\"]]]]],\"^R\",\"Adds a point light. Lights need to be included in the draw() to\\n  remain persistent in a looping program. Placing them in the setup()\\n  of a looping program will cause them to only have an effect the\\n  first time through the loop. The affect of the r, g, and b\\n  parameters is determined by the current color mode. The x, y, and z\\n  parameters set the position of the light\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/point-light\",\"^T\",false,\"^E\",\"Lights\",\"^F\",\"quil/core.cljc\",\"^H\",14,\"^I\",\"pointLight()\",\"^U\",[\"^O\",[[\"~$r\",\"~$g\",\"~$b\",\"~$x\",\"~$y\",\"~$z\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",2977,\"^M\",2983,\"^X\",6,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$r\",\"~$g\",\"~$b\",\"~$x\",\"~$y\",\"~$z\"]]]]],\"^R\",\"Adds a point light. Lights need to be included in the draw() to\\n  remain persistent in a looping program. Placing them in the setup()\\n  of a looping program will cause them to only have an effect the\\n  first time through the loop. The affect of the r, g, and b\\n  parameters is determined by the current color mode. The x, y, and z\\n  parameters set the position of the light\"],\"~$pmouse-x\",[\"^ \",\"^A\",\"Input\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Input\",\"^D\",\"1.0\",\"^E\",\"Mouse\",\"^F\",\"^G\",\"^H\",11,\"^I\",\"pmouseX\",\"^J\",3,\"^K\",true,\"^L\",2945,\"^M\",2945,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Horizontal coordinate of the mouse in the previous frame\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/pmouse-x\",\"^T\",false,\"^E\",\"Mouse\",\"^F\",\"quil/core.cljc\",\"^H\",11,\"^I\",\"pmouseX\",\"^U\",[\"^O\",[[]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",2939,\"^M\",2945,\"^X\",0,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Horizontal coordinate of the mouse in the previous frame\"],\"~$get-sketch-by-id\",[\"^ \",\"^A\",null,\"^B\",null,\"^C\",[\"^ \",\"^A\",null,\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^G\",\"^H\",22,\"^I\",\"getSketchById()\",\"^J\",6,\"^K\",true,\"^L\",185,\"^M\",185,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$id\"]]]]],\"^R\",\"Returns sketch object by id of canvas element of sketch.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/get-sketch-by-id\",\"^T\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^H\",22,\"^I\",\"getSketchById()\",\"^U\",[\"^O\",[[\"^62\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",4,\"^K\",true,\"^L\",179,\"^M\",185,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^62\"]]]]],\"^R\",\"Returns sketch object by id of canvas element of sketch.\"],\"~$stroke\",[\"^ \",\"^A\",\"Color\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Color\",\"^D\",\"1.0\",\"^E\",\"Setting\",\"^F\",\"^G\",\"^H\",9,\"^15\",[\"^ \",\"^T\",false,\"^X\",4,\"^U\",[\"^O\",[[\"^3:\"],[\"^3:\",\"^2?\"],[\"~$x\",\"~$y\",\"~$z\"],[\"~$x\",\"~$y\",\"~$z\",\"~$a\"]]],\"^N\",[\"^O\",[[\"^3:\"],[\"^3:\",\"^2?\"],[\"~$x\",\"~$y\",\"~$z\"],[\"~$x\",\"~$y\",\"~$z\",\"~$a\"]]],\"^W\",[\"^O\",[null,null,null,null]]],\"^I\",\"stroke()\",\"^J\",3,\"^K\",true,\"^L\",4014,\"^M\",4014,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^3:\"],[\"^3:\",\"^2?\"],[\"~$x\",\"~$y\",\"~$z\"],[\"~$x\",\"~$y\",\"~$z\",\"~$a\"]]]]],\"^R\",\"Sets the color used to draw lines and borders around shapes. This\\n  color is either specified in terms of the RGB or HSB color depending\\n  on the current color-mode (the default color space is RGB, with\\n  each value in the range from 0 to 255).\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/stroke\",\"^T\",false,\"^E\",\"Setting\",\"^F\",\"quil/core.cljc\",\"^H\",9,\"^15\",[\"^ \",\"^T\",false,\"^X\",4,\"^U\",[\"^O\",[[\"^3:\"],[\"^3:\",\"^2?\"],[\"~$x\",\"~$y\",\"~$z\"],[\"~$x\",\"~$y\",\"~$z\",\"~$a\"]]],\"^N\",[\"^O\",[[\"^3:\"],[\"^3:\",\"^2?\"],[\"~$x\",\"~$y\",\"~$z\"],[\"~$x\",\"~$y\",\"~$z\",\"~$a\"]]],\"^W\",[\"^O\",[null,null,null,null]]],\"^I\",\"stroke()\",\"^U\",[\"^O\",[[\"^3:\"],[\"^3:\",\"^2?\"],[\"~$x\",\"~$y\",\"~$z\"],[\"~$x\",\"~$y\",\"~$z\",\"~$a\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null,null,null]],\"^J\",1,\"^K\",true,\"^L\",4008,\"^M\",4014,\"^X\",4,\"^Y\",true,\"^N\",[\"^O\",[[\"^3:\"],[\"^3:\",\"^2?\"],[\"~$x\",\"~$y\",\"~$z\"],[\"~$x\",\"~$y\",\"~$z\",\"~$a\"]]],\"^R\",\"Sets the color used to draw lines and borders around shapes. This\\n  color is either specified in terms of the RGB or HSB color depending\\n  on the current color-mode (the default color space is RGB, with\\n  each value in the range from 0 to 255).\"],\"~$mouse-pressed?\",[\"^ \",\"^A\",\"Input\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Input\",\"^D\",\"1.0\",\"^E\",\"Mouse\",\"^F\",\"^G\",\"^H\",17,\"^I\",\"mousePressed\",\"^J\",3,\"^K\",true,\"^L\",2605,\"^M\",2605,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Variable storing if a mouse button is pressed. The value of the\\n  system variable mousePressed is true if a mouse button is pressed\\n  and false if a button is not pressed.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/mouse-pressed?\",\"^T\",false,\"^E\",\"Mouse\",\"^F\",\"quil/core.cljc\",\"^H\",17,\"^I\",\"mousePressed\",\"^U\",[\"^O\",[[]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",2599,\"^M\",2605,\"^X\",0,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Variable storing if a mouse button is pressed. The value of the\\n  system variable mousePressed is true if a mouse button is pressed\\n  and false if a button is not pressed.\"],\"~$key-pressed?\",[\"^ \",\"^A\",\"Input\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Input\",\"^D\",\"1.0\",\"^E\",\"Keyboard\",\"^F\",\"^G\",\"^H\",15,\"^I\",\"keyPressed\",\"^J\",3,\"^K\",true,\"^L\",2217,\"^M\",2217,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"true if any key is currently pressed, false otherwise.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/key-pressed?\",\"^T\",false,\"^E\",\"Keyboard\",\"^F\",\"quil/core.cljc\",\"^H\",15,\"^I\",\"keyPressed\",\"^U\",[\"^O\",[[]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",2211,\"^M\",2217,\"^X\",0,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"true if any key is currently pressed, false otherwise.\"],\"~$quadratic-vertex\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"2.0\",\"^E\",\"Vertex\",\"^F\",\"^G\",\"^H\",19,\"^15\",[\"^ \",\"^T\",false,\"^X\",6,\"^U\",[\"^O\",[[\"~$cx\",\"~$cy\",\"~$x3\",\"~$y3\"],[\"^6;\",\"^6<\",\"~$cz\",\"^6=\",\"^6>\",\"~$z3\"]]],\"^N\",[\"^O\",[[\"^6;\",\"^6<\",\"^6=\",\"^6>\"],[\"^6;\",\"^6<\",\"^6?\",\"^6=\",\"^6>\",\"^6@\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"quadraticVertex()\",\"^J\",3,\"^K\",true,\"^L\",3142,\"^M\",3142,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^6;\",\"^6<\",\"^6=\",\"^6>\"],[\"^6;\",\"^6<\",\"^6?\",\"^6=\",\"^6>\",\"^6@\"]]]]],\"^R\",\"Specifies vertex coordinates for quadratic Bezier curves. Each call to\\n  quadratic-vertex defines the position of one control points and one\\n  anchor point of a Bezier curve, adding a new segment to a line or shape.\\n  The first time quadratic-vertex is used within a begin-shape call, it\\n  must be prefaced with a call to vertex to set the first anchor point.\\n  This function must be used between begin-shape and end-shape and only\\n  when there is no MODE parameter specified to begin-shape. Using the 3D\\n  version requires rendering with :p3d.\"],\"^D\",\"2.0\",\"^5\",\"~$quil.core$macros/quadratic-vertex\",\"^T\",false,\"^E\",\"Vertex\",\"^F\",\"quil/core.cljc\",\"^H\",19,\"^15\",[\"^ \",\"^T\",false,\"^X\",6,\"^U\",[\"^O\",[[\"^6;\",\"^6<\",\"^6=\",\"^6>\"],[\"^6;\",\"^6<\",\"^6?\",\"^6=\",\"^6>\",\"^6@\"]]],\"^N\",[\"^O\",[[\"^6;\",\"^6<\",\"^6=\",\"^6>\"],[\"^6;\",\"^6<\",\"^6?\",\"^6=\",\"^6>\",\"^6@\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"quadraticVertex()\",\"^U\",[\"^O\",[[\"^6;\",\"^6<\",\"^6=\",\"^6>\"],[\"^6;\",\"^6<\",\"^6?\",\"^6=\",\"^6>\",\"^6@\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",3136,\"^M\",3142,\"^X\",6,\"^Y\",true,\"^N\",[\"^O\",[[\"^6;\",\"^6<\",\"^6=\",\"^6>\"],[\"^6;\",\"^6<\",\"^6?\",\"^6=\",\"^6>\",\"^6@\"]]],\"^R\",\"Specifies vertex coordinates for quadratic Bezier curves. Each call to\\n  quadratic-vertex defines the position of one control points and one\\n  anchor point of a Bezier curve, adding a new segment to a line or shape.\\n  The first time quadratic-vertex is used within a begin-shape call, it\\n  must be prefaced with a call to vertex to set the first anchor point.\\n  This function must be used between begin-shape and end-shape and only\\n  when there is no MODE parameter specified to begin-shape. Using the 3D\\n  version requires rendering with :p3d.\"],\"~$texture-wrap-modes\",[\"^ \",\"^5\",\"~$quil.core$macros/texture-wrap-modes\",\"^F\",\"quil/core.cljc\",\"^L\",45,\"^J\",1,\"^M\",70,\"^H\",20,\"^C\",[\"^ \",\"^F\",\"^G\",\"^L\",70,\"^J\",2,\"^M\",70,\"^H\",20]],\"~$noise-seed\",[\"^ \",\"^A\",\"Math\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Math\",\"^D\",\"1.0\",\"^E\",\"Random\",\"^F\",\"^G\",\"^H\",13,\"^I\",\"noiseSeed()\",\"^J\",3,\"^K\",true,\"^L\",2743,\"^M\",2743,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^2Q\"]]]]],\"^R\",\"Sets the seed value for noise. By default, noise produces different\\n  results each time the program is run. Set the value parameter to a\\n  constant to return the same pseudo-random numbers each time the\\n  software is run.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/noise-seed\",\"^T\",false,\"^E\",\"Random\",\"^F\",\"quil/core.cljc\",\"^H\",13,\"^I\",\"noiseSeed()\",\"^U\",[\"^O\",[[\"^2Q\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",2737,\"^M\",2743,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^2Q\"]]]]],\"^R\",\"Sets the seed value for noise. By default, noise produces different\\n  results each time the program is run. Set the value parameter to a\\n  constant to return the same pseudo-random numbers each time the\\n  software is run.\"],\"~$apply-matrix\",[\"^ \",\"^A\",\"Transform\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Transform\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^G\",\"^H\",15,\"^I\",\"applyMatrix()\",\"^J\",3,\"^K\",true,\"^L\",396,\"^M\",396,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$n00\",\"~$n01\",\"~$n02\",\"~$n03\",\"~$n10\",\"~$n11\",\"~$n12\",\"~$n13\",\"~$n20\",\"~$n21\",\"~$n22\",\"~$n23\",\"~$n30\",\"~$n31\",\"~$n32\",\"~$n33\"]]]]],\"^R\",\"Multiplies the current matrix by the one specified through the\\n  parameters. This is very slow because it will try to calculate the\\n  inverse of the transform, so avoid it whenever possible. The\\n  equivalent function in OpenGL is glMultMatrix().\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/apply-matrix\",\"^T\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^H\",15,\"^I\",\"applyMatrix()\",\"^U\",[\"^O\",[[\"^6G\",\"^6H\",\"^6I\",\"^6J\",\"^6K\",\"^6L\",\"^6M\",\"^6N\",\"^6O\",\"^6P\",\"^6Q\",\"^6R\",\"^6S\",\"^6T\",\"^6U\",\"^6V\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",390,\"^M\",396,\"^X\",16,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^6G\",\"^6H\",\"^6I\",\"^6J\",\"^6K\",\"^6L\",\"^6M\",\"^6N\",\"^6O\",\"^6P\",\"^6Q\",\"^6R\",\"^6S\",\"^6T\",\"^6U\",\"^6V\"]]]]],\"^R\",\"Multiplies the current matrix by the one specified through the\\n  parameters. This is very slow because it will try to calculate the\\n  inverse of the transform, so avoid it whenever possible. The\\n  equivalent function in OpenGL is glMultMatrix().\"],\"~$copy\",[\"^ \",\"^A\",\"Image\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Image\",\"^D\",\"1.0\",\"^E\",\"Pixels\",\"^F\",\"^G\",\"^H\",7,\"^15\",[\"^ \",\"^T\",false,\"^X\",4,\"^U\",[\"^O\",[[[\"~$sx\",\"~$sy\",\"~$swidth\",\"~$sheight\"],[\"^1B\",\"^1C\",\"^1D\",\"^1E\"]],[\"^1F\",[\"^6Y\",\"^6Z\",\"^6[\",\"^70\"],[\"^1B\",\"^1C\",\"^1D\",\"^1E\"]],[\"^1F\",\"^1G\",[\"^6Y\",\"^6Z\",\"^6[\",\"^70\"],[\"^1B\",\"^1C\",\"^1D\",\"^1E\"]]]],\"^N\",[\"^O\",[[[\"^6Y\",\"^6Z\",\"^6[\",\"^70\"],[\"^1B\",\"^1C\",\"^1D\",\"^1E\"]],[\"^1F\",[\"^6Y\",\"^6Z\",\"^6[\",\"^70\"],[\"^1B\",\"^1C\",\"^1D\",\"^1E\"]],[\"^1F\",\"^1G\",[\"^6Y\",\"^6Z\",\"^6[\",\"^70\"],[\"^1B\",\"^1C\",\"^1D\",\"^1E\"]]]],\"^W\",[\"^O\",[null,null,null]]],\"^I\",\"copy()\",\"^J\",3,\"^K\",true,\"^L\",1112,\"^M\",1112,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[[\"^6Y\",\"^6Z\",\"^6[\",\"^70\"],[\"^1B\",\"^1C\",\"^1D\",\"^1E\"]],[\"^1F\",[\"^6Y\",\"^6Z\",\"^6[\",\"^70\"],[\"^1B\",\"^1C\",\"^1D\",\"^1E\"]],[\"^1F\",\"^1G\",[\"^6Y\",\"^6Z\",\"^6[\",\"^70\"],[\"^1B\",\"^1C\",\"^1D\",\"^1E\"]]]]]],\"^R\",\"Copies a region of pixels from the one image to another. If src-img\\n  is not specified it defaults to current-graphics. If dest-img is not\\n  specified - it defaults to current-graphics. If the source\\n  and destination regions aren't the same size, it will automatically\\n  resize the source pixels to fit the specified target region. No\\n  alpha information is used in the process, however if the source\\n  image has an alpha channel set, it will be copied as well. \"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/copy\",\"^T\",false,\"^E\",\"Pixels\",\"^F\",\"quil/core.cljc\",\"^H\",7,\"^15\",[\"^ \",\"^T\",false,\"^X\",4,\"^U\",[\"^O\",[[[\"^6Y\",\"^6Z\",\"^6[\",\"^70\"],[\"^1B\",\"^1C\",\"^1D\",\"^1E\"]],[\"^1F\",[\"^6Y\",\"^6Z\",\"^6[\",\"^70\"],[\"^1B\",\"^1C\",\"^1D\",\"^1E\"]],[\"^1F\",\"^1G\",[\"^6Y\",\"^6Z\",\"^6[\",\"^70\"],[\"^1B\",\"^1C\",\"^1D\",\"^1E\"]]]],\"^N\",[\"^O\",[[[\"^6Y\",\"^6Z\",\"^6[\",\"^70\"],[\"^1B\",\"^1C\",\"^1D\",\"^1E\"]],[\"^1F\",[\"^6Y\",\"^6Z\",\"^6[\",\"^70\"],[\"^1B\",\"^1C\",\"^1D\",\"^1E\"]],[\"^1F\",\"^1G\",[\"^6Y\",\"^6Z\",\"^6[\",\"^70\"],[\"^1B\",\"^1C\",\"^1D\",\"^1E\"]]]],\"^W\",[\"^O\",[null,null,null]]],\"^I\",\"copy()\",\"^U\",[\"^O\",[[[\"^6Y\",\"^6Z\",\"^6[\",\"^70\"],[\"^1B\",\"^1C\",\"^1D\",\"^1E\"]],[\"^1F\",[\"^6Y\",\"^6Z\",\"^6[\",\"^70\"],[\"^1B\",\"^1C\",\"^1D\",\"^1E\"]],[\"^1F\",\"^1G\",[\"^6Y\",\"^6Z\",\"^6[\",\"^70\"],[\"^1B\",\"^1C\",\"^1D\",\"^1E\"]]]],\"^V\",null,\"^W\",[\"^O\",[null,null,null]],\"^J\",1,\"^K\",true,\"^L\",1106,\"^M\",1112,\"^X\",4,\"^Y\",true,\"^N\",[\"^O\",[[[\"^6Y\",\"^6Z\",\"^6[\",\"^70\"],[\"^1B\",\"^1C\",\"^1D\",\"^1E\"]],[\"^1F\",[\"^6Y\",\"^6Z\",\"^6[\",\"^70\"],[\"^1B\",\"^1C\",\"^1D\",\"^1E\"]],[\"^1F\",\"^1G\",[\"^6Y\",\"^6Z\",\"^6[\",\"^70\"],[\"^1B\",\"^1C\",\"^1D\",\"^1E\"]]]],\"^R\",\"Copies a region of pixels from the one image to another. If src-img\\n  is not specified it defaults to current-graphics. If dest-img is not\\n  specified - it defaults to current-graphics. If the source\\n  and destination regions aren't the same size, it will automatically\\n  resize the source pixels to fit the specified target region. No\\n  alpha information is used in the process, however if the source\\n  image has an alpha channel set, it will be copied as well. \"],\"~$begin-shape\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"Vertex\",\"^F\",\"^G\",\"^H\",14,\"^15\",[\"^ \",\"^T\",false,\"^X\",1,\"^U\",[\"^O\",[[],[\"^18\"]]],\"^N\",[\"^O\",[[],[\"^18\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"beginShape()\",\"^J\",3,\"^K\",true,\"^L\",635,\"^M\",635,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[],[\"^18\"]]]]],\"^R\",\"Enables the creation of complex forms. begin-shape begins recording\\n  vertices for a shape and end-shape stops recording. Use the mode\\n  keyword to specify which shape create from the provided\\n  vertices. With no mode specified, the shape can be any irregular\\n  polygon.\\n\\n  The available mode keywords are :points, :lines, :triangles,\\n                                  :triangle-fan, :triangle-strip,\\n                                  :quads, :quad-strip.\\n\\n  After calling the begin-shape function, a series of vertex commands\\n  must follow. To stop drawing the shape, call end-shape. The vertex\\n  function with two parameters specifies a position in 2D and the\\n  vertex function with three parameters specifies a position in\\n  3D. Each shape will be outlined with the current stroke color and\\n  filled with the fill color.\\n\\n  Transformations such as translate, rotate, and scale do not work\\n  within begin-shape. It is also not possible to use other shapes,\\n  such as ellipse or rect within begin-shape.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/begin-shape\",\"^T\",false,\"^E\",\"Vertex\",\"^F\",\"quil/core.cljc\",\"^H\",14,\"^15\",[\"^ \",\"^T\",false,\"^X\",1,\"^U\",[\"^O\",[[],[\"^18\"]]],\"^N\",[\"^O\",[[],[\"^18\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"beginShape()\",\"^U\",[\"^O\",[[],[\"^18\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",629,\"^M\",635,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[[],[\"^18\"]]],\"^R\",\"Enables the creation of complex forms. begin-shape begins recording\\n  vertices for a shape and end-shape stops recording. Use the mode\\n  keyword to specify which shape create from the provided\\n  vertices. With no mode specified, the shape can be any irregular\\n  polygon.\\n\\n  The available mode keywords are :points, :lines, :triangles,\\n                                  :triangle-fan, :triangle-strip,\\n                                  :quads, :quad-strip.\\n\\n  After calling the begin-shape function, a series of vertex commands\\n  must follow. To stop drawing the shape, call end-shape. The vertex\\n  function with two parameters specifies a position in 2D and the\\n  vertex function with three parameters specifies a position in\\n  3D. Each shape will be outlined with the current stroke color and\\n  filled with the fill color.\\n\\n  Transformations such as translate, rotate, and scale do not work\\n  within begin-shape. It is also not possible to use other shapes,\\n  such as ellipse or rect within begin-shape.\"],\"~$set-state!\",[\"^ \",\"^A\",\"State\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"State\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^G\",\"^H\",13,\"^15\",[\"^ \",\"^T\",true,\"^X\",0,\"^U\",[[\"^O\",[\"~$state-vals\"]]],\"^N\",[\"^O\",[[\"~$&\",\"^75\"]]],\"^W\",[\"^O\",[null]]],\"^J\",3,\"^K\",true,\"^L\",236,\"^M\",236,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$&\",\"^75\"]]]]],\"^R\",\"Set sketch-specific state. May only be called once (ideally in the\\n  setup fn).  Subsequent calls have no effect.\\n\\n  Example:\\n  (set-state! :foo 1 :bar (atom true) :baz (/ (width) 2))\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/set-state!\",\"^T\",true,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^H\",13,\"^15\",[\"^ \",\"^T\",true,\"^X\",0,\"^U\",[[\"^O\",[\"^75\"]]],\"^N\",[\"^O\",[[\"~$&\",\"^75\"]]],\"^W\",[\"^O\",[null]]],\"^U\",[[\"^O\",[\"^75\"]]],\"^V\",null,\"^W\",[\"^O\",[null]],\"^J\",1,\"^K\",true,\"^L\",231,\"^M\",236,\"^X\",0,\"^Y\",true,\"^N\",[\"^O\",[[\"~$&\",\"^75\"]]],\"^R\",\"Set sketch-specific state. May only be called once (ideally in the\\n  setup fn).  Subsequent calls have no effect.\\n\\n  Example:\\n  (set-state! :foo 1 :bar (atom true) :baz (/ (width) 2))\"],\"~$stroke-join\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"Attributes\",\"^F\",\"^G\",\"^H\",14,\"^I\",\"strokeJoin()\",\"^J\",3,\"^K\",true,\"^L\",4052,\"^M\",4052,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$join-mode\"]]]]],\"^R\",\"Sets the style of the joints which connect line\\n  segments. These joints are either mitered, beveled, or rounded and\\n  specified with the corresponding parameters :miter, :bevel, and\\n  :round. The default joint is :miter.\\n\\n  This function is not available with the :p2d, :p3d, or :opengl\\n  renderers.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/stroke-join\",\"^T\",false,\"^E\",\"Attributes\",\"^F\",\"quil/core.cljc\",\"^H\",14,\"^I\",\"strokeJoin()\",\"^U\",[\"^O\",[[\"^78\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",4046,\"^M\",4052,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^78\"]]]]],\"^R\",\"Sets the style of the joints which connect line\\n  segments. These joints are either mitered, beveled, or rounded and\\n  specified with the corresponding parameters :miter, :bevel, and\\n  :round. The default joint is :miter.\\n\\n  This function is not available with the :p2d, :p3d, or :opengl\\n  renderers.\"],\"~$cos\",[\"^ \",\"^A\",\"Math\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Math\",\"^D\",\"1.0\",\"^E\",\"Trigonometry\",\"^F\",\"^G\",\"^H\",6,\"^I\",\"cos()\",\"^J\",3,\"^K\",false,\"^L\",1138,\"^M\",1138,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^Q\"]]]]],\"^R\",\"Calculates the cosine of an angle. This function expects the values\\n  of the angle parameter to be provided in radians (values from 0 to\\n  Math/PI*2). Values are returned in the range -1 to 1.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/cos\",\"^T\",false,\"^E\",\"Trigonometry\",\"^F\",\"quil/core.cljc\",\"^H\",6,\"^I\",\"cos()\",\"^U\",[\"^O\",[[\"^Q\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",false,\"^L\",1132,\"^M\",1138,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^Q\"]]]]],\"^R\",\"Calculates the cosine of an angle. This function expects the values\\n  of the angle parameter to be provided in radians (values from 0 to\\n  Math/PI*2). Values are returned in the range -1 to 1.\"],\"~$curve-tightness\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"Curves\",\"^F\",\"^G\",\"^H\",18,\"^I\",\"curveTightness()\",\"^J\",3,\"^K\",true,\"^L\",1389,\"^M\",1389,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$ti\"]]]]],\"^R\",\"Modifies the quality of forms created with curve and\\n  curve-vertex. The parameter squishy determines how the curve fits\\n  to the vertex points. The value 0.0 is the default value for\\n  squishy (this value defines the curves to be Catmull-Rom splines)\\n  and the value 1.0 connects all the points with straight\\n  lines. Values within the range -5.0 and 5.0 will deform the curves\\n  but will leave them recognizable and as values increase in\\n  magnitude, they will continue to deform.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/curve-tightness\",\"^T\",false,\"^E\",\"Curves\",\"^F\",\"quil/core.cljc\",\"^H\",18,\"^I\",\"curveTightness()\",\"^U\",[\"^O\",[[\"^7=\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",1383,\"^M\",1389,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^7=\"]]]]],\"^R\",\"Modifies the quality of forms created with curve and\\n  curve-vertex. The parameter squishy determines how the curve fits\\n  to the vertex points. The value 0.0 is the default value for\\n  squishy (this value defines the curves to be Catmull-Rom splines)\\n  and the value 1.0 connects all the points with straight\\n  lines. Values within the range -5.0 and 5.0 will deform the curves\\n  but will leave them recognizable and as values increase in\\n  magnitude, they will continue to deform.\"],\"~$tan\",[\"^ \",\"^A\",\"Math\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Math\",\"^D\",\"1.0\",\"^E\",\"Trigonometry\",\"^F\",\"^G\",\"^H\",6,\"^I\",\"tan()\",\"^J\",3,\"^K\",false,\"^L\",4084,\"^M\",4084,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^Q\"]]]]],\"^R\",\"Calculates the ratio of the sine and cosine of an angle. This\\n  function expects the values of the angle parameter to be provided in\\n  radians (values from 0 to PI*2). Values are returned in the range\\n  infinity to -infinity.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/tan\",\"^T\",false,\"^E\",\"Trigonometry\",\"^F\",\"quil/core.cljc\",\"^H\",6,\"^I\",\"tan()\",\"^U\",[\"^O\",[[\"^Q\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",false,\"^L\",4078,\"^M\",4084,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^Q\"]]]]],\"^R\",\"Calculates the ratio of the sine and cosine of an angle. This\\n  function expects the values of the angle parameter to be provided in\\n  radians (values from 0 to PI*2). Values are returned in the range\\n  infinity to -infinity.\"],\"~$triangle\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"2D Primitives\",\"^F\",\"^G\",\"^H\",11,\"^I\",\"triangle()\",\"^J\",3,\"^K\",true,\"^L\",4481,\"^M\",4481,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^44\",\"^45\",\"^46\",\"^47\",\"^6=\",\"^6>\"]]]]],\"^R\",\"A triangle is a plane created by connecting three points. The first\\n  two arguments specify the first point, the middle two arguments\\n  specify the second point, and the last two arguments specify the\\n  third point.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/triangle\",\"^T\",false,\"^E\",\"2D Primitives\",\"^F\",\"quil/core.cljc\",\"^H\",11,\"^I\",\"triangle()\",\"^U\",[\"^O\",[[\"^44\",\"^45\",\"^46\",\"^47\",\"^6=\",\"^6>\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",4475,\"^M\",4481,\"^X\",6,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^44\",\"^45\",\"^46\",\"^47\",\"^6=\",\"^6>\"]]]]],\"^R\",\"A triangle is a plane created by connecting three points. The first\\n  two arguments specify the first point, the middle two arguments\\n  specify the second point, and the last two arguments specify the\\n  third point.\"],\"~$emissive\",[\"^ \",\"^A\",\"Lights, Camera\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Lights, Camera\",\"^D\",\"1.0\",\"^E\",\"Material Properties\",\"^F\",\"^G\",\"^H\",11,\"^15\",[\"^ \",\"^T\",false,\"^X\",3,\"^U\",[\"^O\",[[\"~$c\"],[\"~$r\",\"~$g\",\"~$b\"]]],\"^N\",[\"^O\",[[\"~$c\"],[\"~$r\",\"~$g\",\"~$b\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"emissive()\",\"^J\",3,\"^K\",true,\"^L\",1594,\"^M\",1594,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$c\"],[\"~$r\",\"~$g\",\"~$b\"]]]]],\"^R\",\"Sets the emissive color of the material used for drawing shapes\\n  drawn to the screen. Used in combination with ambient, specular, and\\n  shininess in setting the material properties of shapes.\\n\\n  If passed one arg - it is assumed to be an int (i.e. a color),\\n  multiple args are converted to floats.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/emissive\",\"^T\",false,\"^E\",\"Material Properties\",\"^F\",\"quil/core.cljc\",\"^H\",11,\"^15\",[\"^ \",\"^T\",false,\"^X\",3,\"^U\",[\"^O\",[[\"~$c\"],[\"~$r\",\"~$g\",\"~$b\"]]],\"^N\",[\"^O\",[[\"~$c\"],[\"~$r\",\"~$g\",\"~$b\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"emissive()\",\"^U\",[\"^O\",[[\"~$c\"],[\"~$r\",\"~$g\",\"~$b\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",1588,\"^M\",1594,\"^X\",3,\"^Y\",true,\"^N\",[\"^O\",[[\"~$c\"],[\"~$r\",\"~$g\",\"~$b\"]]],\"^R\",\"Sets the emissive color of the material used for drawing shapes\\n  drawn to the screen. Used in combination with ambient, specular, and\\n  shininess in setting the material properties of shapes.\\n\\n  If passed one arg - it is assumed to be an int (i.e. a color),\\n  multiple args are converted to floats.\"],\"~$clear-no-fill-cljs\",[\"^ \",\"^B\",null,\"^C\",[\"^ \",\"^F\",\"^G\",\"^L\",1693,\"^J\",11,\"^M\",1693,\"^H\",29,\"^3L\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^1N\"]]]]],\"^R\",\"Sets custom property on graphcs object indicating that it has\\n  fill color.\"],\"^3L\",true,\"^5\",\"~$quil.core$macros/clear-no-fill-cljs\",\"^T\",false,\"^F\",\"quil/core.cljc\",\"^H\",29,\"^U\",[\"^O\",[[\"^1N\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",4,\"^L\",1693,\"^M\",1693,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^1N\"]]]]],\"^R\",\"Sets custom property on graphcs object indicating that it has\\n  fill color.\"],\"~$sketch\",[\"^ \",\"^A\",\"Environment\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Environment\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^G\",\"^H\",9,\"^15\",[\"^ \",\"^T\",true,\"^X\",0,\"^U\",[[\"^O\",[\"~$opts\"]]],\"^N\",[\"^O\",[[\"~$&\",\"^7H\"]]],\"^W\",[\"^O\",[null]]],\"^J\",3,\"^K\",false,\"^L\",4696,\"^M\",4696,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$&\",\"^7H\"]]]]],\"^R\",\"Create and start a new visualisation applet. Can be used to create\\n  new sketches programmatically. See documentation for 'defsketch' for\\n  list of available options.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/sketch\",\"^T\",true,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^H\",9,\"^15\",[\"^ \",\"^T\",true,\"^X\",0,\"^U\",[[\"^O\",[\"^7H\"]]],\"^N\",[\"^O\",[[\"~$&\",\"^7H\"]]],\"^W\",[\"^O\",[null]]],\"^U\",[[\"^O\",[\"^7H\"]]],\"^V\",null,\"^W\",[\"^O\",[null]],\"^J\",1,\"^K\",false,\"^L\",4692,\"^M\",4696,\"^X\",0,\"^Y\",true,\"^N\",[\"^O\",[[\"~$&\",\"^7H\"]]],\"^R\",\"Create and start a new visualisation applet. Can be used to create\\n  new sketches programmatically. See documentation for 'defsketch' for\\n  list of available options.\"],\"~$color\",[\"^ \",\"^A\",\"Color\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Color\",\"^D\",\"1.0\",\"^E\",\"Creating & Reading\",\"^F\",\"^G\",\"^H\",8,\"^15\",[\"^ \",\"^T\",false,\"^X\",4,\"^U\",[\"^O\",[[\"^2>\"],[\"^2>\",\"^2?\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^N\",[\"^O\",[[\"^2>\"],[\"^2>\",\"^2?\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^W\",[\"^O\",[null,null,null,null]]],\"^I\",\"color()\",\"^J\",3,\"^K\",true,\"^L\",1019,\"^M\",1019,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^2>\"],[\"^2>\",\"^2?\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]]]],\"^R\",\"Creates an integer representation of a color The parameters are\\n  interpreted as RGB or HSB values depending on the current\\n  color-mode. The default mode is RGB values from 0 to 255 and\\n  therefore, the function call (color 255 204 0) will return a bright\\n  yellow. Args are cast to floats.\\n\\n  r - red or hue value\\n  g - green or saturation value\\n  b - blue or brightness value\\n  a - alpha value\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/color\",\"^T\",false,\"^E\",\"Creating & Reading\",\"^F\",\"quil/core.cljc\",\"^H\",8,\"^15\",[\"^ \",\"^T\",false,\"^X\",4,\"^U\",[\"^O\",[[\"^2>\"],[\"^2>\",\"^2?\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^N\",[\"^O\",[[\"^2>\"],[\"^2>\",\"^2?\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^W\",[\"^O\",[null,null,null,null]]],\"^I\",\"color()\",\"^U\",[\"^O\",[[\"^2>\"],[\"^2>\",\"^2?\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null,null,null]],\"^J\",1,\"^K\",true,\"^L\",1013,\"^M\",1019,\"^X\",4,\"^Y\",true,\"^N\",[\"^O\",[[\"^2>\"],[\"^2>\",\"^2?\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^R\",\"Creates an integer representation of a color The parameters are\\n  interpreted as RGB or HSB values depending on the current\\n  color-mode. The default mode is RGB values from 0 to 255 and\\n  therefore, the function call (color 255 204 0) will return a bright\\n  yellow. Args are cast to floats.\\n\\n  r - red or hue value\\n  g - green or saturation value\\n  b - blue or brightness value\\n  a - alpha value\"],\"~$arc\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"2D Primitives\",\"^F\",\"^G\",\"^H\",6,\"^I\",\"arc()\",\"^J\",3,\"^K\",true,\"^L\",422,\"^M\",422,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$x\",\"~$y\",\"^1@\",\"^1A\",\"~$start\",\"~$stop\"]]]]],\"^R\",\"Draws an arc in the display window. Arcs are drawn along the outer\\n  edge of an ellipse defined by the x, y, width and height\\n  parameters. The origin or the arc's ellipse may be changed with the\\n  ellipse-mode function. The start and stop parameters specify the\\n  angles at which to draw the arc. The mode is either :open, :chord or :pie.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/arc\",\"^T\",false,\"^E\",\"2D Primitives\",\"^F\",\"quil/core.cljc\",\"^H\",6,\"^I\",\"arc()\",\"^U\",[\"^O\",[[\"~$x\",\"~$y\",\"^1@\",\"^1A\",\"^7M\",\"^7N\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",416,\"^M\",422,\"^X\",6,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$x\",\"~$y\",\"^1@\",\"^1A\",\"^7M\",\"^7N\"]]]]],\"^R\",\"Draws an arc in the display window. Arcs are drawn along the outer\\n  edge of an ellipse defined by the x, y, width and height\\n  parameters. The origin or the arc's ellipse may be changed with the\\n  ellipse-mode function. The start and stop parameters specify the\\n  angles at which to draw the arc. The mode is either :open, :chord or :pie.\"],\"~$text-align\",[\"^ \",\"^A\",\"Typography\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Typography\",\"^D\",\"1.0\",\"^E\",\"Attributes\",\"^F\",\"^G\",\"^H\",13,\"^15\",[\"^ \",\"^T\",false,\"^X\",2,\"^U\",[\"^O\",[[\"~$align\"],[\"~$align-x\",\"~$align-y\"]]],\"^N\",[\"^O\",[[\"^7Q\"],[\"^7R\",\"^7S\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"textAlign()\",\"^J\",3,\"^K\",true,\"^L\",4176,\"^M\",4176,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^7Q\"],[\"^7R\",\"^7S\"]]]]],\"^R\",\"Sets the current alignment for drawing text. Available modes are:\\n\\n  horizontal - :left, :center, and :right\\n  vertical   - :top, :bottom, :center, and :baseline\\n\\n  An optional second parameter specifies the vertical alignment\\n  mode. :baseline is the default. The :top and :center parameters are\\n  straightforward. The :bottom parameter offsets the line based on the\\n  current text-descent. For multiple lines, the final line will be\\n  aligned to the bottom, with the previous lines appearing above it.\\n\\n  When using text with width and height parameters, :baseline is\\n  ignored, and treated as :top. (Otherwise, text would by default draw\\n  outside the box, since :baseline is the default setting. :baseline is\\n  not a useful drawing mode for text drawn in a rectangle.)\\n\\n  The vertical alignment is based on the value of text-ascent, which\\n  many fonts do not specify correctly. It may be necessary to use a\\n  hack and offset by a few pixels by hand so that the offset looks\\n  correct. To do this as less of a hack, use some percentage of\\n  text-ascent or text-descent so that the hack works even if you\\n  change the size of the font.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/text-align\",\"^T\",false,\"^E\",\"Attributes\",\"^F\",\"quil/core.cljc\",\"^H\",13,\"^15\",[\"^ \",\"^T\",false,\"^X\",2,\"^U\",[\"^O\",[[\"^7Q\"],[\"^7R\",\"^7S\"]]],\"^N\",[\"^O\",[[\"^7Q\"],[\"^7R\",\"^7S\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"textAlign()\",\"^U\",[\"^O\",[[\"^7Q\"],[\"^7R\",\"^7S\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",4170,\"^M\",4176,\"^X\",2,\"^Y\",true,\"^N\",[\"^O\",[[\"^7Q\"],[\"^7R\",\"^7S\"]]],\"^R\",\"Sets the current alignment for drawing text. Available modes are:\\n\\n  horizontal - :left, :center, and :right\\n  vertical   - :top, :bottom, :center, and :baseline\\n\\n  An optional second parameter specifies the vertical alignment\\n  mode. :baseline is the default. The :top and :center parameters are\\n  straightforward. The :bottom parameter offsets the line based on the\\n  current text-descent. For multiple lines, the final line will be\\n  aligned to the bottom, with the previous lines appearing above it.\\n\\n  When using text with width and height parameters, :baseline is\\n  ignored, and treated as :top. (Otherwise, text would by default draw\\n  outside the box, since :baseline is the default setting. :baseline is\\n  not a useful drawing mode for text drawn in a rectangle.)\\n\\n  The vertical alignment is based on the value of text-ascent, which\\n  many fonts do not specify correctly. It may be necessary to use a\\n  hack and offset by a few pixels by hand so that the offset looks\\n  correct. To do this as less of a hack, use some percentage of\\n  text-ascent or text-descent so that the hack works even if you\\n  change the size of the font.\"],\"~$text-width\",[\"^ \",\"^A\",\"Typography\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Typography\",\"^D\",\"1.0\",\"^E\",\"Attributes\",\"^F\",\"^G\",\"^H\",13,\"^I\",\"textWidth()\",\"^J\",3,\"^K\",true,\"^L\",4374,\"^M\",4374,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$data\"]]]]],\"^R\",\"Calculates and returns the width of any text string.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/text-width\",\"^T\",false,\"^E\",\"Attributes\",\"^F\",\"quil/core.cljc\",\"^H\",13,\"^I\",\"textWidth()\",\"^U\",[\"^O\",[[\"^7V\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",4368,\"^M\",4374,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^7V\"]]]]],\"^R\",\"Calculates and returns the width of any text string.\"],\"~$mouse-x\",[\"^ \",\"^A\",\"Input\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Input\",\"^D\",\"1.0\",\"^E\",\"Mouse\",\"^F\",\"^G\",\"^H\",10,\"^I\",\"mouseX\",\"^J\",3,\"^K\",true,\"^L\",2618,\"^M\",2618,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Current horizontal coordinate of the mouse.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/mouse-x\",\"^T\",false,\"^E\",\"Mouse\",\"^F\",\"quil/core.cljc\",\"^H\",10,\"^I\",\"mouseX\",\"^U\",[\"^O\",[[]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",2612,\"^M\",2618,\"^X\",0,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Current horizontal coordinate of the mouse.\"],\"~$TWO-PI\",[\"^ \",\"^5\",\"~$quil.core$macros/TWO-PI\",\"^F\",\"quil/core.cljc\",\"^L\",80,\"^J\",1,\"^M\",80,\"^H\",12,\"^C\",[\"^ \",\"^F\",\"^G\",\"^L\",80,\"^J\",6,\"^M\",80,\"^H\",12]],\"~$mag\",[\"^ \",\"^A\",\"Math\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Math\",\"^D\",\"1.0\",\"^E\",\"Calculation\",\"^F\",\"^G\",\"^H\",6,\"^15\",[\"^ \",\"^T\",false,\"^X\",3,\"^U\",[\"^O\",[[\"~$a\",\"~$b\"],[\"~$a\",\"~$b\",\"~$c\"]]],\"^N\",[\"^O\",[[\"~$a\",\"~$b\"],[\"~$a\",\"~$b\",\"~$c\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"mag()\",\"^J\",3,\"^K\",false,\"^L\",2441,\"^M\",2441,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$a\",\"~$b\"],[\"~$a\",\"~$b\",\"~$c\"]]]]],\"^R\",\"Calculates the magnitude (or length) of a vector. A vector is a\\n  direction in space commonly used in computer graphics and linear\\n  algebra. Because it has no start position, the magnitude of a vector\\n  can be thought of as the distance from coordinate (0,0) to its (x,y)\\n  value. Therefore, mag is a shortcut for writing (dist 0 0 x y).\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/mag\",\"^T\",false,\"^E\",\"Calculation\",\"^F\",\"quil/core.cljc\",\"^H\",6,\"^15\",[\"^ \",\"^T\",false,\"^X\",3,\"^U\",[\"^O\",[[\"~$a\",\"~$b\"],[\"~$a\",\"~$b\",\"~$c\"]]],\"^N\",[\"^O\",[[\"~$a\",\"~$b\"],[\"~$a\",\"~$b\",\"~$c\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"mag()\",\"^U\",[\"^O\",[[\"~$a\",\"~$b\"],[\"~$a\",\"~$b\",\"~$c\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",false,\"^L\",2435,\"^M\",2441,\"^X\",3,\"^Y\",true,\"^N\",[\"^O\",[[\"~$a\",\"~$b\"],[\"~$a\",\"~$b\",\"~$c\"]]],\"^R\",\"Calculates the magnitude (or length) of a vector. A vector is a\\n  direction in space commonly used in computer graphics and linear\\n  algebra. Because it has no start position, the magnitude of a vector\\n  can be thought of as the distance from coordinate (0,0) to its (x,y)\\n  value. Therefore, mag is a shortcut for writing (dist 0 0 x y).\"],\"~$exit\",[\"^ \",\"^A\",\"Structure\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Structure\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^G\",\"^H\",7,\"^I\",\"exit()\",\"^J\",3,\"^K\",true,\"^L\",1671,\"^M\",1671,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Quits/stops/exits the program.  Rather than terminating\\n  immediately, exit will cause the sketch to exit after draw has\\n  completed (or after setup completes if called during the setup\\n  method). \"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/exit\",\"^T\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^H\",7,\"^I\",\"exit()\",\"^U\",[\"^O\",[[]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",1665,\"^M\",1671,\"^X\",0,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Quits/stops/exits the program.  Rather than terminating\\n  immediately, exit will cause the sketch to exit after draw has\\n  completed (or after setup completes if called during the setup\\n  method). \"],\"~$map-range\",[\"^ \",\"^A\",\"Math\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Math\",\"^D\",\"1.0\",\"^E\",\"Calculation\",\"^F\",\"^G\",\"^H\",12,\"^I\",\"map()\",\"^J\",3,\"^K\",false,\"^L\",2460,\"^M\",2460,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^2Q\",\"~$low1\",\"~$high1\",\"~$low2\",\"~$high2\"]]]]],\"^R\",\"Re-maps a number from one range to another.\\n\\n  Numbers outside the range are not clamped to 0 and 1, because\\n  out-of-range values are often intentional and useful.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/map-range\",\"^T\",false,\"^E\",\"Calculation\",\"^F\",\"quil/core.cljc\",\"^H\",12,\"^I\",\"map()\",\"^U\",[\"^O\",[[\"^2Q\",\"^85\",\"^86\",\"^87\",\"^88\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",false,\"^L\",2454,\"^M\",2460,\"^X\",5,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^2Q\",\"^85\",\"^86\",\"^87\",\"^88\"]]]]],\"^R\",\"Re-maps a number from one range to another.\\n\\n  Numbers outside the range are not clamped to 0 and 1, because\\n  out-of-range values are often intentional and useful.\"],\"~$model-x\",[\"^ \",\"^A\",\"Lights, Camera\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Lights, Camera\",\"^D\",\"1.0\",\"^E\",\"Coordinates\",\"^F\",\"^G\",\"^H\",10,\"^I\",\"modelX()\",\"^J\",3,\"^K\",true,\"^L\",2523,\"^M\",2523,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$x\",\"~$y\",\"~$z\"]]]]],\"^R\",\"Returns the three-dimensional x, y, z position in model space. This\\n  returns the x value for a given coordinate based on the current set\\n  of transformations (scale, rotate, translate, etc.) The x value can\\n  be used to place an object in space relative to the location of the\\n  original point once the transformations are no longer in use.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/model-x\",\"^T\",false,\"^E\",\"Coordinates\",\"^F\",\"quil/core.cljc\",\"^H\",10,\"^I\",\"modelX()\",\"^U\",[\"^O\",[[\"~$x\",\"~$y\",\"~$z\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",2517,\"^M\",2523,\"^X\",3,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$x\",\"~$y\",\"~$z\"]]]]],\"^R\",\"Returns the three-dimensional x, y, z position in model space. This\\n  returns the x value for a given coordinate based on the current set\\n  of transformations (scale, rotate, translate, etc.) The x value can\\n  be used to place an object in space relative to the location of the\\n  original point once the transformations are no longer in use.\"],\"~$sqrt\",[\"^ \",\"^A\",\"Math\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Math\",\"^D\",\"1.0\",\"^E\",\"Calculation\",\"^F\",\"^G\",\"^H\",7,\"^I\",\"sqrt()\",\"^J\",3,\"^K\",false,\"^L\",3961,\"^M\",3961,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$a\"]]]]],\"^R\",\"Calculates the square root of a number. The square root of a number\\n  is always positive, even though there may be a valid negative\\n  root. The square root s of number a is such that (= a (* s s)) . It\\n  is the opposite of squaring.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/sqrt\",\"^T\",false,\"^E\",\"Calculation\",\"^F\",\"quil/core.cljc\",\"^H\",7,\"^I\",\"sqrt()\",\"^U\",[\"^O\",[[\"~$a\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",false,\"^L\",3955,\"^M\",3961,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$a\"]]]]],\"^R\",\"Calculates the square root of a number. The square root of a number\\n  is always positive, even though there may be a valid negative\\n  root. The square root s of number a is such that (= a (* s s)) . It\\n  is the opposite of squaring.\"],\"~$saturation\",[\"^ \",\"^A\",\"Color\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Color\",\"^D\",\"1.0\",\"^E\",\"Creating & Reading\",\"^F\",\"^G\",\"^H\",13,\"^I\",\"saturation()\",\"^J\",3,\"^K\",true,\"^L\",3512,\"^M\",3512,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$c\"]]]]],\"^R\",\"Extracts the saturation value from a color.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/saturation\",\"^T\",false,\"^E\",\"Creating & Reading\",\"^F\",\"quil/core.cljc\",\"^H\",13,\"^I\",\"saturation()\",\"^U\",[\"^O\",[[\"~$c\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",3506,\"^M\",3512,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$c\"]]]]],\"^R\",\"Extracts the saturation value from a color.\"],\"~$prc-print\",[\"^ \",\"^A\",\"Output\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Output\",\"^D\",\"1.0\",\"^E\",\"Text area\",\"^F\",\"^G\",\"^H\",15,\"^J\",6,\"~:require-bindings\",true,\"^L\",170,\"^M\",170,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$msg\"]]]]],\"^R\",\"Writes to the console area of the Processing environment.\\n  This is often helpful for looking at the data a program is producing.\\n  The companion function println() works like print(), but creates a new line of text for each call to the function.\\n   Individual elements can be separated with quotes (\\\"\\\") and joined with the addition operator (+). \"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/prc-print\",\"^T\",false,\"^E\",\"Text area\",\"^F\",\"quil/core.cljc\",\"^H\",15,\"^U\",[\"^O\",[[\"^8B\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",4,\"^8A\",true,\"^L\",165,\"^M\",170,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^8B\"]]]]],\"^R\",\"Writes to the console area of the Processing environment.\\n  This is often helpful for looking at the data a program is producing.\\n  The companion function println() works like print(), but creates a new line of text for each call to the function.\\n   Individual elements can be separated with quotes (\\\"\\\") and joined with the addition operator (+). \"],\"~$text-font\",[\"^ \",\"^A\",\"Typography\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Typography\",\"^D\",\"1.0\",\"^E\",\"Loading & Displaying\",\"^F\",\"^G\",\"^H\",12,\"^15\",[\"^ \",\"^T\",false,\"^X\",2,\"^U\",[\"^O\",[[\"~$font\"],[\"^8E\",\"^29\"]]],\"^N\",[\"^O\",[[\"^8E\"],[\"^8E\",\"^29\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"textFont()\",\"^J\",3,\"^K\",true,\"^L\",4241,\"^M\",4241,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^8E\"],[\"^8E\",\"^29\"]]]]],\"^R\",\"Sets the current font that will be drawn with the text\\n  function. Fonts must be loaded with load-font before it can be\\n  used. This font will be used in all subsequent calls to the text\\n  function. If no size parameter is input, the font will appear at its\\n  original size until it is changed with text-size.\\n\\n  Because fonts are usually bitmaped, you should create fonts at the\\n  sizes that will be used most commonly. Using textFont without the\\n  size parameter will result in the cleanest-looking text.\\n\\n  With the default (JAVA2D) and PDF renderers, it's also possible to\\n  enable the use of native fonts via the command\\n  (hint :enable-native-fonts). This will produce vector text in JAVA2D\\n  sketches and PDF output in cases where the vector data is available:\\n  when the font is still installed, or the font is created via the\\n  create-font fn\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/text-font\",\"^T\",false,\"^E\",\"Loading & Displaying\",\"^F\",\"quil/core.cljc\",\"^H\",12,\"^15\",[\"^ \",\"^T\",false,\"^X\",2,\"^U\",[\"^O\",[[\"^8E\"],[\"^8E\",\"^29\"]]],\"^N\",[\"^O\",[[\"^8E\"],[\"^8E\",\"^29\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"textFont()\",\"^U\",[\"^O\",[[\"^8E\"],[\"^8E\",\"^29\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",4235,\"^M\",4241,\"^X\",2,\"^Y\",true,\"^N\",[\"^O\",[[\"^8E\"],[\"^8E\",\"^29\"]]],\"^R\",\"Sets the current font that will be drawn with the text\\n  function. Fonts must be loaded with load-font before it can be\\n  used. This font will be used in all subsequent calls to the text\\n  function. If no size parameter is input, the font will appear at its\\n  original size until it is changed with text-size.\\n\\n  Because fonts are usually bitmaped, you should create fonts at the\\n  sizes that will be used most commonly. Using textFont without the\\n  size parameter will result in the cleanest-looking text.\\n\\n  With the default (JAVA2D) and PDF renderers, it's also possible to\\n  enable the use of native fonts via the command\\n  (hint :enable-native-fonts). This will produce vector text in JAVA2D\\n  sketches and PDF output in cases where the vector data is available:\\n  when the font is still installed, or the font is created via the\\n  create-font fn\"],\"~$scale\",[\"^ \",\"^A\",\"Transform\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Transform\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^G\",\"^H\",8,\"^15\",[\"^ \",\"^T\",false,\"^X\",3,\"^U\",[\"^O\",[[\"~$s\"],[\"^6Y\",\"^6Z\"],[\"^6Y\",\"^6Z\",\"~$sz\"]]],\"^N\",[\"^O\",[[\"~$s\"],[\"^6Y\",\"^6Z\"],[\"^6Y\",\"^6Z\",\"^8H\"]]],\"^W\",[\"^O\",[null,null,null]]],\"^I\",\"scale()\",\"^J\",3,\"^K\",true,\"^L\",3561,\"^M\",3561,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$s\"],[\"^6Y\",\"^6Z\"],[\"^6Y\",\"^6Z\",\"^8H\"]]]]],\"^R\",\"Increases or decreases the size of a shape by expanding and\\n  contracting vertices. Objects always scale from their relative\\n  origin to the coordinate system. Scale values are specified as\\n  decimal percentages. For example, the function call (scale 2)\\n  increases the dimension of a shape by 200%. Transformations apply to\\n  everything that happens after and subsequent calls to the function\\n  multiply the effect. For example, calling (scale 2) and then\\n  (scale 1.5) is the same as (scale 3). If scale is called within\\n  draw, the transformation is reset when the loop begins again. Using\\n  this fuction with the z parameter requires specfying :p3d or :opengl\\n  as the renderer. This function can be further controlled by\\n  push-matrix and pop-matrix.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/scale\",\"^T\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^H\",8,\"^15\",[\"^ \",\"^T\",false,\"^X\",3,\"^U\",[\"^O\",[[\"~$s\"],[\"^6Y\",\"^6Z\"],[\"^6Y\",\"^6Z\",\"^8H\"]]],\"^N\",[\"^O\",[[\"~$s\"],[\"^6Y\",\"^6Z\"],[\"^6Y\",\"^6Z\",\"^8H\"]]],\"^W\",[\"^O\",[null,null,null]]],\"^I\",\"scale()\",\"^U\",[\"^O\",[[\"~$s\"],[\"^6Y\",\"^6Z\"],[\"^6Y\",\"^6Z\",\"^8H\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null,null]],\"^J\",1,\"^K\",true,\"^L\",3555,\"^M\",3561,\"^X\",3,\"^Y\",true,\"^N\",[\"^O\",[[\"~$s\"],[\"^6Y\",\"^6Z\"],[\"^6Y\",\"^6Z\",\"^8H\"]]],\"^R\",\"Increases or decreases the size of a shape by expanding and\\n  contracting vertices. Objects always scale from their relative\\n  origin to the coordinate system. Scale values are specified as\\n  decimal percentages. For example, the function call (scale 2)\\n  increases the dimension of a shape by 200%. Transformations apply to\\n  everything that happens after and subsequent calls to the function\\n  multiply the effect. For example, calling (scale 2) and then\\n  (scale 1.5) is the same as (scale 3). If scale is called within\\n  draw, the transformation is reset when the loop begins again. Using\\n  this fuction with the z parameter requires specfying :p3d or :opengl\\n  as the renderer. This function can be further controlled by\\n  push-matrix and pop-matrix.\"],\"~$defsketch\",[\"^ \",\"^A\",\"Environment\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Environment\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^G\",\"^H\",13,\"^15\",[\"^ \",\"^T\",true,\"^X\",3,\"^U\",[[\"^O\",[\"^1L\",\"^1M\",\"~$app-name\",\"~$options\"]]],\"^N\",[\"^O\",[[\"^1L\",\"^1M\",\"^8K\",\"~$&\",\"^8L\"]]],\"^W\",[\"^O\",[null]]],\"^J\",4,\"^K\",false,\"^L\",4708,\"^1P\",true,\"^M\",4708,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^8K\",\"~$&\",\"^8L\"]]]]],\"^R\",\"Define and start a sketch and bind it to a var with the symbol\\n  app-name. If any of the options to the various callbacks are\\n  symbols, it wraps them in a call to var to ensure they aren't\\n  inlined and that redefinitions to the original fns are reflected in\\n  the visualisation.\\n\\n  Available options:\\n\\n   :size           - A vector of width and height for the sketch or :fullscreen.\\n                     Defaults to [500 300]. If you're using :fullscreen you may\\n                     want to enable present mode - :features [:present]\\n\\n   :renderer       - Specifies the renderer type. One of :p2d, :p3d, :java2d,\\n                     :opengl, :pdf). Defaults to :java2d. :dxf renderer\\n                     can't be used as sketch renderer. Use begin-raw method\\n                     instead. In clojurescript only :p2d and :p3d renderers\\n                     are supported.\\n\\n   :output-file    - Specifies an output file path. Only used in :pdf mode.\\n                     Not supported in clojurescript.\\n\\n   :title          - A string which will be displayed at the top of\\n                     the sketch window. Not supported in clojurescript.\\n\\n   :features       - A vector of keywords customizing sketch behaviour.\\n                     Supported features:\\n\\n                     :keep-on-top - Sketch window will always be above other\\n                                    windows. Note: some platforms might not\\n                                    support always-on-top windows.\\n                                    Not supported in clojurescript.\\n\\n                     :exit-on-close - Shutdown JVM  when sketch is closed.\\n                                      Not supported in clojurescript.\\n\\n                     :resizable - Makes sketch resizable.\\n                                  Not supported in clojurescript.\\n\\n                     :no-safe-fns - Do not catch and print exceptions thrown\\n                                    inside functions provided to sketch (like\\n                                    draw, mouse-click, key-pressed and\\n                                    other). By default all exceptions thrown\\n                                    inside these functions are catched. This\\n                                    prevents sketch from breaking when bad\\n                                    function was provided and allows you to\\n                                    fix it and reload it on fly. You can\\n                                    disable this behaviour by enabling\\n                                    :no-safe-fns feature.\\n                                    Not supported in clojurescript.\\n\\n                     :present - Switch to present mode (fullscreen without\\n                                borders, OS panels). You may want to use\\n                                this feature together with :size :fullscreen.\\n                                Not supported in clojurescript.\\n\\n                     :no-start - Disables autostart if sketch was created using\\n                                 defsketch macro. To start sketch you have to\\n                                 call function created defsketch.\\n                                 Supported only in clojurescript.\\n\\n                     :global-key-events - Allows a sketch to receive any\\n                                          keyboard event sent to the page,\\n                                          regardless of whether the canvas it is\\n                                          loaded in has focus or not.\\n                                          Supported only in clojurescript.\\n\\n                     Usage example: :features [:keep-on-top :present]\\n\\n   :bgcolor        - Sets background color for unused space in present mode.\\n                     Color is specified in hex format: #XXXXXX.\\n                     Example: :bgcolor \\\"#00FFFF\\\" (cyan background)\\n                     Not supported in clojurescript.\\n\\n   :display        - Sets what display should be used by this sketch.\\n                     Displays are numbered starting from 0. Example: :display 1.\\n                     Not supported in clojurescript.\\n\\n   :setup          - A function to be called once when setting the sketch up.\\n\\n   :draw           - A function to be repeatedly called at most n times per\\n                     second where n is the target frame-rate set for\\n                     the visualisation.\\n\\n   :host           - String id of canvas element or DOM element itself.\\n                     Specifies host for the sketch. Must be specified in sketch,\\n                     may be omitted in defsketch. If ommitted in defsketch,\\n                     :host is set to the name of the sketch. If element with\\n                     specified id is not found on the page and page is empty -\\n                     new canvas element will be created. Used in clojurescript.\\n\\n   :focus-gained   - Called when the sketch gains focus.\\n                     Not supported in clojurescript.\\n\\n   :focus-lost     - Called when the sketch loses focus.\\n                     Not supported in clojurescript.\\n\\n   :mouse-entered  - Called when the mouse enters the sketch window.\\n\\n   :mouse-exited   - Called when the mouse leaves the sketch window\\n\\n   :mouse-pressed  - Called every time a mouse button is pressed.\\n\\n   :mouse-released - Called every time a mouse button is released.\\n\\n   :mouse-clicked  - called once after a mouse button has been pressed\\n                     and then released.\\n\\n   :mouse-moved    - Called every time the mouse moves and a button is\\n                     not pressed.\\n\\n   :mouse-dragged  - Called every time the mouse moves and a button is\\n                     pressed.\\n\\n   :mouse-wheel    - Called every time mouse wheel is rotated.\\n                     Takes 1 argument - wheel rotation, an int.\\n                     Negative values if the mouse wheel was rotated\\n                     up/away from the user, and positive values\\n                     if the mouse wheel was rotated down/ towards the user\\n\\n   :key-pressed    - Called every time any key is pressed.\\n\\n   :key-released   - Called every time any key is released.\\n\\n   :key-typed      - Called once every time non-modifier keys are\\n                     pressed.\\n\\n   :on-close       - Called once, when sketch is closed\\n                     Not supported in clojurescript.\\n\\n   :middleware     - Vector of middleware to be applied to the sketch.\\n                     Middleware will be applied in the same order as in comp\\n                     function: [f g] will be applied as (f (g options)).\\n\\n   :settings       - cousin of :setup. A function to be called once when\\n                     setting sketch up. Should be used only for (smooth) and\\n                     (no-smooth). Due to Processing limitations these functions\\n                     cannot be used neither in :setup nor in :draw.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/defsketch\",\"^T\",true,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^H\",13,\"^15\",[\"^ \",\"^T\",true,\"^X\",3,\"^U\",[[\"^O\",[\"^1L\",\"^1M\",\"^8K\",\"^8L\"]]],\"^N\",[\"^O\",[[\"^1L\",\"^1M\",\"^8K\",\"~$&\",\"^8L\"]]],\"^W\",[\"^O\",[null]]],\"^U\",[[\"^O\",[\"^1L\",\"^1M\",\"^8K\",\"^8L\"]]],\"^V\",null,\"^W\",[\"^O\",[null]],\"^J\",1,\"^K\",false,\"^L\",4704,\"^1P\",true,\"^M\",4708,\"^X\",3,\"^Y\",false,\"^N\",[\"^O\",[[\"^1L\",\"^1M\",\"^8K\",\"~$&\",\"^8L\"]]],\"^R\",\"Define and start a sketch and bind it to a var with the symbol\\n  app-name. If any of the options to the various callbacks are\\n  symbols, it wraps them in a call to var to ensure they aren't\\n  inlined and that redefinitions to the original fns are reflected in\\n  the visualisation.\\n\\n  Available options:\\n\\n   :size           - A vector of width and height for the sketch or :fullscreen.\\n                     Defaults to [500 300]. If you're using :fullscreen you may\\n                     want to enable present mode - :features [:present]\\n\\n   :renderer       - Specifies the renderer type. One of :p2d, :p3d, :java2d,\\n                     :opengl, :pdf). Defaults to :java2d. :dxf renderer\\n                     can't be used as sketch renderer. Use begin-raw method\\n                     instead. In clojurescript only :p2d and :p3d renderers\\n                     are supported.\\n\\n   :output-file    - Specifies an output file path. Only used in :pdf mode.\\n                     Not supported in clojurescript.\\n\\n   :title          - A string which will be displayed at the top of\\n                     the sketch window. Not supported in clojurescript.\\n\\n   :features       - A vector of keywords customizing sketch behaviour.\\n                     Supported features:\\n\\n                     :keep-on-top - Sketch window will always be above other\\n                                    windows. Note: some platforms might not\\n                                    support always-on-top windows.\\n                                    Not supported in clojurescript.\\n\\n                     :exit-on-close - Shutdown JVM  when sketch is closed.\\n                                      Not supported in clojurescript.\\n\\n                     :resizable - Makes sketch resizable.\\n                                  Not supported in clojurescript.\\n\\n                     :no-safe-fns - Do not catch and print exceptions thrown\\n                                    inside functions provided to sketch (like\\n                                    draw, mouse-click, key-pressed and\\n                                    other). By default all exceptions thrown\\n                                    inside these functions are catched. This\\n                                    prevents sketch from breaking when bad\\n                                    function was provided and allows you to\\n                                    fix it and reload it on fly. You can\\n                                    disable this behaviour by enabling\\n                                    :no-safe-fns feature.\\n                                    Not supported in clojurescript.\\n\\n                     :present - Switch to present mode (fullscreen without\\n                                borders, OS panels). You may want to use\\n                                this feature together with :size :fullscreen.\\n                                Not supported in clojurescript.\\n\\n                     :no-start - Disables autostart if sketch was created using\\n                                 defsketch macro. To start sketch you have to\\n                                 call function created defsketch.\\n                                 Supported only in clojurescript.\\n\\n                     :global-key-events - Allows a sketch to receive any\\n                                          keyboard event sent to the page,\\n                                          regardless of whether the canvas it is\\n                                          loaded in has focus or not.\\n                                          Supported only in clojurescript.\\n\\n                     Usage example: :features [:keep-on-top :present]\\n\\n   :bgcolor        - Sets background color for unused space in present mode.\\n                     Color is specified in hex format: #XXXXXX.\\n                     Example: :bgcolor \\\"#00FFFF\\\" (cyan background)\\n                     Not supported in clojurescript.\\n\\n   :display        - Sets what display should be used by this sketch.\\n                     Displays are numbered starting from 0. Example: :display 1.\\n                     Not supported in clojurescript.\\n\\n   :setup          - A function to be called once when setting the sketch up.\\n\\n   :draw           - A function to be repeatedly called at most n times per\\n                     second where n is the target frame-rate set for\\n                     the visualisation.\\n\\n   :host           - String id of canvas element or DOM element itself.\\n                     Specifies host for the sketch. Must be specified in sketch,\\n                     may be omitted in defsketch. If ommitted in defsketch,\\n                     :host is set to the name of the sketch. If element with\\n                     specified id is not found on the page and page is empty -\\n                     new canvas element will be created. Used in clojurescript.\\n\\n   :focus-gained   - Called when the sketch gains focus.\\n                     Not supported in clojurescript.\\n\\n   :focus-lost     - Called when the sketch loses focus.\\n                     Not supported in clojurescript.\\n\\n   :mouse-entered  - Called when the mouse enters the sketch window.\\n\\n   :mouse-exited   - Called when the mouse leaves the sketch window\\n\\n   :mouse-pressed  - Called every time a mouse button is pressed.\\n\\n   :mouse-released - Called every time a mouse button is released.\\n\\n   :mouse-clicked  - called once after a mouse button has been pressed\\n                     and then released.\\n\\n   :mouse-moved    - Called every time the mouse moves and a button is\\n                     not pressed.\\n\\n   :mouse-dragged  - Called every time the mouse moves and a button is\\n                     pressed.\\n\\n   :mouse-wheel    - Called every time mouse wheel is rotated.\\n                     Takes 1 argument - wheel rotation, an int.\\n                     Negative values if the mouse wheel was rotated\\n                     up/away from the user, and positive values\\n                     if the mouse wheel was rotated down/ towards the user\\n\\n   :key-pressed    - Called every time any key is pressed.\\n\\n   :key-released   - Called every time any key is released.\\n\\n   :key-typed      - Called once every time non-modifier keys are\\n                     pressed.\\n\\n   :on-close       - Called once, when sketch is closed\\n                     Not supported in clojurescript.\\n\\n   :middleware     - Vector of middleware to be applied to the sketch.\\n                     Middleware will be applied in the same order as in comp\\n                     function: [f g] will be applied as (f (g options)).\\n\\n   :settings       - cousin of :setup. A function to be called once when\\n                     setting sketch up. Should be used only for (smooth) and\\n                     (no-smooth). Due to Processing limitations these functions\\n                     cannot be used neither in :setup nor in :draw.\"],\"~$no-stroke\",[\"^ \",\"^A\",\"Color\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Color\",\"^D\",\"1.0\",\"^E\",\"Setting\",\"^F\",\"^G\",\"^H\",12,\"^I\",\"noStroke()\",\"^J\",3,\"^K\",true,\"^L\",2836,\"^M\",2836,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Disables drawing the stroke (outline). If both no-stroke and\\n  no-fill are called, nothing will be drawn to the screen.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/no-stroke\",\"^T\",false,\"^E\",\"Setting\",\"^F\",\"quil/core.cljc\",\"^H\",12,\"^I\",\"noStroke()\",\"^U\",[\"^O\",[[]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",2830,\"^M\",2836,\"^X\",0,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Disables drawing the stroke (outline). If both no-stroke and\\n  no-fill are called, nothing will be drawn to the screen.\"],\"~$end-camera\",[\"^ \",\"^A\",\"Lights, Camera\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Lights, Camera\",\"^D\",\"1.0\",\"^E\",\"Camera\",\"^F\",\"^G\",\"^H\",13,\"^I\",\"endCamera()\",\"^J\",3,\"^K\",true,\"^L\",1612,\"^M\",1612,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Unsets the matrix mode from the camera matrix. See begin-camera.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/end-camera\",\"^T\",false,\"^E\",\"Camera\",\"^F\",\"quil/core.cljc\",\"^H\",13,\"^I\",\"endCamera()\",\"^U\",[\"^O\",[[]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",1606,\"^M\",1612,\"^X\",0,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Unsets the matrix mode from the camera matrix. See begin-camera.\"],\"~$random-seed\",[\"^ \",\"^A\",\"Math\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Math\",\"^D\",\"1.0\",\"^E\",\"Random\",\"^F\",\"^G\",\"^H\",14,\"^I\",\"randomSeed()\",\"^J\",3,\"^K\",true,\"^L\",3215,\"^M\",3215,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$w\"]]]]],\"^R\",\"Sets the seed value for random. By default, random produces\\n  different results each time the program is run. Set the value\\n  parameter to a constant to return the same pseudo-random numbers\\n  each time the software is run.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/random-seed\",\"^T\",false,\"^E\",\"Random\",\"^F\",\"quil/core.cljc\",\"^H\",14,\"^I\",\"randomSeed()\",\"^U\",[\"^O\",[[\"~$w\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",3209,\"^M\",3215,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$w\"]]]]],\"^R\",\"Sets the seed value for random. By default, random produces\\n  different results each time the program is run. Set the value\\n  parameter to a constant to return the same pseudo-random numbers\\n  each time the software is run.\"],\"~$model-z\",[\"^ \",\"^A\",\"Lights, Camera\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Lights, Camera\",\"^D\",\"1.0\",\"^E\",\"Coordinates\",\"^F\",\"^G\",\"^H\",10,\"^I\",\"modelZ()\",\"^J\",3,\"^K\",true,\"^L\",2553,\"^M\",2553,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$x\",\"~$y\",\"~$z\"]]]]],\"^R\",\"Returns the three-dimensional x, y, z position in model space. This\\n  returns the z value for a given coordinate based on the current set\\n  of transformations (scale, rotate, translate, etc.) The z value can\\n  be used to place an object in space relative to the location of the\\n  original point once the transformations are no longer in use.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/model-z\",\"^T\",false,\"^E\",\"Coordinates\",\"^F\",\"quil/core.cljc\",\"^H\",10,\"^I\",\"modelZ()\",\"^U\",[\"^O\",[[\"~$x\",\"~$y\",\"~$z\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",2547,\"^M\",2553,\"^X\",3,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$x\",\"~$y\",\"~$z\"]]]]],\"^R\",\"Returns the three-dimensional x, y, z position in model space. This\\n  returns the z value for a given coordinate based on the current set\\n  of transformations (scale, rotate, translate, etc.) The z value can\\n  be used to place an object in space relative to the location of the\\n  original point once the transformations are no longer in use.\"],\"~$light-specular\",[\"^ \",\"^A\",\"Lights, Camera\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Lights, Camera\",\"^D\",\"1.0\",\"^E\",\"Lights\",\"^F\",\"^G\",\"^H\",17,\"^I\",\"lightSpecular()\",\"^J\",3,\"^K\",true,\"^L\",2306,\"^M\",2306,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$r\",\"~$g\",\"~$b\"]]]]],\"^R\",\"Sets the specular color for lights. Like fill, it affects only the\\n  elements which are created after it in the code. Specular refers to\\n  light which bounces off a surface in a perferred direction (rather\\n  than bouncing in all directions like a diffuse light) and is used\\n  for creating highlights. The specular quality of a light interacts\\n  with the specular material qualities set through the specular and\\n  shininess functions.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/light-specular\",\"^T\",false,\"^E\",\"Lights\",\"^F\",\"quil/core.cljc\",\"^H\",17,\"^I\",\"lightSpecular()\",\"^U\",[\"^O\",[[\"~$r\",\"~$g\",\"~$b\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",2300,\"^M\",2306,\"^X\",3,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$r\",\"~$g\",\"~$b\"]]]]],\"^R\",\"Sets the specular color for lights. Like fill, it affects only the\\n  elements which are created after it in the code. Specular refers to\\n  light which bounces off a surface in a perferred direction (rather\\n  than bouncing in all directions like a diffuse light) and is used\\n  for creating highlights. The specular quality of a light interacts\\n  with the specular material qualities set through the specular and\\n  shininess functions.\"],\"~$key-as-keyword\",[\"^ \",\"^A\",\"Input\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Input\",\"^D\",\"1.6\",\"^E\",\"Keyboard\",\"^F\",\"^G\",\"^H\",17,\"^I\",null,\"^J\",3,\"^K\",true,\"^L\",4873,\"^M\",4873,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Returns a keyword representing the currently pressed key. Modifier\\n  keys are represented as: :up, :down, :left, :right, :alt, :control,\\n  :shift, :command, :f1-24\"],\"^D\",\"1.6\",\"^5\",\"~$quil.core$macros/key-as-keyword\",\"^T\",false,\"^E\",\"Keyboard\",\"^F\",\"quil/core.cljc\",\"^H\",17,\"^I\",null,\"^U\",[\"^O\",[[]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",4868,\"^M\",4873,\"^X\",0,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Returns a keyword representing the currently pressed key. Modifier\\n  keys are represented as: :up, :down, :left, :right, :alt, :control,\\n  :shift, :command, :f1-24\"],\"~$dist\",[\"^ \",\"^A\",\"Math\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Math\",\"^D\",\"1.0\",\"^E\",\"Calculation\",\"^F\",\"^G\",\"^H\",7,\"^15\",[\"^ \",\"^T\",false,\"^X\",6,\"^U\",[\"^O\",[[\"^44\",\"^45\",\"^46\",\"^47\"],[\"^44\",\"^45\",\"^57\",\"^46\",\"^47\",\"^5:\"]]],\"^N\",[\"^O\",[[\"^44\",\"^45\",\"^46\",\"^47\"],[\"^44\",\"^45\",\"^57\",\"^46\",\"^47\",\"^5:\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"dist()\",\"^J\",3,\"^K\",false,\"^L\",1495,\"^M\",1495,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^44\",\"^45\",\"^46\",\"^47\"],[\"^44\",\"^45\",\"^57\",\"^46\",\"^47\",\"^5:\"]]]]],\"^R\",\"Calculates the distance between two points\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/dist\",\"^T\",false,\"^E\",\"Calculation\",\"^F\",\"quil/core.cljc\",\"^H\",7,\"^15\",[\"^ \",\"^T\",false,\"^X\",6,\"^U\",[\"^O\",[[\"^44\",\"^45\",\"^46\",\"^47\"],[\"^44\",\"^45\",\"^57\",\"^46\",\"^47\",\"^5:\"]]],\"^N\",[\"^O\",[[\"^44\",\"^45\",\"^46\",\"^47\"],[\"^44\",\"^45\",\"^57\",\"^46\",\"^47\",\"^5:\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"dist()\",\"^U\",[\"^O\",[[\"^44\",\"^45\",\"^46\",\"^47\"],[\"^44\",\"^45\",\"^57\",\"^46\",\"^47\",\"^5:\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",false,\"^L\",1489,\"^M\",1495,\"^X\",6,\"^Y\",true,\"^N\",[\"^O\",[[\"^44\",\"^45\",\"^46\",\"^47\"],[\"^44\",\"^45\",\"^57\",\"^46\",\"^47\",\"^5:\"]]],\"^R\",\"Calculates the distance between two points\"],\"~$PI\",[\"^ \",\"^5\",\"~$quil.core$macros/PI\",\"^F\",\"quil/core.cljc\",\"^L\",76,\"^J\",10,\"^M\",76,\"^H\",17,\"^C\",[\"^ \",\"^F\",\"^G\",\"^L\",76,\"^J\",15,\"^M\",76,\"^H\",17]],\"~$norm\",[\"^ \",\"^A\",\"Math\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Math\",\"^D\",\"1.0\",\"^E\",\"Calculation\",\"^F\",\"^G\",\"^H\",7,\"^I\",\"norm()\",\"^J\",3,\"^K\",true,\"^L\",2797,\"^M\",2797,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^2Q\",\"^7M\",\"^7N\"]]]]],\"^R\",\"Normalize a value to exist between 0 and 1 (inclusive).\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/norm\",\"^T\",false,\"^E\",\"Calculation\",\"^F\",\"quil/core.cljc\",\"^H\",7,\"^I\",\"norm()\",\"^U\",[\"^O\",[[\"^2Q\",\"^7M\",\"^7N\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",2791,\"^M\",2797,\"^X\",3,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^2Q\",\"^7M\",\"^7N\"]]]]],\"^R\",\"Normalize a value to exist between 0 and 1 (inclusive).\"],\"~$end-shape\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"Vertex\",\"^F\",\"^G\",\"^H\",12,\"^15\",[\"^ \",\"^T\",false,\"^X\",1,\"^U\",[\"^O\",[[],[\"^18\"]]],\"^N\",[\"^O\",[[],[\"^18\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"endShape()\",\"^J\",3,\"^K\",true,\"^L\",1651,\"^M\",1651,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[],[\"^18\"]]]]],\"^R\",\"May only be called after begin-shape. When end-shape is called,\\n  all of image data defined since the previous call to begin-shape is\\n  written into the image buffer. The keyword :close may be passed to\\n  close the shape (to connect the beginning and the end).\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/end-shape\",\"^T\",false,\"^E\",\"Vertex\",\"^F\",\"quil/core.cljc\",\"^H\",12,\"^15\",[\"^ \",\"^T\",false,\"^X\",1,\"^U\",[\"^O\",[[],[\"^18\"]]],\"^N\",[\"^O\",[[],[\"^18\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"endShape()\",\"^U\",[\"^O\",[[],[\"^18\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",1645,\"^M\",1651,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[[],[\"^18\"]]],\"^R\",\"May only be called after begin-shape. When end-shape is called,\\n  all of image data defined since the previous call to begin-shape is\\n  written into the image buffer. The keyword :close may be passed to\\n  close the shape (to connect the beginning and the end).\"],\"~$fill\",[\"^ \",\"^A\",\"Color\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Color\",\"^D\",\"1.0\",\"^E\",\"Setting\",\"^F\",\"^G\",\"^H\",7,\"^15\",[\"^ \",\"^T\",false,\"^X\",4,\"^U\",[\"^O\",[[\"^3:\"],[\"^3:\",\"^2?\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^N\",[\"^O\",[[\"^3:\"],[\"^3:\",\"^2?\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^W\",[\"^O\",[null,null,null,null]]],\"^I\",\"fill()\",\"^J\",3,\"^K\",true,\"^L\",1742,\"^M\",1742,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^3:\"],[\"^3:\",\"^2?\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]]]],\"^R\",\"Sets the color used to fill shapes.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/fill\",\"^T\",false,\"^E\",\"Setting\",\"^F\",\"quil/core.cljc\",\"^H\",7,\"^15\",[\"^ \",\"^T\",false,\"^X\",4,\"^U\",[\"^O\",[[\"^3:\"],[\"^3:\",\"^2?\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^N\",[\"^O\",[[\"^3:\"],[\"^3:\",\"^2?\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^W\",[\"^O\",[null,null,null,null]]],\"^I\",\"fill()\",\"^U\",[\"^O\",[[\"^3:\"],[\"^3:\",\"^2?\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null,null,null]],\"^J\",1,\"^K\",true,\"^L\",1736,\"^M\",1742,\"^X\",4,\"^Y\",true,\"^N\",[\"^O\",[[\"^3:\"],[\"^3:\",\"^2?\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^R\",\"Sets the color used to fill shapes.\"],\"~$with-translation\",[\"^ \",\"^A\",\"Transform\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Transform\",\"^D\",\"1.0\",\"^E\",\"Utility Macros\",\"^F\",\"^G\",\"^H\",19,\"^15\",[\"^ \",\"^T\",true,\"^X\",3,\"^U\",[[\"^O\",[\"^1L\",\"^1M\",\"~$translation-vector\",\"^1O\"]]],\"^N\",[\"^O\",[[\"^1L\",\"^1M\",\"^99\",\"~$&\",\"^1O\"]]],\"^W\",[\"^O\",[null]]],\"^I\",null,\"^J\",3,\"^K\",true,\"^L\",4642,\"^1P\",true,\"^M\",4642,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^99\",\"~$&\",\"^1O\"]]]]],\"^R\",\"Performs body with translation, restores current transformation on\\n  exit.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/with-translation\",\"^T\",true,\"^E\",\"Utility Macros\",\"^F\",\"quil/core.cljc\",\"^H\",19,\"^15\",[\"^ \",\"^T\",true,\"^X\",3,\"^U\",[[\"^O\",[\"^1L\",\"^1M\",\"^99\",\"^1O\"]]],\"^N\",[\"^O\",[[\"^1L\",\"^1M\",\"^99\",\"~$&\",\"^1O\"]]],\"^W\",[\"^O\",[null]]],\"^I\",null,\"^U\",[[\"^O\",[\"^1L\",\"^1M\",\"^99\",\"^1O\"]]],\"^V\",null,\"^W\",[\"^O\",[null]],\"^J\",1,\"^K\",true,\"^L\",4636,\"^1P\",true,\"^M\",4642,\"^X\",3,\"^Y\",false,\"^N\",[\"^O\",[[\"^1L\",\"^1M\",\"^99\",\"~$&\",\"^1O\"]]],\"^R\",\"Performs body with translation, restores current transformation on\\n  exit.\"],\"~$reset-matrix\",[\"^ \",\"^A\",\"Transform\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Transform\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^G\",\"^H\",15,\"^I\",\"resetMatrix()\",\"^J\",3,\"^K\",true,\"^L\",3355,\"^M\",3355,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Replaces the current matrix with the identity matrix. The\\n  equivalent function in OpenGL is glLoadIdentity()\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/reset-matrix\",\"^T\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^H\",15,\"^I\",\"resetMatrix()\",\"^U\",[\"^O\",[[]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",3349,\"^M\",3355,\"^X\",0,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Replaces the current matrix with the identity matrix. The\\n  equivalent function in OpenGL is glLoadIdentity()\"],\"~$emissive-float\",[\"^ \",\"^A\",\"Lights, Camera\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Lights, Camera\",\"^D\",\"1.0\",\"^E\",\"Material Properties\",\"^F\",\"^G\",\"^H\",17,\"^15\",[\"^ \",\"^T\",false,\"^X\",3,\"^U\",[\"^O\",[[\"~$float-val\"],[\"~$r\",\"~$g\",\"~$b\"]]],\"^N\",[\"^O\",[[\"^9>\"],[\"~$r\",\"~$g\",\"~$b\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"emissive()\",\"^J\",3,\"^K\",true,\"^L\",1566,\"^M\",1566,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^9>\"],[\"~$r\",\"~$g\",\"~$b\"]]]]],\"^R\",\"Sets the emissive color of the material used for drawing shapes\\n drawn to the screen. Used in combination with ambient, specular, and\\n shininess in setting the material properties of shapes. Converts all\\n args to floats\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/emissive-float\",\"^T\",false,\"^E\",\"Material Properties\",\"^F\",\"quil/core.cljc\",\"^H\",17,\"^15\",[\"^ \",\"^T\",false,\"^X\",3,\"^U\",[\"^O\",[[\"^9>\"],[\"~$r\",\"~$g\",\"~$b\"]]],\"^N\",[\"^O\",[[\"^9>\"],[\"~$r\",\"~$g\",\"~$b\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"emissive()\",\"^U\",[\"^O\",[[\"^9>\"],[\"~$r\",\"~$g\",\"~$b\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",1560,\"^M\",1566,\"^X\",3,\"^Y\",true,\"^N\",[\"^O\",[[\"^9>\"],[\"~$r\",\"~$g\",\"~$b\"]]],\"^R\",\"Sets the emissive color of the material used for drawing shapes\\n drawn to the screen. Used in combination with ambient, specular, and\\n shininess in setting the material properties of shapes. Converts all\\n args to floats\"],\"~$shape-modes\",[\"^ \",\"^5\",\"~$quil.core$macros/shape-modes\",\"^F\",\"quil/core.cljc\",\"^L\",45,\"^J\",1,\"^M\",47,\"^H\",13,\"^C\",[\"^ \",\"^F\",\"^G\",\"^L\",47,\"^J\",2,\"^M\",47,\"^H\",13]],\"~$green\",[\"^ \",\"^A\",\"Color\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Color\",\"^D\",\"1.0\",\"^E\",\"Creating & Reading\",\"^F\",\"^G\",\"^H\",8,\"^I\",\"green()\",\"^J\",3,\"^K\",true,\"^L\",1939,\"^M\",1939,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^4P\"]]]]],\"^R\",\"Extracts the green value from a color, scaled to match current\\n  color-mode. This value is always returned as a float so be careful\\n  not to assign it to an int value.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/green\",\"^T\",false,\"^E\",\"Creating & Reading\",\"^F\",\"quil/core.cljc\",\"^H\",8,\"^I\",\"green()\",\"^U\",[\"^O\",[[\"^4P\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",1933,\"^M\",1939,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^4P\"]]]]],\"^R\",\"Extracts the green value from a color, scaled to match current\\n  color-mode. This value is always returned as a float so be careful\\n  not to assign it to an int value.\"],\"~$HALF-PI\",[\"^ \",\"^5\",\"~$quil.core$macros/HALF-PI\",\"^F\",\"quil/core.cljc\",\"^L\",77,\"^J\",1,\"^M\",77,\"^H\",13,\"^C\",[\"^ \",\"^F\",\"^G\",\"^L\",77,\"^J\",6,\"^M\",77,\"^H\",13]],\"~$begin-contour\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"2.0\",\"^E\",\"Vertex\",\"^F\",\"^G\",\"^H\",16,\"^I\",\"beginContour()\",\"^J\",3,\"^K\",true,\"^L\",602,\"^M\",602,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Use the begin-contour and end-contour function to create negative\\n  shapes within shapes. These functions can only be within a\\n  begin-shape/end-shape pair and they only work with the :p2d and :p3d\\n  renderers.\"],\"^D\",\"2.0\",\"^5\",\"~$quil.core$macros/begin-contour\",\"^T\",false,\"^E\",\"Vertex\",\"^F\",\"quil/core.cljc\",\"^H\",16,\"^I\",\"beginContour()\",\"^U\",[\"^O\",[[]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",596,\"^M\",602,\"^X\",0,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Use the begin-contour and end-contour function to create negative\\n  shapes within shapes. These functions can only be within a\\n  begin-shape/end-shape pair and they only work with the :p2d and :p3d\\n  renderers.\"],\"~$DEG-TO-RAD\",[\"^ \",\"^5\",\"~$quil.core$macros/DEG-TO-RAD\",\"^F\",\"quil/core.cljc\",\"^L\",82,\"^J\",1,\"^M\",82,\"^H\",16,\"^C\",[\"^ \",\"^F\",\"^G\",\"^L\",82,\"^J\",6,\"^M\",82,\"^H\",16]],\"~$pow\",[\"^ \",\"^A\",\"Math\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Math\",\"^D\",\"1.0\",\"^E\",\"Calculation\",\"^F\",\"^G\",\"^H\",6,\"^I\",\"pow()\",\"^J\",3,\"^K\",false,\"^L\",3032,\"^M\",3032,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$num\",\"~$exponent\"]]]]],\"^R\",\"Facilitates exponential expressions. The pow() function is an\\n  efficient way of multiplying numbers by themselves (or their\\n  reciprocal) in large quantities. For example, (pow 3 5) is\\n  equivalent to the expression (* 3 3 3 3 3) and (pow 3 -5) is\\n  equivalent to (/ 1 (* 3 3 3 3 3)).\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/pow\",\"^T\",false,\"^E\",\"Calculation\",\"^F\",\"quil/core.cljc\",\"^H\",6,\"^I\",\"pow()\",\"^U\",[\"^O\",[[\"^9K\",\"^9L\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",false,\"^L\",3026,\"^M\",3032,\"^X\",2,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^9K\",\"^9L\"]]]]],\"^R\",\"Facilitates exponential expressions. The pow() function is an\\n  efficient way of multiplying numbers by themselves (or their\\n  reciprocal) in large quantities. For example, (pow 3 5) is\\n  equivalent to the expression (* 3 3 3 3 3) and (pow 3 -5) is\\n  equivalent to (/ 1 (* 3 3 3 3 3)).\"],\"~$box\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"3D Primitives\",\"^F\",\"^G\",\"^H\",6,\"^15\",[\"^ \",\"^T\",false,\"^X\",3,\"^U\",[\"^O\",[[\"^29\"],[\"^1@\",\"^1A\",\"~$depth\"]]],\"^N\",[\"^O\",[[\"^29\"],[\"^1@\",\"^1A\",\"^9O\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"box()\",\"^J\",3,\"^K\",true,\"^L\",917,\"^M\",917,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^29\"],[\"^1@\",\"^1A\",\"^9O\"]]]]],\"^R\",\"Creates an extruded rectangle.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/box\",\"^T\",false,\"^E\",\"3D Primitives\",\"^F\",\"quil/core.cljc\",\"^H\",6,\"^15\",[\"^ \",\"^T\",false,\"^X\",3,\"^U\",[\"^O\",[[\"^29\"],[\"^1@\",\"^1A\",\"^9O\"]]],\"^N\",[\"^O\",[[\"^29\"],[\"^1@\",\"^1A\",\"^9O\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"box()\",\"^U\",[\"^O\",[[\"^29\"],[\"^1@\",\"^1A\",\"^9O\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",911,\"^M\",917,\"^X\",3,\"^Y\",true,\"^N\",[\"^O\",[[\"^29\"],[\"^1@\",\"^1A\",\"^9O\"]]],\"^R\",\"Creates an extruded rectangle.\"],\"~$exp\",[\"^ \",\"^A\",\"Math\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Math\",\"^D\",\"1.0\",\"^E\",\"Calculation\",\"^F\",\"^G\",\"^H\",6,\"^I\",\"exp()\",\"^J\",3,\"^K\",false,\"^L\",1685,\"^M\",1685,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^2Q\"]]]]],\"^R\",\"Returns Euler's number e (2.71828...) raised to the power of the\\n  value parameter.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/exp\",\"^T\",false,\"^E\",\"Calculation\",\"^F\",\"quil/core.cljc\",\"^H\",6,\"^I\",\"exp()\",\"^U\",[\"^O\",[[\"^2Q\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",false,\"^L\",1679,\"^M\",1685,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^2Q\"]]]]],\"^R\",\"Returns Euler's number e (2.71828...) raised to the power of the\\n  value parameter.\"],\"~$with-sketch\",[\"^ \",\"^B\",null,\"^C\",[\"^ \",\"^F\",\"^G\",\"^L\",190,\"^J\",11,\"^M\",190,\"^H\",22,\"^1P\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$applet\",\"~$&\",\"^1O\"]]]]],\"^15\",[\"^ \",\"^T\",true,\"^X\",3,\"^U\",[[\"^O\",[\"^1L\",\"^1M\",\"^9T\",\"^1O\"]]],\"^N\",[\"^O\",[[\"^1L\",\"^1M\",\"^9T\",\"~$&\",\"^1O\"]]],\"^W\",[\"^O\",[null]]]],\"^5\",\"~$quil.core$macros/with-sketch\",\"^T\",true,\"^F\",\"quil/core.cljc\",\"^H\",22,\"^15\",[\"^ \",\"^T\",true,\"^X\",3,\"^U\",[[\"^O\",[\"^1L\",\"^1M\",\"^9T\",\"^1O\"]]],\"^N\",[\"^O\",[[\"^1L\",\"^1M\",\"^9T\",\"~$&\",\"^1O\"]]],\"^W\",[\"^O\",[null]]],\"^U\",[[\"^O\",[\"^1L\",\"^1M\",\"^9T\",\"^1O\"]]],\"^V\",null,\"^W\",[\"^O\",[null]],\"^J\",1,\"^L\",190,\"^1P\",true,\"^M\",190,\"^X\",3,\"^Y\",false,\"^N\",[\"^O\",[[\"^1L\",\"^1M\",\"^9T\",\"~$&\",\"^1O\"]]]],\"~$text-ascent\",[\"^ \",\"^A\",\"Typography\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Typography\",\"^D\",\"1.0\",\"^E\",\"Metrics\",\"^F\",\"^G\",\"^H\",14,\"^I\",\"textAscent()\",\"^J\",3,\"^K\",true,\"^L\",4213,\"^M\",4213,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Returns the ascent of the current font at its current size. This\\n  information is useful for determining the height of the font above\\n  the baseline. For example, adding the text-ascent and text-descent\\n  values will give you the total height of the line.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/text-ascent\",\"^T\",false,\"^E\",\"Metrics\",\"^F\",\"quil/core.cljc\",\"^H\",14,\"^I\",\"textAscent()\",\"^U\",[\"^O\",[[]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",4207,\"^M\",4213,\"^X\",0,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Returns the ascent of the current font at its current size. This\\n  information is useful for determining the height of the font above\\n  the baseline. For example, adding the text-ascent and text-descent\\n  values will give you the total height of the line.\"],\"~$tint-int\",[\"^ \",\"^A\",\"Image\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Image\",\"^D\",\"1.0\",\"^E\",\"Loading & Displaying\",\"^F\",\"^G\",\"^H\",11,\"^15\",[\"^ \",\"^T\",false,\"^X\",2,\"^U\",[\"^O\",[[\"^3:\"],[\"^3:\",\"^2?\"]]],\"^N\",[\"^O\",[[\"^3:\"],[\"^3:\",\"^2?\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"tint()\",\"^J\",3,\"^K\",true,\"^L\",4410,\"^M\",4410,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^3:\"],[\"^3:\",\"^2?\"]]]]],\"^R\",\"Sets the fill value for displaying images. Images can be tinted to\\n  specified colors or made transparent by setting the alpha.\\n\\n  To make an image transparent, but not change it's color, use white\\n  as the tint color and specify an alpha value. For instance,\\n  tint(255, 128) will make an image 50% transparent (unless\\n  colorMode() has been used).\\n\\n  The value for the parameter gray must be less than or equal to the\\n  current maximum value as specified by colorMode(). The default\\n  maximum value is 255.\\n\\n  Also used to control the coloring of textures in 3D.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/tint-int\",\"^T\",false,\"^E\",\"Loading & Displaying\",\"^F\",\"quil/core.cljc\",\"^H\",11,\"^15\",[\"^ \",\"^T\",false,\"^X\",2,\"^U\",[\"^O\",[[\"^3:\"],[\"^3:\",\"^2?\"]]],\"^N\",[\"^O\",[[\"^3:\"],[\"^3:\",\"^2?\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"tint()\",\"^U\",[\"^O\",[[\"^3:\"],[\"^3:\",\"^2?\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",4404,\"^M\",4410,\"^X\",2,\"^Y\",true,\"^N\",[\"^O\",[[\"^3:\"],[\"^3:\",\"^2?\"]]],\"^R\",\"Sets the fill value for displaying images. Images can be tinted to\\n  specified colors or made transparent by setting the alpha.\\n\\n  To make an image transparent, but not change it's color, use white\\n  as the tint color and specify an alpha value. For instance,\\n  tint(255, 128) will make an image 50% transparent (unless\\n  colorMode() has been used).\\n\\n  The value for the parameter gray must be less than or equal to the\\n  current maximum value as specified by colorMode(). The default\\n  maximum value is 255.\\n\\n  Also used to control the coloring of textures in 3D.\"],\"~$shininess\",[\"^ \",\"^A\",\"Lights, Camera\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Lights, Camera\",\"^D\",\"1.0\",\"^E\",\"Material Properties\",\"^F\",\"^G\",\"^H\",12,\"^I\",\"shininess()\",\"^J\",3,\"^K\",true,\"^L\",3822,\"^M\",3822,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$shine\"]]]]],\"^R\",\"Sets the amount of gloss in the surface of shapes. Used in\\n  combination with ambient, specular, and emissive in setting\\n  the material properties of shapes.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/shininess\",\"^T\",false,\"^E\",\"Material Properties\",\"^F\",\"quil/core.cljc\",\"^H\",12,\"^I\",\"shininess()\",\"^U\",[\"^O\",[[\"^9[\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",3816,\"^M\",3822,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^9[\"]]]]],\"^R\",\"Sets the amount of gloss in the surface of shapes. Used in\\n  combination with ambient, specular, and emissive in setting\\n  the material properties of shapes.\"],\"~$rect-mode\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"Attributes\",\"^F\",\"^G\",\"^H\",12,\"^I\",\"rectMode()\",\"^J\",3,\"^K\",true,\"^L\",3274,\"^M\",3274,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^18\"]]]]],\"^R\",\"Modifies the location from which rectangles draw. The default mode\\n  is :corner. Available modes are:\\n\\n\\n  :corner  - Specifies the location to be the upper left corner of the\\n             shape and uses the third and fourth parameters of rect to\\n             specify the width and height.\\n\\n  :corners - Uses the first and second parameters of rect to set the\\n             location of one corner and uses the third and fourth\\n             parameters to set the opposite corner.\\n\\n  :center  - Draws the image from its center point and uses the third\\n             and forth parameters of rect to specify the image's width\\n             and height.\\n\\n  :radius  - Draws the image from its center point and uses the third\\n             and forth parameters of rect() to specify half of the\\n             image's width and height.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/rect-mode\",\"^T\",false,\"^E\",\"Attributes\",\"^F\",\"quil/core.cljc\",\"^H\",12,\"^I\",\"rectMode()\",\"^U\",[\"^O\",[[\"^18\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",3268,\"^M\",3274,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^18\"]]]]],\"^R\",\"Modifies the location from which rectangles draw. The default mode\\n  is :corner. Available modes are:\\n\\n\\n  :corner  - Specifies the location to be the upper left corner of the\\n             shape and uses the third and fourth parameters of rect to\\n             specify the width and height.\\n\\n  :corners - Uses the first and second parameters of rect to set the\\n             location of one corner and uses the third and fourth\\n             parameters to set the opposite corner.\\n\\n  :center  - Draws the image from its center point and uses the third\\n             and forth parameters of rect to specify the image's width\\n             and height.\\n\\n  :radius  - Draws the image from its center point and uses the third\\n             and forth parameters of rect() to specify half of the\\n             image's width and height.\"],\"~$ellipse-mode\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"Attributes\",\"^F\",\"^G\",\"^H\",15,\"^I\",\"ellipseMode()\",\"^J\",3,\"^K\",true,\"^L\",1544,\"^M\",1544,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^18\"]]]]],\"^R\",\"Modifies the origin of the ellispse according to the specified mode:\\n\\n  :center  - specifies the location of the ellipse as\\n             the center of the shape. (Default).\\n  :radius  - similar to center, but the width and height parameters to\\n             ellipse specify the radius of the ellipse, rather than the\\n             diameter.\\n  :corner  - draws the shape from the upper-left corner of its bounding\\n             box.\\n  :corners - uses the four parameters to ellipse to set two opposing\\n             corners of the ellipse's bounding box.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/ellipse-mode\",\"^T\",false,\"^E\",\"Attributes\",\"^F\",\"quil/core.cljc\",\"^H\",15,\"^I\",\"ellipseMode()\",\"^U\",[\"^O\",[[\"^18\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",1538,\"^M\",1544,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^18\"]]]]],\"^R\",\"Modifies the origin of the ellispse according to the specified mode:\\n\\n  :center  - specifies the location of the ellipse as\\n             the center of the shape. (Default).\\n  :radius  - similar to center, but the width and height parameters to\\n             ellipse specify the radius of the ellipse, rather than the\\n             diameter.\\n  :corner  - draws the shape from the upper-left corner of its bounding\\n             box.\\n  :corners - uses the four parameters to ellipse to set two opposing\\n             corners of the ellipse's bounding box.\"],\"~$month\",[\"^ \",\"^A\",\"Input\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Input\",\"^D\",\"1.0\",\"^E\",\"Time & Date\",\"^F\",\"^G\",\"^H\",8,\"^I\",\"month()\",\"^J\",3,\"^K\",false,\"^L\",2568,\"^M\",2568,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Returns the current month as a value from 1 - 12.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/month\",\"^T\",false,\"^E\",\"Time & Date\",\"^F\",\"quil/core.cljc\",\"^H\",8,\"^I\",\"month()\",\"^U\",[\"^O\",[[]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",false,\"^L\",2562,\"^M\",2568,\"^X\",0,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Returns the current month as a value from 1 - 12.\"],\"~$texture-modes\",[\"^ \",\"^5\",\"~$quil.core$macros/texture-modes\",\"^F\",\"quil/core.cljc\",\"^L\",45,\"^J\",1,\"^M\",69,\"^H\",15,\"^C\",[\"^ \",\"^F\",\"^G\",\"^L\",69,\"^J\",2,\"^M\",69,\"^H\",15]],\"~$tint-float\",[\"^ \",\"^A\",\"Image\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Image\",\"^D\",\"1.0\",\"^E\",\"Loading & Displaying\",\"^F\",\"^G\",\"^H\",13,\"^15\",[\"^ \",\"^T\",false,\"^X\",4,\"^U\",[\"^O\",[[\"^2>\"],[\"^2>\",\"^2?\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^N\",[\"^O\",[[\"^2>\"],[\"^2>\",\"^2?\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^W\",[\"^O\",[null,null,null,null]]],\"^I\",\"tint()\",\"^J\",3,\"^K\",true,\"^L\",4385,\"^M\",4385,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^2>\"],[\"^2>\",\"^2?\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]]]],\"^R\",\"Sets the fill value for displaying images. Images can be tinted to\\n  specified colors or made transparent by setting the alpha.\\n\\n  To make an image transparent, but not change it's color, use white\\n  as the tint color and specify an alpha value. For instance,\\n  tint(255, 128) will make an image 50% transparent (unless\\n  colorMode() has been used).\\n\\n  The value for the parameter gray must be less than or equal to the\\n  current maximum value as specified by colorMode(). The default\\n  maximum value is 255.\\n\\n  Also used to control the coloring of textures in 3D.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/tint-float\",\"^T\",false,\"^E\",\"Loading & Displaying\",\"^F\",\"quil/core.cljc\",\"^H\",13,\"^15\",[\"^ \",\"^T\",false,\"^X\",4,\"^U\",[\"^O\",[[\"^2>\"],[\"^2>\",\"^2?\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^N\",[\"^O\",[[\"^2>\"],[\"^2>\",\"^2?\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^W\",[\"^O\",[null,null,null,null]]],\"^I\",\"tint()\",\"^U\",[\"^O\",[[\"^2>\"],[\"^2>\",\"^2?\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null,null,null]],\"^J\",1,\"^K\",true,\"^L\",4379,\"^M\",4385,\"^X\",4,\"^Y\",true,\"^N\",[\"^O\",[[\"^2>\"],[\"^2>\",\"^2?\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^R\",\"Sets the fill value for displaying images. Images can be tinted to\\n  specified colors or made transparent by setting the alpha.\\n\\n  To make an image transparent, but not change it's color, use white\\n  as the tint color and specify an alpha value. For instance,\\n  tint(255, 128) will make an image 50% transparent (unless\\n  colorMode() has been used).\\n\\n  The value for the parameter gray must be less than or equal to the\\n  current maximum value as specified by colorMode(). The default\\n  maximum value is 255.\\n\\n  Also used to control the coloring of textures in 3D.\"],\"^1@\",[\"^ \",\"^A\",\"Environment\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Environment\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^G\",\"^H\",8,\"^I\",\"getWidth()\",\"^J\",3,\"^3Y\",null,\"^K\",true,\"^L\",4592,\"^M\",4592,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Width of the display window. The value of width is zero until size is\\n  called.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/width\",\"^T\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^H\",8,\"^I\",\"getWidth()\",\"^U\",[\"^O\",[[]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^3Y\",null,\"^K\",true,\"^L\",4585,\"^M\",4592,\"^X\",0,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Width of the display window. The value of width is zero until size is\\n  called.\"],\"~$background\",[\"^ \",\"^A\",\"Color\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Color\",\"^D\",\"1.0\",\"^E\",\"Setting\",\"^F\",\"^G\",\"^H\",13,\"^15\",[\"^ \",\"^T\",false,\"^X\",4,\"^U\",[\"^O\",[[\"^3:\"],[\"^3:\",\"^2?\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^N\",[\"^O\",[[\"^3:\"],[\"^3:\",\"^2?\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^W\",[\"^O\",[null,null,null,null]]],\"^I\",\"background()\",\"^J\",3,\"^K\",true,\"^L\",550,\"^M\",550,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^3:\"],[\"^3:\",\"^2?\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]]]],\"^R\",\"Sets the color used for the background of the Processing\\n  window. The default background is light gray. In the draw function,\\n  the background color is used to clear the display window at the\\n  beginning of each frame.\\n\\n  It is not possible to use transparency (alpha) in background colors\\n  with the main drawing surface, however they will work properly with\\n  create-graphics. Converts args to floats.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/background\",\"^T\",false,\"^E\",\"Setting\",\"^F\",\"quil/core.cljc\",\"^H\",13,\"^15\",[\"^ \",\"^T\",false,\"^X\",4,\"^U\",[\"^O\",[[\"^3:\"],[\"^3:\",\"^2?\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^N\",[\"^O\",[[\"^3:\"],[\"^3:\",\"^2?\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^W\",[\"^O\",[null,null,null,null]]],\"^I\",\"background()\",\"^U\",[\"^O\",[[\"^3:\"],[\"^3:\",\"^2?\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null,null,null]],\"^J\",1,\"^K\",true,\"^L\",544,\"^M\",550,\"^X\",4,\"^Y\",true,\"^N\",[\"^O\",[[\"^3:\"],[\"^3:\",\"^2?\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^R\",\"Sets the color used for the background of the Processing\\n  window. The default background is light gray. In the draw function,\\n  the background color is used to clear the display window at the\\n  beginning of each frame.\\n\\n  It is not possible to use transparency (alpha) in background colors\\n  with the main drawing surface, however they will work properly with\\n  create-graphics. Converts args to floats.\"],\"~$ortho\",[\"^ \",\"^A\",\"Lights, Camera\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Lights, Camera\",\"^D\",\"1.0\",\"^E\",\"Camera\",\"^F\",\"^G\",\"^H\",8,\"^15\",[\"^ \",\"^T\",false,\"^X\",6,\"^U\",[\"^O\",[[],[\"~$left\",\"~$right\",\"~$bottom\",\"~$top\"],[\"^:?\",\"^:@\",\"^:A\",\"^:B\",\"~$near\",\"~$far\"]]],\"^N\",[\"^O\",[[],[\"^:?\",\"^:@\",\"^:A\",\"^:B\"],[\"^:?\",\"^:@\",\"^:A\",\"^:B\",\"^:C\",\"^:D\"]]],\"^W\",[\"^O\",[null,null,null]]],\"^I\",\"ortho()\",\"^J\",3,\"^K\",true,\"^L\",2860,\"^M\",2860,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[],[\"^:?\",\"^:@\",\"^:A\",\"^:B\"],[\"^:?\",\"^:@\",\"^:A\",\"^:B\",\"^:C\",\"^:D\"]]]]],\"^R\",\"Sets an orthographic projection and defines a parallel clipping\\n  volume. All objects with the same dimension appear the same size,\\n  regardless of whether they are near or far from the camera. The\\n  parameters to this function specify the clipping volume where left\\n  and right are the minimum and maximum x values, top and bottom are\\n  the minimum and maximum y values, and near and far are the minimum\\n  and maximum z values. If no parameters are given, the default is\\n  used: (ortho 0 width 0 height -10 10)\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/ortho\",\"^T\",false,\"^E\",\"Camera\",\"^F\",\"quil/core.cljc\",\"^H\",8,\"^15\",[\"^ \",\"^T\",false,\"^X\",6,\"^U\",[\"^O\",[[],[\"^:?\",\"^:@\",\"^:A\",\"^:B\"],[\"^:?\",\"^:@\",\"^:A\",\"^:B\",\"^:C\",\"^:D\"]]],\"^N\",[\"^O\",[[],[\"^:?\",\"^:@\",\"^:A\",\"^:B\"],[\"^:?\",\"^:@\",\"^:A\",\"^:B\",\"^:C\",\"^:D\"]]],\"^W\",[\"^O\",[null,null,null]]],\"^I\",\"ortho()\",\"^U\",[\"^O\",[[],[\"^:?\",\"^:@\",\"^:A\",\"^:B\"],[\"^:?\",\"^:@\",\"^:A\",\"^:B\",\"^:C\",\"^:D\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null,null]],\"^J\",1,\"^K\",true,\"^L\",2854,\"^M\",2860,\"^X\",6,\"^Y\",true,\"^N\",[\"^O\",[[],[\"^:?\",\"^:@\",\"^:A\",\"^:B\"],[\"^:?\",\"^:@\",\"^:A\",\"^:B\",\"^:C\",\"^:D\"]]],\"^R\",\"Sets an orthographic projection and defines a parallel clipping\\n  volume. All objects with the same dimension appear the same size,\\n  regardless of whether they are near or far from the camera. The\\n  parameters to this function specify the clipping volume where left\\n  and right are the minimum and maximum x values, top and bottom are\\n  the minimum and maximum y values, and near and far are the minimum\\n  and maximum z values. If no parameters are given, the default is\\n  used: (ortho 0 width 0 height -10 10)\"],\"~$hint-options\",[\"^ \",\"^5\",\"~$quil.core$macros/hint-options\",\"^F\",\"quil/core.cljc\",\"^L\",45,\"^J\",1,\"^M\",53,\"^H\",14,\"^C\",[\"^ \",\"^F\",\"^G\",\"^L\",53,\"^J\",2,\"^M\",53,\"^H\",14]],\"~$prc-println\",[\"^ \",\"^A\",\"Output\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Output\",\"^D\",\"1.0\",\"^E\",\"Text area\",\"^F\",\"^G\",\"^H\",17,\"^J\",6,\"^8A\",true,\"^L\",152,\"^M\",152,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^8B\"]]]]],\"^R\",\"Writes to the text area of the Processing environment's console.\\n  This is often helpful for looking at the data a program is producing.\\n  Each call to this function creates a new line of output.\\n  Individual elements can be separated with quotes (\\\"\\\") and joined with the string concatenation operator (+).\\n  Also writes the content of an array to the text area of the Processing environment.\\n  This is often helpful for looking at the data a program is producing.\\n  A new line is put between each element of the array. This function can only print 1D arrays,\\n  but can test to see if the content are null or not null for 2+ dimensional arrays.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/prc-println\",\"^T\",false,\"^E\",\"Text area\",\"^F\",\"quil/core.cljc\",\"^H\",17,\"^U\",[\"^O\",[[\"^8B\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",4,\"^8A\",true,\"^L\",147,\"^M\",152,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^8B\"]]]]],\"^R\",\"Writes to the text area of the Processing environment's console.\\n  This is often helpful for looking at the data a program is producing.\\n  Each call to this function creates a new line of output.\\n  Individual elements can be separated with quotes (\\\"\\\") and joined with the string concatenation operator (+).\\n  Also writes the content of an array to the text area of the Processing environment.\\n  This is often helpful for looking at the data a program is producing.\\n  A new line is put between each element of the array. This function can only print 1D arrays,\\n  but can test to see if the content are null or not null for 2+ dimensional arrays.\"],\"~$brightness\",[\"^ \",\"^A\",\"Color\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Color\",\"^D\",\"1.0\",\"^E\",\"Creating & Reading\",\"^F\",\"^G\",\"^H\",13,\"^I\",\"brightness()\",\"^J\",3,\"^K\",true,\"^L\",928,\"^M\",928,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^7J\"]]]]],\"^R\",\"Extracts the brightness value from a color. Returns a float.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/brightness\",\"^T\",false,\"^E\",\"Creating & Reading\",\"^F\",\"quil/core.cljc\",\"^H\",13,\"^I\",\"brightness()\",\"^U\",[\"^O\",[[\"^7J\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",922,\"^M\",928,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^7J\"]]]]],\"^R\",\"Extracts the brightness value from a color. Returns a float.\"],\"~$arc-modes\",[\"^ \",\"^5\",\"~$quil.core$macros/arc-modes\",\"^F\",\"quil/core.cljc\",\"^L\",45,\"^J\",1,\"^M\",46,\"^H\",11,\"^C\",[\"^ \",\"^F\",\"^G\",\"^L\",46,\"^J\",2,\"^M\",46,\"^H\",11]],\"~$specular\",[\"^ \",\"^A\",\"Lights, Camera\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Lights, Camera\",\"^D\",\"1.0\",\"^E\",\"Material Properties\",\"^F\",\"^G\",\"^H\",11,\"^15\",[\"^ \",\"^T\",false,\"^X\",3,\"^U\",[\"^O\",[[\"^2>\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^N\",[\"^O\",[[\"^2>\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"specular()\",\"^J\",3,\"^K\",true,\"^L\",3879,\"^M\",3879,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^2>\"],[\"~$x\",\"~$y\",\"~$z\"]]]]],\"^R\",\"Sets the specular color of the materials used for shapes drawn to\\n  the screen, which sets the color of hightlights. Specular refers to\\n  light which bounces off a surface in a perferred direction (rather\\n  than bouncing in all directions like a diffuse light). Used in\\n  combination with emissive, ambient, and shininess in setting\\n  the material properties of shapes.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/specular\",\"^T\",false,\"^E\",\"Material Properties\",\"^F\",\"quil/core.cljc\",\"^H\",11,\"^15\",[\"^ \",\"^T\",false,\"^X\",3,\"^U\",[\"^O\",[[\"^2>\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^N\",[\"^O\",[[\"^2>\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"specular()\",\"^U\",[\"^O\",[[\"^2>\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",3873,\"^M\",3879,\"^X\",3,\"^Y\",true,\"^N\",[\"^O\",[[\"^2>\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^R\",\"Sets the specular color of the materials used for shapes drawn to\\n  the screen, which sets the color of hightlights. Specular refers to\\n  light which bounces off a surface in a perferred direction (rather\\n  than bouncing in all directions like a diffuse light). Used in\\n  combination with emissive, ambient, and shininess in setting\\n  the material properties of shapes.\"],\"~$save-frame\",[\"^ \",\"^A\",\"Output\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Output\",\"^D\",\"1.0\",\"^E\",\"Image\",\"^F\",\"^G\",\"^H\",13,\"^15\",[\"^ \",\"^T\",false,\"^X\",1,\"^U\",[\"^O\",[[],[\"~$name\"]]],\"^N\",[\"^O\",[[],[\"^:Q\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"saveFrame()\",\"^J\",3,\"^K\",true,\"^L\",3541,\"^M\",3541,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[],[\"^:Q\"]]]]],\"^R\",\"Saves an image identical to the current display window as a\\n  file. May be called multple times - each file saved will have a\\n  unique name. Name and image formate may be modified by passing a\\n  string parameter of the form \\\"foo-####.ext\\\" where foo- can be any\\n  arbitrary string, #### will be replaced with the current frame id\\n  and .ext is one of .tiff, .targa, .png, .jpeg or .jpg\\n\\n  Examples:\\n  (save-frame)\\n  (save-frame \\\"pretty-pic-####.jpg\\\")\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/save-frame\",\"^T\",false,\"^E\",\"Image\",\"^F\",\"quil/core.cljc\",\"^H\",13,\"^15\",[\"^ \",\"^T\",false,\"^X\",1,\"^U\",[\"^O\",[[],[\"^:Q\"]]],\"^N\",[\"^O\",[[],[\"^:Q\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"saveFrame()\",\"^U\",[\"^O\",[[],[\"^:Q\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",3535,\"^M\",3541,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[[],[\"^:Q\"]]],\"^R\",\"Saves an image identical to the current display window as a\\n  file. May be called multple times - each file saved will have a\\n  unique name. Name and image formate may be modified by passing a\\n  string parameter of the form \\\"foo-####.ext\\\" where foo- can be any\\n  arbitrary string, #### will be replaced with the current frame id\\n  and .ext is one of .tiff, .targa, .png, .jpeg or .jpg\\n\\n  Examples:\\n  (save-frame)\\n  (save-frame \\\"pretty-pic-####.jpg\\\")\"],\"~$cursor\",[\"^ \",\"^A\",\"Environment\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Environment\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^G\",\"^H\",9,\"^15\",[\"^ \",\"^T\",false,\"^X\",1,\"^U\",[\"^O\",[[],[\"~$cursor-mode\"]]],\"^N\",[\"^O\",[[],[\"^:T\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"cursor()\",\"^J\",3,\"^K\",true,\"^L\",1286,\"^M\",1286,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[],[\"^:T\"]]]]],\"^R\",\"Sets the cursor to a predefined symbol or makes it\\n  visible if already hidden (after no-cursor was called).\\n\\n  Available modes: :arrow, :cross, :hand, :move, :text, :wait\\n\\n  See cursor-image for specifying a generic image as the cursor\\n  symbol.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/cursor\",\"^T\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^H\",9,\"^15\",[\"^ \",\"^T\",false,\"^X\",1,\"^U\",[\"^O\",[[],[\"^:T\"]]],\"^N\",[\"^O\",[[],[\"^:T\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"cursor()\",\"^U\",[\"^O\",[[],[\"^:T\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",1280,\"^M\",1286,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[[],[\"^:T\"]]],\"^R\",\"Sets the cursor to a predefined symbol or makes it\\n  visible if already hidden (after no-cursor was called).\\n\\n  Available modes: :arrow, :cross, :hand, :move, :text, :wait\\n\\n  See cursor-image for specifying a generic image as the cursor\\n  symbol.\"],\"~$noise\",[\"^ \",\"^A\",\"Math\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Math\",\"^D\",\"1.0\",\"^E\",\"Random\",\"^F\",\"^G\",\"^H\",8,\"^15\",[\"^ \",\"^T\",false,\"^X\",3,\"^U\",[\"^O\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^N\",[\"^O\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^W\",[\"^O\",[null,null,null]]],\"^I\",\"noise()\",\"^J\",3,\"^K\",true,\"^L\",2676,\"^M\",2676,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]]]],\"^R\",\"Returns the Perlin noise value at specified coordinates. Perlin\\n  noise is a random sequence generator producing a more natural\\n  ordered, harmonic succession of numbers compared to the standard\\n  random function. It was invented by Ken Perlin in the 1980s and\\n  been used since in graphical applications to produce procedural\\n  textures, natural motion, shapes, terrains etc.\\n\\n  The main difference to the random function is that Perlin noise is\\n  defined in an infinite n-dimensional space where each pair of\\n  coordinates corresponds to a fixed semi-random value (fixed only for\\n  the lifespan of the program). The resulting value will always be\\n  between 0.0 and 1.0. Processing can compute 1D, 2D and 3D noise,\\n  depending on the number of coordinates given. The noise value can be\\n  animated by moving through the noise space and the 2nd and 3rd\\n  dimensions can also be interpreted as time.\\n\\n  The actual noise is structured similar to an audio signal, in\\n  respect to the function's use of frequencies. Similar to the concept\\n  of harmonics in physics, perlin noise is computed over several\\n  octaves which are added together for the final result.\\n\\n  Another way to adjust the character of the resulting sequence is the\\n  scale of the input coordinates. As the function works within an\\n  infinite space the value of the coordinates doesn't matter as such,\\n  only the distance between successive coordinates does (eg. when\\n  using noise within a loop). As a general rule the smaller the\\n  difference between coordinates, the smoother the resulting noise\\n  sequence will be. Steps of 0.005-0.03 work best for most\\n  applications, but this will differ depending on use.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/noise\",\"^T\",false,\"^E\",\"Random\",\"^F\",\"quil/core.cljc\",\"^H\",8,\"^15\",[\"^ \",\"^T\",false,\"^X\",3,\"^U\",[\"^O\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^N\",[\"^O\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^W\",[\"^O\",[null,null,null]]],\"^I\",\"noise()\",\"^U\",[\"^O\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null,null]],\"^J\",1,\"^K\",true,\"^L\",2670,\"^M\",2676,\"^X\",3,\"^Y\",true,\"^N\",[\"^O\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^R\",\"Returns the Perlin noise value at specified coordinates. Perlin\\n  noise is a random sequence generator producing a more natural\\n  ordered, harmonic succession of numbers compared to the standard\\n  random function. It was invented by Ken Perlin in the 1980s and\\n  been used since in graphical applications to produce procedural\\n  textures, natural motion, shapes, terrains etc.\\n\\n  The main difference to the random function is that Perlin noise is\\n  defined in an infinite n-dimensional space where each pair of\\n  coordinates corresponds to a fixed semi-random value (fixed only for\\n  the lifespan of the program). The resulting value will always be\\n  between 0.0 and 1.0. Processing can compute 1D, 2D and 3D noise,\\n  depending on the number of coordinates given. The noise value can be\\n  animated by moving through the noise space and the 2nd and 3rd\\n  dimensions can also be interpreted as time.\\n\\n  The actual noise is structured similar to an audio signal, in\\n  respect to the function's use of frequencies. Similar to the concept\\n  of harmonics in physics, perlin noise is computed over several\\n  octaves which are added together for the final result.\\n\\n  Another way to adjust the character of the resulting sequence is the\\n  scale of the input coordinates. As the function works within an\\n  infinite space the value of the coordinates doesn't matter as such,\\n  only the distance between successive coordinates does (eg. when\\n  using noise within a loop). As a general rule the smaller the\\n  difference between coordinates, the smoother the resulting noise\\n  sequence will be. Steps of 0.005-0.03 work best for most\\n  applications, but this will differ depending on use.\"],\"~$push-style\",[\"^ \",\"^A\",\"Structure\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Structure\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^G\",\"^H\",13,\"^I\",\"pushStyle()\",\"^J\",3,\"^K\",true,\"^L\",3100,\"^M\",3100,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Saves the current style settings onto a 'style stack'. Use with\\n  pop-style which restores the prior settings. Note that these\\n  functions are always used together. They allow you to change the\\n  style settings and later return to what you had. When a new style is\\n  started with push-style, it builds on the current style\\n  information. The push-style and pop-style fns can be embedded to\\n  provide more control.\\n\\n  The style information controlled by the following functions are\\n  included in the style: fill, stroke, tint, stroke-weight,\\n  stroke-cap, stroke-join, image-mode, rect-mode, ellipse-mode,\\n  shape-mode, color-mode, text-align, text-font, text-mode, text-size,\\n  text-leading, emissive, specular, shininess, and ambient\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/push-style\",\"^T\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^H\",13,\"^I\",\"pushStyle()\",\"^U\",[\"^O\",[[]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",3094,\"^M\",3100,\"^X\",0,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Saves the current style settings onto a 'style stack'. Use with\\n  pop-style which restores the prior settings. Note that these\\n  functions are always used together. They allow you to change the\\n  style settings and later return to what you had. When a new style is\\n  started with push-style, it builds on the current style\\n  information. The push-style and pop-style fns can be embedded to\\n  provide more control.\\n\\n  The style information controlled by the following functions are\\n  included in the style: fill, stroke, tint, stroke-weight,\\n  stroke-cap, stroke-join, image-mode, rect-mode, ellipse-mode,\\n  shape-mode, color-mode, text-align, text-font, text-mode, text-size,\\n  text-leading, emissive, specular, shininess, and ambient\"],\"~$bezier-vertex\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"Vertex\",\"^F\",\"^G\",\"^H\",16,\"^15\",[\"^ \",\"^T\",false,\"^X\",9,\"^U\",[\"^O\",[[\"^53\",\"^54\",\"^55\",\"^56\",\"~$x\",\"~$y\"],[\"^53\",\"^54\",\"^58\",\"^55\",\"^56\",\"^59\",\"~$x\",\"~$y\",\"~$z\"]]],\"^N\",[\"^O\",[[\"^53\",\"^54\",\"^55\",\"^56\",\"~$x\",\"~$y\"],[\"^53\",\"^54\",\"^58\",\"^55\",\"^56\",\"^59\",\"~$x\",\"~$y\",\"~$z\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"bezierVertex()\",\"^J\",3,\"^K\",true,\"^L\",735,\"^M\",735,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^53\",\"^54\",\"^55\",\"^56\",\"~$x\",\"~$y\"],[\"^53\",\"^54\",\"^58\",\"^55\",\"^56\",\"^59\",\"~$x\",\"~$y\",\"~$z\"]]]]],\"^R\",\"Specifies vertex coordinates for Bezier curves. Each call to\\n  bezier-vertex defines the position of two control points and one\\n  anchor point of a Bezier curve, adding a new segment to a line or\\n  shape. The first time bezier-vertex is used within a begin-shape\\n  call, it must be prefaced with a call to vertex to set the first\\n  anchor point. This function must be used between begin-shape and\\n  end-shape and only when there is no parameter specified to\\n  begin-shape.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/bezier-vertex\",\"^T\",false,\"^E\",\"Vertex\",\"^F\",\"quil/core.cljc\",\"^H\",16,\"^15\",[\"^ \",\"^T\",false,\"^X\",9,\"^U\",[\"^O\",[[\"^53\",\"^54\",\"^55\",\"^56\",\"~$x\",\"~$y\"],[\"^53\",\"^54\",\"^58\",\"^55\",\"^56\",\"^59\",\"~$x\",\"~$y\",\"~$z\"]]],\"^N\",[\"^O\",[[\"^53\",\"^54\",\"^55\",\"^56\",\"~$x\",\"~$y\"],[\"^53\",\"^54\",\"^58\",\"^55\",\"^56\",\"^59\",\"~$x\",\"~$y\",\"~$z\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"bezierVertex()\",\"^U\",[\"^O\",[[\"^53\",\"^54\",\"^55\",\"^56\",\"~$x\",\"~$y\"],[\"^53\",\"^54\",\"^58\",\"^55\",\"^56\",\"^59\",\"~$x\",\"~$y\",\"~$z\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",729,\"^M\",735,\"^X\",9,\"^Y\",true,\"^N\",[\"^O\",[[\"^53\",\"^54\",\"^55\",\"^56\",\"~$x\",\"~$y\"],[\"^53\",\"^54\",\"^58\",\"^55\",\"^56\",\"^59\",\"~$x\",\"~$y\",\"~$z\"]]],\"^R\",\"Specifies vertex coordinates for Bezier curves. Each call to\\n  bezier-vertex defines the position of two control points and one\\n  anchor point of a Bezier curve, adding a new segment to a line or\\n  shape. The first time bezier-vertex is used within a begin-shape\\n  call, it must be prefaced with a call to vertex to set the first\\n  anchor point. This function must be used between begin-shape and\\n  end-shape and only when there is no parameter specified to\\n  begin-shape.\"],\"~$light-falloff\",[\"^ \",\"^A\",\"Lights, Camera\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Lights, Camera\",\"^D\",\"1.0\",\"^E\",\"Lights\",\"^F\",\"^G\",\"^H\",16,\"^I\",\"lightFalloff()\",\"^J\",3,\"^K\",true,\"^L\",2228,\"^M\",2228,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$constant\",\"~$linear\",\"~$quadratic\"]]]]],\"^R\",\"Sets the falloff rates for point lights, spot lights, and ambient\\n  lights. The parameters are used to determine the falloff with the\\n  following equation:\\n\\n  d = distance from light position to vertex position\\n  falloff = 1 / (CONSTANT + d * LINEAR + (d*d) * QUADRATIC)\\n\\n  Like fill, it affects only the elements which are created after it\\n  in the code. The default value is (light-falloff 1.0 0.0 0.0).\\n  Thinking about an ambient light with a falloff can be tricky. It is\\n  used, for example, if you wanted a region of your scene to be lit\\n  ambiently one color and another region to be lit ambiently by\\n  another color, you would use an ambient light with location and\\n  falloff. You can think of it as a point light that doesn't care\\n  which direction a surface is facing.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/light-falloff\",\"^T\",false,\"^E\",\"Lights\",\"^F\",\"quil/core.cljc\",\"^H\",16,\"^I\",\"lightFalloff()\",\"^U\",[\"^O\",[[\"^;1\",\"^;2\",\"^;3\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",2222,\"^M\",2228,\"^X\",3,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^;1\",\"^;2\",\"^;3\"]]]]],\"^R\",\"Sets the falloff rates for point lights, spot lights, and ambient\\n  lights. The parameters are used to determine the falloff with the\\n  following equation:\\n\\n  d = distance from light position to vertex position\\n  falloff = 1 / (CONSTANT + d * LINEAR + (d*d) * QUADRATIC)\\n\\n  Like fill, it affects only the elements which are created after it\\n  in the code. The default value is (light-falloff 1.0 0.0 0.0).\\n  Thinking about an ambient light with a falloff can be tricky. It is\\n  used, for example, if you wanted a region of your scene to be lit\\n  ambiently one color and another region to be lit ambiently by\\n  another color, you would use an ambient light with location and\\n  falloff. You can think of it as a point light that doesn't care\\n  which direction a surface is facing.\"],\"~$noise-detail\",[\"^ \",\"^A\",\"Math\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Math\",\"^D\",\"1.0\",\"^E\",\"Random\",\"^F\",\"^G\",\"^H\",15,\"^15\",[\"^ \",\"^T\",false,\"^X\",2,\"^U\",[\"^O\",[[\"~$octaves\"],[\"^;6\",\"~$falloff\"]]],\"^N\",[\"^O\",[[\"^;6\"],[\"^;6\",\"^;7\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"noiseDetail()\",\"^J\",3,\"^K\",true,\"^L\",2716,\"^M\",2716,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^;6\"],[\"^;6\",\"^;7\"]]]]],\"^R\",\"Adjusts the character and level of detail produced by the Perlin\\n  noise function. Similar to harmonics in physics, noise is computed\\n  over several octaves. Lower octaves contribute more to the output\\n  signal and as such define the overal intensity of the noise, whereas\\n  higher octaves create finer grained details in the noise\\n  sequence. By default, noise is computed over 4 octaves with each\\n  octave contributing exactly half than its predecessor, starting at\\n  50% strength for the 1st octave. This falloff amount can be changed\\n  by adding an additional function parameter. Eg. a falloff factor of\\n  0.75 means each octave will now have 75% impact (25% less) of the\\n  previous lower octave. Any value between 0.0 and 1.0 is valid,\\n  however note that values greater than 0.5 might result in greater\\n  than 1.0 values returned by noise.\\n\\n  By changing these parameters, the signal created by the noise\\n  function can be adapted to fit very specific needs and\\n  characteristics.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/noise-detail\",\"^T\",false,\"^E\",\"Random\",\"^F\",\"quil/core.cljc\",\"^H\",15,\"^15\",[\"^ \",\"^T\",false,\"^X\",2,\"^U\",[\"^O\",[[\"^;6\"],[\"^;6\",\"^;7\"]]],\"^N\",[\"^O\",[[\"^;6\"],[\"^;6\",\"^;7\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"noiseDetail()\",\"^U\",[\"^O\",[[\"^;6\"],[\"^;6\",\"^;7\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",2710,\"^M\",2716,\"^X\",2,\"^Y\",true,\"^N\",[\"^O\",[[\"^;6\"],[\"^;6\",\"^;7\"]]],\"^R\",\"Adjusts the character and level of detail produced by the Perlin\\n  noise function. Similar to harmonics in physics, noise is computed\\n  over several octaves. Lower octaves contribute more to the output\\n  signal and as such define the overal intensity of the noise, whereas\\n  higher octaves create finer grained details in the noise\\n  sequence. By default, noise is computed over 4 octaves with each\\n  octave contributing exactly half than its predecessor, starting at\\n  50% strength for the 1st octave. This falloff amount can be changed\\n  by adding an additional function parameter. Eg. a falloff factor of\\n  0.75 means each octave will now have 75% impact (25% less) of the\\n  previous lower octave. Any value between 0.0 and 1.0 is valid,\\n  however note that values greater than 0.5 might result in greater\\n  than 1.0 values returned by noise.\\n\\n  By changing these parameters, the signal created by the noise\\n  function can be adapted to fit very specific needs and\\n  characteristics.\"],\"~$save\",[\"^ \",\"^A\",\"Output\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Output\",\"^D\",\"1.0\",\"^E\",\"Image\",\"^F\",\"^G\",\"^H\",7,\"^I\",\"save()\",\"^J\",3,\"^K\",true,\"^L\",3523,\"^M\",3523,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^4M\"]]]]],\"^R\",\"Saves an image from the display window. Images are saved in TIFF,\\n  TARGA, JPEG, and PNG format depending on the extension within the\\n  filename parameter. For example, image.tif will have a TIFF image\\n  and image.png will save a PNG image. If no extension is included in\\n  the filename, the image will save in TIFF format and .tif will be\\n  added to the name. All images saved from the main drawing window\\n  will be opaque. To save images without a background, use\\n  create-graphics.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/save\",\"^T\",false,\"^E\",\"Image\",\"^F\",\"quil/core.cljc\",\"^H\",7,\"^I\",\"save()\",\"^U\",[\"^O\",[[\"^4M\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",3517,\"^M\",3523,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^4M\"]]]]],\"^R\",\"Saves an image from the display window. Images are saved in TIFF,\\n  TARGA, JPEG, and PNG format depending on the extension within the\\n  filename parameter. For example, image.tif will have a TIFF image\\n  and image.png will save a PNG image. If no extension is included in\\n  the filename, the image will save in TIFF format and .tif will be\\n  added to the name. All images saved from the main drawing window\\n  will be opaque. To save images without a background, use\\n  create-graphics.\"],\"~$curve-point\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"Curves\",\"^F\",\"^G\",\"^H\",14,\"^I\",\"curvePoint()\",\"^J\",3,\"^K\",true,\"^L\",1362,\"^M\",1362,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$t\"]]]]],\"^R\",\"Evalutes the curve at point t for points a, b, c, d. The parameter\\n  t varies between 0 and 1, a and d are points on the curve, and b c\\n  and are the control points. This can be done once with the x\\n  coordinates and a second time with the y coordinates to get the\\n  location of a curve at t.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/curve-point\",\"^T\",false,\"^E\",\"Curves\",\"^F\",\"quil/core.cljc\",\"^H\",14,\"^I\",\"curvePoint()\",\"^U\",[\"^O\",[[\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$t\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",1356,\"^M\",1362,\"^X\",5,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$t\"]]]]],\"^R\",\"Evalutes the curve at point t for points a, b, c, d. The parameter\\n  t varies between 0 and 1, a and d are points on the curve, and b c\\n  and are the control points. This can be done once with the x\\n  coordinates and a second time with the y coordinates to get the\\n  location of a curve at t.\"],\"~$state\",[\"^ \",\"^A\",\"State\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"State\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^G\",\"^H\",8,\"^15\",[\"^ \",\"^T\",false,\"^X\",1,\"^U\",[\"^O\",[[],[\"~$key\"]]],\"^N\",[\"^O\",[[],[\"^;>\"]]],\"^W\",[\"^O\",[null,null]]],\"^J\",3,\"^K\",true,\"^L\",215,\"^M\",215,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[],[\"^;>\"]]]]],\"^R\",\"Retrieve sketch-specific state by key. Must initially call\\n  set-state! to store state. If no parameter passed whole\\n  state map is returned.\\n\\n  (set-state! :foo 1)\\n  (state :foo) ;=> 1\\n  (state) ;=> {:foo 1}\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/state\",\"^T\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^H\",8,\"^15\",[\"^ \",\"^T\",false,\"^X\",1,\"^U\",[\"^O\",[[],[\"^;>\"]]],\"^N\",[\"^O\",[[],[\"^;>\"]]],\"^W\",[\"^O\",[null,null]]],\"^U\",[\"^O\",[[],[\"^;>\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",210,\"^M\",215,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[[],[\"^;>\"]]],\"^R\",\"Retrieve sketch-specific state by key. Must initially call\\n  set-state! to store state. If no parameter passed whole\\n  state map is returned.\\n\\n  (set-state! :foo 1)\\n  (state :foo) ;=> 1\\n  (state) ;=> {:foo 1}\"],\"~$load-shader\",[\"^ \",\"^A\",\"Rendering\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Rendering\",\"^D\",\"2.0\",\"^E\",\"Shaders\",\"^F\",\"^G\",\"^H\",14,\"^15\",[\"^ \",\"^T\",false,\"^X\",2,\"^U\",[\"^O\",[[\"~$fragment-filename\"],[\"^;A\",\"~$vertex-filename\"]]],\"^N\",[\"^O\",[[\"^;A\"],[\"^;A\",\"^;B\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"loadShader()\",\"^J\",3,\"^K\",true,\"^L\",2403,\"^M\",2403,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^;A\"],[\"^;A\",\"^;B\"]]]]],\"^R\",\"Loads a shader into the PShader object. Shaders are compatible with the\\n  P2D and P3D renderers, but not with the default renderer.\"],\"^D\",\"2.0\",\"^5\",\"~$quil.core$macros/load-shader\",\"^T\",false,\"^E\",\"Shaders\",\"^F\",\"quil/core.cljc\",\"^H\",14,\"^15\",[\"^ \",\"^T\",false,\"^X\",2,\"^U\",[\"^O\",[[\"^;A\"],[\"^;A\",\"^;B\"]]],\"^N\",[\"^O\",[[\"^;A\"],[\"^;A\",\"^;B\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"loadShader()\",\"^U\",[\"^O\",[[\"^;A\"],[\"^;A\",\"^;B\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",2397,\"^M\",2403,\"^X\",2,\"^Y\",true,\"^N\",[\"^O\",[[\"^;A\"],[\"^;A\",\"^;B\"]]],\"^R\",\"Loads a shader into the PShader object. Shaders are compatible with the\\n  P2D and P3D renderers, but not with the default renderer.\"],\"~$resize\",[\"^ \",\"^A\",\"Image\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Image\",\"^D\",\"2.1.0\",\"^F\",\"^G\",\"^H\",9,\"^I\",\"resize()\",\"^J\",3,\"^3Y\",\"http://processing.org/reference/PImage_resize_.html\",\"^K\",true,\"^L\",3389,\"^M\",3389,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^1Z\",\"~$w\",\"~$h\"]]]]],\"^R\",\"Resize the image to a new width and height.\\n  To make the image scale proportionally, use 0 as the value for the wide or\\n  high parameter. For instance, to make the width of an image 150 pixels,\\n  and change the height using the same proportion, use resize(150, 0).\\n\\n  Even though a PGraphics is technically a PImage, it is not possible\\n  to rescale the image data found in a PGraphics.\\n  (It's simply not possible to do this consistently across renderers:\\n  technically infeasible with P3D, or what would it even do with PDF?)\\n  If you want to resize PGraphics content, first get a copy of its image data\\n  using the get() method, and call resize() on the PImage that is returned.\"],\"^D\",\"2.1.0\",\"^5\",\"~$quil.core$macros/resize\",\"^T\",false,\"^F\",\"quil/core.cljc\",\"^H\",9,\"^I\",\"resize()\",\"^U\",[\"^O\",[[\"^1Z\",\"~$w\",\"~$h\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^3Y\",\"http://processing.org/reference/PImage_resize_.html\",\"^K\",true,\"^L\",3383,\"^M\",3389,\"^X\",3,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^1Z\",\"~$w\",\"~$h\"]]]]],\"^R\",\"Resize the image to a new width and height.\\n  To make the image scale proportionally, use 0 as the value for the wide or\\n  high parameter. For instance, to make the width of an image 150 pixels,\\n  and change the height using the same proportion, use resize(150, 0).\\n\\n  Even though a PGraphics is technically a PImage, it is not possible\\n  to rescale the image data found in a PGraphics.\\n  (It's simply not possible to do this consistently across renderers:\\n  technically infeasible with P3D, or what would it even do with PDF?)\\n  If you want to resize PGraphics content, first get a copy of its image data\\n  using the get() method, and call resize() on the PImage that is returned.\"],\"~$normal\",[\"^ \",\"^A\",\"Lights, Camera\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Lights, Camera\",\"^D\",\"1.0\",\"^E\",\"Lights\",\"^F\",\"^G\",\"^H\",9,\"^I\",\"normal()\",\"^J\",3,\"^K\",true,\"^L\",2809,\"^M\",2809,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^5F\",\"^5G\",\"^5H\"]]]]],\"^R\",\"Sets the current normal vector. This is for drawing three\\n  dimensional shapes and surfaces and specifies a vector perpendicular\\n  to the surface of the shape which determines how lighting affects\\n  it. Processing attempts to automatically assign normals to shapes,\\n  but since that's imperfect, this is a better option when you want\\n  more control. This function is identical to glNormal3f() in OpenGL.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/normal\",\"^T\",false,\"^E\",\"Lights\",\"^F\",\"quil/core.cljc\",\"^H\",9,\"^I\",\"normal()\",\"^U\",[\"^O\",[[\"^5F\",\"^5G\",\"^5H\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",2803,\"^M\",2809,\"^X\",3,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^5F\",\"^5G\",\"^5H\"]]]]],\"^R\",\"Sets the current normal vector. This is for drawing three\\n  dimensional shapes and surfaces and specifies a vector perpendicular\\n  to the surface of the shape which determines how lighting affects\\n  it. Processing attempts to automatically assign normals to shapes,\\n  but since that's imperfect, this is a better option when you want\\n  more control. This function is identical to glNormal3f() in OpenGL.\"],\"~$perspective\",[\"^ \",\"^A\",\"Lights, Camera\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Lights, Camera\",\"^D\",\"1.0\",\"^E\",\"Camera\",\"^F\",\"^G\",\"^H\",14,\"^15\",[\"^ \",\"^T\",false,\"^X\",4,\"^U\",[\"^O\",[[],[\"~$fovy\",\"~$aspect\",\"~$z-near\",\"~$z-far\"]]],\"^N\",[\"^O\",[[],[\"^;I\",\"^;J\",\"^;K\",\"^;L\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"perspective()\",\"^J\",3,\"^K\",true,\"^L\",2881,\"^M\",2881,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[],[\"^;I\",\"^;J\",\"^;K\",\"^;L\"]]]]],\"^R\",\"Sets a perspective projection applying foreshortening, making\\n  distant objects appear smaller than closer ones. The parameters\\n  define a viewing volume with the shape of truncated pyramid. Objects\\n  near to the front of the volume appear their actual size, while\\n  farther objects appear smaller. This projection simulates the\\n  perspective of the world more accurately than orthographic\\n  projection. The version of perspective without parameters sets the\\n  default perspective and the version with four parameters allows the\\n  programmer to set the area precisely. The default values are:\\n  perspective(PI/3.0, width/height, cameraZ/10.0, cameraZ*10.0) where\\n  cameraZ is ((height/2.0) / tan(PI*60.0/360.0));\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/perspective\",\"^T\",false,\"^E\",\"Camera\",\"^F\",\"quil/core.cljc\",\"^H\",14,\"^15\",[\"^ \",\"^T\",false,\"^X\",4,\"^U\",[\"^O\",[[],[\"^;I\",\"^;J\",\"^;K\",\"^;L\"]]],\"^N\",[\"^O\",[[],[\"^;I\",\"^;J\",\"^;K\",\"^;L\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"perspective()\",\"^U\",[\"^O\",[[],[\"^;I\",\"^;J\",\"^;K\",\"^;L\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",2875,\"^M\",2881,\"^X\",4,\"^Y\",true,\"^N\",[\"^O\",[[],[\"^;I\",\"^;J\",\"^;K\",\"^;L\"]]],\"^R\",\"Sets a perspective projection applying foreshortening, making\\n  distant objects appear smaller than closer ones. The parameters\\n  define a viewing volume with the shape of truncated pyramid. Objects\\n  near to the front of the volume appear their actual size, while\\n  farther objects appear smaller. This projection simulates the\\n  perspective of the world more accurately than orthographic\\n  projection. The version of perspective without parameters sets the\\n  default perspective and the version with four parameters allows the\\n  programmer to set the area precisely. The default values are:\\n  perspective(PI/3.0, width/height, cameraZ/10.0, cameraZ*10.0) where\\n  cameraZ is ((height/2.0) / tan(PI*60.0/360.0));\"],\"~$seconds\",[\"^ \",\"^A\",\"Input\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Input\",\"^D\",\"1.0\",\"^E\",\"Time & Date\",\"^F\",\"^G\",\"^H\",10,\"^I\",\"second()\",\"^J\",3,\"^K\",false,\"^L\",3656,\"^M\",3656,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Returns the current second as a value from 0 - 59.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/seconds\",\"^T\",false,\"^E\",\"Time & Date\",\"^F\",\"quil/core.cljc\",\"^H\",10,\"^I\",\"second()\",\"^U\",[\"^O\",[[]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",false,\"^L\",3650,\"^M\",3656,\"^X\",0,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Returns the current second as a value from 0 - 59.\"],\"~$hint\",[\"^ \",\"^A\",\"Rendering\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Rendering\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^G\",\"^H\",7,\"^I\",\"hint()\",\"^J\",3,\"^3Y\",null,\"^K\",true,\"^L\",1983,\"^M\",1983,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$hint-type\"]]]]],\"^R\",\"Set various hints and hacks for the renderer. This is used to\\n  handle obscure rendering features that cannot be implemented in a\\n  consistent manner across renderers. Many options will often graduate\\n  to standard features instead of hints over time.\\n\\n  Options:\\n\\n  :enable-native-fonts - Use the native version fonts when they are\\n    installed, rather than the bitmapped version from a .vlw\\n    file. This is useful with the default (or JAVA2D) renderer\\n    setting, as it will improve font rendering speed. This is not\\n    enabled by default, because it can be misleading while testing\\n    because the type will look great on your machine (because you have\\n    the font installed) but lousy on others' machines if the identical\\n    font is unavailable. This option can only be set per-sketch, and\\n    must be called before any use of text-font.\\n\\n  :disable-native-fonts - Disables native font support.\\n\\n  :disable-depth-test - Disable the zbuffer, allowing you to draw on\\n    top of everything at will. When depth testing is disabled, items\\n    will be drawn to the screen sequentially, like a painting. This\\n    hint is most often used to draw in 3D, then draw in 2D on top of\\n    it (for instance, to draw GUI controls in 2D on top of a 3D\\n    interface). Starting in release 0149, this will also clear the\\n    depth buffer. Restore the default with :enable-depth-test\\n    but note that with the depth buffer cleared, any 3D drawing that\\n    happens later in draw will ignore existing shapes on the screen.\\n\\n  :enable-depth-test - Enables the zbuffer.\\n\\n  :enable-depth-sort - Enable primitive z-sorting of triangles and\\n    lines in :p3d and :opengl rendering modes. This can slow\\n    performance considerably, and the algorithm is not yet perfect.\\n\\n  :disable-depth-sort - Disables hint :enable-depth-sort\\n\\n  :disable-opengl-errors - Speeds up the OPENGL renderer setting\\n     by not checking for errors while running.\\n\\n  :enable-opengl-errors - Turns on OpenGL error checking\\n\\n  :enable-depth-mask\\n  :disable-depth-mask\\n\\n  :enable-optimized-stroke\\n  :disable-optimized-stroke\\n  :enable-retina-pixels\\n  :disable-retina-pixels\\n  :enable-stroke-perspective\\n  :disable-stroke-perspective\\n  :enable-stroke-pure\\n  :disable-stroke-pure\\n  :enable-texture-mipmaps\\n  :disable-texture-mipmaps\\n\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/hint\",\"^T\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^H\",7,\"^I\",\"hint()\",\"^U\",[\"^O\",[[\"^;Q\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^3Y\",null,\"^K\",true,\"^L\",1976,\"^M\",1983,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^;Q\"]]]]],\"^R\",\"Set various hints and hacks for the renderer. This is used to\\n  handle obscure rendering features that cannot be implemented in a\\n  consistent manner across renderers. Many options will often graduate\\n  to standard features instead of hints over time.\\n\\n  Options:\\n\\n  :enable-native-fonts - Use the native version fonts when they are\\n    installed, rather than the bitmapped version from a .vlw\\n    file. This is useful with the default (or JAVA2D) renderer\\n    setting, as it will improve font rendering speed. This is not\\n    enabled by default, because it can be misleading while testing\\n    because the type will look great on your machine (because you have\\n    the font installed) but lousy on others' machines if the identical\\n    font is unavailable. This option can only be set per-sketch, and\\n    must be called before any use of text-font.\\n\\n  :disable-native-fonts - Disables native font support.\\n\\n  :disable-depth-test - Disable the zbuffer, allowing you to draw on\\n    top of everything at will. When depth testing is disabled, items\\n    will be drawn to the screen sequentially, like a painting. This\\n    hint is most often used to draw in 3D, then draw in 2D on top of\\n    it (for instance, to draw GUI controls in 2D on top of a 3D\\n    interface). Starting in release 0149, this will also clear the\\n    depth buffer. Restore the default with :enable-depth-test\\n    but note that with the depth buffer cleared, any 3D drawing that\\n    happens later in draw will ignore existing shapes on the screen.\\n\\n  :enable-depth-test - Enables the zbuffer.\\n\\n  :enable-depth-sort - Enable primitive z-sorting of triangles and\\n    lines in :p3d and :opengl rendering modes. This can slow\\n    performance considerably, and the algorithm is not yet perfect.\\n\\n  :disable-depth-sort - Disables hint :enable-depth-sort\\n\\n  :disable-opengl-errors - Speeds up the OPENGL renderer setting\\n     by not checking for errors while running.\\n\\n  :enable-opengl-errors - Turns on OpenGL error checking\\n\\n  :enable-depth-mask\\n  :disable-depth-mask\\n\\n  :enable-optimized-stroke\\n  :disable-optimized-stroke\\n  :enable-retina-pixels\\n  :disable-retina-pixels\\n  :enable-stroke-perspective\\n  :disable-stroke-perspective\\n  :enable-stroke-pure\\n  :disable-stroke-pure\\n  :enable-texture-mipmaps\\n  :disable-texture-mipmaps\\n\"],\"~$sphere-detail\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"3D Primitives\",\"^F\",\"^G\",\"^H\",16,\"^15\",[\"^ \",\"^T\",false,\"^X\",2,\"^U\",[\"^O\",[[\"~$res\"],[\"~$ures\",\"~$vres\"]]],\"^N\",[\"^O\",[[\"^;T\"],[\"^;U\",\"^;V\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"sphereDetail()\",\"^J\",3,\"^K\",true,\"^L\",3905,\"^M\",3905,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^;T\"],[\"^;U\",\"^;V\"]]]]],\"^R\",\"Controls the detail used to render a sphere by adjusting the number\\n  of vertices of the sphere mesh. The default resolution is 30, which\\n  creates a fairly detailed sphere definition with vertices every\\n  360/30 = 12 degrees. If you're going to render a great number of\\n  spheres per frame, it is advised to reduce the level of detail using\\n  this function. The setting stays active until sphere-detail is\\n  called again with a new parameter and so should not be called prior\\n  to every sphere statement, unless you wish to render spheres with\\n  different settings, e.g. using less detail for smaller spheres or\\n  ones further away from the camera. To controla the detail of the\\n  horizontal and vertical resolution independently, use the version of\\n  the functions with two parameters.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/sphere-detail\",\"^T\",false,\"^E\",\"3D Primitives\",\"^F\",\"quil/core.cljc\",\"^H\",16,\"^15\",[\"^ \",\"^T\",false,\"^X\",2,\"^U\",[\"^O\",[[\"^;T\"],[\"^;U\",\"^;V\"]]],\"^N\",[\"^O\",[[\"^;T\"],[\"^;U\",\"^;V\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"sphereDetail()\",\"^U\",[\"^O\",[[\"^;T\"],[\"^;U\",\"^;V\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",3899,\"^M\",3905,\"^X\",2,\"^Y\",true,\"^N\",[\"^O\",[[\"^;T\"],[\"^;U\",\"^;V\"]]],\"^R\",\"Controls the detail used to render a sphere by adjusting the number\\n  of vertices of the sphere mesh. The default resolution is 30, which\\n  creates a fairly detailed sphere definition with vertices every\\n  360/30 = 12 degrees. If you're going to render a great number of\\n  spheres per frame, it is advised to reduce the level of detail using\\n  this function. The setting stays active until sphere-detail is\\n  called again with a new parameter and so should not be called prior\\n  to every sphere statement, unless you wish to render spheres with\\n  different settings, e.g. using less detail for smaller spheres or\\n  ones further away from the camera. To controla the detail of the\\n  horizontal and vertical resolution independently, use the version of\\n  the functions with two parameters.\"],\"~$vertex\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"Vertex\",\"^F\",\"^G\",\"^H\",9,\"^15\",[\"^ \",\"^T\",false,\"^X\",5,\"^U\",[\"^O\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"],[\"~$x\",\"~$y\",\"~$u\",\"~$v\"],[\"~$x\",\"~$y\",\"~$z\",\"~$u\",\"~$v\"]]],\"^N\",[\"^O\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"],[\"~$x\",\"~$y\",\"~$u\",\"~$v\"],[\"~$x\",\"~$y\",\"~$z\",\"~$u\",\"~$v\"]]],\"^W\",[\"^O\",[null,null,null,null]]],\"^I\",\"vertex()\",\"^J\",3,\"^K\",true,\"^L\",4552,\"^M\",4552,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"],[\"~$x\",\"~$y\",\"~$u\",\"~$v\"],[\"~$x\",\"~$y\",\"~$z\",\"~$u\",\"~$v\"]]]]],\"^R\",\"All shapes are constructed by connecting a series of\\n  vertices. vertex is used to specify the vertex coordinates for\\n  points, lines, triangles, quads, and polygons and is used\\n  exclusively within the begin-shape and end-shape fns.\\n\\n  Drawing a vertex in 3D using the z parameter requires the :p3d or\\n  :opengl renderers to be used.\\n\\n  This function is also used to map a texture onto the geometry. The\\n  texture fn declares the texture to apply to the geometry and the u\\n  and v coordinates set define the mapping of this texture to the\\n  form. By default, the coordinates used for u and v are specified in\\n  relation to the image's size in pixels, but this relation can be\\n  changed with texture-mode.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/vertex\",\"^T\",false,\"^E\",\"Vertex\",\"^F\",\"quil/core.cljc\",\"^H\",9,\"^15\",[\"^ \",\"^T\",false,\"^X\",5,\"^U\",[\"^O\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"],[\"~$x\",\"~$y\",\"~$u\",\"~$v\"],[\"~$x\",\"~$y\",\"~$z\",\"~$u\",\"~$v\"]]],\"^N\",[\"^O\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"],[\"~$x\",\"~$y\",\"~$u\",\"~$v\"],[\"~$x\",\"~$y\",\"~$z\",\"~$u\",\"~$v\"]]],\"^W\",[\"^O\",[null,null,null,null]]],\"^I\",\"vertex()\",\"^U\",[\"^O\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"],[\"~$x\",\"~$y\",\"~$u\",\"~$v\"],[\"~$x\",\"~$y\",\"~$z\",\"~$u\",\"~$v\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null,null,null]],\"^J\",1,\"^K\",true,\"^L\",4546,\"^M\",4552,\"^X\",5,\"^Y\",true,\"^N\",[\"^O\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"],[\"~$x\",\"~$y\",\"~$u\",\"~$v\"],[\"~$x\",\"~$y\",\"~$z\",\"~$u\",\"~$v\"]]],\"^R\",\"All shapes are constructed by connecting a series of\\n  vertices. vertex is used to specify the vertex coordinates for\\n  points, lines, triangles, quads, and polygons and is used\\n  exclusively within the begin-shape and end-shape fns.\\n\\n  Drawing a vertex in 3D using the z parameter requires the :p3d or\\n  :opengl renderers to be used.\\n\\n  This function is also used to map a texture onto the geometry. The\\n  texture fn declares the texture to apply to the geometry and the u\\n  and v coordinates set define the mapping of this texture to the\\n  form. By default, the coordinates used for u and v are specified in\\n  relation to the image's size in pixels, but this relation can be\\n  changed with texture-mode.\"],\"~$delay-frame\",[\"^ \",\"^A\",\"Structure\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Structure\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^G\",\"^H\",14,\"^I\",\"delay()\",\"^J\",3,\"^3Y\",null,\"^K\",true,\"^L\",1456,\"^M\",1456,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$freeze-ms\"]]]]],\"^R\",\"Forces the program to stop running for a specified time. Delay\\n  times are specified in thousandths of a second, therefore the\\n  function call (delay 3000) will stop the program for three\\n  seconds. Because the screen is updated only at the end of draw,\\n  the program may appear to 'freeze', because the screen will not\\n  update when the delay fn is used. This function has no affect\\n  inside setup.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/delay-frame\",\"^T\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^H\",14,\"^I\",\"delay()\",\"^U\",[\"^O\",[[\"^;[\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^3Y\",null,\"^K\",true,\"^L\",1449,\"^M\",1456,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^;[\"]]]]],\"^R\",\"Forces the program to stop running for a specified time. Delay\\n  times are specified in thousandths of a second, therefore the\\n  function call (delay 3000) will stop the program for three\\n  seconds. Because the screen is updated only at the end of draw,\\n  the program may appear to 'freeze', because the screen will not\\n  update when the delay fn is used. This function has no affect\\n  inside setup.\"],\"~$horizontal-alignment-modes\",[\"^ \",\"^5\",\"~$quil.core$macros/horizontal-alignment-modes\",\"^F\",\"quil/core.cljc\",\"^L\",45,\"^J\",1,\"^M\",66,\"^H\",28,\"^C\",[\"^ \",\"^F\",\"^G\",\"^L\",66,\"^J\",2,\"^M\",66,\"^H\",28]],\"~$spot-light\",[\"^ \",\"^A\",\"Lights, Camera\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Lights, Camera\",\"^D\",\"1.0\",\"^E\",\"Lights\",\"^F\",\"^G\",\"^H\",13,\"^15\",[\"^ \",\"^T\",false,\"^X\",11,\"^U\",[\"^O\",[[\"~$r\",\"~$g\",\"~$b\",\"~$x\",\"~$y\",\"~$z\",\"^5F\",\"^5G\",\"^5H\",\"^Q\",\"~$concentration\"],[[\"~$r\",\"~$g\",\"~$b\"],[\"~$x\",\"~$y\",\"~$z\"],[\"^5F\",\"^5G\",\"^5H\"],\"^Q\",\"^<4\"]]],\"^N\",[\"^O\",[[\"~$r\",\"~$g\",\"~$b\",\"~$x\",\"~$y\",\"~$z\",\"^5F\",\"^5G\",\"^5H\",\"^Q\",\"^<4\"],[[\"~$r\",\"~$g\",\"~$b\"],[\"~$x\",\"~$y\",\"~$z\"],[\"^5F\",\"^5G\",\"^5H\"],\"^Q\",\"^<4\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"spotLight()\",\"^J\",3,\"^K\",true,\"^L\",3927,\"^M\",3927,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$r\",\"~$g\",\"~$b\",\"~$x\",\"~$y\",\"~$z\",\"^5F\",\"^5G\",\"^5H\",\"^Q\",\"^<4\"],[[\"~$r\",\"~$g\",\"~$b\"],[\"~$x\",\"~$y\",\"~$z\"],[\"^5F\",\"^5G\",\"^5H\"],\"^Q\",\"^<4\"]]]]],\"^R\",\"Adds a spot light. Lights need to be included in the draw to\\n  remain persistent in a looping program. Placing them in the setup\\n  of a looping program will cause them to only have an effect the\\n  first time through the loop. The affect of the r, g, and b\\n  parameters is determined by the current color mode. The x, y, and z\\n  parameters specify the position of the light and nx, ny, nz specify\\n  the direction or light. The angle parameter affects angle of the\\n  spotlight cone.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/spot-light\",\"^T\",false,\"^E\",\"Lights\",\"^F\",\"quil/core.cljc\",\"^H\",13,\"^15\",[\"^ \",\"^T\",false,\"^X\",11,\"^U\",[\"^O\",[[\"~$r\",\"~$g\",\"~$b\",\"~$x\",\"~$y\",\"~$z\",\"^5F\",\"^5G\",\"^5H\",\"^Q\",\"^<4\"],[[\"~$r\",\"~$g\",\"~$b\"],[\"~$x\",\"~$y\",\"~$z\"],[\"^5F\",\"^5G\",\"^5H\"],\"^Q\",\"^<4\"]]],\"^N\",[\"^O\",[[\"~$r\",\"~$g\",\"~$b\",\"~$x\",\"~$y\",\"~$z\",\"^5F\",\"^5G\",\"^5H\",\"^Q\",\"^<4\"],[[\"~$r\",\"~$g\",\"~$b\"],[\"~$x\",\"~$y\",\"~$z\"],[\"^5F\",\"^5G\",\"^5H\"],\"^Q\",\"^<4\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"spotLight()\",\"^U\",[\"^O\",[[\"~$r\",\"~$g\",\"~$b\",\"~$x\",\"~$y\",\"~$z\",\"^5F\",\"^5G\",\"^5H\",\"^Q\",\"^<4\"],[[\"~$r\",\"~$g\",\"~$b\"],[\"~$x\",\"~$y\",\"~$z\"],[\"^5F\",\"^5G\",\"^5H\"],\"^Q\",\"^<4\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",3921,\"^M\",3927,\"^X\",11,\"^Y\",true,\"^N\",[\"^O\",[[\"~$r\",\"~$g\",\"~$b\",\"~$x\",\"~$y\",\"~$z\",\"^5F\",\"^5G\",\"^5H\",\"^Q\",\"^<4\"],[[\"~$r\",\"~$g\",\"~$b\"],[\"~$x\",\"~$y\",\"~$z\"],[\"^5F\",\"^5G\",\"^5H\"],\"^Q\",\"^<4\"]]],\"^R\",\"Adds a spot light. Lights need to be included in the draw to\\n  remain persistent in a looping program. Placing them in the setup\\n  of a looping program will cause them to only have an effect the\\n  first time through the loop. The affect of the r, g, and b\\n  parameters is determined by the current color mode. The x, y, and z\\n  parameters specify the position of the light and nx, ny, nz specify\\n  the direction or light. The angle parameter affects angle of the\\n  spotlight cone.\"],\"~$target-frame-rate\",[\"^ \",\"^A\",\"Environment\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Environment\",\"^D\",\"1.5.0\",\"^E\",null,\"^F\",\"^G\",\"^H\",20,\"^J\",3,\"^K\",true,\"^L\",4098,\"^M\",4098,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Returns the target framerate specified with the fn frame-rate\"],\"^D\",\"1.5.0\",\"^5\",\"~$quil.core$macros/target-frame-rate\",\"^T\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^H\",20,\"^U\",[\"^O\",[[]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",4093,\"^M\",4098,\"^X\",0,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Returns the target framerate specified with the fn frame-rate\"],\"~$tint\",[\"^ \",\"^A\",\"Image\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Image\",\"^D\",\"1.0\",\"^E\",\"Loading & Displaying\",\"^F\",\"^G\",\"^H\",7,\"^15\",[\"^ \",\"^T\",false,\"^X\",4,\"^U\",[\"^O\",[[\"^3:\"],[\"^3:\",\"^2?\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^N\",[\"^O\",[[\"^3:\"],[\"^3:\",\"^2?\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^W\",[\"^O\",[null,null,null,null]]],\"^I\",\"tint()\",\"^J\",3,\"^K\",true,\"^L\",4433,\"^M\",4433,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^3:\"],[\"^3:\",\"^2?\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]]]],\"^R\",\"Sets the fill value for displaying images. Images can be tinted to\\n  specified colors or made transparent by setting the alpha.\\n\\n  To make an image transparent, but not change it's color, use white\\n  as the tint color and specify an alpha value. For instance,\\n  tint(255, 128) will make an image 50% transparent (unless\\n  colorMode() has been used).\\n\\n  The value for the parameter gray must be less than or equal to the\\n  current maximum value as specified by colorMode(). The default\\n  maximum value is 255.\\n\\n  Also used to control the coloring of textures in 3D.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/tint\",\"^T\",false,\"^E\",\"Loading & Displaying\",\"^F\",\"quil/core.cljc\",\"^H\",7,\"^15\",[\"^ \",\"^T\",false,\"^X\",4,\"^U\",[\"^O\",[[\"^3:\"],[\"^3:\",\"^2?\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^N\",[\"^O\",[[\"^3:\"],[\"^3:\",\"^2?\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^W\",[\"^O\",[null,null,null,null]]],\"^I\",\"tint()\",\"^U\",[\"^O\",[[\"^3:\"],[\"^3:\",\"^2?\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null,null,null]],\"^J\",1,\"^K\",true,\"^L\",4427,\"^M\",4433,\"^X\",4,\"^Y\",true,\"^N\",[\"^O\",[[\"^3:\"],[\"^3:\",\"^2?\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^R\",\"Sets the fill value for displaying images. Images can be tinted to\\n  specified colors or made transparent by setting the alpha.\\n\\n  To make an image transparent, but not change it's color, use white\\n  as the tint color and specify an alpha value. For instance,\\n  tint(255, 128) will make an image 50% transparent (unless\\n  colorMode() has been used).\\n\\n  The value for the parameter gray must be less than or equal to the\\n  current maximum value as specified by colorMode(). The default\\n  maximum value is 255.\\n\\n  Also used to control the coloring of textures in 3D.\"],\"~$bezier-tangent\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"Curves\",\"^F\",\"^G\",\"^H\",17,\"^I\",\"bezierTangent()\",\"^J\",3,\"^K\",true,\"^L\",722,\"^M\",722,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$t\"]]]]],\"^R\",\"Calculates the tangent of a point on a Bezier curve.\\n  (See http://en.wikipedia.org/wiki/Tangent)\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/bezier-tangent\",\"^T\",false,\"^E\",\"Curves\",\"^F\",\"quil/core.cljc\",\"^H\",17,\"^I\",\"bezierTangent()\",\"^U\",[\"^O\",[[\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$t\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",716,\"^M\",722,\"^X\",5,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$t\"]]]]],\"^R\",\"Calculates the tangent of a point on a Bezier curve.\\n  (See http://en.wikipedia.org/wiki/Tangent)\"],\"~$asin\",[\"^ \",\"^A\",\"Math\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Math\",\"^D\",\"1.0\",\"^E\",\"Trigonometry\",\"^F\",\"^G\",\"^H\",7,\"^I\",\"asin()\",\"^J\",3,\"^K\",false,\"^L\",444,\"^M\",444,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$n\"]]]]],\"^R\",\"The inverse of sin, returns the arc sine of a value. This function\\n  expects the values in the range of -1 to 1 and values are returned\\n  in the range -PI/2 to PI/2.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/asin\",\"^T\",false,\"^E\",\"Trigonometry\",\"^F\",\"quil/core.cljc\",\"^H\",7,\"^I\",\"asin()\",\"^U\",[\"^O\",[[\"~$n\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",false,\"^L\",438,\"^M\",444,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$n\"]]]]],\"^R\",\"The inverse of sin, returns the arc sine of a value. This function\\n  expects the values in the range of -1 to 1 and values are returned\\n  in the range -PI/2 to PI/2.\"],\"~$lerp\",[\"^ \",\"^A\",\"Math\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Math\",\"^D\",\"1.0\",\"^E\",\"Calculation\",\"^F\",\"^G\",\"^H\",7,\"^I\",\"lerp()\",\"^J\",3,\"^K\",false,\"^L\",2267,\"^M\",2267,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^7M\",\"^7N\",\"^2B\"]]]]],\"^R\",\"Calculates a number between two numbers at a specific\\n  increment. The amt parameter is the amount to interpolate between\\n  the two values where 0.0 equal to the first point, 0.1 is very near\\n  the first point, 0.5 is half-way in between, etc. The lerp function\\n  is convenient for creating motion along a straight path and for\\n  drawing dotted lines.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/lerp\",\"^T\",false,\"^E\",\"Calculation\",\"^F\",\"quil/core.cljc\",\"^H\",7,\"^I\",\"lerp()\",\"^U\",[\"^O\",[[\"^7M\",\"^7N\",\"^2B\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",false,\"^L\",2261,\"^M\",2267,\"^X\",3,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^7M\",\"^7N\",\"^2B\"]]]]],\"^R\",\"Calculates a number between two numbers at a specific\\n  increment. The amt parameter is the amount to interpolate between\\n  the two values where 0.0 equal to the first point, 0.1 is very near\\n  the first point, 0.5 is half-way in between, etc. The lerp function\\n  is convenient for creating motion along a straight path and for\\n  drawing dotted lines.\"],\"~$unhex\",[\"^ \",\"^A\",\"Data\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Data\",\"^4@\",false,\"^E\",\"Conversion\",\"^F\",\"^G\",\"^H\",8,\"^I\",\"hex()\",\"^J\",3,\"^L\",4510,\"^M\",4510,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$hex-str\"]]]]],\"^R\",\"Converts a String representation of a hexadecimal number to its\\n  equivalent integer value.\"],\"^4@\",false,\"^5\",\"~$quil.core$macros/unhex\",\"^T\",false,\"^E\",\"Conversion\",\"^F\",\"quil/core.cljc\",\"^H\",8,\"^I\",\"hex()\",\"^U\",[\"^O\",[[\"^<A\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^L\",4505,\"^M\",4510,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^<A\"]]]]],\"^R\",\"Converts a String representation of a hexadecimal number to its\\n  equivalent integer value.\"],\"~$begin-camera\",[\"^ \",\"^A\",\"Lights, Camera\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Lights, Camera\",\"^D\",\"1.0\",\"^E\",\"Camera\",\"^F\",\"^G\",\"^H\",15,\"^I\",\"beginCamera()\",\"^J\",3,\"^K\",true,\"^L\",585,\"^M\",585,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Sets the matrix mode to the camera matrix so calls such as\\n  translate, rotate, apply-matrix and reset-matrix affect the\\n  camera. begin-camera should always be used with a following\\n  end-camera and pairs of begin-camera and end-camera cannot be\\n  nested.\\n\\n  For most situations the camera function will be sufficient.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/begin-camera\",\"^T\",false,\"^E\",\"Camera\",\"^F\",\"quil/core.cljc\",\"^H\",15,\"^I\",\"beginCamera()\",\"^U\",[\"^O\",[[]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",579,\"^M\",585,\"^X\",0,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Sets the matrix mode to the camera matrix so calls such as\\n  translate, rotate, apply-matrix and reset-matrix affect the\\n  camera. begin-camera should always be used with a following\\n  end-camera and pairs of begin-camera and end-camera cannot be\\n  nested.\\n\\n  For most situations the camera function will be sufficient.\"],\"~$text-num\",[\"^ \",\"^A\",\"Typography\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Typography\",\"^D\",\"1.0\",\"^E\",\"Loading & Displaying\",\"^F\",\"^G\",\"^H\",11,\"^15\",[\"^ \",\"^T\",false,\"^X\",4,\"^U\",[\"^O\",[[\"^9K\",\"~$x\",\"~$y\"],[\"^9K\",\"~$x\",\"~$y\",\"~$z\"]]],\"^N\",[\"^O\",[[\"^9K\",\"~$x\",\"~$y\"],[\"^9K\",\"~$x\",\"~$y\",\"~$z\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"text()\",\"^J\",3,\"^K\",true,\"^L\",4132,\"^M\",4132,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^9K\",\"~$x\",\"~$y\"],[\"^9K\",\"~$x\",\"~$y\",\"~$z\"]]]]],\"^R\",\"Draws a number to the screen in the specified position. See text fn\\n  for more details.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/text-num\",\"^T\",false,\"^E\",\"Loading & Displaying\",\"^F\",\"quil/core.cljc\",\"^H\",11,\"^15\",[\"^ \",\"^T\",false,\"^X\",4,\"^U\",[\"^O\",[[\"^9K\",\"~$x\",\"~$y\"],[\"^9K\",\"~$x\",\"~$y\",\"~$z\"]]],\"^N\",[\"^O\",[[\"^9K\",\"~$x\",\"~$y\"],[\"^9K\",\"~$x\",\"~$y\",\"~$z\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"text()\",\"^U\",[\"^O\",[[\"^9K\",\"~$x\",\"~$y\"],[\"^9K\",\"~$x\",\"~$y\",\"~$z\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",4126,\"^M\",4132,\"^X\",4,\"^Y\",true,\"^N\",[\"^O\",[[\"^9K\",\"~$x\",\"~$y\"],[\"^9K\",\"~$x\",\"~$y\",\"~$z\"]]],\"^R\",\"Draws a number to the screen in the specified position. See text fn\\n  for more details.\"],\"~$round\",[\"^ \",\"^A\",\"Math\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Math\",\"^D\",\"1.0\",\"^E\",\"Calculation\",\"^F\",\"^G\",\"^H\",8,\"^I\",\"round()\",\"^J\",3,\"^K\",false,\"^L\",3499,\"^M\",3499,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^2Q\"]]]]],\"^R\",\"Calculates the integer closest to the value parameter. For example,\\n  (round 9.2) returns the value 9.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/round\",\"^T\",false,\"^E\",\"Calculation\",\"^F\",\"quil/core.cljc\",\"^H\",8,\"^I\",\"round()\",\"^U\",[\"^O\",[[\"^2Q\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",false,\"^L\",3493,\"^M\",3499,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^2Q\"]]]]],\"^R\",\"Calculates the integer closest to the value parameter. For example,\\n  (round 9.2) returns the value 9.\"],\"~$background-image\",[\"^ \",\"^A\",\"Color\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Color\",\"^D\",\"1.0\",\"^E\",\"Setting\",\"^F\",\"^G\",\"^H\",19,\"^I\",\"background()\",\"^J\",3,\"^K\",true,\"^L\",572,\"^M\",572,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^1Z\"]]]]],\"^R\",\"Specify an image to be used as the background for a sketch. Its\\n  width and height must be the same size as the sketch window. Images\\n  used as background will ignore the current tint setting.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/background-image\",\"^T\",false,\"^E\",\"Setting\",\"^F\",\"quil/core.cljc\",\"^H\",19,\"^I\",\"background()\",\"^U\",[\"^O\",[[\"^1Z\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",566,\"^M\",572,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^1Z\"]]]]],\"^R\",\"Specify an image to be used as the background for a sketch. Its\\n  width and height must be the same size as the sketch window. Images\\n  used as background will ignore the current tint setting.\"],\"~$load-shape\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"Loading & Displaying\",\"^F\",\"^G\",\"^H\",13,\"^I\",\"loadShape()\",\"^J\",3,\"^K\",true,\"^L\",2417,\"^M\",2417,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^4M\"]]]]],\"^R\",\"Load a geometry from a file as a PShape.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/load-shape\",\"^T\",false,\"^E\",\"Loading & Displaying\",\"^F\",\"quil/core.cljc\",\"^H\",13,\"^I\",\"loadShape()\",\"^U\",[\"^O\",[[\"^4M\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",2411,\"^M\",2417,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^4M\"]]]]],\"^R\",\"Load a geometry from a file as a PShape.\"],\"~$vertical-alignment-modes\",[\"^ \",\"^5\",\"~$quil.core$macros/vertical-alignment-modes\",\"^F\",\"quil/core.cljc\",\"^L\",45,\"^J\",1,\"^M\",67,\"^H\",26,\"^C\",[\"^ \",\"^F\",\"^G\",\"^L\",67,\"^J\",2,\"^M\",67,\"^H\",26]],\"~$blend-color\",[\"^ \",\"^A\",\"Color\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Color\",\"^D\",\"1.0\",\"^E\",\"Creating & Reading\",\"^F\",\"^G\",\"^H\",14,\"^I\",\"blendColor()\",\"^J\",3,\"^3Y\",null,\"^K\",false,\"^L\",828,\"^M\",828,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^3E\",\"^3F\",\"^18\"]]]]],\"^R\",\"Blends two color values together based on the blending mode given specified\\n  with the mode keyword.\\n\\n  Available blend modes are:\\n\\n  :blend      - linear interpolation of colours: C = A*factor + B\\n  :add        - additive blending with white clip:\\n                                            C = min(A*factor + B, 255)\\n  :subtract   - subtractive blending with black clip:\\n                                            C = max(B - A*factor, 0)\\n  :darkest    - only the darkest colour succeeds:\\n                                            C = min(A*factor, B)\\n  :lightest   - only the lightest colour succeeds:\\n                                            C = max(A*factor, B)\\n  :difference - subtract colors from underlying image.\\n  :exclusion  - similar to :difference, but less extreme.\\n  :multiply   - Multiply the colors, result will always be darker.\\n  :screen     - Opposite multiply, uses inverse values of the colors.\\n  :overlay    - A mix of :multiply and :screen. Multiplies dark values\\n                and screens light values.\\n  :hard-light - :screen when greater than 50% gray, :multiply when\\n                lower.\\n  :soft-light - Mix of :darkest and :lightest. Works like :overlay,\\n                but not as harsh.\\n  :dodge      - Lightens light tones and increases contrast, ignores\\n                darks.\\n                Called \\\"Color Dodge\\\" in Illustrator and Photoshop.\\n  :burn       - Darker areas are applied, increasing contrast, ignores\\n                lights. Called \\\"Color Burn\\\" in Illustrator and\\n                Photoshop.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/blend-color\",\"^T\",false,\"^E\",\"Creating & Reading\",\"^F\",\"quil/core.cljc\",\"^H\",14,\"^I\",\"blendColor()\",\"^U\",[\"^O\",[[\"^3E\",\"^3F\",\"^18\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^3Y\",null,\"^K\",false,\"^L\",821,\"^M\",828,\"^X\",3,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^3E\",\"^3F\",\"^18\"]]]]],\"^R\",\"Blends two color values together based on the blending mode given specified\\n  with the mode keyword.\\n\\n  Available blend modes are:\\n\\n  :blend      - linear interpolation of colours: C = A*factor + B\\n  :add        - additive blending with white clip:\\n                                            C = min(A*factor + B, 255)\\n  :subtract   - subtractive blending with black clip:\\n                                            C = max(B - A*factor, 0)\\n  :darkest    - only the darkest colour succeeds:\\n                                            C = min(A*factor, B)\\n  :lightest   - only the lightest colour succeeds:\\n                                            C = max(A*factor, B)\\n  :difference - subtract colors from underlying image.\\n  :exclusion  - similar to :difference, but less extreme.\\n  :multiply   - Multiply the colors, result will always be darker.\\n  :screen     - Opposite multiply, uses inverse values of the colors.\\n  :overlay    - A mix of :multiply and :screen. Multiplies dark values\\n                and screens light values.\\n  :hard-light - :screen when greater than 50% gray, :multiply when\\n                lower.\\n  :soft-light - Mix of :darkest and :lightest. Works like :overlay,\\n                but not as harsh.\\n  :dodge      - Lightens light tones and increases contrast, ignores\\n                darks.\\n                Called \\\"Color Dodge\\\" in Illustrator and Photoshop.\\n  :burn       - Darker areas are applied, increasing contrast, ignores\\n                lights. Called \\\"Color Burn\\\" in Illustrator and\\n                Photoshop.\"],\"~$QUARTER-PI\",[\"^ \",\"^5\",\"~$quil.core$macros/QUARTER-PI\",\"^F\",\"quil/core.cljc\",\"^L\",79,\"^J\",1,\"^M\",79,\"^H\",16,\"^C\",[\"^ \",\"^F\",\"^G\",\"^L\",79,\"^J\",6,\"^M\",79,\"^H\",16]],\"~$stroke-cap\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"Attributes\",\"^F\",\"^G\",\"^H\",13,\"^I\",\"strokeCap()\",\"^J\",3,\"^K\",true,\"^L\",4036,\"^M\",4036,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$cap-mode\"]]]]],\"^R\",\"Sets the style for rendering line endings. These ends are either\\n  squared, extended, or rounded and specified with the corresponding\\n  parameters :square, :project, and :round. The default cap is :round.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/stroke-cap\",\"^T\",false,\"^E\",\"Attributes\",\"^F\",\"quil/core.cljc\",\"^H\",13,\"^I\",\"strokeCap()\",\"^U\",[\"^O\",[[\"^<T\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",4030,\"^M\",4036,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^<T\"]]]]],\"^R\",\"Sets the style for rendering line endings. These ends are either\\n  squared, extended, or rounded and specified with the corresponding\\n  parameters :square, :project, and :round. The default cap is :round.\"],\"~$blend-modes\",[\"^ \",\"^5\",\"~$quil.core$macros/blend-modes\",\"^F\",\"quil/core.cljc\",\"^L\",45,\"^J\",1,\"^M\",48,\"^H\",13,\"^C\",[\"^ \",\"^F\",\"^G\",\"^L\",48,\"^J\",2,\"^M\",48,\"^H\",13]],\"~$no-fill\",[\"^ \",\"^A\",\"Color\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Color\",\"^D\",\"1.0\",\"^E\",\"Setting\",\"^F\",\"^G\",\"^H\",10,\"^I\",\"noFill()\",\"^J\",3,\"^K\",true,\"^L\",2664,\"^M\",2664,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Disables filling geometry. If both no-stroke and no-fill are called,\\n  nothing will be drawn to the screen.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/no-fill\",\"^T\",false,\"^E\",\"Setting\",\"^F\",\"quil/core.cljc\",\"^H\",10,\"^I\",\"noFill()\",\"^U\",[\"^O\",[[]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",2658,\"^M\",2664,\"^X\",0,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Disables filling geometry. If both no-stroke and no-fill are called,\\n  nothing will be drawn to the screen.\"],\"~$year\",[\"^ \",\"^A\",\"Input\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Input\",\"^D\",\"1.0\",\"^E\",\"Time & Date\",\"^F\",\"^G\",\"^H\",7,\"^I\",\"year()\",\"^J\",3,\"^K\",false,\"^L\",4579,\"^M\",4579,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Returns the current year as an integer (2003, 2004, 2005, etc).\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/year\",\"^T\",false,\"^E\",\"Time & Date\",\"^F\",\"quil/core.cljc\",\"^H\",7,\"^I\",\"year()\",\"^U\",[\"^O\",[[]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",false,\"^L\",4573,\"^M\",4579,\"^X\",0,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Returns the current year as an integer (2003, 2004, 2005, etc).\"],\"~$key-coded?\",[\"^ \",\"^A\",\"Input\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Input\",\"^D\",\"1.6\",\"^E\",\"Keyboard\",\"^F\",\"^G\",\"^H\",13,\"^I\",null,\"^J\",3,\"^K\",false,\"^L\",4859,\"^M\",4859,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$c\"]]]]],\"^R\",\"Returns true if char c is a 'coded' char i.e. it is necessary to\\n  fetch the key-code as an integer and use that to determine the\\n  specific key pressed. See key-keyword.\"],\"^D\",\"1.6\",\"^5\",\"~$quil.core$macros/key-coded?\",\"^T\",false,\"^E\",\"Keyboard\",\"^F\",\"quil/core.cljc\",\"^H\",13,\"^I\",null,\"^U\",[\"^O\",[[\"~$c\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",false,\"^L\",4854,\"^M\",4859,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$c\"]]]]],\"^R\",\"Returns true if char c is a 'coded' char i.e. it is necessary to\\n  fetch the key-code as an integer and use that to determine the\\n  specific key pressed. See key-keyword.\"],\"~$curve-tangent\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"Curves\",\"^F\",\"^G\",\"^H\",16,\"^I\",\"curveTangent()\",\"^J\",3,\"^K\",true,\"^L\",1377,\"^M\",1377,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$t\"]]]]],\"^R\",\"Calculates the tangent of a point on a curve.\\n  See: http://en.wikipedia.org/wiki/Tangent\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/curve-tangent\",\"^T\",false,\"^E\",\"Curves\",\"^F\",\"quil/core.cljc\",\"^H\",16,\"^I\",\"curveTangent()\",\"^U\",[\"^O\",[[\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$t\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",1371,\"^M\",1377,\"^X\",5,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$t\"]]]]],\"^R\",\"Calculates the tangent of a point on a curve.\\n  See: http://en.wikipedia.org/wiki/Tangent\"],\"~$ellipse-modes\",[\"^ \",\"^5\",\"~$quil.core$macros/ellipse-modes\",\"^F\",\"quil/core.cljc\",\"^L\",45,\"^J\",1,\"^M\",52,\"^H\",15,\"^C\",[\"^ \",\"^F\",\"^G\",\"^L\",52,\"^J\",2,\"^M\",52,\"^H\",15]],\"~$pmouse-y\",[\"^ \",\"^A\",\"Input\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Input\",\"^D\",\"1.0\",\"^E\",\"Mouse\",\"^F\",\"^G\",\"^H\",11,\"^I\",\"pmouseY\",\"^J\",3,\"^K\",true,\"^L\",2956,\"^M\",2956,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Vertical coordinate of the mouse in the previous frame\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/pmouse-y\",\"^T\",false,\"^E\",\"Mouse\",\"^F\",\"quil/core.cljc\",\"^H\",11,\"^I\",\"pmouseY\",\"^U\",[\"^O\",[[]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",2950,\"^M\",2956,\"^X\",0,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Vertical coordinate of the mouse in the previous frame\"],\"~$hex\",[\"^ \",\"^A\",\"Data\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Data\",\"^4@\",false,\"^E\",\"Conversion\",\"^F\",\"^G\",\"^H\",6,\"^15\",[\"^ \",\"^T\",false,\"^X\",2,\"^U\",[\"^O\",[[\"^2Q\"],[\"^2Q\",\"^4A\"]]],\"^N\",[\"^O\",[[\"^2Q\"],[\"^2Q\",\"^4A\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"hex()\",\"^J\",3,\"^L\",1951,\"^M\",1951,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^2Q\"],[\"^2Q\",\"^4A\"]]]]],\"^R\",\"Converts a byte, char, int, or color to a String containing the\\n  equivalent hexadecimal notation. For example color(0, 102, 153) will\\n  convert to the String \\\"FF006699\\\". This function can help make your\\n  geeky debugging sessions much happier. \"],\"^4@\",false,\"^5\",\"~$quil.core$macros/hex\",\"^T\",false,\"^E\",\"Conversion\",\"^F\",\"quil/core.cljc\",\"^H\",6,\"^15\",[\"^ \",\"^T\",false,\"^X\",2,\"^U\",[\"^O\",[[\"^2Q\"],[\"^2Q\",\"^4A\"]]],\"^N\",[\"^O\",[[\"^2Q\"],[\"^2Q\",\"^4A\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"hex()\",\"^U\",[\"^O\",[[\"^2Q\"],[\"^2Q\",\"^4A\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^L\",1946,\"^M\",1951,\"^X\",2,\"^Y\",true,\"^N\",[\"^O\",[[\"^2Q\"],[\"^2Q\",\"^4A\"]]],\"^R\",\"Converts a byte, char, int, or color to a String containing the\\n  equivalent hexadecimal notation. For example color(0, 102, 153) will\\n  convert to the String \\\"FF006699\\\". This function can help make your\\n  geeky debugging sessions much happier. \"],\"~$with-fill\",[\"^ \",\"^A\",\"Color\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Color\",\"^D\",\"1.7\",\"^E\",\"Utility Macros\",\"^F\",\"^G\",\"^H\",13,\"^15\",[\"^ \",\"^T\",true,\"^X\",3,\"^U\",[[\"^O\",[\"^1L\",\"^1M\",\"~$fill-args\",\"^1O\"]]],\"^N\",[\"^O\",[[\"^1L\",\"^1M\",\"^=;\",\"~$&\",\"^1O\"]]],\"^W\",[\"^O\",[null]]],\"^I\",null,\"^J\",4,\"^K\",true,\"^L\",4604,\"^1P\",true,\"^M\",4604,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^=;\",\"~$&\",\"^1O\"]]]]],\"^R\",\"Temporarily set the fill color for the body of this macro.\\n   The code outside of with-fill form will have the previous fill color set.\\n\\n   The fill color has to be in a vector!\\n   Example: (with-fill [255] ...)\\n            (with-fill [10 80 98] ...)\"],\"^D\",\"1.7\",\"^5\",\"~$quil.core$macros/with-fill\",\"^T\",true,\"^E\",\"Utility Macros\",\"^F\",\"quil/core.cljc\",\"^H\",13,\"^15\",[\"^ \",\"^T\",true,\"^X\",3,\"^U\",[[\"^O\",[\"^1L\",\"^1M\",\"^=;\",\"^1O\"]]],\"^N\",[\"^O\",[[\"^1L\",\"^1M\",\"^=;\",\"~$&\",\"^1O\"]]],\"^W\",[\"^O\",[null]]],\"^I\",null,\"^U\",[[\"^O\",[\"^1L\",\"^1M\",\"^=;\",\"^1O\"]]],\"^V\",null,\"^W\",[\"^O\",[null]],\"^J\",1,\"^K\",true,\"^L\",4598,\"^1P\",true,\"^M\",4604,\"^X\",3,\"^Y\",false,\"^N\",[\"^O\",[[\"^1L\",\"^1M\",\"^=;\",\"~$&\",\"^1O\"]]],\"^R\",\"Temporarily set the fill color for the body of this macro.\\n   The code outside of with-fill form will have the previous fill color set.\\n\\n   The fill color has to be in a vector!\\n   Example: (with-fill [255] ...)\\n            (with-fill [10 80 98] ...)\"],\"~$no-cursor\",[\"^ \",\"^A\",\"Environment\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Environment\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^G\",\"^H\",12,\"^I\",\"noCursor()\",\"^J\",3,\"^K\",true,\"^L\",2652,\"^M\",2652,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Hides the cursor from view. Will not work when running the in full\\n  screen (Present) mode.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/no-cursor\",\"^T\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^H\",12,\"^I\",\"noCursor()\",\"^U\",[\"^O\",[[]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",2646,\"^M\",2652,\"^X\",0,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Hides the cursor from view. Will not work when running the in full\\n  screen (Present) mode.\"],\"~$create-font\",[\"^ \",\"^A\",\"Typography\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Typography\",\"^D\",\"1.0\",\"^E\",\"Loading & Displaying\",\"^F\",\"^G\",\"^H\",14,\"^15\",[\"^ \",\"^T\",false,\"^X\",4,\"^U\",[\"^O\",[[\"^:Q\",\"^29\"],[\"^:Q\",\"^29\",\"^5<\"],[\"^:Q\",\"^29\",\"^5<\",\"~$charset\"]]],\"^N\",[\"^O\",[[\"^:Q\",\"^29\"],[\"^:Q\",\"^29\",\"^5<\"],[\"^:Q\",\"^29\",\"^5<\",\"^=@\"]]],\"^W\",[\"^O\",[null,null,null]]],\"^I\",\"createFont()\",\"^J\",3,\"^K\",true,\"^L\",1167,\"^M\",1167,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^:Q\",\"^29\"],[\"^:Q\",\"^29\",\"^5<\"],[\"^:Q\",\"^29\",\"^5<\",\"^=@\"]]]]],\"^R\",\"Dynamically converts a font to the format used by Processing (a\\n  PFont) from either a font name that's installed on the computer, or\\n  from a .ttf or .otf file inside the sketches 'data' folder. This\\n  function is an advanced feature for precise control.\\n\\n  Use available-fonts to obtain the names for the fonts recognized by\\n  the computer and are compatible with this function.\\n\\n  The size parameter states the font size you want to generate. The\\n  smooth parameter specifies if the font should be antialiased or not,\\n  and the charset parameter is an array of chars that specifies the\\n  characters to generate.\\n\\n  This function creates a bitmapped version of a font It loads a font\\n  by name, and converts it to a series of images based on the size of\\n  the font. When possible, the text function will use a native font\\n  rather than the bitmapped version created behind the scenes with\\n  create-font. For instance, when using the default renderer\\n  setting (JAVA2D), the actual native version of the font will be\\n  employed by the sketch, improving drawing quality and\\n  performance. With the :p2d, :p3d, and :opengl renderer settings, the\\n  bitmapped version will be used. While this can drastically improve\\n  speed and appearance, results are poor when exporting if the sketch\\n  does not include the .otf or .ttf file, and the requested font is\\n  not available on the machine running the sketch.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/create-font\",\"^T\",false,\"^E\",\"Loading & Displaying\",\"^F\",\"quil/core.cljc\",\"^H\",14,\"^15\",[\"^ \",\"^T\",false,\"^X\",4,\"^U\",[\"^O\",[[\"^:Q\",\"^29\"],[\"^:Q\",\"^29\",\"^5<\"],[\"^:Q\",\"^29\",\"^5<\",\"^=@\"]]],\"^N\",[\"^O\",[[\"^:Q\",\"^29\"],[\"^:Q\",\"^29\",\"^5<\"],[\"^:Q\",\"^29\",\"^5<\",\"^=@\"]]],\"^W\",[\"^O\",[null,null,null]]],\"^I\",\"createFont()\",\"^U\",[\"^O\",[[\"^:Q\",\"^29\"],[\"^:Q\",\"^29\",\"^5<\"],[\"^:Q\",\"^29\",\"^5<\",\"^=@\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null,null]],\"^J\",1,\"^K\",true,\"^L\",1161,\"^M\",1167,\"^X\",4,\"^Y\",true,\"^N\",[\"^O\",[[\"^:Q\",\"^29\"],[\"^:Q\",\"^29\",\"^5<\"],[\"^:Q\",\"^29\",\"^5<\",\"^=@\"]]],\"^R\",\"Dynamically converts a font to the format used by Processing (a\\n  PFont) from either a font name that's installed on the computer, or\\n  from a .ttf or .otf file inside the sketches 'data' folder. This\\n  function is an advanced feature for precise control.\\n\\n  Use available-fonts to obtain the names for the fonts recognized by\\n  the computer and are compatible with this function.\\n\\n  The size parameter states the font size you want to generate. The\\n  smooth parameter specifies if the font should be antialiased or not,\\n  and the charset parameter is an array of chars that specifies the\\n  characters to generate.\\n\\n  This function creates a bitmapped version of a font It loads a font\\n  by name, and converts it to a series of images based on the size of\\n  the font. When possible, the text function will use a native font\\n  rather than the bitmapped version created behind the scenes with\\n  create-font. For instance, when using the default renderer\\n  setting (JAVA2D), the actual native version of the font will be\\n  employed by the sketch, improving drawing quality and\\n  performance. With the :p2d, :p3d, and :opengl renderer settings, the\\n  bitmapped version will be used. While this can drastically improve\\n  speed and appearance, results are poor when exporting if the sketch\\n  does not include the .otf or .ttf file, and the requested font is\\n  not available on the machine running the sketch.\"],\"~$current-graphics\",[\"^ \",\"^A\",\"Environment\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Environment\",\"^D\",\"2.0\",\"^E\",null,\"^F\",\"^G\",\"^H\",19,\"^J\",3,\"^K\",true,\"^L\",32,\"^M\",32,\"~:tag\",\"~$PGraphics\",\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Graphics currently used for drawing. By default it is sketch graphics,\\n  but if called inside with-graphics macro - graphics passed to the macro\\n  is returned. This method should be used if you need to call some methods\\n  that are not implemented by quil. Example:\\n  (.beginDraw (current-graphics)).\"],\"^D\",\"2.0\",\"^5\",\"~$quil.core$macros/current-graphics\",\"^T\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^H\",19,\"^U\",[\"^O\",[[]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",26,\"~:ret-tag\",\"^=D\",\"^M\",32,\"^X\",0,\"^=C\",\"^=D\",\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Graphics currently used for drawing. By default it is sketch graphics,\\n  but if called inside with-graphics macro - graphics passed to the macro\\n  is returned. This method should be used if you need to call some methods\\n  that are not implemented by quil. Example:\\n  (.beginDraw (current-graphics)).\"],\"~$abs\",[\"^ \",\"^A\",\"Math\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Math\",\"^D\",\"1.0\",\"^E\",\"Calculation\",\"^F\",\"^G\",\"^H\",6,\"^I\",\"abs()\",\"^J\",3,\"^K\",false,\"^L\",281,\"^M\",281,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$n\"]]]]],\"^R\",\"Calculates the absolute value (magnitude) of a number. The\\n  absolute value of a number is always positive. Dynamically casts to\\n  an int or float appropriately\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/abs\",\"^T\",false,\"^E\",\"Calculation\",\"^F\",\"quil/core.cljc\",\"^H\",6,\"^I\",\"abs()\",\"^U\",[\"^O\",[[\"~$n\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",false,\"^L\",275,\"^M\",281,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$n\"]]]]],\"^R\",\"Calculates the absolute value (magnitude) of a number. The\\n  absolute value of a number is always positive. Dynamically casts to\\n  an int or float appropriately\"],\"~$pop-style\",[\"^ \",\"^A\",\"Structure\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Structure\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^G\",\"^H\",12,\"^I\",\"popStyle()\",\"^J\",3,\"^K\",true,\"^L\",3016,\"^M\",3016,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Restores the prior settings on the 'style stack'. Used in\\n  conjunction with push-style. Together they allow you to change the\\n  style settings and later return to what you had. When a new style is\\n  started with push-style, it builds on the current style information.\\n  The push-style and pop-style functions can be nested to provide more\\n  control\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/pop-style\",\"^T\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^H\",12,\"^I\",\"popStyle()\",\"^U\",[\"^O\",[[]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",3010,\"^M\",3016,\"^X\",0,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Restores the prior settings on the 'style stack'. Used in\\n  conjunction with push-style. Together they allow you to change the\\n  style settings and later return to what you had. When a new style is\\n  started with push-style, it builds on the current style information.\\n  The push-style and pop-style functions can be nested to provide more\\n  control\"],\"~$focused\",[\"^ \",\"^A\",\"Environment\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Environment\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^G\",\"^H\",10,\"^I\",\"focused\",\"^J\",3,\"^K\",true,\"^L\",1843,\"^M\",1843,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Returns a boolean value representing whether the applet has focus.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/focused\",\"^T\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^H\",10,\"^I\",\"focused\",\"^U\",[\"^O\",[[]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",1837,\"^M\",1843,\"^X\",0,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Returns a boolean value representing whether the applet has focus.\"],\"~$background-float\",[\"^ \",\"^A\",\"Color\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Color\",\"^D\",\"1.0\",\"^E\",\"Setting\",\"^F\",\"^G\",\"^H\",19,\"^15\",[\"^ \",\"^T\",false,\"^X\",4,\"^U\",[\"^O\",[[\"^2>\"],[\"^2>\",\"^2?\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^N\",[\"^O\",[[\"^2>\"],[\"^2>\",\"^2?\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^W\",[\"^O\",[null,null,null,null]]],\"^I\",\"background()\",\"^J\",3,\"^K\",true,\"^L\",512,\"^M\",512,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^2>\"],[\"^2>\",\"^2?\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]]]],\"^R\",\"Sets the color used for the background of the Processing\\n  window. The default background is light gray. In the draw function,\\n  the background color is used to clear the display window at the\\n  beginning of each frame.\\n\\n  It is not possible to use transparency (alpha) in background colors\\n  with the main drawing surface, however they will work properly with\\n  create-graphics. Converts args to floats.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/background-float\",\"^T\",false,\"^E\",\"Setting\",\"^F\",\"quil/core.cljc\",\"^H\",19,\"^15\",[\"^ \",\"^T\",false,\"^X\",4,\"^U\",[\"^O\",[[\"^2>\"],[\"^2>\",\"^2?\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^N\",[\"^O\",[[\"^2>\"],[\"^2>\",\"^2?\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^W\",[\"^O\",[null,null,null,null]]],\"^I\",\"background()\",\"^U\",[\"^O\",[[\"^2>\"],[\"^2>\",\"^2?\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null,null,null]],\"^J\",1,\"^K\",true,\"^L\",506,\"^M\",512,\"^X\",4,\"^Y\",true,\"^N\",[\"^O\",[[\"^2>\"],[\"^2>\",\"^2?\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^R\",\"Sets the color used for the background of the Processing\\n  window. The default background is light gray. In the draw function,\\n  the background color is used to clear the display window at the\\n  beginning of each frame.\\n\\n  It is not possible to use transparency (alpha) in background colors\\n  with the main drawing surface, however they will work properly with\\n  create-graphics. Converts args to floats.\"],\"~$text-mode\",[\"^ \",\"^A\",\"Typography\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Typography\",\"^D\",\"1.0\",\"^E\",\"Attributes\",\"^F\",\"^G\",\"^H\",12,\"^I\",\"textMode()\",\"^J\",3,\"^K\",true,\"^L\",4279,\"^M\",4279,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^18\"]]]]],\"^R\",\"Sets the way text draws to the screen - available modes\\n  are :model and :shape\\n\\n  In the default configuration (the :model mode), it's possible to\\n  rotate, scale, and place letters in two and three dimensional space.\\n\\n  The :shape mode draws text using the glyph outlines of individual\\n  characters rather than as textures. This mode is only supported with\\n  the PDF and OPENGL renderer settings. With the PDF renderer, you\\n  must specify the :shape text-mode before any other drawing occurs.\\n  If the outlines are not available, then :shape will be ignored and\\n  :model will be used instead.\\n\\n  The :shape option in OPENGL mode can be combined with begin-raw to\\n  write vector-accurate text to 2D and 3D output files, for instance\\n  DXF or PDF. :shape is not currently optimized for OPENGL, so if\\n  recording shape data, use :model until you're ready to capture the\\n  geometry with begin-raw.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/text-mode\",\"^T\",false,\"^E\",\"Attributes\",\"^F\",\"quil/core.cljc\",\"^H\",12,\"^I\",\"textMode()\",\"^U\",[\"^O\",[[\"^18\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",4273,\"^M\",4279,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^18\"]]]]],\"^R\",\"Sets the way text draws to the screen - available modes\\n  are :model and :shape\\n\\n  In the default configuration (the :model mode), it's possible to\\n  rotate, scale, and place letters in two and three dimensional space.\\n\\n  The :shape mode draws text using the glyph outlines of individual\\n  characters rather than as textures. This mode is only supported with\\n  the PDF and OPENGL renderer settings. With the PDF renderer, you\\n  must specify the :shape text-mode before any other drawing occurs.\\n  If the outlines are not available, then :shape will be ignored and\\n  :model will be used instead.\\n\\n  The :shape option in OPENGL mode can be combined with begin-raw to\\n  write vector-accurate text to 2D and 3D output files, for instance\\n  DXF or PDF. :shape is not currently optimized for OPENGL, so if\\n  recording shape data, use :model until you're ready to capture the\\n  geometry with begin-raw.\"],\"~$image-mode\",[\"^ \",\"^A\",\"Image\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Image\",\"^D\",\"1.0\",\"^E\",\"Loading & Displaying\",\"^F\",\"^G\",\"^H\",13,\"^I\",\"imageMode()\",\"^J\",3,\"^K\",true,\"^L\",2145,\"^M\",2145,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^18\"]]]]],\"^R\",\"Modifies the location from which images draw. The default mode is :corner.\\n   Available modes are:\\n\\n  :corner  - specifies the location to be the upper left corner and\\n             uses the fourth and fifth parameters of image to set the\\n             image's width and height.\\n\\n  :corners - uses the second and third parameters of image to set the\\n             location of one corner of the image and uses the fourth\\n             and fifth parameters to set the opposite corner.\\n\\n  :center  - draw images centered at the given x and y position.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/image-mode\",\"^T\",false,\"^E\",\"Loading & Displaying\",\"^F\",\"quil/core.cljc\",\"^H\",13,\"^I\",\"imageMode()\",\"^U\",[\"^O\",[[\"^18\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",2139,\"^M\",2145,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^18\"]]]]],\"^R\",\"Modifies the location from which images draw. The default mode is :corner.\\n   Available modes are:\\n\\n  :corner  - specifies the location to be the upper left corner and\\n             uses the fourth and fifth parameters of image to set the\\n             image's width and height.\\n\\n  :corners - uses the second and third parameters of image to set the\\n             location of one corner of the image and uses the fourth\\n             and fifth parameters to set the opposite corner.\\n\\n  :center  - draw images centered at the given x and y position.\"],\"~$line\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"2D Primitives\",\"^F\",\"^G\",\"^H\",7,\"^15\",[\"^ \",\"^T\",false,\"^X\",6,\"^U\",[\"^O\",[[\"~$p1\",\"~$p2\"],[\"^44\",\"^45\",\"^46\",\"^47\"],[\"^44\",\"^45\",\"^57\",\"^46\",\"^47\",\"^5:\"]]],\"^N\",[\"^O\",[[\"^=T\",\"^=U\"],[\"^44\",\"^45\",\"^46\",\"^47\"],[\"^44\",\"^45\",\"^57\",\"^46\",\"^47\",\"^5:\"]]],\"^W\",[\"^O\",[null,null,null]]],\"^I\",\"line()\",\"^J\",3,\"^K\",true,\"^L\",2323,\"^M\",2323,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^=T\",\"^=U\"],[\"^44\",\"^45\",\"^46\",\"^47\"],[\"^44\",\"^45\",\"^57\",\"^46\",\"^47\",\"^5:\"]]]]],\"^R\",\"Draws a line (a direct path between two points) to the screen. The\\n  version of line with four parameters draws the line in 2D. To color\\n  a line, use the stroke function. A line cannot be filled, therefore\\n  the fill method will not affect the color of a line. 2D lines are\\n  drawn with a width of one pixel by default, but this can be changed\\n  with the stroke-weight function. The version with six parameters\\n  allows the line to be placed anywhere within XYZ space. \"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/line\",\"^T\",false,\"^E\",\"2D Primitives\",\"^F\",\"quil/core.cljc\",\"^H\",7,\"^15\",[\"^ \",\"^T\",false,\"^X\",6,\"^U\",[\"^O\",[[\"^=T\",\"^=U\"],[\"^44\",\"^45\",\"^46\",\"^47\"],[\"^44\",\"^45\",\"^57\",\"^46\",\"^47\",\"^5:\"]]],\"^N\",[\"^O\",[[\"^=T\",\"^=U\"],[\"^44\",\"^45\",\"^46\",\"^47\"],[\"^44\",\"^45\",\"^57\",\"^46\",\"^47\",\"^5:\"]]],\"^W\",[\"^O\",[null,null,null]]],\"^I\",\"line()\",\"^U\",[\"^O\",[[\"^=T\",\"^=U\"],[\"^44\",\"^45\",\"^46\",\"^47\"],[\"^44\",\"^45\",\"^57\",\"^46\",\"^47\",\"^5:\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null,null]],\"^J\",1,\"^K\",true,\"^L\",2317,\"^M\",2323,\"^X\",6,\"^Y\",true,\"^N\",[\"^O\",[[\"^=T\",\"^=U\"],[\"^44\",\"^45\",\"^46\",\"^47\"],[\"^44\",\"^45\",\"^57\",\"^46\",\"^47\",\"^5:\"]]],\"^R\",\"Draws a line (a direct path between two points) to the screen. The\\n  version of line with four parameters draws the line in 2D. To color\\n  a line, use the stroke function. A line cannot be filled, therefore\\n  the fill method will not affect the color of a line. 2D lines are\\n  drawn with a width of one pixel by default, but this can be changed\\n  with the stroke-weight function. The version with six parameters\\n  allows the line to be placed anywhere within XYZ space. \"],\"~$do-record\",[\"^ \",\"^A\",\"Output\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Output\",\"^D\",\"2.5\",\"^E\",\"Files\",\"^F\",\"^G\",\"^H\",12,\"^15\",[\"^ \",\"^T\",true,\"^X\",3,\"^U\",[[\"^O\",[\"^1L\",\"^1M\",\"^1N\",\"^1O\"]]],\"^N\",[\"^O\",[[\"^1L\",\"^1M\",\"^1N\",\"~$&\",\"^1O\"]]],\"^W\",[\"^O\",[null]]],\"^I\",null,\"^J\",3,\"^K\",true,\"^L\",1510,\"^1P\",true,\"^M\",1510,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^1N\",\"~$&\",\"^1O\"]]]]],\"^R\",\"Macro for drawing on graphics which saves result in the file at the end.\\n  Similar to 'with-graphics' macro. do-record assumed to be used with :pdf\\n  graphics. Example:\\n\\n  (q/do-record (q/create-graphics 200 200 :pdf \\\"output.pdf\\\")\\n    (q/fill 250 0 0)\\n    (q/ellipse 100 100 150 150))\\n  \"],\"^D\",\"2.5\",\"^5\",\"~$quil.core$macros/do-record\",\"^T\",true,\"^E\",\"Files\",\"^F\",\"quil/core.cljc\",\"^H\",12,\"^15\",[\"^ \",\"^T\",true,\"^X\",3,\"^U\",[[\"^O\",[\"^1L\",\"^1M\",\"^1N\",\"^1O\"]]],\"^N\",[\"^O\",[[\"^1L\",\"^1M\",\"^1N\",\"~$&\",\"^1O\"]]],\"^W\",[\"^O\",[null]]],\"^I\",null,\"^U\",[[\"^O\",[\"^1L\",\"^1M\",\"^1N\",\"^1O\"]]],\"^V\",null,\"^W\",[\"^O\",[null]],\"^J\",1,\"^K\",true,\"^L\",1504,\"^1P\",true,\"^M\",1510,\"^X\",3,\"^Y\",false,\"^N\",[\"^O\",[[\"^1L\",\"^1M\",\"^1N\",\"~$&\",\"^1O\"]]],\"^R\",\"Macro for drawing on graphics which saves result in the file at the end.\\n  Similar to 'with-graphics' macro. do-record assumed to be used with :pdf\\n  graphics. Example:\\n\\n  (q/do-record (q/create-graphics 200 200 :pdf \\\"output.pdf\\\")\\n    (q/fill 250 0 0)\\n    (q/ellipse 100 100 150 150))\\n  \"],\"~$red\",[\"^ \",\"^A\",\"Color\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Color\",\"^D\",\"1.0\",\"^E\",\"Creating & Reading\",\"^F\",\"^G\",\"^H\",6,\"^I\",\"red()\",\"^J\",3,\"^K\",true,\"^L\",3305,\"^M\",3305,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$c\"]]]]],\"^R\",\"Extracts the red value from a color, scaled to match current color-mode.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/red\",\"^T\",false,\"^E\",\"Creating & Reading\",\"^F\",\"quil/core.cljc\",\"^H\",6,\"^I\",\"red()\",\"^U\",[\"^O\",[[\"~$c\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",3299,\"^M\",3305,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$c\"]]]]],\"^R\",\"Extracts the red value from a color, scaled to match current color-mode.\"],\"~$current-fill\",[\"^ \",\"^A\",\"Color\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Color\",\"^E\",\"Creating & Reading\",\"^F\",\"^G\",\"^H\",15,\"^I\",\"PGraphics.fillColor\",\"^J\",3,\"^3Y\",\"http://processing.github.io/processing-javadocs/core/processing/core/PGraphics.html#fillColor\",\"^K\",true,\"^L\",1264,\"^M\",1264,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Return the current fill color.\"],\"^5\",\"~$quil.core$macros/current-fill\",\"^T\",false,\"^E\",\"Creating & Reading\",\"^F\",\"quil/core.cljc\",\"^H\",15,\"^I\",\"PGraphics.fillColor\",\"^U\",[\"^O\",[[]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^3Y\",\"http://processing.github.io/processing-javadocs/core/processing/core/PGraphics.html#fillColor\",\"^K\",true,\"^L\",1258,\"^M\",1264,\"^X\",0,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Return the current fill color.\"],\"~$color-modes\",[\"^ \",\"^5\",\"~$quil.core$macros/color-modes\",\"^F\",\"quil/core.cljc\",\"^L\",45,\"^J\",1,\"^M\",50,\"^H\",13,\"^C\",[\"^ \",\"^F\",\"^G\",\"^L\",50,\"^J\",2,\"^M\",50,\"^H\",13]],\"~$blue\",[\"^ \",\"^A\",\"Color\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Color\",\"^D\",\"1.0\",\"^E\",\"Creating & Reading\",\"^F\",\"^G\",\"^H\",7,\"^I\",\"blue()\",\"^J\",3,\"^K\",true,\"^L\",905,\"^M\",905,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^7J\"]]]]],\"^R\",\"Extracts the blue value from a color, scaled to match current color-mode.\\n  Returns a float.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/blue\",\"^T\",false,\"^E\",\"Creating & Reading\",\"^F\",\"quil/core.cljc\",\"^H\",7,\"^I\",\"blue()\",\"^U\",[\"^O\",[[\"^7J\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",899,\"^M\",905,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^7J\"]]]]],\"^R\",\"Extracts the blue value from a color, scaled to match current color-mode.\\n  Returns a float.\"],\"~$frustum\",[\"^ \",\"^A\",\"Lights, Camera\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Lights, Camera\",\"^D\",\"1.0\",\"^E\",\"Camera\",\"^F\",\"^G\",\"^H\",10,\"^I\",\"frustum()\",\"^J\",3,\"^K\",true,\"^L\",1897,\"^M\",1897,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^:?\",\"^:@\",\"^:A\",\"^:B\",\"^:C\",\"^:D\"]]]]],\"^R\",\"Sets a perspective matrix defined through the parameters. Works\\n  like glFrustum, except it wipes out the current perspective matrix\\n  rather than muliplying itself with it.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/frustum\",\"^T\",false,\"^E\",\"Camera\",\"^F\",\"quil/core.cljc\",\"^H\",10,\"^I\",\"frustum()\",\"^U\",[\"^O\",[[\"^:?\",\"^:@\",\"^:A\",\"^:B\",\"^:C\",\"^:D\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",1891,\"^M\",1897,\"^X\",6,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^:?\",\"^:@\",\"^:A\",\"^:B\",\"^:C\",\"^:D\"]]]]],\"^R\",\"Sets a perspective matrix defined through the parameters. Works\\n  like glFrustum, except it wipes out the current perspective matrix\\n  rather than muliplying itself with it.\"],\"~$with-rotation\",[\"^ \",\"^A\",\"Transform\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Transform\",\"^D\",\"1.0\",\"^E\",\"Utility Macros\",\"^F\",\"^G\",\"^H\",16,\"^15\",[\"^ \",\"^T\",true,\"^X\",3,\"^U\",[[\"^O\",[\"^1L\",\"^1M\",\"~$rotation\",\"^1O\"]]],\"^N\",[\"^O\",[[\"^1L\",\"^1M\",\"^>8\",\"~$&\",\"^1O\"]]],\"^W\",[\"^O\",[null]]],\"^I\",null,\"^J\",3,\"^K\",true,\"^L\",4660,\"^1P\",true,\"^M\",4660,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^>8\",\"~$&\",\"^1O\"]]]]],\"^R\",\"Performs body with rotation, restores current transformation on exit.\\n  Accepts a vector [angle] or [angle x-axis y-axis z-axis].\\n\\n  Example:\\n    (with-rotation [angle]\\n      (vertex 1 2))\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/with-rotation\",\"^T\",true,\"^E\",\"Utility Macros\",\"^F\",\"quil/core.cljc\",\"^H\",16,\"^15\",[\"^ \",\"^T\",true,\"^X\",3,\"^U\",[[\"^O\",[\"^1L\",\"^1M\",\"^>8\",\"^1O\"]]],\"^N\",[\"^O\",[[\"^1L\",\"^1M\",\"^>8\",\"~$&\",\"^1O\"]]],\"^W\",[\"^O\",[null]]],\"^I\",null,\"^U\",[[\"^O\",[\"^1L\",\"^1M\",\"^>8\",\"^1O\"]]],\"^V\",null,\"^W\",[\"^O\",[null]],\"^J\",1,\"^K\",true,\"^L\",4654,\"^1P\",true,\"^M\",4660,\"^X\",3,\"^Y\",false,\"^N\",[\"^O\",[[\"^1L\",\"^1M\",\"^>8\",\"~$&\",\"^1O\"]]],\"^R\",\"Performs body with rotation, restores current transformation on exit.\\n  Accepts a vector [angle] or [angle x-axis y-axis z-axis].\\n\\n  Example:\\n    (with-rotation [angle]\\n      (vertex 1 2))\"],\"~$print-matrix\",[\"^ \",\"^A\",\"Transform\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Transform\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^G\",\"^H\",15,\"^I\",\"printMatrix()\",\"^J\",3,\"^K\",true,\"^L\",3059,\"^M\",3059,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Prints the current matrix to std out. Useful for debugging.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/print-matrix\",\"^T\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^H\",15,\"^I\",\"printMatrix()\",\"^U\",[\"^O\",[[]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",3053,\"^M\",3059,\"^X\",0,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Prints the current matrix to std out. Useful for debugging.\"],\"~$ambient-light\",[\"^ \",\"^A\",\"Lights, Camera\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Lights, Camera\",\"^D\",\"1.0\",\"^E\",\"Lights\",\"^F\",\"^G\",\"^H\",16,\"^15\",[\"^ \",\"^T\",false,\"^X\",6,\"^U\",[\"^O\",[[\"^=Y\",\"^9B\",\"^>3\"],[\"^=Y\",\"^9B\",\"^>3\",\"~$x\",\"~$y\",\"~$z\"]]],\"^N\",[\"^O\",[[\"^=Y\",\"^9B\",\"^>3\"],[\"^=Y\",\"^9B\",\"^>3\",\"~$x\",\"~$y\",\"~$z\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"ambientLight()\",\"^J\",3,\"^K\",true,\"^L\",375,\"^M\",375,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^=Y\",\"^9B\",\"^>3\"],[\"^=Y\",\"^9B\",\"^>3\",\"~$x\",\"~$y\",\"~$z\"]]]]],\"^R\",\"Adds an ambient light. Ambient light doesn't come from a specific direction,\\n  the rays have light have bounced around so much that objects are\\n  evenly lit from all sides. Ambient lights are almost always used in\\n  combination with other types of lights. Lights need to be included\\n  in the draw to remain persistent in a looping program. Placing them\\n  in the setup of a looping program will cause them to only have an\\n  effect the first time through the loop. The effect of the\\n  parameters is determined by the current color mode.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/ambient-light\",\"^T\",false,\"^E\",\"Lights\",\"^F\",\"quil/core.cljc\",\"^H\",16,\"^15\",[\"^ \",\"^T\",false,\"^X\",6,\"^U\",[\"^O\",[[\"^=Y\",\"^9B\",\"^>3\"],[\"^=Y\",\"^9B\",\"^>3\",\"~$x\",\"~$y\",\"~$z\"]]],\"^N\",[\"^O\",[[\"^=Y\",\"^9B\",\"^>3\"],[\"^=Y\",\"^9B\",\"^>3\",\"~$x\",\"~$y\",\"~$z\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"ambientLight()\",\"^U\",[\"^O\",[[\"^=Y\",\"^9B\",\"^>3\"],[\"^=Y\",\"^9B\",\"^>3\",\"~$x\",\"~$y\",\"~$z\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",369,\"^M\",375,\"^X\",6,\"^Y\",true,\"^N\",[\"^O\",[[\"^=Y\",\"^9B\",\"^>3\"],[\"^=Y\",\"^9B\",\"^>3\",\"~$x\",\"~$y\",\"~$z\"]]],\"^R\",\"Adds an ambient light. Ambient light doesn't come from a specific direction,\\n  the rays have light have bounced around so much that objects are\\n  evenly lit from all sides. Ambient lights are almost always used in\\n  combination with other types of lights. Lights need to be included\\n  in the draw to remain persistent in a looping program. Placing them\\n  in the setup of a looping program will cause them to only have an\\n  effect the first time through the loop. The effect of the\\n  parameters is determined by the current color mode.\"],\"~$bezier-point\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"Curves\",\"^F\",\"^G\",\"^H\",15,\"^I\",\"bezierPoint()\",\"^J\",3,\"^K\",true,\"^L\",706,\"^M\",706,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$t\"]]]]],\"^R\",\"Evaluates the Bezier at point t for points a, b, c, d. The\\n  parameter t varies between 0 and 1, a and d are points on the curve,\\n  and b and c are the control points. This can be done once with the x\\n  coordinates and a second time with the y coordinates to get the\\n  location of a bezier curve at t.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/bezier-point\",\"^T\",false,\"^E\",\"Curves\",\"^F\",\"quil/core.cljc\",\"^H\",15,\"^I\",\"bezierPoint()\",\"^U\",[\"^O\",[[\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$t\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",700,\"^M\",706,\"^X\",5,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$t\"]]]]],\"^R\",\"Evaluates the Bezier at point t for points a, b, c, d. The\\n  parameter t varies between 0 and 1, a and d are points on the curve,\\n  and b and c are the control points. This can be done once with the x\\n  coordinates and a second time with the y coordinates to get the\\n  location of a bezier curve at t.\"],\"~$stroke-cap-modes\",[\"^ \",\"^5\",\"~$quil.core$macros/stroke-cap-modes\",\"^F\",\"quil/core.cljc\",\"^L\",45,\"^J\",1,\"^M\",64,\"^H\",18,\"^C\",[\"^ \",\"^F\",\"^G\",\"^L\",64,\"^J\",2,\"^M\",64,\"^H\",18]],\"~$quad\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"2D Primitives\",\"^F\",\"^G\",\"^H\",7,\"^I\",\"quad()\",\"^J\",3,\"^K\",true,\"^L\",3123,\"^M\",3123,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^44\",\"^45\",\"^46\",\"^47\",\"^6=\",\"^6>\",\"~$x4\",\"~$y4\"]]]]],\"^R\",\"A quad is a quadrilateral, a four sided polygon. It is similar to a\\n  rectangle, but the angles between its edges are not constrained to\\n  be ninety degrees. The first pair of parameters (x1,y1) sets the\\n  first vertex and the subsequent pairs should proceed clockwise or\\n  counter-clockwise around the defined shape.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/quad\",\"^T\",false,\"^E\",\"2D Primitives\",\"^F\",\"quil/core.cljc\",\"^H\",7,\"^I\",\"quad()\",\"^U\",[\"^O\",[[\"^44\",\"^45\",\"^46\",\"^47\",\"^6=\",\"^6>\",\"^>C\",\"^>D\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",3117,\"^M\",3123,\"^X\",8,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^44\",\"^45\",\"^46\",\"^47\",\"^6=\",\"^6>\",\"^>C\",\"^>D\"]]]]],\"^R\",\"A quad is a quadrilateral, a four sided polygon. It is similar to a\\n  rectangle, but the angles between its edges are not constrained to\\n  be ninety degrees. The first pair of parameters (x1,y1) sets the\\n  first vertex and the subsequent pairs should proceed clockwise or\\n  counter-clockwise around the defined shape.\"],\"~$screen-x\",[\"^ \",\"^A\",\"Lights, Camera\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Lights, Camera\",\"^D\",\"1.0\",\"^E\",\"Coordinates\",\"^F\",\"^G\",\"^H\",11,\"^15\",[\"^ \",\"^T\",false,\"^X\",3,\"^U\",[\"^O\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^N\",[\"^O\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"screenX()\",\"^J\",3,\"^K\",true,\"^L\",3614,\"^M\",3614,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]]]],\"^R\",\"Takes a three-dimensional x, y, z position and returns the x value\\n  for where it will appear on a (two-dimensional) screen, once\\n  affected by translate, scale or any other transformations\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/screen-x\",\"^T\",false,\"^E\",\"Coordinates\",\"^F\",\"quil/core.cljc\",\"^H\",11,\"^15\",[\"^ \",\"^T\",false,\"^X\",3,\"^U\",[\"^O\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^N\",[\"^O\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"screenX()\",\"^U\",[\"^O\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",3608,\"^M\",3614,\"^X\",3,\"^Y\",true,\"^N\",[\"^O\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^R\",\"Takes a three-dimensional x, y, z position and returns the x value\\n  for where it will appear on a (two-dimensional) screen, once\\n  affected by translate, scale or any other transformations\"],\"~$lights\",[\"^ \",\"^A\",\"Lights, Camera\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Lights, Camera\",\"^D\",\"1.0\",\"^E\",\"Lights\",\"^F\",\"^G\",\"^H\",9,\"^I\",\"lights()\",\"^J\",3,\"^K\",true,\"^L\",2284,\"^M\",2284,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Sets the default ambient light, directional light, falloff, and\\n  specular values. The defaults are:\\n\\n  (ambient-light 128 128 128)\\n  (directional-light 128 128 128 0 0 -1)\\n  (light-falloff 1 0 0)\\n  (light-specular 0 0 0).\\n\\n  Lights need to be included in the draw to remain persistent in a\\n  looping program. Placing them in the setup of a looping program\\n  will cause them to only have an effect the first time through the\\n  loop.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/lights\",\"^T\",false,\"^E\",\"Lights\",\"^F\",\"quil/core.cljc\",\"^H\",9,\"^I\",\"lights()\",\"^U\",[\"^O\",[[]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",2278,\"^M\",2284,\"^X\",0,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Sets the default ambient light, directional light, falloff, and\\n  specular values. The defaults are:\\n\\n  (ambient-light 128 128 128)\\n  (directional-light 128 128 128 0 0 -1)\\n  (light-falloff 1 0 0)\\n  (light-specular 0 0 0).\\n\\n  Lights need to be included in the draw to remain persistent in a\\n  looping program. Placing them in the setup of a looping program\\n  will cause them to only have an effect the first time through the\\n  loop.\"],\"~$*graphics*\",[\"^ \",\"^C\",[\"^ \",\"^F\",\"^G\",\"^L\",22,\"^J\",3,\"^M\",22,\"^H\",13,\"^3L\",true,\"~:dynamic\",true],\"^3L\",true,\"^5\",\"~$quil.core$macros/*graphics*\",\"^F\",\"quil/core.cljc\",\"^H\",13,\"^J\",1,\"^>K\",true,\"^L\",20,\"^M\",22],\"~$KEY-CODES\",[\"^ \",\"^5\",\"~$quil.core$macros/KEY-CODES\",\"^F\",\"quil/core.cljc\",\"^L\",122,\"^J\",4,\"^M\",123,\"^H\",15,\"^3L\",true,\"^C\",[\"^ \",\"^F\",\"^G\",\"^L\",123,\"^J\",6,\"^M\",123,\"^H\",15,\"^3L\",true]],\"~$curve-detail\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"Curves\",\"^F\",\"^G\",\"^H\",15,\"^I\",\"curveDetail()\",\"^J\",3,\"^K\",true,\"^L\",1348,\"^M\",1348,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^35\"]]]]],\"^R\",\"Sets the resolution at which curves display. The default value is\\n  20. This function is only useful when using the :p3d or :opengl\\n  renderer as the default (:java2d) renderer does not use this\\n  information.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/curve-detail\",\"^T\",false,\"^E\",\"Curves\",\"^F\",\"quil/core.cljc\",\"^H\",15,\"^I\",\"curveDetail()\",\"^U\",[\"^O\",[[\"^35\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",1342,\"^M\",1348,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^35\"]]]]],\"^R\",\"Sets the resolution at which curves display. The default value is\\n  20. This function is only useful when using the :p3d or :opengl\\n  renderer as the default (:java2d) renderer does not use this\\n  information.\"],\"~$current-frame-rate\",[\"^ \",\"^A\",\"Environment\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Environment\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^G\",\"^H\",21,\"^I\",\"frameRate\",\"^J\",3,\"^K\",true,\"^L\",1867,\"^M\",1867,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Returns the current framerate\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/current-frame-rate\",\"^T\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^H\",21,\"^I\",\"frameRate\",\"^U\",[\"^O\",[[]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",1861,\"^M\",1867,\"^X\",0,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Returns the current framerate\"],\"~$end-contour\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"2.0\",\"^E\",\"Vertex\",\"^F\",\"^G\",\"^H\",14,\"^I\",\"endContour()\",\"^J\",3,\"^K\",true,\"^L\",1624,\"^M\",1624,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Use the begin-contour and end-contour function to create negative\\n  shapes within shapes. These functions can only be within a\\n  begin-shape/end-shape pair and they only work with the :p2d and :p3d\\n  renderers.\"],\"^D\",\"2.0\",\"^5\",\"~$quil.core$macros/end-contour\",\"^T\",false,\"^E\",\"Vertex\",\"^F\",\"quil/core.cljc\",\"^H\",14,\"^I\",\"endContour()\",\"^U\",[\"^O\",[[]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",1618,\"^M\",1624,\"^X\",0,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Use the begin-contour and end-contour function to create negative\\n  shapes within shapes. These functions can only be within a\\n  begin-shape/end-shape pair and they only work with the :p2d and :p3d\\n  renderers.\"],\"~$sin\",[\"^ \",\"^A\",\"Math\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Math\",\"^D\",\"1.0\",\"^E\",\"Trigonometry\",\"^F\",\"^G\",\"^H\",6,\"^I\",\"sin()\",\"^J\",3,\"^K\",false,\"^L\",3835,\"^M\",3835,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^Q\"]]]]],\"^R\",\"Calculates the sine of an angle. This function expects the values\\n  of the angle parameter to be provided in radians (values from 0 to\\n  6.28). A float within the range -1 to 1 is returned.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/sin\",\"^T\",false,\"^E\",\"Trigonometry\",\"^F\",\"quil/core.cljc\",\"^H\",6,\"^I\",\"sin()\",\"^U\",[\"^O\",[[\"^Q\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",false,\"^L\",3829,\"^M\",3835,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^Q\"]]]]],\"^R\",\"Calculates the sine of an angle. This function expects the values\\n  of the angle parameter to be provided in radians (values from 0 to\\n  6.28). A float within the range -1 to 1 is returned.\"],\"~$current-stroke\",[\"^ \",\"^A\",\"Color\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Color\",\"^E\",\"Creating & Reading\",\"^F\",\"^G\",\"^H\",17,\"^I\",\"PGraphics.strokeColor\",\"^J\",3,\"^3Y\",\"http://processing.github.io/processing-javadocs/core/processing/core/PGraphics.html#strokeColor\",\"^K\",true,\"^L\",1275,\"^M\",1275,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Return the current stroke color.\"],\"^5\",\"~$quil.core$macros/current-stroke\",\"^T\",false,\"^E\",\"Creating & Reading\",\"^F\",\"quil/core.cljc\",\"^H\",17,\"^I\",\"PGraphics.strokeColor\",\"^U\",[\"^O\",[[]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^3Y\",\"http://processing.github.io/processing-javadocs/core/processing/core/PGraphics.html#strokeColor\",\"^K\",true,\"^L\",1269,\"^M\",1275,\"^X\",0,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Return the current stroke color.\"],\"~$curve\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"Curves\",\"^F\",\"^G\",\"^H\",8,\"^15\",[\"^ \",\"^T\",false,\"^X\",12,\"^U\",[\"^O\",[[\"^44\",\"^45\",\"^46\",\"^47\",\"^6=\",\"^6>\",\"^>C\",\"^>D\"],[\"^44\",\"^45\",\"^57\",\"^46\",\"^47\",\"^5:\",\"^6=\",\"^6>\",\"^6@\",\"^>C\",\"^>D\",\"~$z4\"]]],\"^N\",[\"^O\",[[\"^44\",\"^45\",\"^46\",\"^47\",\"^6=\",\"^6>\",\"^>C\",\"^>D\"],[\"^44\",\"^45\",\"^57\",\"^46\",\"^47\",\"^5:\",\"^6=\",\"^6>\",\"^6@\",\"^>C\",\"^>D\",\"^>Z\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"curve()\",\"^J\",3,\"^K\",true,\"^L\",1320,\"^M\",1320,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^44\",\"^45\",\"^46\",\"^47\",\"^6=\",\"^6>\",\"^>C\",\"^>D\"],[\"^44\",\"^45\",\"^57\",\"^46\",\"^47\",\"^5:\",\"^6=\",\"^6>\",\"^6@\",\"^>C\",\"^>D\",\"^>Z\"]]]]],\"^R\",\"Draws a curved line on the screen. The first and second parameters\\n  specify the beginning control point and the last two parameters\\n  specify the ending control point. The middle parameters specify the\\n  start and stop of the curve. Longer curves can be created by putting\\n  a series of curve fns together or using curve-vertex. An additional\\n  fn called curve-tightness provides control for the visual quality of\\n  the curve. The curve fn is an implementation of Catmull-Rom\\n  splines.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/curve\",\"^T\",false,\"^E\",\"Curves\",\"^F\",\"quil/core.cljc\",\"^H\",8,\"^15\",[\"^ \",\"^T\",false,\"^X\",12,\"^U\",[\"^O\",[[\"^44\",\"^45\",\"^46\",\"^47\",\"^6=\",\"^6>\",\"^>C\",\"^>D\"],[\"^44\",\"^45\",\"^57\",\"^46\",\"^47\",\"^5:\",\"^6=\",\"^6>\",\"^6@\",\"^>C\",\"^>D\",\"^>Z\"]]],\"^N\",[\"^O\",[[\"^44\",\"^45\",\"^46\",\"^47\",\"^6=\",\"^6>\",\"^>C\",\"^>D\"],[\"^44\",\"^45\",\"^57\",\"^46\",\"^47\",\"^5:\",\"^6=\",\"^6>\",\"^6@\",\"^>C\",\"^>D\",\"^>Z\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"curve()\",\"^U\",[\"^O\",[[\"^44\",\"^45\",\"^46\",\"^47\",\"^6=\",\"^6>\",\"^>C\",\"^>D\"],[\"^44\",\"^45\",\"^57\",\"^46\",\"^47\",\"^5:\",\"^6=\",\"^6>\",\"^6@\",\"^>C\",\"^>D\",\"^>Z\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",1314,\"^M\",1320,\"^X\",12,\"^Y\",true,\"^N\",[\"^O\",[[\"^44\",\"^45\",\"^46\",\"^47\",\"^6=\",\"^6>\",\"^>C\",\"^>D\"],[\"^44\",\"^45\",\"^57\",\"^46\",\"^47\",\"^5:\",\"^6=\",\"^6>\",\"^6@\",\"^>C\",\"^>D\",\"^>Z\"]]],\"^R\",\"Draws a curved line on the screen. The first and second parameters\\n  specify the beginning control point and the last two parameters\\n  specify the ending control point. The middle parameters specify the\\n  start and stop of the curve. Longer curves can be created by putting\\n  a series of curve fns together or using curve-vertex. An additional\\n  fn called curve-tightness provides control for the visual quality of\\n  the curve. The curve fn is an implementation of Catmull-Rom\\n  splines.\"],\"~$shape\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"Loading & Displaying\",\"^F\",\"^G\",\"^H\",8,\"^15\",[\"^ \",\"^T\",false,\"^X\",5,\"^U\",[\"^O\",[[\"~$sh\"],[\"^?1\",\"~$x\",\"~$y\"],[\"^?1\",\"~$x\",\"~$y\",\"^1@\",\"^1A\"]]],\"^N\",[\"^O\",[[\"^?1\"],[\"^?1\",\"~$x\",\"~$y\"],[\"^?1\",\"~$x\",\"~$y\",\"^1@\",\"^1A\"]]],\"^W\",[\"^O\",[null,null,null]]],\"^I\",\"shape()\",\"^J\",3,\"^K\",true,\"^L\",3723,\"^M\",3723,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^?1\"],[\"^?1\",\"~$x\",\"~$y\"],[\"^?1\",\"~$x\",\"~$y\",\"^1@\",\"^1A\"]]]]],\"^R\",\"Displays shapes to the screen. The shapes must have been loaded\\n  with load-shape. Processing currently works with SVG shapes\\n  only. The sh parameter specifies the shape to display and the x and\\n  y parameters define the location of the shape from its upper-left\\n  corner. The shape is displayed at its original size unless the width\\n  and height parameters specify a different size. The shape-mode\\n  fn changes the way the parameters work. A call to\\n  (shape-mode :corners), for example, will change the width and height\\n  parameters to define the x and y values of the opposite corner of\\n  the shape.\\n\\n  Note complex shapes may draw awkwardly with the renderers :p2d, :p3d, and\\n  :opengl. Those renderers do not yet support shapes that have holes\\n  or complicated breaks.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/shape\",\"^T\",false,\"^E\",\"Loading & Displaying\",\"^F\",\"quil/core.cljc\",\"^H\",8,\"^15\",[\"^ \",\"^T\",false,\"^X\",5,\"^U\",[\"^O\",[[\"^?1\"],[\"^?1\",\"~$x\",\"~$y\"],[\"^?1\",\"~$x\",\"~$y\",\"^1@\",\"^1A\"]]],\"^N\",[\"^O\",[[\"^?1\"],[\"^?1\",\"~$x\",\"~$y\"],[\"^?1\",\"~$x\",\"~$y\",\"^1@\",\"^1A\"]]],\"^W\",[\"^O\",[null,null,null]]],\"^I\",\"shape()\",\"^U\",[\"^O\",[[\"^?1\"],[\"^?1\",\"~$x\",\"~$y\"],[\"^?1\",\"~$x\",\"~$y\",\"^1@\",\"^1A\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null,null]],\"^J\",1,\"^K\",true,\"^L\",3717,\"^M\",3723,\"^X\",5,\"^Y\",true,\"^N\",[\"^O\",[[\"^?1\"],[\"^?1\",\"~$x\",\"~$y\"],[\"^?1\",\"~$x\",\"~$y\",\"^1@\",\"^1A\"]]],\"^R\",\"Displays shapes to the screen. The shapes must have been loaded\\n  with load-shape. Processing currently works with SVG shapes\\n  only. The sh parameter specifies the shape to display and the x and\\n  y parameters define the location of the shape from its upper-left\\n  corner. The shape is displayed at its original size unless the width\\n  and height parameters specify a different size. The shape-mode\\n  fn changes the way the parameters work. A call to\\n  (shape-mode :corners), for example, will change the width and height\\n  parameters to define the x and y values of the opposite corner of\\n  the shape.\\n\\n  Note complex shapes may draw awkwardly with the renderers :p2d, :p3d, and\\n  :opengl. Those renderers do not yet support shapes that have holes\\n  or complicated breaks.\"],\"~$image-formats\",[\"^ \",\"^5\",\"~$quil.core$macros/image-formats\",\"^F\",\"quil/core.cljc\",\"^L\",45,\"^J\",1,\"^M\",51,\"^H\",15,\"^C\",[\"^ \",\"^F\",\"^G\",\"^L\",51,\"^J\",2,\"^M\",51,\"^H\",15]],\"~$text-descent\",[\"^ \",\"^A\",\"Typography\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Typography\",\"^D\",\"1.0\",\"^E\",\"Metrics\",\"^F\",\"^G\",\"^H\",15,\"^I\",\"textDescent()\",\"^J\",3,\"^K\",true,\"^L\",4227,\"^M\",4227,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Returns descent of the current font at its current size. This\\n  information is useful for determining the height of the font below\\n  the baseline. For example, adding the text-ascent and text-descent\\n  values will give you the total height of the line.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/text-descent\",\"^T\",false,\"^E\",\"Metrics\",\"^F\",\"quil/core.cljc\",\"^H\",15,\"^I\",\"textDescent()\",\"^U\",[\"^O\",[[]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",4221,\"^M\",4227,\"^X\",0,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Returns descent of the current font at its current size. This\\n  information is useful for determining the height of the font below\\n  the baseline. For example, adding the text-ascent and text-descent\\n  values will give you the total height of the line.\"],\"~$screen-z\",[\"^ \",\"^A\",\"Lights, Camera\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Lights, Camera\",\"^D\",\"1.0\",\"^E\",\"Coordinates\",\"^F\",\"^G\",\"^H\",11,\"^I\",\"screenZ()\",\"^J\",3,\"^K\",true,\"^L\",3640,\"^M\",3640,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$x\",\"~$y\",\"~$z\"]]]]],\"^R\",\"Given an x, y, z coordinate, returns its z value.\\n   This value can be used to determine if an x, y, z coordinate is in\\n   front or in back of another (x, y, z) coordinate. The units are\\n   based on how the zbuffer is set up, and don't relate to anything\\n   'real'. They're only useful for in comparison to another value\\n   obtained from screen-z, or directly out of the zbuffer\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/screen-z\",\"^T\",false,\"^E\",\"Coordinates\",\"^F\",\"quil/core.cljc\",\"^H\",11,\"^I\",\"screenZ()\",\"^U\",[\"^O\",[[\"~$x\",\"~$y\",\"~$z\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",3634,\"^M\",3640,\"^X\",3,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$x\",\"~$y\",\"~$z\"]]]]],\"^R\",\"Given an x, y, z coordinate, returns its z value.\\n   This value can be used to determine if an x, y, z coordinate is in\\n   front or in back of another (x, y, z) coordinate. The units are\\n   based on how the zbuffer is set up, and don't relate to anything\\n   'real'. They're only useful for in comparison to another value\\n   obtained from screen-z, or directly out of the zbuffer\"],\"~$ambient-int\",[\"^ \",\"^A\",\"Lights, Camera\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Lights, Camera\",\"^D\",\"1.0\",\"^E\",\"Material Properties\",\"^F\",\"^G\",\"^H\",14,\"^I\",\"ambient()\",\"^J\",3,\"^K\",true,\"^L\",341,\"^M\",341,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^3:\"]]]]],\"^R\",\"Sets the ambient reflectance for shapes drawn to the screen. This\\n  is combined with the ambient light component of environment. The rgb\\n  color components set define the reflectance. Used in combination\\n  with emissive, specular, and shininess in setting the material\\n  properties of shapes.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/ambient-int\",\"^T\",false,\"^E\",\"Material Properties\",\"^F\",\"quil/core.cljc\",\"^H\",14,\"^I\",\"ambient()\",\"^U\",[\"^O\",[[\"^3:\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",335,\"^M\",341,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^3:\"]]]]],\"^R\",\"Sets the ambient reflectance for shapes drawn to the screen. This\\n  is combined with the ambient light component of environment. The rgb\\n  color components set define the reflectance. Used in combination\\n  with emissive, specular, and shininess in setting the material\\n  properties of shapes.\"],\"~$ellipse\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"2D Primitives\",\"^F\",\"^G\",\"^H\",10,\"^I\",\"ellipse()\",\"^J\",3,\"^K\",true,\"^L\",1531,\"^M\",1531,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$x\",\"~$y\",\"^1@\",\"^1A\"]]]]],\"^R\",\"Draws an ellipse (oval) in the display window. An ellipse with an\\n  equal width and height is a circle.  The origin may be changed with\\n  the ellipse-mode function\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/ellipse\",\"^T\",false,\"^E\",\"2D Primitives\",\"^F\",\"quil/core.cljc\",\"^H\",10,\"^I\",\"ellipse()\",\"^U\",[\"^O\",[[\"~$x\",\"~$y\",\"^1@\",\"^1A\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",1525,\"^M\",1531,\"^X\",4,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$x\",\"~$y\",\"^1@\",\"^1A\"]]]]],\"^R\",\"Draws an ellipse (oval) in the display window. An ellipse with an\\n  equal width and height is a circle.  The origin may be changed with\\n  the ellipse-mode function\"],\"~$text-leading\",[\"^ \",\"^A\",\"Typography\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Typography\",\"^D\",\"1.0\",\"^E\",\"Attributes\",\"^F\",\"^G\",\"^H\",15,\"^I\",\"textLeading()\",\"^J\",3,\"^K\",true,\"^L\",4267,\"^M\",4267,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$leading\"]]]]],\"^R\",\"Sets the spacing between lines of text in units of pixels. This\\n  setting will be used in all subsequent calls to the text function.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/text-leading\",\"^T\",false,\"^E\",\"Attributes\",\"^F\",\"quil/core.cljc\",\"^H\",15,\"^I\",\"textLeading()\",\"^U\",[\"^O\",[[\"^?>\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",4261,\"^M\",4267,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^?>\"]]]]],\"^R\",\"Sets the spacing between lines of text in units of pixels. This\\n  setting will be used in all subsequent calls to the text function.\"],\"~$image-filter\",[\"^ \",\"^A\",\"Image\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Image\",\"^D\",\"2.0\",\"^E\",\"Pixels\",\"^F\",\"^G\",\"^H\",15,\"^15\",[\"^ \",\"^T\",false,\"^X\",3,\"^U\",[\"^O\",[[\"^1Z\",\"^18\"],[\"^1Z\",\"^18\",\"^19\"]]],\"^N\",[\"^O\",[[\"^1Z\",\"^18\"],[\"^1Z\",\"^18\",\"^19\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"PImage.filter()\",\"^J\",3,\"^K\",true,\"^L\",2105,\"^M\",2105,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^1Z\",\"^18\"],[\"^1Z\",\"^18\",\"^19\"]]]]],\"^R\",\"Originally named filter in Processing Language.\\n  Filters given image with the specified mode and level.\\n  Level defines the quality of the filter and mode may be one of\\n  the following keywords:\\n\\n  :threshold - converts the image to black and white pixels depending\\n               if they are above or below the threshold defined by\\n               the level parameter. The level must be between\\n               0.0 (black) and 1.0 (white). If no level is specified,\\n               0.5 is used.\\n  :gray      - converts any colors in the image to grayscale\\n               equivalents. Doesn't work with level.\\n  :invert    - sets each pixel to its inverse value. Doesn't work with\\n               level.\\n  :posterize - limits each channel of the image to the number of\\n               colors specified as the level parameter. The parameter can\\n               be set to values between 2 and 255, but results are most\\n               noticeable in the lower ranges.\\n  :blur      - executes a Guassian blur with the level parameter\\n               specifying the extent of the blurring. If no level\\n               parameter is used, the blur is equivalent to Guassian\\n               blur of radius 1.\\n  :opaque    - sets the alpha channel to entirely opaque. Doesn't work\\n               with level.\\n  :erode     - reduces the light areas. Doesn't work with level.\\n  :dilate    - increases the light areas.  Doesn't work with level.\"],\"^D\",\"2.0\",\"^5\",\"~$quil.core$macros/image-filter\",\"^T\",false,\"^E\",\"Pixels\",\"^F\",\"quil/core.cljc\",\"^H\",15,\"^15\",[\"^ \",\"^T\",false,\"^X\",3,\"^U\",[\"^O\",[[\"^1Z\",\"^18\"],[\"^1Z\",\"^18\",\"^19\"]]],\"^N\",[\"^O\",[[\"^1Z\",\"^18\"],[\"^1Z\",\"^18\",\"^19\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"PImage.filter()\",\"^U\",[\"^O\",[[\"^1Z\",\"^18\"],[\"^1Z\",\"^18\",\"^19\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",2099,\"^M\",2105,\"^X\",3,\"^Y\",true,\"^N\",[\"^O\",[[\"^1Z\",\"^18\"],[\"^1Z\",\"^18\",\"^19\"]]],\"^R\",\"Originally named filter in Processing Language.\\n  Filters given image with the specified mode and level.\\n  Level defines the quality of the filter and mode may be one of\\n  the following keywords:\\n\\n  :threshold - converts the image to black and white pixels depending\\n               if they are above or below the threshold defined by\\n               the level parameter. The level must be between\\n               0.0 (black) and 1.0 (white). If no level is specified,\\n               0.5 is used.\\n  :gray      - converts any colors in the image to grayscale\\n               equivalents. Doesn't work with level.\\n  :invert    - sets each pixel to its inverse value. Doesn't work with\\n               level.\\n  :posterize - limits each channel of the image to the number of\\n               colors specified as the level parameter. The parameter can\\n               be set to values between 2 and 255, but results are most\\n               noticeable in the lower ranges.\\n  :blur      - executes a Guassian blur with the level parameter\\n               specifying the extent of the blurring. If no level\\n               parameter is used, the blur is equivalent to Guassian\\n               blur of radius 1.\\n  :opaque    - sets the alpha channel to entirely opaque. Doesn't work\\n               with level.\\n  :erode     - reduces the light areas. Doesn't work with level.\\n  :dilate    - increases the light areas.  Doesn't work with level.\"],\"~$random\",[\"^ \",\"^A\",\"Math\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Math\",\"^D\",\"1.0\",\"^E\",\"Random\",\"^F\",\"^G\",\"^H\",9,\"^15\",[\"^ \",\"^T\",false,\"^X\",2,\"^U\",[\"^O\",[[\"^3N\"],[\"~$min\",\"^3N\"]]],\"^N\",[\"^O\",[[\"^3N\"],[\"^?C\",\"^3N\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"random()\",\"^J\",3,\"^K\",true,\"^L\",3179,\"^M\",3179,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^3N\"],[\"^?C\",\"^3N\"]]]]],\"^R\",\"Generates random numbers. Each time the random function is called,\\n  it returns an unexpected value within the specified range. If one\\n  parameter is passed to the function it will return a float between\\n  zero and the value of the high parameter. The function call (random\\n  5) returns values between 0 and 5 (starting at zero, up to but not\\n  including 5). If two parameters are passed, it will return a float\\n  with a value between the parameters. The function call\\n  (random -5 10.2) returns values starting at -5 up to (but not\\n  including) 10.2.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/random\",\"^T\",false,\"^E\",\"Random\",\"^F\",\"quil/core.cljc\",\"^H\",9,\"^15\",[\"^ \",\"^T\",false,\"^X\",2,\"^U\",[\"^O\",[[\"^3N\"],[\"^?C\",\"^3N\"]]],\"^N\",[\"^O\",[[\"^3N\"],[\"^?C\",\"^3N\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"random()\",\"^U\",[\"^O\",[[\"^3N\"],[\"^?C\",\"^3N\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",3173,\"^M\",3179,\"^X\",2,\"^Y\",true,\"^N\",[\"^O\",[[\"^3N\"],[\"^?C\",\"^3N\"]]],\"^R\",\"Generates random numbers. Each time the random function is called,\\n  it returns an unexpected value within the specified range. If one\\n  parameter is passed to the function it will return a float between\\n  zero and the value of the high parameter. The function call (random\\n  5) returns values between 0 and 5 (starting at zero, up to but not\\n  including 5). If two parameters are passed, it will return a float\\n  with a value between the parameters. The function call\\n  (random -5 10.2) returns values starting at -5 up to (but not\\n  including) 10.2.\"],\"~$texture-mode\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"Vertex\",\"^F\",\"^G\",\"^H\",15,\"^I\",\"textureMode()\",\"^J\",3,\"^K\",true,\"^L\",4339,\"^M\",4339,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^18\"]]]]],\"^R\",\"Sets the coordinate space for texture mapping. There are two\\n  options, :image and :normal.\\n\\n  :image refers to the actual coordinates of the image and :normal\\n  refers to a normalized space of values ranging from 0 to 1. The\\n  default mode is :image. In :image, if an image is 100 x 200 pixels,\\n  mapping the image onto the entire size of a quad would require the\\n  points (0,0) (0,100) (100,200) (0,200). The same mapping in\\n  NORMAL_SPACE is (0,0) (0,1) (1,1) (0,1).\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/texture-mode\",\"^T\",false,\"^E\",\"Vertex\",\"^F\",\"quil/core.cljc\",\"^H\",15,\"^I\",\"textureMode()\",\"^U\",[\"^O\",[[\"^18\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",4333,\"^M\",4339,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^18\"]]]]],\"^R\",\"Sets the coordinate space for texture mapping. There are two\\n  options, :image and :normal.\\n\\n  :image refers to the actual coordinates of the image and :normal\\n  refers to a normalized space of values ranging from 0 to 1. The\\n  default mode is :image. In :image, if an image is 100 x 200 pixels,\\n  mapping the image onto the entire size of a quad would require the\\n  points (0,0) (0,100) (100,200) (0,200). The same mapping in\\n  NORMAL_SPACE is (0,0) (0,1) (1,1) (0,1).\"],\"~$redraw\",[\"^ \",\"^A\",\"Structure\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Structure\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^G\",\"^H\",9,\"^I\",\"redraw()\",\"^J\",3,\"^K\",true,\"^L\",3316,\"^M\",3316,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Executes the code within the draw fn one time. This functions\\n  allows the program to update the display window only when necessary,\\n  for example when an event registered by mouse-pressed or\\n  key-pressed occurs.\\n\\n  In structuring a program, it only makes sense to call redraw\\n  within events such as mouse-pressed. This is because redraw does\\n  not run draw immediately (it only sets a flag that indicates an\\n  update is needed).\\n\\n  Calling redraw within draw has no effect because draw is\\n  continuously called anyway.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/redraw\",\"^T\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^H\",9,\"^I\",\"redraw()\",\"^U\",[\"^O\",[[]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",3310,\"^M\",3316,\"^X\",0,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Executes the code within the draw fn one time. This functions\\n  allows the program to update the display window only when necessary,\\n  for example when an event registered by mouse-pressed or\\n  key-pressed occurs.\\n\\n  In structuring a program, it only makes sense to call redraw\\n  within events such as mouse-pressed. This is because redraw does\\n  not run draw immediately (it only sets a flag that indicates an\\n  update is needed).\\n\\n  Calling redraw within draw has no effect because draw is\\n  continuously called anyway.\"],\"~$RAD-TO-DEG\",[\"^ \",\"^5\",\"~$quil.core$macros/RAD-TO-DEG\",\"^F\",\"quil/core.cljc\",\"^L\",83,\"^J\",1,\"^M\",83,\"^H\",16,\"^C\",[\"^ \",\"^F\",\"^G\",\"^L\",83,\"^J\",6,\"^M\",83,\"^H\",16]],\"~$get-pixel\",[\"^ \",\"^A\",\"Image\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Image\",\"^D\",\"1.0\",\"^E\",\"Pixels\",\"^F\",\"^G\",\"^H\",12,\"^15\",[\"^ \",\"^T\",false,\"^X\",5,\"^U\",[\"^O\",[[],[\"^1Z\"],[\"~$x\",\"~$y\"],[\"^1Z\",\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$w\",\"~$h\"],[\"^1Z\",\"~$x\",\"~$y\",\"~$w\",\"~$h\"]]],\"^N\",[\"^O\",[[],[\"^1Z\"],[\"~$x\",\"~$y\"],[\"^1Z\",\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$w\",\"~$h\"],[\"^1Z\",\"~$x\",\"~$y\",\"~$w\",\"~$h\"]]],\"^W\",[\"^O\",[null,null,null,null,null,null]]],\"^I\",\"get()\",\"^J\",3,\"^K\",true,\"^L\",1911,\"^M\",1911,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[],[\"^1Z\"],[\"~$x\",\"~$y\"],[\"^1Z\",\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$w\",\"~$h\"],[\"^1Z\",\"~$x\",\"~$y\",\"~$w\",\"~$h\"]]]]],\"^R\",\"Reads the color of any pixel or grabs a section of an image. If no\\n  parameters are specified, a copy of entire image is returned. Get the\\n  value of one pixel by specifying an x,y coordinate. Get a section of\\n  the image by specifying an additional width and height parameter.\\n  If the pixel requested is outside of the image window, black is returned.\\n  The numbers returned are scaled according to the current color ranges,\\n  but only RGB values are returned by this function. For example, even though\\n  you may have drawn a shape with (color-mode :hsb), the numbers returned\\n  will be in RGB.\\n\\n  Getting the color of a single pixel with (get x y) is easy, but not\\n  as fast as grabbing the data directly using the pixels fn.\\n\\n  If no img specified - current-graphics is used.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/get-pixel\",\"^T\",false,\"^E\",\"Pixels\",\"^F\",\"quil/core.cljc\",\"^H\",12,\"^15\",[\"^ \",\"^T\",false,\"^X\",5,\"^U\",[\"^O\",[[],[\"^1Z\"],[\"~$x\",\"~$y\"],[\"^1Z\",\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$w\",\"~$h\"],[\"^1Z\",\"~$x\",\"~$y\",\"~$w\",\"~$h\"]]],\"^N\",[\"^O\",[[],[\"^1Z\"],[\"~$x\",\"~$y\"],[\"^1Z\",\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$w\",\"~$h\"],[\"^1Z\",\"~$x\",\"~$y\",\"~$w\",\"~$h\"]]],\"^W\",[\"^O\",[null,null,null,null,null,null]]],\"^I\",\"get()\",\"^U\",[\"^O\",[[],[\"^1Z\"],[\"~$x\",\"~$y\"],[\"^1Z\",\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$w\",\"~$h\"],[\"^1Z\",\"~$x\",\"~$y\",\"~$w\",\"~$h\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null,null,null,null,null]],\"^J\",1,\"^K\",true,\"^L\",1905,\"^M\",1911,\"^X\",5,\"^Y\",true,\"^N\",[\"^O\",[[],[\"^1Z\"],[\"~$x\",\"~$y\"],[\"^1Z\",\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$w\",\"~$h\"],[\"^1Z\",\"~$x\",\"~$y\",\"~$w\",\"~$h\"]]],\"^R\",\"Reads the color of any pixel or grabs a section of an image. If no\\n  parameters are specified, a copy of entire image is returned. Get the\\n  value of one pixel by specifying an x,y coordinate. Get a section of\\n  the image by specifying an additional width and height parameter.\\n  If the pixel requested is outside of the image window, black is returned.\\n  The numbers returned are scaled according to the current color ranges,\\n  but only RGB values are returned by this function. For example, even though\\n  you may have drawn a shape with (color-mode :hsb), the numbers returned\\n  will be in RGB.\\n\\n  Getting the color of a single pixel with (get x y) is easy, but not\\n  as fast as grabbing the data directly using the pixels fn.\\n\\n  If no img specified - current-graphics is used.\"],\"~$rotate\",[\"^ \",\"^A\",\"Transform\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Transform\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^G\",\"^H\",9,\"^15\",[\"^ \",\"^T\",false,\"^X\",4,\"^U\",[\"^O\",[[\"^Q\"],[\"^Q\",\"~$vx\",\"~$vy\",\"~$vz\"]]],\"^N\",[\"^O\",[[\"^Q\"],[\"^Q\",\"^?N\",\"^?O\",\"^?P\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"rotate()\",\"^J\",3,\"^K\",true,\"^L\",3410,\"^M\",3410,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^Q\"],[\"^Q\",\"^?N\",\"^?O\",\"^?P\"]]]]],\"^R\",\"Rotates a shape the amount specified by the angle parameter. Angles\\n  should be specified in radians (values from 0 to TWO-PI) or\\n  converted to radians with the radians function.\\n\\n  Objects are always rotated around their relative position to the\\n  origin and positive numbers rotate objects in a clockwise\\n  direction. Transformations apply to everything that happens after\\n  and subsequent calls to the function accumulates the effect. For\\n  example, calling (rotate HALF-PI) and then (rotate HALF-PI) is the\\n  same as (rotate PI). All tranformations are reset when draw begins\\n  again.\\n\\n  Technically, rotate multiplies the current transformation matrix by\\n  a rotation matrix. This function can be further controlled by the\\n  push-matrix and pop-matrix.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/rotate\",\"^T\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^H\",9,\"^15\",[\"^ \",\"^T\",false,\"^X\",4,\"^U\",[\"^O\",[[\"^Q\"],[\"^Q\",\"^?N\",\"^?O\",\"^?P\"]]],\"^N\",[\"^O\",[[\"^Q\"],[\"^Q\",\"^?N\",\"^?O\",\"^?P\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"rotate()\",\"^U\",[\"^O\",[[\"^Q\"],[\"^Q\",\"^?N\",\"^?O\",\"^?P\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",3404,\"^M\",3410,\"^X\",4,\"^Y\",true,\"^N\",[\"^O\",[[\"^Q\"],[\"^Q\",\"^?N\",\"^?O\",\"^?P\"]]],\"^R\",\"Rotates a shape the amount specified by the angle parameter. Angles\\n  should be specified in radians (values from 0 to TWO-PI) or\\n  converted to radians with the radians function.\\n\\n  Objects are always rotated around their relative position to the\\n  origin and positive numbers rotate objects in a clockwise\\n  direction. Transformations apply to everything that happens after\\n  and subsequent calls to the function accumulates the effect. For\\n  example, calling (rotate HALF-PI) and then (rotate HALF-PI) is the\\n  same as (rotate PI). All tranformations are reset when draw begins\\n  again.\\n\\n  Technically, rotate multiplies the current transformation matrix by\\n  a rotation matrix. This function can be further controlled by the\\n  push-matrix and pop-matrix.\"],\"~$set-pixel\",[\"^ \",\"^A\",\"Image\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Image\",\"^D\",\"1.0\",\"^E\",\"Pixels\",\"^F\",\"^G\",\"^H\",12,\"^15\",[\"^ \",\"^T\",false,\"^X\",4,\"^U\",[\"^O\",[[\"~$x\",\"~$y\",\"~$c\"],[\"^1Z\",\"~$x\",\"~$y\",\"~$c\"]]],\"^N\",[\"^O\",[[\"~$x\",\"~$y\",\"~$c\"],[\"^1Z\",\"~$x\",\"~$y\",\"~$c\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"set()\",\"^J\",3,\"^K\",true,\"^L\",3668,\"^M\",3668,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$x\",\"~$y\",\"~$c\"],[\"^1Z\",\"~$x\",\"~$y\",\"~$c\"]]]]],\"^R\",\"Changes the color of any pixel in the display window. The x and y\\n  parameters specify the pixel to change and the color parameter\\n  specifies the color value. The color parameter is affected by the\\n  current color mode (the default is RGB values from 0 to 255).\\n\\n  Setting the color of a single pixel with (set x, y) is easy, but not\\n  as fast as putting the data directly into pixels[].\\n\\n  This function ignores imageMode().\\n\\n  Due to what appears to be a bug in Apple's Java implementation, the\\n  point() and set() methods are extremely slow in some circumstances\\n  when used with the default renderer. Using :p2d or :p3d will fix the\\n  problem. Grouping many calls to point or set-pixel together can also\\n  help. (Bug 1094)\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/set-pixel\",\"^T\",false,\"^E\",\"Pixels\",\"^F\",\"quil/core.cljc\",\"^H\",12,\"^15\",[\"^ \",\"^T\",false,\"^X\",4,\"^U\",[\"^O\",[[\"~$x\",\"~$y\",\"~$c\"],[\"^1Z\",\"~$x\",\"~$y\",\"~$c\"]]],\"^N\",[\"^O\",[[\"~$x\",\"~$y\",\"~$c\"],[\"^1Z\",\"~$x\",\"~$y\",\"~$c\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"set()\",\"^U\",[\"^O\",[[\"~$x\",\"~$y\",\"~$c\"],[\"^1Z\",\"~$x\",\"~$y\",\"~$c\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",3662,\"^M\",3668,\"^X\",4,\"^Y\",true,\"^N\",[\"^O\",[[\"~$x\",\"~$y\",\"~$c\"],[\"^1Z\",\"~$x\",\"~$y\",\"~$c\"]]],\"^R\",\"Changes the color of any pixel in the display window. The x and y\\n  parameters specify the pixel to change and the color parameter\\n  specifies the color value. The color parameter is affected by the\\n  current color mode (the default is RGB values from 0 to 255).\\n\\n  Setting the color of a single pixel with (set x, y) is easy, but not\\n  as fast as putting the data directly into pixels[].\\n\\n  This function ignores imageMode().\\n\\n  Due to what appears to be a bug in Apple's Java implementation, the\\n  point() and set() methods are extremely slow in some circumstances\\n  when used with the default renderer. Using :p2d or :p3d will fix the\\n  problem. Grouping many calls to point or set-pixel together can also\\n  help. (Bug 1094)\"],\"~$push-matrix\",[\"^ \",\"^A\",\"Transform\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Transform\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^G\",\"^H\",14,\"^I\",\"pushMatrix()\",\"^J\",3,\"^K\",true,\"^L\",3082,\"^M\",3082,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Pushes the current transformation matrix onto the matrix\\n  stack. Understanding push-matrix and pop-matrix requires\\n  understanding the concept of a matrix stack. The push-matrix\\n  function saves the current coordinate system to the stack and\\n  pop-matrix restores the prior coordinate system. push-matrix and\\n  pop-matrix are used in conjuction with the other transformation\\n  methods and may be embedded to control the scope of the\\n  transformations.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/push-matrix\",\"^T\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^H\",14,\"^I\",\"pushMatrix()\",\"^U\",[\"^O\",[[]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",3076,\"^M\",3082,\"^X\",0,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Pushes the current transformation matrix onto the matrix\\n  stack. Understanding push-matrix and pop-matrix requires\\n  understanding the concept of a matrix stack. The push-matrix\\n  function saves the current coordinate system to the stack and\\n  pop-matrix restores the prior coordinate system. push-matrix and\\n  pop-matrix are used in conjuction with the other transformation\\n  methods and may be embedded to control the scope of the\\n  transformations.\"],\"~$no-smooth\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"Attributes\",\"^F\",\"^G\",\"^H\",12,\"^I\",\"noSmooth()\",\"^J\",3,\"^K\",true,\"^L\",2825,\"^M\",2825,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Draws all geometry with jagged (aliased) edges. Must be called inside\\n  :settings handler.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/no-smooth\",\"^T\",false,\"^E\",\"Attributes\",\"^F\",\"quil/core.cljc\",\"^H\",12,\"^I\",\"noSmooth()\",\"^U\",[\"^O\",[[]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",2819,\"^M\",2825,\"^X\",0,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Draws all geometry with jagged (aliased) edges. Must be called inside\\n  :settings handler.\"],\"^2?\",[\"^ \",\"^A\",\"Color\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Color\",\"^D\",\"1.0\",\"^E\",\"Creating & Reading\",\"^F\",\"^G\",\"^H\",8,\"^I\",\"alpha()\",\"^J\",3,\"^K\",true,\"^L\",313,\"^M\",313,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^7J\"]]]]],\"^R\",\"Extracts the alpha value from a color.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/alpha\",\"^T\",false,\"^E\",\"Creating & Reading\",\"^F\",\"quil/core.cljc\",\"^H\",8,\"^I\",\"alpha()\",\"^U\",[\"^O\",[[\"^7J\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",307,\"^M\",313,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^7J\"]]]]],\"^R\",\"Extracts the alpha value from a color.\"],\"~$camera\",[\"^ \",\"^A\",\"Lights, Camera\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Lights, Camera\",\"^D\",\"1.0\",\"^E\",\"Camera\",\"^F\",\"^G\",\"^H\",9,\"^15\",[\"^ \",\"^T\",false,\"^X\",9,\"^U\",[\"^O\",[[],[\"~$eyeX\",\"~$eyeY\",\"~$eyeZ\",\"~$centerX\",\"~$centerY\",\"~$centerZ\",\"~$upX\",\"~$upY\",\"~$upZ\"]]],\"^N\",[\"^O\",[[],[\"^?Z\",\"^?[\",\"^@0\",\"^@1\",\"^@2\",\"^@3\",\"^@4\",\"^@5\",\"^@6\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"camera()\",\"^J\",3,\"^K\",true,\"^L\",939,\"^M\",939,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[],[\"^?Z\",\"^?[\",\"^@0\",\"^@1\",\"^@2\",\"^@3\",\"^@4\",\"^@5\",\"^@6\"]]]]],\"^R\",\"Sets the position of the camera through setting the eye position,\\n  the center of the scene, and which axis is facing upward. Moving the\\n  eye position and the direction it is pointing (the center of the\\n  scene) allows the images to be seen from different angles. The\\n  version without any parameters sets the camera to the default\\n  position, pointing to the center of the display window with the Y\\n  axis as up. The default values are:\\n\\n  eyeX:     (/ (width) 2.0)\\n  eyeY:     (/ (height) 2.0)\\n  eyeZ:     (/ (/ (height) 2.0) (tan (/ (* Math/PI 60.0) 360.0)))\\n  centerX:  (/ (width) 2.0)\\n  centerY:  (/ (height) 2.0)\\n  centerZ:  0\\n  upX:      0\\n  upY:      1\\n  upZ:      0\\n\\n  Similar imilar to gluLookAt() in OpenGL, but it first clears the\\n  current camera settings.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/camera\",\"^T\",false,\"^E\",\"Camera\",\"^F\",\"quil/core.cljc\",\"^H\",9,\"^15\",[\"^ \",\"^T\",false,\"^X\",9,\"^U\",[\"^O\",[[],[\"^?Z\",\"^?[\",\"^@0\",\"^@1\",\"^@2\",\"^@3\",\"^@4\",\"^@5\",\"^@6\"]]],\"^N\",[\"^O\",[[],[\"^?Z\",\"^?[\",\"^@0\",\"^@1\",\"^@2\",\"^@3\",\"^@4\",\"^@5\",\"^@6\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"camera()\",\"^U\",[\"^O\",[[],[\"^?Z\",\"^?[\",\"^@0\",\"^@1\",\"^@2\",\"^@3\",\"^@4\",\"^@5\",\"^@6\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",933,\"^M\",939,\"^X\",9,\"^Y\",true,\"^N\",[\"^O\",[[],[\"^?Z\",\"^?[\",\"^@0\",\"^@1\",\"^@2\",\"^@3\",\"^@4\",\"^@5\",\"^@6\"]]],\"^R\",\"Sets the position of the camera through setting the eye position,\\n  the center of the scene, and which axis is facing upward. Moving the\\n  eye position and the direction it is pointing (the center of the\\n  scene) allows the images to be seen from different angles. The\\n  version without any parameters sets the camera to the default\\n  position, pointing to the center of the display window with the Y\\n  axis as up. The default values are:\\n\\n  eyeX:     (/ (width) 2.0)\\n  eyeY:     (/ (height) 2.0)\\n  eyeZ:     (/ (/ (height) 2.0) (tan (/ (* Math/PI 60.0) 360.0)))\\n  centerX:  (/ (width) 2.0)\\n  centerY:  (/ (height) 2.0)\\n  centerZ:  0\\n  upX:      0\\n  upY:      1\\n  upZ:      0\\n\\n  Similar imilar to gluLookAt() in OpenGL, but it first clears the\\n  current camera settings.\"],\"~$translate\",[\"^ \",\"^A\",\"Transform\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Transform\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^G\",\"^H\",12,\"^15\",[\"^ \",\"^T\",false,\"^X\",3,\"^U\",[\"^O\",[[\"~$v\"],[\"~$tx\",\"~$ty\"],[\"^@9\",\"^@:\",\"~$tz\"]]],\"^N\",[\"^O\",[[\"~$v\"],[\"^@9\",\"^@:\"],[\"^@9\",\"^@:\",\"^@;\"]]],\"^W\",[\"^O\",[null,null,null]]],\"^I\",\"translate()\",\"^J\",3,\"^K\",true,\"^L\",4460,\"^M\",4460,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$v\"],[\"^@9\",\"^@:\"],[\"^@9\",\"^@:\",\"^@;\"]]]]],\"^R\",\"Specifies an amount to displace objects within the display\\n  window. The x parameter specifies left/right translation, the y\\n  parameter specifies up/down translation, and the z parameter\\n  specifies translations toward/away from the screen.  Transformations\\n  apply to everything that happens after and subsequent calls to the\\n  function accumulates the effect. For example, calling (translate 50\\n  0) and then (translate 20, 0) is the same as (translate 70, 0). If\\n  translate is called within draw, the transformation is reset when\\n  the loop begins again. This function can be further controlled by\\n  the push-matrix and pop-matrix.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/translate\",\"^T\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^H\",12,\"^15\",[\"^ \",\"^T\",false,\"^X\",3,\"^U\",[\"^O\",[[\"~$v\"],[\"^@9\",\"^@:\"],[\"^@9\",\"^@:\",\"^@;\"]]],\"^N\",[\"^O\",[[\"~$v\"],[\"^@9\",\"^@:\"],[\"^@9\",\"^@:\",\"^@;\"]]],\"^W\",[\"^O\",[null,null,null]]],\"^I\",\"translate()\",\"^U\",[\"^O\",[[\"~$v\"],[\"^@9\",\"^@:\"],[\"^@9\",\"^@:\",\"^@;\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null,null]],\"^J\",1,\"^K\",true,\"^L\",4454,\"^M\",4460,\"^X\",3,\"^Y\",true,\"^N\",[\"^O\",[[\"~$v\"],[\"^@9\",\"^@:\"],[\"^@9\",\"^@:\",\"^@;\"]]],\"^R\",\"Specifies an amount to displace objects within the display\\n  window. The x parameter specifies left/right translation, the y\\n  parameter specifies up/down translation, and the z parameter\\n  specifies translations toward/away from the screen.  Transformations\\n  apply to everything that happens after and subsequent calls to the\\n  function accumulates the effect. For example, calling (translate 50\\n  0) and then (translate 20, 0) is the same as (translate 70, 0). If\\n  translate is called within draw, the transformation is reset when\\n  the loop begins again. This function can be further controlled by\\n  the push-matrix and pop-matrix.\"],\"~$load-font\",[\"^ \",\"^A\",\"Typography\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Typography\",\"^D\",\"1.0\",\"^E\",\"Loading & Displaying\",\"^F\",\"^G\",\"^H\",12,\"^I\",\"loadFont()\",\"^J\",3,\"^K\",true,\"^L\",2343,\"^M\",2343,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^4M\"]]]]],\"^R\",\"Loads a font into a variable of type PFont. To load correctly,\\n  fonts must be located in the data directory of the current sketch.\\n  To create a font to use with Processing use the create-font fn.\\n\\n  Like load-image and other methods that load data, the load-font fn\\n  should not be used inside draw, because it will slow down the sketch\\n  considerably, as the font will be re-loaded from the disk (or\\n  network) on each frame.\\n\\n  For most renderers, Processing displays fonts using the .vlw font\\n  format, which uses images for each letter, rather than defining them\\n  through vector data. When hint :enable-native-fonts is used with the\\n  JAVA2D renderer, the native version of a font will be used if it is\\n  installed on the user's machine.\\n\\n  Using create-font (instead of load-font) enables vector data to be\\n  used with the JAVA2D (default) renderer setting. This can be helpful\\n  when many font sizes are needed, or when using any renderer based on\\n  JAVA2D, such as the PDF library.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/load-font\",\"^T\",false,\"^E\",\"Loading & Displaying\",\"^F\",\"quil/core.cljc\",\"^H\",12,\"^I\",\"loadFont()\",\"^U\",[\"^O\",[[\"^4M\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",2337,\"^M\",2343,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^4M\"]]]]],\"^R\",\"Loads a font into a variable of type PFont. To load correctly,\\n  fonts must be located in the data directory of the current sketch.\\n  To create a font to use with Processing use the create-font fn.\\n\\n  Like load-image and other methods that load data, the load-font fn\\n  should not be used inside draw, because it will slow down the sketch\\n  considerably, as the font will be re-loaded from the disk (or\\n  network) on each frame.\\n\\n  For most renderers, Processing displays fonts using the .vlw font\\n  format, which uses images for each letter, rather than defining them\\n  through vector data. When hint :enable-native-fonts is used with the\\n  JAVA2D renderer, the native version of a font will be used if it is\\n  installed on the user's machine.\\n\\n  Using create-font (instead of load-font) enables vector data to be\\n  used with the JAVA2D (default) renderer setting. This can be helpful\\n  when many font sizes are needed, or when using any renderer based on\\n  JAVA2D, such as the PDF library.\"],\"~$ambient\",[\"^ \",\"^A\",\"Lights, Camera\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Lights, Camera\",\"^D\",\"1.0\",\"^E\",\"Material Properties\",\"^F\",\"^G\",\"^H\",10,\"^15\",[\"^ \",\"^T\",false,\"^X\",3,\"^U\",[\"^O\",[[\"^3:\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^N\",[\"^O\",[[\"^3:\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"ambient()\",\"^J\",3,\"^K\",true,\"^L\",356,\"^M\",356,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^3:\"],[\"~$x\",\"~$y\",\"~$z\"]]]]],\"^R\",\"Sets the ambient reflectance for shapes drawn to the screen. This\\n  is combined with the ambient light component of environment. The\\n  color components set through the parameters define the\\n  reflectance. For example in the default color mode, setting x=255,\\n  y=126, z=0, would cause all the red light to reflect and half of the\\n  green light to reflect. Used in combination with emissive, specular,\\n  and shininess in setting the material properties of shapes.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/ambient\",\"^T\",false,\"^E\",\"Material Properties\",\"^F\",\"quil/core.cljc\",\"^H\",10,\"^15\",[\"^ \",\"^T\",false,\"^X\",3,\"^U\",[\"^O\",[[\"^3:\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^N\",[\"^O\",[[\"^3:\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"ambient()\",\"^U\",[\"^O\",[[\"^3:\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",350,\"^M\",356,\"^X\",3,\"^Y\",true,\"^N\",[\"^O\",[[\"^3:\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^R\",\"Sets the ambient reflectance for shapes drawn to the screen. This\\n  is combined with the ambient light component of environment. The\\n  color components set through the parameters define the\\n  reflectance. For example in the default color mode, setting x=255,\\n  y=126, z=0, would cause all the red light to reflect and half of the\\n  green light to reflect. Used in combination with emissive, specular,\\n  and shininess in setting the material properties of shapes.\"],\"~$shear-y\",[\"^ \",\"^A\",\"Transform\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Transform\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^G\",\"^H\",10,\"^I\",\"shearY()\",\"^J\",3,\"^K\",true,\"^L\",3773,\"^M\",3773,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^Q\"]]]]],\"^R\",\"Shears a shape around the y-axis the amount specified by the angle\\n  parameter. Angles should be specified in radians (values from 0 to\\n  PI*2) or converted to radians with the radians() function. Objects\\n  are always sheared around their relative position to the origin and\\n  positive numbers shear objects in a clockwise direction.\\n  Transformations apply to everything that happens after and\\n  subsequent calls to the function accumulates the effect. For\\n  example, calling (shear-y (/ PI 2)) and then (shear-y (/ PI 2)) is\\n  the same as (shear-y PI). If shear-y is called within the draw fn,\\n  the transformation is reset when the loop begins again. This\\n  function works in P2D or JAVA2D mode.\\n\\n  Technically, shear-y multiplies the current transformation matrix\\n  by a rotation matrix. This function can be further controlled by the\\n  push-matrix and pop-matrix fns.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/shear-y\",\"^T\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^H\",10,\"^I\",\"shearY()\",\"^U\",[\"^O\",[[\"^Q\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",3767,\"^M\",3773,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^Q\"]]]]],\"^R\",\"Shears a shape around the y-axis the amount specified by the angle\\n  parameter. Angles should be specified in radians (values from 0 to\\n  PI*2) or converted to radians with the radians() function. Objects\\n  are always sheared around their relative position to the origin and\\n  positive numbers shear objects in a clockwise direction.\\n  Transformations apply to everything that happens after and\\n  subsequent calls to the function accumulates the effect. For\\n  example, calling (shear-y (/ PI 2)) and then (shear-y (/ PI 2)) is\\n  the same as (shear-y PI). If shear-y is called within the draw fn,\\n  the transformation is reset when the loop begins again. This\\n  function works in P2D or JAVA2D mode.\\n\\n  Technically, shear-y multiplies the current transformation matrix\\n  by a rotation matrix. This function can be further controlled by the\\n  push-matrix and pop-matrix fns.\"],\"~$cursor-modes\",[\"^ \",\"^5\",\"~$quil.core$macros/cursor-modes\",\"^F\",\"quil/core.cljc\",\"^L\",45,\"^J\",1,\"^M\",72,\"^H\",14,\"^C\",[\"^ \",\"^F\",\"^G\",\"^L\",72,\"^J\",2,\"^M\",72,\"^H\",14]],\"~$mouse-y\",[\"^ \",\"^A\",\"Input\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Input\",\"^D\",\"1.0\",\"^E\",\"Mouse\",\"^F\",\"^G\",\"^H\",10,\"^I\",\"mouseY\",\"^J\",3,\"^K\",true,\"^L\",2629,\"^M\",2629,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Current vertical coordinate of the mouse.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/mouse-y\",\"^T\",false,\"^E\",\"Mouse\",\"^F\",\"quil/core.cljc\",\"^H\",10,\"^I\",\"mouseY\",\"^U\",[\"^O\",[[]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",2623,\"^M\",2629,\"^X\",0,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Current vertical coordinate of the mouse.\"],\"~$mouse-button\",[\"^ \",\"^A\",\"Input\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Input\",\"^D\",\"1.0\",\"^E\",\"Mouse\",\"^F\",\"^G\",\"^H\",15,\"^I\",\"mouseButton\",\"^J\",3,\"^K\",true,\"^L\",2580,\"^M\",2580,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"The value of the system variable mouseButton is either :left, :right,\\n  or :center depending on which button is pressed. nil if no button pressed\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/mouse-button\",\"^T\",false,\"^E\",\"Mouse\",\"^F\",\"quil/core.cljc\",\"^H\",15,\"^I\",\"mouseButton\",\"^U\",[\"^O\",[[]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",2574,\"^M\",2580,\"^X\",0,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"The value of the system variable mouseButton is either :left, :right,\\n  or :center depending on which button is pressed. nil if no button pressed\"],\"~$p-shape-modes\",[\"^ \",\"^5\",\"~$quil.core$macros/p-shape-modes\",\"^F\",\"quil/core.cljc\",\"^L\",45,\"^J\",1,\"^M\",63,\"^H\",15,\"^C\",[\"^ \",\"^F\",\"^G\",\"^L\",63,\"^J\",2,\"^M\",63,\"^H\",15]],\"~$image\",[\"^ \",\"^A\",\"Image\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Image\",\"^D\",\"1.0\",\"^E\",\"Loading & Displaying\",\"^F\",\"^G\",\"^H\",8,\"^15\",[\"^ \",\"^T\",false,\"^X\",5,\"^U\",[\"^O\",[[\"^1Z\",\"~$x\",\"~$y\"],[\"^1Z\",\"~$x\",\"~$y\",\"~$c\",\"~$d\"]]],\"^N\",[\"^O\",[[\"^1Z\",\"~$x\",\"~$y\"],[\"^1Z\",\"~$x\",\"~$y\",\"~$c\",\"~$d\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"image()\",\"^J\",3,\"^K\",true,\"^L\",2076,\"^M\",2076,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^1Z\",\"~$x\",\"~$y\"],[\"^1Z\",\"~$x\",\"~$y\",\"~$c\",\"~$d\"]]]]],\"^R\",\"Displays images to the screen. Processing currently works with GIF,\\n  JPEG, and Targa images. The color of an image may be modified with\\n  the tint function and if a GIF has transparency, it will maintain\\n  its transparency. The img parameter specifies the image to display\\n  and the x and y parameters define the location of the image from its\\n  upper-left corner. The image is displayed at its original size\\n  unless the width and height parameters specify a different size. The\\n  image-mode fn changes the way the parameters work. A call to\\n  (image-mode :corners) will change the width and height parameters to\\n  define the x and y values of the opposite corner of the image.\\n\\n  Starting with release 0124, when using the default (JAVA2D)\\n  renderer, smooth will also improve image quality of resized\\n  images.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/image\",\"^T\",false,\"^E\",\"Loading & Displaying\",\"^F\",\"quil/core.cljc\",\"^H\",8,\"^15\",[\"^ \",\"^T\",false,\"^X\",5,\"^U\",[\"^O\",[[\"^1Z\",\"~$x\",\"~$y\"],[\"^1Z\",\"~$x\",\"~$y\",\"~$c\",\"~$d\"]]],\"^N\",[\"^O\",[[\"^1Z\",\"~$x\",\"~$y\"],[\"^1Z\",\"~$x\",\"~$y\",\"~$c\",\"~$d\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"image()\",\"^U\",[\"^O\",[[\"^1Z\",\"~$x\",\"~$y\"],[\"^1Z\",\"~$x\",\"~$y\",\"~$c\",\"~$d\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",2070,\"^M\",2076,\"^X\",5,\"^Y\",true,\"^N\",[\"^O\",[[\"^1Z\",\"~$x\",\"~$y\"],[\"^1Z\",\"~$x\",\"~$y\",\"~$c\",\"~$d\"]]],\"^R\",\"Displays images to the screen. Processing currently works with GIF,\\n  JPEG, and Targa images. The color of an image may be modified with\\n  the tint function and if a GIF has transparency, it will maintain\\n  its transparency. The img parameter specifies the image to display\\n  and the x and y parameters define the location of the image from its\\n  upper-left corner. The image is displayed at its original size\\n  unless the width and height parameters specify a different size. The\\n  image-mode fn changes the way the parameters work. A call to\\n  (image-mode :corners) will change the width and height parameters to\\n  define the x and y values of the opposite corner of the image.\\n\\n  Starting with release 0124, when using the default (JAVA2D)\\n  renderer, smooth will also improve image quality of resized\\n  images.\"],\"~$unbinary\",[\"^ \",\"^A\",\"Data\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Data\",\"^4@\",false,\"^D\",\"1.0\",\"^E\",\"Conversion\",\"^F\",\"^G\",\"^H\",11,\"^I\",\"unbinary()\",\"^J\",3,\"^L\",4498,\"^M\",4498,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$str-val\"]]]]],\"^R\",\"Unpack a binary string to an integer. See binary for converting\\n  integers to strings.\"],\"^4@\",false,\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/unbinary\",\"^T\",false,\"^E\",\"Conversion\",\"^F\",\"quil/core.cljc\",\"^H\",11,\"^I\",\"unbinary()\",\"^U\",[\"^O\",[[\"^@N\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^L\",4492,\"^M\",4498,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^@N\"]]]]],\"^R\",\"Unpack a binary string to an integer. See binary for converting\\n  integers to strings.\"],\"~$no-tint\",[\"^ \",\"^A\",\"Image\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Image\",\"^D\",\"1.0\",\"^E\",\"Loading & Displaying\",\"^F\",\"^G\",\"^H\",10,\"^I\",\"noTint()\",\"^J\",3,\"^K\",true,\"^L\",2848,\"^M\",2848,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Removes the current fill value for displaying images and reverts to\\n  displaying images with their original hues.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/no-tint\",\"^T\",false,\"^E\",\"Loading & Displaying\",\"^F\",\"quil/core.cljc\",\"^H\",10,\"^I\",\"noTint()\",\"^U\",[\"^O\",[[]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",2842,\"^M\",2848,\"^X\",0,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Removes the current fill value for displaying images and reverts to\\n  displaying images with their original hues.\"],\"~$no-lights\",[\"^ \",\"^A\",\"Lights, Camera\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Lights, Camera\",\"^D\",\"1.0\",\"^E\",\"Lights\",\"^F\",\"^G\",\"^H\",12,\"^I\",\"noLights()\",\"^J\",3,\"^K\",true,\"^L\",2757,\"^M\",2757,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Disable all lighting. Lighting is turned off by default and enabled\\n  with the lights fn. This function can be used to disable lighting so\\n  that 2D geometry (which does not require lighting) can be drawn\\n  after a set of lighted 3D geometry.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/no-lights\",\"^T\",false,\"^E\",\"Lights\",\"^F\",\"quil/core.cljc\",\"^H\",12,\"^I\",\"noLights()\",\"^U\",[\"^O\",[[]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",2751,\"^M\",2757,\"^X\",0,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[]]]]],\"^R\",\"Disable all lighting. Lighting is turned off by default and enabled\\n  with the lights fn. This function can be used to disable lighting so\\n  that 2D geometry (which does not require lighting) can be drawn\\n  after a set of lighted 3D geometry.\"],\"~$emissive-int\",[\"^ \",\"^A\",\"Lights, Camera\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Lights, Camera\",\"^D\",\"1.0\",\"^E\",\"Material Properties\",\"^F\",\"^G\",\"^H\",15,\"^I\",\"emissive()\",\"^J\",3,\"^K\",true,\"^L\",1580,\"^M\",1580,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$int-val\"]]]]],\"^R\",\"Sets the emissive color of the material used for drawing shapes\\n  drawn to the screen. Used in combination with ambient, specular, and\\n  shininess in setting the material properties of shapes. Converts all\\n  args to ints\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/emissive-int\",\"^T\",false,\"^E\",\"Material Properties\",\"^F\",\"quil/core.cljc\",\"^H\",15,\"^I\",\"emissive()\",\"^U\",[\"^O\",[[\"^@U\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",1574,\"^M\",1580,\"^X\",1,\"^Y\",true,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"^@U\"]]]]],\"^R\",\"Sets the emissive color of the material used for drawing shapes\\n  drawn to the screen. Used in combination with ambient, specular, and\\n  shininess in setting the material properties of shapes. Converts all\\n  args to ints\"],\"~$point\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"2D Primitives\",\"^F\",\"^G\",\"^H\",8,\"^15\",[\"^ \",\"^T\",false,\"^X\",3,\"^U\",[\"^O\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^N\",[\"^O\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"point()\",\"^J\",3,\"^K\",true,\"^L\",2967,\"^M\",2967,\"^N\",[\"^O\",[\"^P\",[\"^O\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]]]],\"^R\",\"Draws a point, a coordinate in space at the dimension of one\\n  pixel. The first parameter is the horizontal value for the point,\\n  the second value is the vertical value for the point, and the\\n  optional third value is the depth value. Drawing this shape in 3D\\n  using the z parameter requires the :P3D or :opengl renderer to be\\n  used.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core$macros/point\",\"^T\",false,\"^E\",\"2D Primitives\",\"^F\",\"quil/core.cljc\",\"^H\",8,\"^15\",[\"^ \",\"^T\",false,\"^X\",3,\"^U\",[\"^O\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^N\",[\"^O\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^W\",[\"^O\",[null,null]]],\"^I\",\"point()\",\"^U\",[\"^O\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^V\",null,\"^W\",[\"^O\",[null,null]],\"^J\",1,\"^K\",true,\"^L\",2961,\"^M\",2967,\"^X\",3,\"^Y\",true,\"^N\",[\"^O\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^R\",\"Draws a point, a coordinate in space at the dimension of one\\n  pixel. The first parameter is the horizontal value for the point,\\n  the second value is the vertical value for the point, and the\\n  optional third value is the depth value. Drawing this shape in 3D\\n  using the z parameter requires the :P3D or :opengl renderer to be\\n  used.\"]],\"~:require-macros\",[\"^ \",\"^;\",\"^<\",\"^<\",\"^<\",\"~$u\",\"^=\",\"^=\",\"^=\"],\"~:cljs.analyzer/constants\",[\"^ \",\"~:seen\",[\"^4\",[\"~:shift\",\"~$.endDraw\",\"~:open\",\"~:baseline\",\"~:disable-stroke-perspective\",\"~:hsb\",\"~:quads\",\"~:arrow\",\"~:dilate\",\"~$quil.core/current-fill\",\"~$try\",\"~$quil.core/*graphics*\",\"~:quad-strip\",\"~:down\",\"~:disable-depth-mask\",\"~$cljs.core/binding\",\"~:burn\",\"~:posterize\",\"~$quil.sketch/with-sketch\",\"~:f8\",\"~$quil.core/translate\",\"~:screen\",\"~:enable-depth-test\",\"~:gray\",\"~:enable-depth-sort\",\"~:f1\",\"~:corner\",\"~:disable-texture-mipmaps\",\"~:darkest\",\"~:f10\",\"~:dodge\",\"~:bottom\",\"~$tr__19__auto__\",\"~$gr__21__auto__\",\"~:bevel\",\"~:disable-stroke-pure\",\"~:replace\",\"~:alt\",\"~:top\",\"~$cljs.core/apply\",\"~:disable-depth-test\",\"~$finally\",\"~:pie\",\"~$quil.core/pop-matrix\",\"~:enable-stroke-perspective\",\"~:chord\",\"~:rgb\",\"~$.dispose\",\"~:lines\",\"~:argb\",\"~:move\",\"~:f5\",\"~:command\",\"~$tr__20__auto__\",\"~$quil.core/stroke\",\"~:miter\",\"~:points\",\"~:hand\",\"~:close\",\"~:radius\",\"~:normal\",\"~$old-stroke__18__auto__\",\"~:threshold\",\"~:up\",\"~:center\",\"~:round\",\"~:disable-optimized-stroke\",\"~$cljs.core/let\",\"~:corners\",\"~:f11\",\"~:opaque\",\"~:overlay\",\"~$quil.sketch/defsketch\",\"~:enable-opengl-errors\",\"~:enable-stroke-pure\",\"~:blur\",\"~:project\",\"~:triangle-fan\",\"~:f3\",\"~:enable-depth-mask\",\"~:f2\",\"~:control\",\"~:difference\",\"~$quil.core/push-matrix\",\"~:square\",\"~:enable-optimized-stroke\",\"~:p2d\",\"~:shape\",\"~:f12\",\"~:exclusion\",\"~$quil.core/fill\",\"~:disable-opengl-errors\",\"~:unknown-key\",\"~:alpha\",\"~:wait\",\"~:right\",\"~$quil.core/current-stroke\",\"~$gr__16__auto__\",\"~:repeat\",\"~:hard-light\",\"~:image\",\"~:multiply\",\"~:lightest\",\"~$quil.core/rotate\",\"~:f7\",\"~$old-fill__17__auto__\",\"~:blend\",\"~:disable-depth-sort\",\"~:f9\",\"~:erode\",\"~:add\",\"~:soft-light\",\"~$quil.core/with-graphics\",\"~:subtract\",\"~:clamp\",\"~:f6\",\"~:f4\",\"~:triangle-strip\",\"~:cross\",\"~:triangles\",\"~$.beginDraw\",\"~:left\",\"~:invert\",\"~:text\",\"~:enable-texture-mipmaps\",\"~:model\"]],\"~:order\",[\"^A2\",\"^B1\",\"^AZ\",\"^A7\",\"^CN\",\"^B=\",\"^B6\",\"^CS\",\"^C6\",\"^B<\",\"^B4\",\"^CO\",\"^BQ\",\"^CM\",\"^A6\",\"^A<\",\"^A@\",\"^AE\",\"^AL\",\"^AN\",\"^AT\",\"^BK\",\"^BV\",\"^C1\",\"^C;\",\"^C=\",\"^C>\",\"^CB\",\"^CF\",\"^CG\",\"^CI\",\"^B2\",\"^A5\",\"^B5\",\"^C5\",\"^BD\",\"^B?\",\"^AJ\",\"^BH\",\"^A4\",\"^A>\",\"^AF\",\"^AH\",\"^AK\",\"^AS\",\"^AX\",\"^B0\",\"^BF\",\"^BM\",\"^BN\",\"^BS\",\"^BY\",\"^C3\",\"^CC\",\"^CT\",\"^BX\",\"^BE\",\"^BP\",\"^CU\",\"^B;\",\"^AR\",\"^CQ\",\"^C7\",\"^AV\",\"^AO\",\"^A3\",\"^B[\",\"^C<\",\"^B@\",\"^CJ\",\"^C:\",\"^BB\",\"^AG\",\"^CR\",\"^AA\",\"^BO\",\"^BJ\",\"^CE\",\"^A8\",\"^BC\",\"^A=\",\"^A0\",\"^AI\",\"^BU\",\"^BT\",\"^AU\",\"^BR\",\"^CL\",\"^B7\",\"^CK\",\"^C@\",\"^AC\",\"^CD\",\"^AM\",\"^BI\",\"^C0\",\"^B8\",\"^AB\",\"^BZ\",\"^BG\",\"^C9\",\"^CH\",\"^B3\",\"^B>\",\"^CA\",\"^A9\",\"^AW\",\"^C2\",\"^BA\",\"^C8\",\"^B:\",\"^AP\",\"^BW\",\"^A:\",\"^AD\",\"^AY\",\"^A[\",\"^B9\",\"^C?\",\"^AQ\",\"^A?\",\"^A;\",\"^CP\",\"^A1\",\"^BL\",\"^C4\"]],\"^R\",null]","quil/util.cache.json":"[\"^ \",\"~:rename-macros\",[\"^ \"],\"~:renames\",[\"^ \"],\"~:use-macros\",[\"^ \"],\"~:excludes\",[\"~#set\",[]],\"~:name\",\"~$quil.util\",\"~:imports\",null,\"~:requires\",[\"^ \",\"~$cstr\",\"~$clojure.string\",\"^:\",\"^:\"],\"~:uses\",null,\"~:defs\",[\"^ \",\"~$clj-compilation?\",[\"^ \",\"~:protocol-inline\",null,\"~:meta\",[\"^ \",\"~:file\",\"^6\",\"~:line\",71,\"~:column\",7,\"~:end-line\",71,\"~:end-column\",23,\"~:arglists\",[\"~#list\",[\"~$quote\",[\"^F\",[[]]]]]],\"^5\",\"~$quil.util/clj-compilation?\",\"~:variadic\",false,\"^@\",\"quil/util.cljc\",\"^D\",23,\"~:method-params\",[\"^F\",[[]]],\"~:protocol-impl\",null,\"~:arglists-meta\",[\"^F\",[null,null]],\"^B\",1,\"^A\",71,\"^C\",71,\"~:max-fixed-arity\",0,\"~:fn-var\",true,\"^E\",[\"^F\",[\"^G\",[\"^F\",[[]]]]]],\"~$make-quil-constant-map\",[\"^ \",\"^>\",null,\"^?\",[\"^ \",\"^@\",\"^6\",\"^A\",98,\"^B\",7,\"^C\",98,\"^D\",29,\"^E\",[\"^F\",[\"^G\",[\"^F\",[[\"~$target\",\"~$const-map-name\",\"~$const-map\"]]]]]],\"^5\",\"~$quil.util/make-quil-constant-map\",\"^I\",false,\"^@\",\"quil/util.cljc\",\"^D\",29,\"^J\",[\"^F\",[[\"^P\",\"^Q\",\"^R\"]]],\"^K\",null,\"^L\",[\"^F\",[null,null]],\"^B\",1,\"^A\",98,\"^C\",98,\"^M\",3,\"^N\",true,\"^E\",[\"^F\",[\"^G\",[\"^F\",[[\"^P\",\"^Q\",\"^R\"]]]]]],\"~$print-definition-list\",[\"^ \",\"^>\",null,\"^?\",[\"^ \",\"^@\",\"^6\",\"^A\",60,\"^B\",7,\"^C\",60,\"^D\",28,\"^E\",[\"^F\",[\"^G\",[\"^F\",[[\"~$definitions\"]]]]]],\"^5\",\"~$quil.util/print-definition-list\",\"^I\",false,\"^@\",\"quil/util.cljc\",\"^D\",28,\"^J\",[\"^F\",[[\"^U\"]]],\"^K\",null,\"^L\",[\"^F\",[null,null]],\"^B\",1,\"^A\",60,\"^C\",60,\"^M\",1,\"^N\",true,\"^E\",[\"^F\",[\"^G\",[\"^F\",[[\"^U\"]]]]]],\"~$generate-quil-constants\",[\"^ \",\"^>\",null,\"^?\",[\"^ \",\"^@\",\"^6\",\"^A\",105,\"^B\",11,\"^C\",105,\"^D\",34,\"~:macro\",true,\"^E\",[\"^F\",[\"^G\",[\"^F\",[[\"^P\",\"~$&\",\"~$opts\"]]]]],\"~:top-fn\",[\"^ \",\"^I\",true,\"^M\",3,\"^J\",[[\"^F\",[\"~$&form\",\"~$&env\",\"^P\",\"^Y\"]]],\"^E\",[\"^F\",[[\"^[\",\"^10\",\"^P\",\"~$&\",\"^Y\"]]],\"^L\",[\"^F\",[null]]]],\"^5\",\"~$quil.util/generate-quil-constants\",\"^I\",true,\"^@\",\"quil/util.cljc\",\"^D\",34,\"^Z\",[\"^ \",\"^I\",true,\"^M\",3,\"^J\",[[\"^F\",[\"^[\",\"^10\",\"^P\",\"^Y\"]]],\"^E\",[\"^F\",[[\"^[\",\"^10\",\"^P\",\"~$&\",\"^Y\"]]],\"^L\",[\"^F\",[null]]],\"^J\",[[\"^F\",[\"^[\",\"^10\",\"^P\",\"^Y\"]]],\"^K\",null,\"^L\",[\"^F\",[null]],\"^B\",1,\"^A\",105,\"^X\",true,\"^C\",105,\"^M\",3,\"^N\",false,\"^E\",[\"^F\",[[\"^[\",\"^10\",\"^P\",\"~$&\",\"^Y\"]]]],\"~$resolve-constant-key\",[\"^ \",\"^>\",null,\"^?\",[\"^ \",\"^@\",\"^6\",\"^A\",27,\"^B\",7,\"^C\",27,\"^D\",27,\"^E\",[\"^F\",[\"^G\",[\"^F\",[[\"~$key\",\"~$mappings\"]]]]],\"~:doc\",\"Returns the val associated with key in mappings or key directly if it\\n  is one of the vals in mappings. Otherwise throws an exception.\"],\"^5\",\"~$quil.util/resolve-constant-key\",\"^I\",false,\"^@\",\"quil/util.cljc\",\"^D\",27,\"^J\",[\"^F\",[[\"^13\",\"^14\"]]],\"^K\",null,\"^L\",[\"^F\",[null,null]],\"^B\",1,\"^A\",27,\"^C\",27,\"^M\",2,\"^N\",true,\"^E\",[\"^F\",[\"^G\",[\"^F\",[[\"^13\",\"^14\"]]]]],\"^15\",\"Returns the val associated with key in mappings or key directly if it\\n  is one of the vals in mappings. Otherwise throws an exception.\"],\"~$no-fn\",[\"^ \",\"^>\",null,\"^?\",[\"^ \",\"^@\",\"^6\",\"^A\",5,\"^B\",7,\"^C\",5,\"^D\",12,\"^E\",[\"^F\",[\"^G\",[\"^F\",[[]]]]],\"^15\",\"Function that does nothing.\"],\"^5\",\"~$quil.util/no-fn\",\"^I\",false,\"^@\",\"quil/util.cljc\",\"^D\",12,\"^J\",[\"^F\",[[]]],\"^K\",null,\"^L\",[\"^F\",[null,null]],\"^B\",1,\"^A\",5,\"^C\",5,\"^M\",0,\"^N\",true,\"^E\",[\"^F\",[\"^G\",[\"^F\",[[]]]]],\"^15\",\"Function that does nothing.\"],\"~$prepare-quil-clj-constants\",[\"^ \",\"^>\",null,\"^?\",[\"^ \",\"^@\",\"^6\",\"^A\",86,\"^B\",7,\"^C\",86,\"^D\",33,\"^E\",[\"^F\",[\"^G\",[\"^F\",[[\"~$constants\"]]]]]],\"^5\",\"~$quil.util/prepare-quil-clj-constants\",\"^I\",false,\"^@\",\"quil/util.cljc\",\"^D\",33,\"^J\",[\"^F\",[[\"^1:\"]]],\"^K\",null,\"^L\",[\"^F\",[null,null]],\"^B\",1,\"^A\",86,\"^C\",86,\"^M\",1,\"^N\",true,\"^E\",[\"^F\",[\"^G\",[\"^F\",[[\"^1:\"]]]]]],\"~$prepare-quil-cljs-constants\",[\"^ \",\"^>\",null,\"^?\",[\"^ \",\"^@\",\"^6\",\"^A\",92,\"^B\",7,\"^C\",92,\"^D\",34,\"^E\",[\"^F\",[\"^G\",[\"^F\",[[\"^1:\"]]]]]],\"^5\",\"~$quil.util/prepare-quil-cljs-constants\",\"^I\",false,\"^@\",\"quil/util.cljc\",\"^D\",34,\"^J\",[\"^F\",[[\"^1:\"]]],\"^K\",null,\"^L\",[\"^F\",[null,null]],\"^B\",1,\"^A\",92,\"^C\",92,\"^M\",1,\"^N\",true,\"^E\",[\"^F\",[\"^G\",[\"^F\",[[\"^1:\"]]]]]],\"~$length-of-longest-key\",[\"^ \",\"^>\",null,\"^?\",[\"^ \",\"^@\",\"^6\",\"^A\",39,\"^B\",8,\"^C\",39,\"^D\",29,\"~:private\",true,\"^E\",[\"^F\",[\"^G\",[\"^F\",[[\"~$m\"]]]]],\"^15\",\"Returns the length of the longest key of map m. Assumes m's keys are strings\\n   and returns 0 if map is empty:\\n   (length-of-longest-key {\\\"foo\\\" 1 \\\"barr\\\" 2 \\\"bazzz\\\" 3}) ;=> 5\\n   (length-of-longest-key {}) ;=> 0\"],\"^1?\",true,\"^5\",\"~$quil.util/length-of-longest-key\",\"^I\",false,\"^@\",\"quil/util.cljc\",\"^D\",29,\"^J\",[\"^F\",[[\"~$m\"]]],\"^K\",null,\"^L\",[\"^F\",[null,null]],\"^B\",1,\"^A\",39,\"^C\",39,\"^M\",1,\"^N\",true,\"^E\",[\"^F\",[\"^G\",[\"^F\",[[\"~$m\"]]]]],\"^15\",\"Returns the length of the longest key of map m. Assumes m's keys are strings\\n   and returns 0 if map is empty:\\n   (length-of-longest-key {\\\"foo\\\" 1 \\\"barr\\\" 2 \\\"bazzz\\\" 3}) ;=> 5\\n   (length-of-longest-key {}) ;=> 0\"],\"~$gen-padding\",[\"^ \",\"^>\",null,\"^?\",[\"^ \",\"^1?\",true,\"^@\",\"^6\",\"^D\",19,\"^Z\",[\"^ \",\"^I\",false,\"^M\",3,\"^J\",[\"^F\",[[\"~$len\"],[\"^1B\",\"~$pad\"],[\"~$s\",\"^1B\",\"^1C\"]]],\"^E\",[\"^F\",[[\"^1B\"],[\"^1B\",\"^1C\"],[\"~$s\",\"^1B\",\"^1C\"]]],\"^L\",[\"^F\",[null,null,null]]],\"^B\",8,\"^A\",48,\"^C\",48,\"^E\",[\"^F\",[\"^G\",[\"^F\",[[\"^1B\"],[\"^1B\",\"^1C\"],[\"~$s\",\"^1B\",\"^1C\"]]]]],\"^15\",\"Generates a padding string starting concatting s with len times pad:\\n   (gen-padding \\\"\\\" 5 \\\"b\\\") ;=> \\\"bbbbb\\\"\\n   May be called without starting string s in which case it defaults to the\\n   empty string and also without pad in which case it defaults to a single space\"],\"^1?\",true,\"^5\",\"~$quil.util/gen-padding\",\"^I\",false,\"^@\",\"quil/util.cljc\",\"^D\",19,\"^Z\",[\"^ \",\"^I\",false,\"^M\",3,\"^J\",[\"^F\",[[\"^1B\"],[\"^1B\",\"^1C\"],[\"~$s\",\"^1B\",\"^1C\"]]],\"^E\",[\"^F\",[[\"^1B\"],[\"^1B\",\"^1C\"],[\"~$s\",\"^1B\",\"^1C\"]]],\"^L\",[\"^F\",[null,null,null]]],\"^J\",[\"^F\",[[\"^1B\"],[\"^1B\",\"^1C\"],[\"~$s\",\"^1B\",\"^1C\"]]],\"^K\",null,\"^L\",[\"^F\",[null,null,null]],\"^B\",1,\"^A\",48,\"^C\",48,\"^M\",3,\"^N\",true,\"^E\",[\"^F\",[[\"^1B\"],[\"^1B\",\"^1C\"],[\"~$s\",\"^1B\",\"^1C\"]]],\"^15\",\"Generates a padding string starting concatting s with len times pad:\\n   (gen-padding \\\"\\\" 5 \\\"b\\\") ;=> \\\"bbbbb\\\"\\n   May be called without starting string s in which case it defaults to the\\n   empty string and also without pad in which case it defaults to a single space\"],\"~$prepare-quil-name\",[\"^ \",\"^>\",null,\"^?\",[\"^ \",\"^@\",\"^6\",\"^A\",81,\"^B\",7,\"^C\",81,\"^D\",24,\"^E\",[\"^F\",[\"^G\",[\"^F\",[[\"~$const-keyword\"]]]]]],\"^5\",\"~$quil.util/prepare-quil-name\",\"^I\",false,\"^@\",\"quil/util.cljc\",\"^D\",24,\"^J\",[\"^F\",[[\"^1F\"]]],\"^K\",null,\"^L\",[\"^F\",[null,null]],\"^B\",1,\"^A\",81,\"^C\",81,\"^M\",1,\"^N\",true,\"^E\",[\"^F\",[\"^G\",[\"^F\",[[\"^1F\"]]]]]]],\"~:require-macros\",null,\"~:cljs.analyzer/constants\",[\"^ \",\"~:seen\",[\"^4\",[\"~:else\",\"~$cljs.core/aget\",\"~$js/Processing.prototype.PConstants\",\"~$def\",\"~:clj\",\"~$do\"]],\"~:order\",[\"^1K\",\"^1L\",\"^1M\",\"^1N\",\"^1O\",\"^1P\"]],\"^15\",\"Utility fns\"]","quil/sketch.cache.json":"[\"^ \",\"~:rename-macros\",[\"^ \"],\"~:renames\",[\"^ \"],\"~:use-macros\",[\"^ \"],\"~:excludes\",[\"~#set\",[]],\"~:name\",\"~$quil.sketch\",\"~:imports\",null,\"~:requires\",[\"^ \",\"~$goog.dom\",\"^9\",\"~$dom\",\"^9\",\"~$u\",\"~$quil.util\",\"~$EventType\",\"~$goog.events.EventType\",\"~$quil.middlewares.deprecated-options\",\"^>\",\"~$do\",\"^>\",\"^=\",\"^=\",\"~$events\",\"~$goog.events\",\"^A\",\"^A\",\"^;\",\"^;\"],\"~:uses\",null,\"~:defs\",[\"^ \",\"~$current-applet\",[\"^ \",\"~:protocol-inline\",null,\"~:meta\",[\"^ \",\"~:file\",\"^6\",\"~:line\",12,\"~:column\",7,\"~:end-line\",12,\"~:end-column\",21,\"~:arglists\",[\"~#list\",[\"~$quote\",[\"^M\",[[]]]]]],\"^5\",\"~$quil.sketch/current-applet\",\"~:variadic\",false,\"^G\",\"quil/sketch.cljs\",\"^K\",21,\"~:method-params\",[\"^M\",[[]]],\"~:protocol-impl\",null,\"~:arglists-meta\",[\"^M\",[null,null]],\"^I\",1,\"^H\",12,\"^J\",12,\"~:max-fixed-arity\",0,\"~:fn-var\",true,\"^L\",[\"^M\",[\"^N\",[\"^M\",[[]]]]]],\"~$make-sketch\",[\"^ \",\"^E\",null,\"^F\",[\"^ \",\"^G\",\"^6\",\"^H\",49,\"^I\",7,\"^J\",49,\"^K\",18,\"^L\",[\"^M\",[\"^N\",[\"^M\",[[\"~$options\"]]]]]],\"^5\",\"~$quil.sketch/make-sketch\",\"^P\",false,\"^G\",\"quil/sketch.cljs\",\"^K\",18,\"^Q\",[\"^M\",[[\"^W\"]]],\"^R\",null,\"^S\",[\"^M\",[null,null]],\"^I\",1,\"^H\",49,\"^J\",49,\"^T\",1,\"^U\",true,\"^L\",[\"^M\",[\"^N\",[\"^M\",[[\"^W\"]]]]]],\"~$sketch\",[\"^ \",\"^E\",null,\"^F\",[\"^ \",\"^G\",\"^6\",\"^H\",86,\"^I\",7,\"^J\",86,\"^K\",13,\"^L\",[\"^M\",[\"^N\",[\"^M\",[[\"~$&\",\"~$opts\"]]]]],\"~:top-fn\",[\"^ \",\"^P\",true,\"^T\",0,\"^Q\",[[\"^M\",[\"^Z\"]]],\"^L\",[\"^M\",[[\"~$&\",\"^Z\"]]],\"^S\",[\"^M\",[null]]]],\"^5\",\"~$quil.sketch/sketch\",\"^P\",true,\"^G\",\"quil/sketch.cljs\",\"^K\",13,\"^[\",[\"^ \",\"^P\",true,\"^T\",0,\"^Q\",[[\"^M\",[\"^Z\"]]],\"^L\",[\"^M\",[[\"~$&\",\"^Z\"]]],\"^S\",[\"^M\",[null]]],\"^Q\",[[\"^M\",[\"^Z\"]]],\"^R\",null,\"^S\",[\"^M\",[null]],\"^I\",1,\"^H\",86,\"^J\",86,\"^T\",0,\"^U\",true,\"^L\",[\"^M\",[[\"~$&\",\"^Z\"]]]],\"~$bind-handlers\",[\"^ \",\"^E\",null,\"^F\",[\"^ \",\"^G\",\"^6\",\"^H\",27,\"^I\",8,\"^J\",27,\"^K\",21,\"~:private\",true,\"^L\",[\"^M\",[\"^N\",[\"^M\",[[\"~$prc\",\"^Z\"]]]]]],\"^12\",true,\"^5\",\"~$quil.sketch/bind-handlers\",\"^P\",false,\"^G\",\"quil/sketch.cljs\",\"^K\",21,\"^Q\",[\"^M\",[[\"^13\",\"^Z\"]]],\"^R\",null,\"^S\",[\"^M\",[null,null]],\"^I\",1,\"^H\",27,\"^J\",27,\"^T\",2,\"^U\",true,\"^L\",[\"^M\",[\"^N\",[\"^M\",[[\"^13\",\"^Z\"]]]]]],\"~$empty-body?\",[\"^ \",\"^E\",null,\"^F\",[\"^ \",\"^G\",\"^6\",\"^H\",103,\"^I\",7,\"^J\",103,\"^K\",18,\"^L\",[\"^M\",[\"^N\",[\"^M\",[[]]]]]],\"^5\",\"~$quil.sketch/empty-body?\",\"^P\",false,\"^G\",\"quil/sketch.cljs\",\"^K\",18,\"^Q\",[\"^M\",[[]]],\"^R\",null,\"^S\",[\"^M\",[null,null]],\"^I\",1,\"^H\",103,\"^J\",103,\"^T\",0,\"^U\",true,\"^L\",[\"^M\",[\"^N\",[\"^M\",[[]]]]]],\"~$rendering-modes\",[\"^ \",\"^5\",\"~$quil.sketch/rendering-modes\",\"^G\",\"quil/sketch.cljs\",\"^H\",14,\"^I\",1,\"^J\",15,\"^K\",18,\"^F\",[\"^ \",\"^G\",\"^6\",\"^H\",15,\"^I\",3,\"^J\",15,\"^K\",18]],\"~$size\",[\"^ \",\"^E\",null,\"^F\",[\"^ \",\"^G\",\"^6\",\"^H\",20,\"^I\",7,\"^J\",20,\"^K\",11,\"^L\",[\"^M\",[\"^N\",[\"^M\",[[\"~$width\",\"~$height\"],[\"^1:\",\"^1;\",\"~$mode\"]]]]],\"^[\",[\"^ \",\"^P\",false,\"^T\",3,\"^Q\",[\"^M\",[[\"^1:\",\"^1;\"],[\"^1:\",\"^1;\",\"^1<\"]]],\"^L\",[\"^M\",[[\"^1:\",\"^1;\"],[\"^1:\",\"^1;\",\"^1<\"]]],\"^S\",[\"^M\",[null,null]]]],\"^5\",\"~$quil.sketch/size\",\"^P\",false,\"^G\",\"quil/sketch.cljs\",\"^K\",11,\"^[\",[\"^ \",\"^P\",false,\"^T\",3,\"^Q\",[\"^M\",[[\"^1:\",\"^1;\"],[\"^1:\",\"^1;\",\"^1<\"]]],\"^L\",[\"^M\",[[\"^1:\",\"^1;\"],[\"^1:\",\"^1;\",\"^1<\"]]],\"^S\",[\"^M\",[null,null]]],\"^Q\",[\"^M\",[[\"^1:\",\"^1;\"],[\"^1:\",\"^1;\",\"^1<\"]]],\"^R\",null,\"^S\",[\"^M\",[null,null]],\"^I\",1,\"^H\",20,\"^J\",20,\"^T\",3,\"^U\",true,\"^L\",[\"^M\",[[\"^1:\",\"^1;\"],[\"^1:\",\"^1;\",\"^1<\"]]]],\"~$add-sketch-to-init-list\",[\"^ \",\"^E\",null,\"^F\",[\"^ \",\"^G\",\"^6\",\"^H\",122,\"^I\",7,\"^J\",122,\"^K\",30,\"^L\",[\"^M\",[\"^N\",[\"^M\",[[\"~$sk\"]]]]]],\"^5\",\"~$quil.sketch/add-sketch-to-init-list\",\"^P\",false,\"^G\",\"quil/sketch.cljs\",\"^K\",30,\"^Q\",[\"^M\",[[\"^1?\"]]],\"^R\",null,\"^S\",[\"^M\",[null,null]],\"^I\",1,\"^H\",122,\"^J\",122,\"^T\",1,\"^U\",true,\"^L\",[\"^M\",[\"^N\",[\"^M\",[[\"^1?\"]]]]]],\"~$sketch-init-list\",[\"^ \",\"^5\",\"~$quil.sketch/sketch-init-list\",\"^G\",\"quil/sketch.cljs\",\"^H\",101,\"^I\",1,\"^J\",101,\"^K\",22,\"^F\",[\"^ \",\"^G\",\"^6\",\"^H\",101,\"^I\",6,\"^J\",101,\"^K\",22]],\"~$init-sketches\",[\"^ \",\"^E\",null,\"^F\",[\"^ \",\"^G\",\"^6\",\"^H\",114,\"^I\",7,\"^J\",114,\"^K\",20,\"^L\",[\"^M\",[\"^N\",[\"^M\",[[]]]]]],\"^5\",\"~$quil.sketch/init-sketches\",\"^P\",false,\"^G\",\"quil/sketch.cljs\",\"^K\",20,\"^Q\",[\"^M\",[[]]],\"^R\",null,\"^S\",[\"^M\",[null,null]],\"^I\",1,\"^H\",114,\"^J\",114,\"^T\",0,\"^U\",true,\"^L\",[\"^M\",[\"^N\",[\"^M\",[[]]]]]],\"~$destroy-previous-sketch\",[\"^ \",\"^E\",null,\"^F\",[\"^ \",\"^G\",\"^6\",\"^H\",82,\"^I\",7,\"^J\",82,\"^K\",30,\"^L\",[\"^M\",[\"^N\",[\"^M\",[[\"~$host-elem\"]]]]]],\"^5\",\"~$quil.sketch/destroy-previous-sketch\",\"^P\",false,\"^G\",\"quil/sketch.cljs\",\"^K\",30,\"^Q\",[\"^M\",[[\"^1F\"]]],\"^R\",null,\"^S\",[\"^M\",[null,null]],\"^I\",1,\"^H\",82,\"^J\",82,\"^T\",1,\"^U\",true,\"^L\",[\"^M\",[\"^N\",[\"^M\",[[\"^1F\"]]]]]],\"~$resolve-renderer\",[\"^ \",\"^E\",null,\"^F\",[\"^ \",\"^G\",\"^6\",\"^H\",17,\"^I\",7,\"^J\",17,\"^K\",23,\"^L\",[\"^M\",[\"^N\",[\"^M\",[[\"^1<\"]]]]]],\"^5\",\"~$quil.sketch/resolve-renderer\",\"^P\",false,\"^G\",\"quil/sketch.cljs\",\"^K\",23,\"^Q\",[\"^M\",[[\"^1<\"]]],\"^R\",null,\"^S\",[\"^M\",[null,null]],\"^I\",1,\"^H\",17,\"^J\",17,\"^T\",1,\"^U\",true,\"^L\",[\"^M\",[\"^N\",[\"^M\",[[\"^1<\"]]]]]],\"~$*applet*\",[\"^ \",\"^5\",\"~$quil.sketch/*applet*\",\"^G\",\"quil/sketch.cljs\",\"^H\",9,\"^I\",1,\"^J\",10,\"^K\",11,\"~:dynamic\",true,\"^F\",[\"^ \",\"^G\",\"^6\",\"^H\",10,\"^I\",3,\"^J\",10,\"^K\",11,\"^1L\",true]],\"~$add-canvas\",[\"^ \",\"^E\",null,\"^F\",[\"^ \",\"^G\",\"^6\",\"^H\",109,\"^I\",7,\"^J\",109,\"^K\",17,\"^L\",[\"^M\",[\"^N\",[\"^M\",[[\"~$canvas-id\"]]]]]],\"^5\",\"~$quil.sketch/add-canvas\",\"^P\",false,\"^G\",\"quil/sketch.cljs\",\"^K\",17,\"^Q\",[\"^M\",[[\"^1N\"]]],\"^R\",null,\"^S\",[\"^M\",[null,null]],\"^I\",1,\"^H\",109,\"^J\",109,\"^T\",1,\"^U\",true,\"^L\",[\"^M\",[\"^N\",[\"^M\",[[\"^1N\"]]]]]]],\"~:require-macros\",[\"^ \",\"^6\",\"^6\",\"~$u\",\"^;\",\"^;\",\"^;\"],\"~:cljs.analyzer/constants\",[\"^ \",\"~:seen\",[\"^4\",[\"~:features\",\"~:key-typed\",\"~:mouse-clicked\",\"~:mouse-released\",\"~:fn\",\"~:mouse-exited\",\"~:java2d\",\"~:mouse-wheel\",\"~:keyPressed\",\"~:opengl\",\"~:mouse-moved\",\"~:mouseOut\",\"~:settings\",\"~:mouseScrolled\",\"~:mouseDragged\",\"~:renderer\",\"~:size\",\"~:setup\",\"~:mouse-pressed\",\"~:middleware\",\"~:global-key-events\",\"~:host\",\"~:mouse-entered\",\"~:key-pressed\",\"~:key-released\",\"~:keyReleased\",\"~:mouseClicked\",\"~:p2d\",\"~:mouseReleased\",\"~:mousePressed\",\"~:mouseMoved\",\"~:mouseOver\",\"~:host-id\",\"~:keyTyped\",\"~:draw\",\"~:p3d\",\"~:mouse-dragged\"]],\"~:order\",[\"^1Y\",\"^2B\",\"^2J\",\"^20\",\"^1[\",\"^22\",\"^24\",\"^25\",\"^28\",\"^2@\",\"^2A\",\"^2C\",\"^2D\",\"^2E\",\"^2F\",\"^2H\",\"^2I\",\"^2>\",\"^1X\",\"^1Z\",\"^2K\",\"^2?\",\"^1U\",\"^1V\",\"^29\",\"^21\",\"^2=\",\"^1T\",\"^27\",\"^2:\",\"^26\",\"^1S\",\"^23\",\"^2;\",\"^2<\",\"^2G\",\"^1W\"]],\"~:doc\",null]","quil/middlewares/deprecated_options.cache.json":"[\"^ \",\"~:rename-macros\",[\"^ \"],\"~:renames\",[\"^ \"],\"~:use-macros\",[\"^ \"],\"~:excludes\",[\"~#set\",[]],\"~:name\",\"~$quil.middlewares.deprecated-options\",\"~:imports\",null,\"~:requires\",null,\"~:uses\",null,\"~:defs\",[\"^ \",\"~$check-features-vector\",[\"^ \",\"~:protocol-inline\",null,\"~:meta\",[\"^ \",\"~:file\",\"^6\",\"~:line\",8,\"~:column\",8,\"~:end-line\",8,\"~:end-column\",29,\"~:private\",true,\"~:arglists\",[\"~#list\",[\"~$quote\",[\"^E\",[[\"~$features\"]]]]]],\"^C\",true,\"^5\",\"~$quil.middlewares.deprecated-options/check-features-vector\",\"~:variadic\",false,\"^>\",\"quil/middlewares/deprecated_options.cljc\",\"^B\",29,\"~:method-params\",[\"^E\",[[\"^G\"]]],\"~:protocol-impl\",null,\"~:arglists-meta\",[\"^E\",[null,null]],\"^@\",1,\"^?\",8,\"^A\",8,\"~:max-fixed-arity\",1,\"~:fn-var\",true,\"^D\",[\"^E\",[\"^F\",[\"^E\",[[\"^G\"]]]]]],\"~$deprecated\",[\"^ \",\"^5\",\"~$quil.middlewares.deprecated-options/deprecated\",\"^>\",\"quil/middlewares/deprecated_options.cljc\",\"^?\",3,\"^@\",1,\"^A\",3,\"^B\",26,\"^C\",true,\"^=\",[\"^ \",\"^>\",\"^6\",\"^?\",3,\"^@\",16,\"^A\",3,\"^B\",26,\"^C\",true]],\"~$deprecated-options\",[\"^ \",\"^<\",null,\"^=\",[\"^ \",\"^>\",\"^6\",\"^?\",15,\"^@\",7,\"^A\",15,\"^B\",25,\"^D\",[\"^E\",[\"^F\",[\"^E\",[[\"~$options\"]]]]],\"~:doc\",\"Checks if options map contains deprected options and removes them.\\n  Prints messages how to fix deprecated functions.\"],\"^5\",\"~$quil.middlewares.deprecated-options/deprecated-options\",\"^I\",false,\"^>\",\"quil/middlewares/deprecated_options.cljc\",\"^B\",25,\"^J\",[\"^E\",[[\"^R\"]]],\"^K\",null,\"^L\",[\"^E\",[null,null]],\"^@\",1,\"^?\",15,\"^A\",15,\"^M\",1,\"^N\",true,\"^D\",[\"^E\",[\"^F\",[\"^E\",[[\"^R\"]]]]],\"^S\",\"Checks if options map contains deprected options and removes them.\\n  Prints messages how to fix deprecated functions.\"]],\"~:require-macros\",null,\"~:cljs.analyzer/constants\",[\"^ \",\"~:seen\",[\"^4\",[\"~:decor\",\"~:safe-draw-fn\",\"~:target\",\"~:no-safe-draw\",\"~:features\"]],\"~:order\",[\"^X\",\"^Y\",\"^Z\",\"^[\",\"^10\"]],\"^S\",null]","quil/middlewares/deprecated_options.js":"// Compiled by ClojureScript 1.9.293 {:elide-asserts true}\ngoog.provide(\"quil.middlewares.deprecated_options\");\nquil.middlewares.deprecated_options.deprecated = new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\"decor\",\"decor\",(-1730969431)),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"2.0\",\"Try :features [:present] for similar effect\"], null),new cljs.core.Keyword(null,\"safe-draw-fn\",\"safe-draw-fn\",(1454900202)),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"2.0\",\"Use :features [:no-safe-fns] instead.\"], null),new cljs.core.Keyword(null,\"target\",\"target\",(253001721)),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"2.0\",\"Use :features [:keep-on-top] instead.\"], null)], null);\nquil.middlewares.deprecated_options.check_features_vector = (function quil$middlewares$deprecated_options$check_features_vector(features){\nvar features__$1 = cljs.core.set.call(null,features);\nif(cljs.core.truth_(features__$1.call(null,new cljs.core.Keyword(null,\"no-safe-draw\",\"no-safe-draw\",(-1157778157))))){\ncljs.core.println.call(null,\"Feature :no-safe-draw was renamed to :no-safe-fns in Quil 2.1.\",\"Use :feature [:no-safe-fns] now.\");\n} else {\n}\n\nreturn cljs.core.disj.call(null,features__$1,new cljs.core.Keyword(null,\"no-safe-draw\",\"no-safe-draw\",(-1157778157)));\n});\n/**\n * Checks if options map contains deprected options and removes them.\n *   Prints messages how to fix deprecated functions.\n */\nquil.middlewares.deprecated_options.deprecated_options = (function quil$middlewares$deprecated_options$deprecated_options(options){\nvar options__$1 = cljs.core.update_in.call(null,options,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"features\",\"features\",(-1146962336))], null),quil.middlewares.deprecated_options.check_features_vector);\nreturn cljs.core.into.call(null,cljs.core.PersistentArrayMap.EMPTY,cljs.core.remove.call(null,cljs.core.nil_QMARK_,(function (){var iter__12962__auto__ = ((function (options__$1){\nreturn (function quil$middlewares$deprecated_options$deprecated_options_$_iter__249(s__250){\nreturn (new cljs.core.LazySeq(null,((function (options__$1){\nreturn (function (){\nvar s__250__$1 = s__250;\nwhile(true){\nvar temp__10400__auto__ = cljs.core.seq.call(null,s__250__$1);\nif(temp__10400__auto__){\nvar s__250__$2 = temp__10400__auto__;\nif(cljs.core.chunked_seq_QMARK_.call(null,s__250__$2)){\nvar c__12960__auto__ = cljs.core.chunk_first.call(null,s__250__$2);\nvar size__12961__auto__ = cljs.core.count.call(null,c__12960__auto__);\nvar b__252 = cljs.core.chunk_buffer.call(null,size__12961__auto__);\nif((function (){var i__251 = (0);\nwhile(true){\nif((i__251 < size__12961__auto__)){\nvar vec__265 = cljs.core._nth.call(null,c__12960__auto__,i__251);\nvar name = cljs.core.nth.call(null,vec__265,(0),null);\nvar value = cljs.core.nth.call(null,vec__265,(1),null);\ncljs.core.chunk_append.call(null,b__252,(function (){var temp__10174__auto__ = quil.middlewares.deprecated_options.deprecated.call(null,name);\nif(cljs.core.truth_(temp__10174__auto__)){\nvar vec__268 = temp__10174__auto__;\nvar version = cljs.core.nth.call(null,vec__268,(0),null);\nvar message = cljs.core.nth.call(null,vec__268,(1),null);\ncljs.core.println.call(null,name,\"option was removed in Quil\",version,\".\",message);\n\nreturn null;\n} else {\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [name,value], null);\n}\n})());\n\nvar G__277 = (i__251 + (1));\ni__251 = G__277;\ncontinue;\n} else {\nreturn true;\n}\nbreak;\n}\n})()){\nreturn cljs.core.chunk_cons.call(null,cljs.core.chunk.call(null,b__252),quil$middlewares$deprecated_options$deprecated_options_$_iter__249.call(null,cljs.core.chunk_rest.call(null,s__250__$2)));\n} else {\nreturn cljs.core.chunk_cons.call(null,cljs.core.chunk.call(null,b__252),null);\n}\n} else {\nvar vec__271 = cljs.core.first.call(null,s__250__$2);\nvar name = cljs.core.nth.call(null,vec__271,(0),null);\nvar value = cljs.core.nth.call(null,vec__271,(1),null);\nreturn cljs.core.cons.call(null,(function (){var temp__10174__auto__ = quil.middlewares.deprecated_options.deprecated.call(null,name);\nif(cljs.core.truth_(temp__10174__auto__)){\nvar vec__274 = temp__10174__auto__;\nvar version = cljs.core.nth.call(null,vec__274,(0),null);\nvar message = cljs.core.nth.call(null,vec__274,(1),null);\ncljs.core.println.call(null,name,\"option was removed in Quil\",version,\".\",message);\n\nreturn null;\n} else {\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [name,value], null);\n}\n})(),quil$middlewares$deprecated_options$deprecated_options_$_iter__249.call(null,cljs.core.rest.call(null,s__250__$2)));\n}\n} else {\nreturn null;\n}\nbreak;\n}\n});})(options__$1))\n,null,null));\n});})(options__$1))\n;\nreturn iter__12962__auto__.call(null,options__$1);\n})()));\n});\n","quil/core.cache.json":"[\"^ \",\"~:rename-macros\",[\"^ \"],\"~:renames\",[\"^ \"],\"~:use-macros\",[\"^ \"],\"~:excludes\",[\"~#set\",[]],\"~:name\",\"~$quil.core\",\"~:imports\",null,\"~:requires\",[\"^ \",\"~$clojure.string\",\"^9\",\"~$org.processingjs.Processing\",\"^:\",\"~$ap\",\"~$quil.sketch\",\"^<\",\"^<\",\"~$u\",\"~$quil.util\",\"^=\",\"^=\"],\"~:uses\",null,\"~:defs\",[\"^ \",\"~$rotate-x\",[\"^ \",\"~:category\",\"Transform\",\"~:protocol-inline\",null,\"~:meta\",[\"^ \",\"^A\",\"Transform\",\"~:added\",\"1.0\",\"~:subcategory\",null,\"~:file\",\"^6\",\"~:end-column\",11,\"~:processing-name\",\"rotateX()\",\"~:column\",3,\"~:requires-bindings\",true,\"~:line\",3436,\"~:end-line\",3436,\"~:arglists\",[\"~#list\",[\"~$quote\",[\"^N\",[[\"~$angle\"]]]]],\"~:doc\",\"Rotates a shape around the x-axis the amount specified by the angle\\n  parameter. Angles should be specified in radians (values from 0 to\\n  (* PI 2)) or converted to radians with the radians function. Objects\\n  are always rotated around their relative position to the origin and\\n  positive numbers rotate objects in a counterclockwise\\n  direction. Transformations apply to everything that happens after\\n  and subsequent calls to the function accumulates the effect. For\\n  example, calling (rotate-x HALF-PI) and then (rotate-x HALF-PI) is\\n  the same as (rotate-x PI). If rotate-x is called within the draw fn,\\n  the transformation is reset when the loop begins again. This\\n  function requires either the :p3d or :opengl renderer.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/rotate-x\",\"~:variadic\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^G\",11,\"^H\",\"rotateX()\",\"~:method-params\",[\"^N\",[[\"^P\"]]],\"~:protocol-impl\",null,\"~:arglists-meta\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",3430,\"^L\",3436,\"~:max-fixed-arity\",1,\"~:fn-var\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^P\"]]]]],\"^Q\",\"Rotates a shape around the x-axis the amount specified by the angle\\n  parameter. Angles should be specified in radians (values from 0 to\\n  (* PI 2)) or converted to radians with the radians function. Objects\\n  are always rotated around their relative position to the origin and\\n  positive numbers rotate objects in a counterclockwise\\n  direction. Transformations apply to everything that happens after\\n  and subsequent calls to the function accumulates the effect. For\\n  example, calling (rotate-x HALF-PI) and then (rotate-x HALF-PI) is\\n  the same as (rotate-x PI). If rotate-x is called within the draw fn,\\n  the transformation is reset when the loop begins again. This\\n  function requires either the :p3d or :opengl renderer.\"],\"~$text-modes\",[\"^ \",\"^5\",\"~$quil.core/text-modes\",\"^F\",\"quil/core.cljc\",\"^K\",45,\"^I\",1,\"^L\",68,\"^G\",12,\"^C\",[\"^ \",\"^F\",\"^6\",\"^K\",68,\"^I\",2,\"^L\",68,\"^G\",12]],\"~$print-projection\",[\"^ \",\"^A\",\"Lights, Camera\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Lights, Camera\",\"^D\",\"1.0\",\"^E\",\"Camera\",\"^F\",\"^6\",\"^G\",19,\"^H\",\"printProjection()\",\"^I\",3,\"^J\",true,\"^K\",3070,\"^L\",3070,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Prints the current projection matrix to std out. Useful for\\n  debugging\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/print-projection\",\"^S\",false,\"^E\",\"Camera\",\"^F\",\"quil/core.cljc\",\"^G\",19,\"^H\",\"printProjection()\",\"^T\",[\"^N\",[[]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",3064,\"^L\",3070,\"^W\",0,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Prints the current projection matrix to std out. Useful for\\n  debugging\"],\"~$raw-key\",[\"^ \",\"^A\",\"Input\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Input\",\"^D\",\"1.0\",\"^E\",\"Keyboard\",\"^F\",\"^6\",\"^G\",10,\"^H\",\"key\",\"^I\",3,\"^J\",true,\"^K\",3229,\"^L\",3229,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Contains the value of the most recent key on the keyboard that was\\n  used (either pressed or released).\\n\\n  For non-ASCII keys, use the keyCode variable. The keys included in\\n  the ASCII specification (BACKSPACE, TAB, ENTER, RETURN, ESC, and\\n  DELETE) do not require checking to see if they key is coded, and you\\n  should simply use the key variable instead of keyCode If you're\\n  making cross-platform projects, note that the ENTER key is commonly\\n  used on PCs and Unix and the RETURN key is used instead on\\n  Macintosh. Check for both ENTER and RETURN to make sure your program\\n  will work for all platforms.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/raw-key\",\"^S\",false,\"^E\",\"Keyboard\",\"^F\",\"quil/core.cljc\",\"^G\",10,\"^H\",\"key\",\"^T\",[\"^N\",[[]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",3223,\"^L\",3229,\"^W\",0,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Contains the value of the most recent key on the keyboard that was\\n  used (either pressed or released).\\n\\n  For non-ASCII keys, use the keyCode variable. The keys included in\\n  the ASCII specification (BACKSPACE, TAB, ENTER, RETURN, ESC, and\\n  DELETE) do not require checking to see if they key is coded, and you\\n  should simply use the key variable instead of keyCode If you're\\n  making cross-platform projects, note that the ENTER key is commonly\\n  used on PCs and Unix and the RETURN key is used instead on\\n  Macintosh. Check for both ENTER and RETURN to make sure your program\\n  will work for all platforms.\"],\"~$text-char\",[\"^ \",\"^A\",\"Typography\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Typography\",\"^D\",\"1.0\",\"^E\",\"Loading & Displaying\",\"^F\",\"^6\",\"^G\",12,\"~:top-fn\",[\"^ \",\"^S\",false,\"^W\",4,\"^T\",[\"^N\",[[\"~$c\",\"~$x\",\"~$y\"],[\"~$c\",\"~$x\",\"~$y\",\"~$z\"]]],\"^M\",[\"^N\",[[\"~$c\",\"~$x\",\"~$y\"],[\"~$c\",\"~$x\",\"~$y\",\"~$z\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"text()\",\"^I\",3,\"^J\",true,\"^K\",4116,\"^L\",4116,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$c\",\"~$x\",\"~$y\"],[\"~$c\",\"~$x\",\"~$y\",\"~$z\"]]]]],\"^Q\",\"Draws a char to the screen in the specified position. See text fn\\n  for more details.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/text-char\",\"^S\",false,\"^E\",\"Loading & Displaying\",\"^F\",\"quil/core.cljc\",\"^G\",12,\"^14\",[\"^ \",\"^S\",false,\"^W\",4,\"^T\",[\"^N\",[[\"~$c\",\"~$x\",\"~$y\"],[\"~$c\",\"~$x\",\"~$y\",\"~$z\"]]],\"^M\",[\"^N\",[[\"~$c\",\"~$x\",\"~$y\"],[\"~$c\",\"~$x\",\"~$y\",\"~$z\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"text()\",\"^T\",[\"^N\",[[\"~$c\",\"~$x\",\"~$y\"],[\"~$c\",\"~$x\",\"~$y\",\"~$z\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",4110,\"^L\",4116,\"^W\",4,\"^X\",true,\"^M\",[\"^N\",[[\"~$c\",\"~$x\",\"~$y\"],[\"~$c\",\"~$x\",\"~$y\",\"~$z\"]]],\"^Q\",\"Draws a char to the screen in the specified position. See text fn\\n  for more details.\"],\"~$display-filter\",[\"^ \",\"^A\",\"Image\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Image\",\"^D\",\"1.0\",\"^E\",\"Pixels\",\"^F\",\"^6\",\"^G\",17,\"^14\",[\"^ \",\"^S\",false,\"^W\",2,\"^T\",[\"^N\",[[\"~$mode\"],[\"^17\",\"~$level\"]]],\"^M\",[\"^N\",[[\"^17\"],[\"^17\",\"^18\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"filter()\",\"^I\",3,\"^J\",true,\"^K\",1777,\"^L\",1777,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^17\"],[\"^17\",\"^18\"]]]]],\"^Q\",\"Originally named filter in Processing Language.\\n  Filters the display window with the specified mode and level.\\n  Level defines the quality of the filter and mode may be one of the\\n  following keywords:\\n\\n  :threshold - converts the image to black and white pixels depending\\n               if they are above or below the threshold defined by\\n               the level parameter. The level must be between\\n               0.0 (black) and 1.0 (white). If no level is specified,\\n               0.5 is used.\\n  :gray      - converts any colors in the image to grayscale\\n               equivalents. Doesn't work with level.\\n  :invert    - sets each pixel to its inverse value. Doesn't work with\\n               level.\\n  :posterize - limits each channel of the image to the number of\\n               colors specified as the level parameter. The parameter can\\n               be set to values between 2 and 255, but results are most\\n               noticeable in the lower ranges.\\n  :blur      - executes a Guassian blur with the level parameter\\n               specifying the extent of the blurring. If no level\\n               parameter is used, the blur is equivalent to Guassian\\n               blur of radius 1.\\n  :opaque    - sets the alpha channel to entirely opaque. Doesn't work\\n               with level.\\n  :erode     - reduces the light areas. Doesn't work with level.\\n  :dilate    - increases the light areas.  Doesn't work with level.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/display-filter\",\"^S\",false,\"^E\",\"Pixels\",\"^F\",\"quil/core.cljc\",\"^G\",17,\"^14\",[\"^ \",\"^S\",false,\"^W\",2,\"^T\",[\"^N\",[[\"^17\"],[\"^17\",\"^18\"]]],\"^M\",[\"^N\",[[\"^17\"],[\"^17\",\"^18\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"filter()\",\"^T\",[\"^N\",[[\"^17\"],[\"^17\",\"^18\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",1771,\"^L\",1777,\"^W\",2,\"^X\",true,\"^M\",[\"^N\",[[\"^17\"],[\"^17\",\"^18\"]]],\"^Q\",\"Originally named filter in Processing Language.\\n  Filters the display window with the specified mode and level.\\n  Level defines the quality of the filter and mode may be one of the\\n  following keywords:\\n\\n  :threshold - converts the image to black and white pixels depending\\n               if they are above or below the threshold defined by\\n               the level parameter. The level must be between\\n               0.0 (black) and 1.0 (white). If no level is specified,\\n               0.5 is used.\\n  :gray      - converts any colors in the image to grayscale\\n               equivalents. Doesn't work with level.\\n  :invert    - sets each pixel to its inverse value. Doesn't work with\\n               level.\\n  :posterize - limits each channel of the image to the number of\\n               colors specified as the level parameter. The parameter can\\n               be set to values between 2 and 255, but results are most\\n               noticeable in the lower ranges.\\n  :blur      - executes a Guassian blur with the level parameter\\n               specifying the extent of the blurring. If no level\\n               parameter is used, the blur is equivalent to Guassian\\n               blur of radius 1.\\n  :opaque    - sets the alpha channel to entirely opaque. Doesn't work\\n               with level.\\n  :erode     - reduces the light areas. Doesn't work with level.\\n  :dilate    - increases the light areas.  Doesn't work with level.\"],\"~$rotate-z\",[\"^ \",\"^A\",\"Transform\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Transform\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^6\",\"^G\",11,\"^H\",\"rotateZ()\",\"^I\",3,\"^J\",true,\"^K\",3478,\"^L\",3478,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^P\"]]]]],\"^Q\",\"Rotates a shape around the z-axis the amount specified by the angle\\n  parameter. Angles should be specified in radians (values from 0\\n  to (* PI 2)) or converted to radians with the radians function.\\n  Objects are always rotated around their relative position to the\\n  origin and positive numbers rotate objects in a counterclockwise\\n  direction. Transformations apply to everything that happens after\\n  and subsequent calls to the function accumulates the effect. For\\n  example, calling (rotate-z HALF-PI) and then (rotate-z HALF-PI) is\\n  the same as (rotate-z PI). If rotate-y is called within the draw fn,\\n  the transformation is reset when the loop begins again. This\\n  function requires either the :p3d or :opengl renderer.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/rotate-z\",\"^S\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^G\",11,\"^H\",\"rotateZ()\",\"^T\",[\"^N\",[[\"^P\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",3472,\"^L\",3478,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^P\"]]]]],\"^Q\",\"Rotates a shape around the z-axis the amount specified by the angle\\n  parameter. Angles should be specified in radians (values from 0\\n  to (* PI 2)) or converted to radians with the radians function.\\n  Objects are always rotated around their relative position to the\\n  origin and positive numbers rotate objects in a counterclockwise\\n  direction. Transformations apply to everything that happens after\\n  and subsequent calls to the function accumulates the effect. For\\n  example, calling (rotate-z HALF-PI) and then (rotate-z HALF-PI) is\\n  the same as (rotate-z PI). If rotate-y is called within the draw fn,\\n  the transformation is reset when the loop begins again. This\\n  function requires either the :p3d or :opengl renderer.\"],\"~$random-gaussian\",[\"^ \",\"^A\",\"Math\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Math\",\"^D\",\"2.0\",\"^E\",\"Random\",\"^F\",\"^6\",\"^G\",18,\"^H\",\"randomGaussian()\",\"^I\",3,\"^J\",true,\"^K\",3198,\"^L\",3198,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Returns a float from a random series of numbers having a mean of 0 and\\n  standard deviation of 1. Each time the randomGaussian() function is called,\\n  it returns a number fitting a Gaussian, or normal, distribution.\\n  There is theoretically no minimum or maximum value that randomGaussian()\\n  might return. Rather, there is just a very low probability that values far\\n  from the mean will be returned; and a higher probability that numbers near\\n  the mean will be returned. .\"],\"^D\",\"2.0\",\"^5\",\"~$quil.core/random-gaussian\",\"^S\",false,\"^E\",\"Random\",\"^F\",\"quil/core.cljc\",\"^G\",18,\"^H\",\"randomGaussian()\",\"^T\",[\"^N\",[[]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",3192,\"^L\",3198,\"^W\",0,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Returns a float from a random series of numbers having a mean of 0 and\\n  standard deviation of 1. Each time the randomGaussian() function is called,\\n  it returns a number fitting a Gaussian, or normal, distribution.\\n  There is theoretically no minimum or maximum value that randomGaussian()\\n  might return. Rather, there is just a very low probability that values far\\n  from the mean will be returned; and a higher probability that numbers near\\n  the mean will be returned. .\"],\"~$blend\",[\"^ \",\"^A\",\"Image\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Image\",\"^D\",\"1.0\",\"^E\",\"Pixels\",\"^F\",\"^6\",\"^G\",8,\"^14\",[\"^ \",\"^S\",false,\"^W\",11,\"^T\",[\"^N\",[[\"~$x\",\"~$y\",\"~$width\",\"~$height\",\"~$dx\",\"~$dy\",\"~$dwidth\",\"~$dheight\",\"^17\"],[\"~$src-img\",\"~$x\",\"~$y\",\"^1?\",\"^1@\",\"^1A\",\"^1B\",\"^1C\",\"^1D\",\"^17\"],[\"^1E\",\"~$dest-img\",\"~$x\",\"~$y\",\"^1?\",\"^1@\",\"^1A\",\"^1B\",\"^1C\",\"^1D\",\"^17\"]]],\"^M\",[\"^N\",[[\"~$x\",\"~$y\",\"^1?\",\"^1@\",\"^1A\",\"^1B\",\"^1C\",\"^1D\",\"^17\"],[\"^1E\",\"~$x\",\"~$y\",\"^1?\",\"^1@\",\"^1A\",\"^1B\",\"^1C\",\"^1D\",\"^17\"],[\"^1E\",\"^1F\",\"~$x\",\"~$y\",\"^1?\",\"^1@\",\"^1A\",\"^1B\",\"^1C\",\"^1D\",\"^17\"]]],\"^V\",[\"^N\",[null,null,null]]],\"^H\",\"blend()\",\"^I\",3,\"^J\",true,\"^K\",778,\"^L\",778,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$x\",\"~$y\",\"^1?\",\"^1@\",\"^1A\",\"^1B\",\"^1C\",\"^1D\",\"^17\"],[\"^1E\",\"~$x\",\"~$y\",\"^1?\",\"^1@\",\"^1A\",\"^1B\",\"^1C\",\"^1D\",\"^17\"],[\"^1E\",\"^1F\",\"~$x\",\"~$y\",\"^1?\",\"^1@\",\"^1A\",\"^1B\",\"^1C\",\"^1D\",\"^17\"]]]]],\"^Q\",\"Blends a region of pixels from one image into another with full alpha\\n  channel support. If src is not specified it defaults to current-graphics.\\n  If dest is not specified it defaults to current-graphics.\\n\\n  Note: blend-mode function is recommended to use instead of this one.\\n\\n  Available blend modes are:\\n\\n  :blend      - linear interpolation of colours: C = A*factor + B\\n  :add        - additive blending with white clip:\\n                                            C = min(A*factor + B, 255)\\n  :subtract   - subtractive blending with black clip:\\n                                            C = max(B - A*factor, 0)\\n  :darkest    - only the darkest colour succeeds:\\n                                            C = min(A*factor, B)\\n  :lightest   - only the lightest colour succeeds:\\n                                            C = max(A*factor, B)\\n  :difference - subtract colors from underlying image.\\n  :exclusion  - similar to :difference, but less extreme.\\n  :multiply   - Multiply the colors, result will always be darker.\\n  :screen     - Opposite multiply, uses inverse values of the colors.\\n  :overlay    - A mix of :multiply and :screen. Multiplies dark values\\n                and screens light values.\\n  :hard-light - :screen when greater than 50% gray, :multiply when\\n                lower.\\n  :soft-light - Mix of :darkest and :lightest. Works like :overlay,\\n                but not as harsh.\\n  :dodge      - Lightens light tones and increases contrast, ignores\\n                darks.\\n                Called \\\"Color Dodge\\\" in Illustrator and Photoshop.\\n  :burn       - Darker areas are applied, increasing contrast, ignores\\n                lights. Called \\\"Color Burn\\\" in Illustrator and\\n                Photoshop.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/blend\",\"^S\",false,\"^E\",\"Pixels\",\"^F\",\"quil/core.cljc\",\"^G\",8,\"^14\",[\"^ \",\"^S\",false,\"^W\",11,\"^T\",[\"^N\",[[\"~$x\",\"~$y\",\"^1?\",\"^1@\",\"^1A\",\"^1B\",\"^1C\",\"^1D\",\"^17\"],[\"^1E\",\"~$x\",\"~$y\",\"^1?\",\"^1@\",\"^1A\",\"^1B\",\"^1C\",\"^1D\",\"^17\"],[\"^1E\",\"^1F\",\"~$x\",\"~$y\",\"^1?\",\"^1@\",\"^1A\",\"^1B\",\"^1C\",\"^1D\",\"^17\"]]],\"^M\",[\"^N\",[[\"~$x\",\"~$y\",\"^1?\",\"^1@\",\"^1A\",\"^1B\",\"^1C\",\"^1D\",\"^17\"],[\"^1E\",\"~$x\",\"~$y\",\"^1?\",\"^1@\",\"^1A\",\"^1B\",\"^1C\",\"^1D\",\"^17\"],[\"^1E\",\"^1F\",\"~$x\",\"~$y\",\"^1?\",\"^1@\",\"^1A\",\"^1B\",\"^1C\",\"^1D\",\"^17\"]]],\"^V\",[\"^N\",[null,null,null]]],\"^H\",\"blend()\",\"^T\",[\"^N\",[[\"~$x\",\"~$y\",\"^1?\",\"^1@\",\"^1A\",\"^1B\",\"^1C\",\"^1D\",\"^17\"],[\"^1E\",\"~$x\",\"~$y\",\"^1?\",\"^1@\",\"^1A\",\"^1B\",\"^1C\",\"^1D\",\"^17\"],[\"^1E\",\"^1F\",\"~$x\",\"~$y\",\"^1?\",\"^1@\",\"^1A\",\"^1B\",\"^1C\",\"^1D\",\"^17\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null,null]],\"^I\",1,\"^J\",true,\"^K\",772,\"^L\",778,\"^W\",11,\"^X\",true,\"^M\",[\"^N\",[[\"~$x\",\"~$y\",\"^1?\",\"^1@\",\"^1A\",\"^1B\",\"^1C\",\"^1D\",\"^17\"],[\"^1E\",\"~$x\",\"~$y\",\"^1?\",\"^1@\",\"^1A\",\"^1B\",\"^1C\",\"^1D\",\"^17\"],[\"^1E\",\"^1F\",\"~$x\",\"~$y\",\"^1?\",\"^1@\",\"^1A\",\"^1B\",\"^1C\",\"^1D\",\"^17\"]]],\"^Q\",\"Blends a region of pixels from one image into another with full alpha\\n  channel support. If src is not specified it defaults to current-graphics.\\n  If dest is not specified it defaults to current-graphics.\\n\\n  Note: blend-mode function is recommended to use instead of this one.\\n\\n  Available blend modes are:\\n\\n  :blend      - linear interpolation of colours: C = A*factor + B\\n  :add        - additive blending with white clip:\\n                                            C = min(A*factor + B, 255)\\n  :subtract   - subtractive blending with black clip:\\n                                            C = max(B - A*factor, 0)\\n  :darkest    - only the darkest colour succeeds:\\n                                            C = min(A*factor, B)\\n  :lightest   - only the lightest colour succeeds:\\n                                            C = max(A*factor, B)\\n  :difference - subtract colors from underlying image.\\n  :exclusion  - similar to :difference, but less extreme.\\n  :multiply   - Multiply the colors, result will always be darker.\\n  :screen     - Opposite multiply, uses inverse values of the colors.\\n  :overlay    - A mix of :multiply and :screen. Multiplies dark values\\n                and screens light values.\\n  :hard-light - :screen when greater than 50% gray, :multiply when\\n                lower.\\n  :soft-light - Mix of :darkest and :lightest. Works like :overlay,\\n                but not as harsh.\\n  :dodge      - Lightens light tones and increases contrast, ignores\\n                darks.\\n                Called \\\"Color Dodge\\\" in Illustrator and Photoshop.\\n  :burn       - Darker areas are applied, increasing contrast, ignores\\n                lights. Called \\\"Color Burn\\\" in Illustrator and\\n                Photoshop.\"],\"~$frame-count\",[\"^ \",\"^A\",\"Environment\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Environment\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^6\",\"^G\",14,\"^H\",\"frameCount\",\"^I\",3,\"^J\",true,\"^K\",1853,\"^L\",1853,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"The system variable frameCount contains the number of frames\\n  displayed since the program started. Inside setup() the value is 0\\n  and after the first iteration of draw it is 1, etc.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/frame-count\",\"^S\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^G\",14,\"^H\",\"frameCount\",\"^T\",[\"^N\",[[]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",1847,\"^L\",1853,\"^W\",0,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"The system variable frameCount contains the number of frames\\n  displayed since the program started. Inside setup() the value is 0\\n  and after the first iteration of draw it is 1, etc.\"],\"~$with-graphics\",[\"^ \",\"^A\",\"Rendering\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Rendering\",\"^D\",\"1.7\",\"^F\",\"^6\",\"^G\",16,\"^14\",[\"^ \",\"^S\",true,\"^W\",3,\"^T\",[[\"^N\",[\"~$&form\",\"~$&env\",\"~$graphics\",\"~$body\"]]],\"^M\",[\"^N\",[[\"^1K\",\"^1L\",\"^1M\",\"~$&\",\"^1N\"]]],\"^V\",[\"^N\",[null]]],\"^H\",null,\"^I\",3,\"^J\",true,\"^K\",4681,\"~:macro\",true,\"^L\",4681,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^1M\",\"~$&\",\"^1N\"]]]]],\"^Q\",\"All subsequent calls of any drawing function will draw on given\\n  graphics. 'with-graphics' cannot be nested (you can draw simultaneously\\n  only on 1 graphics)\"],\"^D\",\"1.7\",\"^5\",\"~$quil.core/with-graphics\",\"^S\",true,\"^F\",\"quil/core.cljc\",\"^G\",16,\"^14\",[\"^ \",\"^S\",true,\"^W\",3,\"^T\",[[\"^N\",[\"^1K\",\"^1L\",\"^1M\",\"^1N\"]]],\"^M\",[\"^N\",[[\"^1K\",\"^1L\",\"^1M\",\"~$&\",\"^1N\"]]],\"^V\",[\"^N\",[null]]],\"^H\",null,\"^T\",[[\"^N\",[\"^1K\",\"^1L\",\"^1M\",\"^1N\"]]],\"^U\",null,\"^V\",[\"^N\",[null]],\"^I\",1,\"^J\",true,\"^K\",4676,\"^1O\",true,\"^L\",4681,\"^W\",3,\"^X\",false,\"^M\",[\"^N\",[[\"^1K\",\"^1L\",\"^1M\",\"~$&\",\"^1N\"]]],\"^Q\",\"All subsequent calls of any drawing function will draw on given\\n  graphics. 'with-graphics' cannot be nested (you can draw simultaneously\\n  only on 1 graphics)\"],\"~$model-y\",[\"^ \",\"^A\",\"Lights, Camera\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Lights, Camera\",\"^D\",\"1.0\",\"^E\",\"Coordinates\",\"^F\",\"^6\",\"^G\",10,\"^H\",\"modelY()\",\"^I\",3,\"^J\",true,\"^K\",2538,\"^L\",2538,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$x\",\"~$y\",\"~$z\"]]]]],\"^Q\",\"Returns the three-dimensional x, y, z position in model space. This\\n  returns the y value for a given coordinate based on the current set\\n  of transformations (scale, rotate, translate, etc.) The y value can\\n  be used to place an object in space relative to the location of the\\n  original point once the transformations are no longer in use.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/model-y\",\"^S\",false,\"^E\",\"Coordinates\",\"^F\",\"quil/core.cljc\",\"^G\",10,\"^H\",\"modelY()\",\"^T\",[\"^N\",[[\"~$x\",\"~$y\",\"~$z\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",2532,\"^L\",2538,\"^W\",3,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$x\",\"~$y\",\"~$z\"]]]]],\"^Q\",\"Returns the three-dimensional x, y, z position in model space. This\\n  returns the y value for a given coordinate based on the current set\\n  of transformations (scale, rotate, translate, etc.) The y value can\\n  be used to place an object in space relative to the location of the\\n  original point once the transformations are no longer in use.\"],\"~$set-image\",[\"^ \",\"^A\",\"Image\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Image\",\"^D\",\"1.0\",\"^E\",\"Pixels\",\"^F\",\"^6\",\"^G\",12,\"^H\",\"set()\",\"^I\",3,\"^J\",true,\"^K\",3694,\"^L\",3694,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$x\",\"~$y\",\"~$src\"]]]]],\"^Q\",\"Writes an image directly into the display window. The x and y\\n  parameters define the coordinates for the upper-left corner of the\\n  image.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/set-image\",\"^S\",false,\"^E\",\"Pixels\",\"^F\",\"quil/core.cljc\",\"^G\",12,\"^H\",\"set()\",\"^T\",[\"^N\",[[\"~$x\",\"~$y\",\"^1T\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",3688,\"^L\",3694,\"^W\",3,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$x\",\"~$y\",\"^1T\"]]]]],\"^Q\",\"Writes an image directly into the display window. The x and y\\n  parameters define the coordinates for the upper-left corner of the\\n  image.\"],\"~$shape-mode\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"Loading & Displaying\",\"^F\",\"^6\",\"^G\",13,\"^H\",\"shapeMode()\",\"^I\",3,\"^J\",true,\"^K\",3797,\"^L\",3797,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^17\"]]]]],\"^Q\",\"Modifies the location from which shapes draw. Available modes are\\n  :corner, :corners and :center. Default is :corner.\\n\\n  :corner  - specifies the location to be the upper left corner of the\\n             shape and uses the third and fourth parameters of shape\\n             to specify the width and height.\\n\\n  :corners - uses the first and second parameters of shape to set\\n             the location of one corner and uses the third and fourth\\n             parameters to set the opposite corner.\\n\\n  :center  - draws the shape from its center point and uses the third\\n             and forth parameters of shape to specify the width and\\n             height. \"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/shape-mode\",\"^S\",false,\"^E\",\"Loading & Displaying\",\"^F\",\"quil/core.cljc\",\"^G\",13,\"^H\",\"shapeMode()\",\"^T\",[\"^N\",[[\"^17\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",3792,\"^L\",3797,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^17\"]]]]],\"^Q\",\"Modifies the location from which shapes draw. Available modes are\\n  :corner, :corners and :center. Default is :corner.\\n\\n  :corner  - specifies the location to be the upper left corner of the\\n             shape and uses the third and fourth parameters of shape\\n             to specify the width and height.\\n\\n  :corners - uses the first and second parameters of shape to set\\n             the location of one corner and uses the third and fourth\\n             parameters to set the opposite corner.\\n\\n  :center  - draws the shape from its center point and uses the third\\n             and forth parameters of shape to specify the width and\\n             height. \"],\"~$cursor-image\",[\"^ \",\"^A\",\"Environment\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Environment\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^6\",\"^G\",17,\"^14\",[\"^ \",\"^S\",false,\"^W\",3,\"^T\",[\"^N\",[[\"~$img\"],[\"^1Y\",\"~$hx\",\"~$hy\"]]],\"^M\",[\"^N\",[[\"^1Y\"],[\"^1Y\",\"^1Z\",\"^1[\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"cursor()\",\"^I\",5,\"^J\",true,\"^K\",1307,\"^L\",1307,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^1Y\"],[\"^1Y\",\"^1Z\",\"^1[\"]]]]],\"^Q\",\"Set the cursor to a predefined image. The horizontal and vertical\\n  active spots of the cursor may be specified with hx and hy.\\n  It is recommended to make the size 16x16 or 32x32 pixels.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/cursor-image\",\"^S\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^G\",17,\"^14\",[\"^ \",\"^S\",false,\"^W\",3,\"^T\",[\"^N\",[[\"^1Y\"],[\"^1Y\",\"^1Z\",\"^1[\"]]],\"^M\",[\"^N\",[[\"^1Y\"],[\"^1Y\",\"^1Z\",\"^1[\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"cursor()\",\"^T\",[\"^N\",[[\"^1Y\"],[\"^1Y\",\"^1Z\",\"^1[\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",1301,\"^L\",1307,\"^W\",3,\"^X\",true,\"^M\",[\"^N\",[[\"^1Y\"],[\"^1Y\",\"^1Z\",\"^1[\"]]],\"^Q\",\"Set the cursor to a predefined image. The horizontal and vertical\\n  active spots of the cursor may be specified with hx and hy.\\n  It is recommended to make the size 16x16 or 32x32 pixels.\"],\"~$create-graphics\",[\"^ \",\"^A\",\"Image\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Image\",\"^D\",\"1.0\",\"^E\",\"Rendering\",\"^F\",\"^6\",\"^G\",18,\"^14\",[\"^ \",\"^S\",false,\"^W\",4,\"^T\",[\"^N\",[[\"~$w\",\"~$h\"],[\"~$w\",\"~$h\",\"~$renderer\"],[\"~$w\",\"~$h\",\"^22\",\"~$path\"]]],\"^M\",[\"^N\",[[\"~$w\",\"~$h\"],[\"~$w\",\"~$h\",\"^22\"],[\"~$w\",\"~$h\",\"^22\",\"^23\"]]],\"^V\",[\"^N\",[null,null,null]]],\"^H\",\"createGraphics()\",\"^I\",3,\"^J\",true,\"^K\",1204,\"^L\",1204,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$w\",\"~$h\"],[\"~$w\",\"~$h\",\"^22\"],[\"~$w\",\"~$h\",\"^22\",\"^23\"]]]]],\"^Q\",\"Creates and returns a new PGraphics object of the types :p2d, :p3d,\\n  :java2d, :pdf. By default :java2d is used. Use this class if you\\n  need to draw into an off-screen graphics buffer. It's not possible\\n  to use create-graphics with the :opengl renderer, because it doesn't\\n  allow offscreen use. The :pdf renderer requires the filename parameter.\\n\\n  Note: don't use create-graphics in draw in clojurescript, it leaks memory.\\n  You should create graphic in setup and reuse it in draw instead of creating\\n  a new one.\\n\\n  It's important to call any drawing commands between (.beginDraw graphics) and\\n  (.endDraw graphics) statements or use with-graphics macro. This is also true\\n  for any commands that affect drawing, such as smooth or color-mode.\\n\\n  If you're using :pdf renderer - don't forget to call (.dispose graphics)\\n  as last command inside with-graphics macro, otherwise graphics won't be\\n  saved.\\n\\n  Unlike the main drawing surface which is completely opaque, surfaces\\n  created with create-graphics can have transparency. This makes it\\n  possible to draw into a graphics and maintain the alpha channel. By\\n  using save to write a PNG or TGA file, the transparency of the\\n  graphics object will be honored.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/create-graphics\",\"^S\",false,\"^E\",\"Rendering\",\"^F\",\"quil/core.cljc\",\"^G\",18,\"^14\",[\"^ \",\"^S\",false,\"^W\",4,\"^T\",[\"^N\",[[\"~$w\",\"~$h\"],[\"~$w\",\"~$h\",\"^22\"],[\"~$w\",\"~$h\",\"^22\",\"^23\"]]],\"^M\",[\"^N\",[[\"~$w\",\"~$h\"],[\"~$w\",\"~$h\",\"^22\"],[\"~$w\",\"~$h\",\"^22\",\"^23\"]]],\"^V\",[\"^N\",[null,null,null]]],\"^H\",\"createGraphics()\",\"^T\",[\"^N\",[[\"~$w\",\"~$h\"],[\"~$w\",\"~$h\",\"^22\"],[\"~$w\",\"~$h\",\"^22\",\"^23\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null,null]],\"^I\",1,\"^J\",true,\"^K\",1198,\"^L\",1204,\"^W\",4,\"^X\",true,\"^M\",[\"^N\",[[\"~$w\",\"~$h\"],[\"~$w\",\"~$h\",\"^22\"],[\"~$w\",\"~$h\",\"^22\",\"^23\"]]],\"^Q\",\"Creates and returns a new PGraphics object of the types :p2d, :p3d,\\n  :java2d, :pdf. By default :java2d is used. Use this class if you\\n  need to draw into an off-screen graphics buffer. It's not possible\\n  to use create-graphics with the :opengl renderer, because it doesn't\\n  allow offscreen use. The :pdf renderer requires the filename parameter.\\n\\n  Note: don't use create-graphics in draw in clojurescript, it leaks memory.\\n  You should create graphic in setup and reuse it in draw instead of creating\\n  a new one.\\n\\n  It's important to call any drawing commands between (.beginDraw graphics) and\\n  (.endDraw graphics) statements or use with-graphics macro. This is also true\\n  for any commands that affect drawing, such as smooth or color-mode.\\n\\n  If you're using :pdf renderer - don't forget to call (.dispose graphics)\\n  as last command inside with-graphics macro, otherwise graphics won't be\\n  saved.\\n\\n  Unlike the main drawing surface which is completely opaque, surfaces\\n  created with create-graphics can have transparency. This makes it\\n  possible to draw into a graphics and maintain the alpha channel. By\\n  using save to write a PNG or TGA file, the transparency of the\\n  graphics object will be honored.\"],\"~$update-pixels\",[\"^ \",\"^A\",\"Image\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Image\",\"^D\",\"1.0\",\"^E\",\"Pixels\",\"^F\",\"^6\",\"^G\",16,\"^14\",[\"^ \",\"^S\",false,\"^W\",1,\"^T\",[\"^N\",[[],[\"^1Y\"]]],\"^M\",[\"^N\",[[],[\"^1Y\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"updatePixels()\",\"^I\",3,\"^J\",true,\"^K\",4523,\"^L\",4523,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[],[\"^1Y\"]]]]],\"^Q\",\"Updates the display window or image with the data in the pixels array.\\n  Use in conjunction with (pixels). If you're only reading pixels from\\n  the array, there's no need to call update-pixels unless there are\\n  changes.\\n\\n  Certain renderers may or may not seem to require pixels or\\n  update-pixels. However, the rule is that any time you want to\\n  manipulate the pixels array, you must first call pixels, and\\n  after changes have been made, call update-pixels. Even if the\\n  renderer may not seem to use this function in the current Processing\\n  release, this will always be subject to change.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/update-pixels\",\"^S\",false,\"^E\",\"Pixels\",\"^F\",\"quil/core.cljc\",\"^G\",16,\"^14\",[\"^ \",\"^S\",false,\"^W\",1,\"^T\",[\"^N\",[[],[\"^1Y\"]]],\"^M\",[\"^N\",[[],[\"^1Y\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"updatePixels()\",\"^T\",[\"^N\",[[],[\"^1Y\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",4517,\"^L\",4523,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[[],[\"^1Y\"]]],\"^Q\",\"Updates the display window or image with the data in the pixels array.\\n  Use in conjunction with (pixels). If you're only reading pixels from\\n  the array, there's no need to call update-pixels unless there are\\n  changes.\\n\\n  Certain renderers may or may not seem to require pixels or\\n  update-pixels. However, the rule is that any time you want to\\n  manipulate the pixels array, you must first call pixels, and\\n  after changes have been made, call update-pixels. Even if the\\n  renderer may not seem to use this function in the current Processing\\n  release, this will always be subject to change.\"],\"~$text-size\",[\"^ \",\"^A\",\"Typography\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Typography\",\"^D\",\"1.0\",\"^E\",\"Attributes\",\"^F\",\"^6\",\"^G\",12,\"^H\",\"textSize()\",\"^I\",3,\"^J\",true,\"^K\",4308,\"^L\",4308,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$size\"]]]]],\"^Q\",\"Sets the current font size. This size will be used in all\\n  subsequent calls to the text fn. Font size is measured in\\n  units of pixels.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/text-size\",\"^S\",false,\"^E\",\"Attributes\",\"^F\",\"quil/core.cljc\",\"^G\",12,\"^H\",\"textSize()\",\"^T\",[\"^N\",[[\"^28\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",4302,\"^L\",4308,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^28\"]]]]],\"^Q\",\"Sets the current font size. This size will be used in all\\n  subsequent calls to the text fn. Font size is measured in\\n  units of pixels.\"],\"~$pixels\",[\"^ \",\"^A\",\"Image\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Image\",\"^D\",\"1.0\",\"^E\",\"Pixels\",\"^F\",\"^6\",\"^G\",9,\"^14\",[\"^ \",\"^S\",false,\"^W\",1,\"^T\",[\"^N\",[[],[\"^1Y\"]]],\"^M\",[\"^N\",[[],[\"^1Y\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"pixels[]\",\"^I\",3,\"^J\",true,\"^K\",2920,\"^L\",2920,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[],[\"^1Y\"]]]]],\"^Q\",\"Array containing the values for all the pixels in the display\\n  window or image. This array is therefore the size of the display window. If\\n  this array is modified, the update-pixels fn must be called to update\\n  the changes. Calls .loadPixels before obtaining the pixel array.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/pixels\",\"^S\",false,\"^E\",\"Pixels\",\"^F\",\"quil/core.cljc\",\"^G\",9,\"^14\",[\"^ \",\"^S\",false,\"^W\",1,\"^T\",[\"^N\",[[],[\"^1Y\"]]],\"^M\",[\"^N\",[[],[\"^1Y\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"pixels[]\",\"^T\",[\"^N\",[[],[\"^1Y\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",2914,\"^L\",2920,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[[],[\"^1Y\"]]],\"^Q\",\"Array containing the values for all the pixels in the display\\n  window or image. This array is therefore the size of the display window. If\\n  this array is modified, the update-pixels fn must be called to update\\n  the changes. Calls .loadPixels before obtaining the pixel array.\"],\"~$stroke-float\",[\"^ \",\"^A\",\"Color\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Color\",\"^D\",\"1.0\",\"^E\",\"Setting\",\"^F\",\"^6\",\"^G\",15,\"^14\",[\"^ \",\"^S\",false,\"^W\",4,\"^T\",[\"^N\",[[\"~$gray\"],[\"^2=\",\"~$alpha\"],[\"~$x\",\"~$y\",\"~$z\"],[\"~$x\",\"~$y\",\"~$z\",\"~$a\"]]],\"^M\",[\"^N\",[[\"^2=\"],[\"^2=\",\"^2>\"],[\"~$x\",\"~$y\",\"~$z\"],[\"~$x\",\"~$y\",\"~$z\",\"~$a\"]]],\"^V\",[\"^N\",[null,null,null,null]]],\"^H\",\"stroke()\",\"^I\",3,\"^J\",true,\"^K\",3988,\"^L\",3988,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^2=\"],[\"^2=\",\"^2>\"],[\"~$x\",\"~$y\",\"~$z\"],[\"~$x\",\"~$y\",\"~$z\",\"~$a\"]]]]],\"^Q\",\"Sets the color used to draw lines and borders around\\n  shapes. Converts all args to floats\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/stroke-float\",\"^S\",false,\"^E\",\"Setting\",\"^F\",\"quil/core.cljc\",\"^G\",15,\"^14\",[\"^ \",\"^S\",false,\"^W\",4,\"^T\",[\"^N\",[[\"^2=\"],[\"^2=\",\"^2>\"],[\"~$x\",\"~$y\",\"~$z\"],[\"~$x\",\"~$y\",\"~$z\",\"~$a\"]]],\"^M\",[\"^N\",[[\"^2=\"],[\"^2=\",\"^2>\"],[\"~$x\",\"~$y\",\"~$z\"],[\"~$x\",\"~$y\",\"~$z\",\"~$a\"]]],\"^V\",[\"^N\",[null,null,null,null]]],\"^H\",\"stroke()\",\"^T\",[\"^N\",[[\"^2=\"],[\"^2=\",\"^2>\"],[\"~$x\",\"~$y\",\"~$z\"],[\"~$x\",\"~$y\",\"~$z\",\"~$a\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null,null,null]],\"^I\",1,\"^J\",true,\"^K\",3982,\"^L\",3988,\"^W\",4,\"^X\",true,\"^M\",[\"^N\",[[\"^2=\"],[\"^2=\",\"^2>\"],[\"~$x\",\"~$y\",\"~$z\"],[\"~$x\",\"~$y\",\"~$z\",\"~$a\"]]],\"^Q\",\"Sets the color used to draw lines and borders around\\n  shapes. Converts all args to floats\"],\"~$constrain\",[\"^ \",\"^A\",\"Math\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Math\",\"^D\",\"1.0\",\"^E\",\"Calculation\",\"^F\",\"^6\",\"^G\",12,\"^H\",\"constrain()\",\"^I\",3,\"^J\",false,\"^K\",1097,\"^L\",1097,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$amt\",\"~$low\",\"~$high\"]]]]],\"^Q\",\"Constrains a value to not exceed a maximum and minimum value.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/constrain\",\"^S\",false,\"^E\",\"Calculation\",\"^F\",\"quil/core.cljc\",\"^G\",12,\"^H\",\"constrain()\",\"^T\",[\"^N\",[[\"^2A\",\"^2B\",\"^2C\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",false,\"^K\",1091,\"^L\",1097,\"^W\",3,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^2A\",\"^2B\",\"^2C\"]]]]],\"^Q\",\"Constrains a value to not exceed a maximum and minimum value.\"],\"~$screen-y\",[\"^ \",\"^A\",\"Lights, Camera\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Lights, Camera\",\"^D\",\"1.0\",\"^E\",\"Coordinates\",\"^F\",\"^6\",\"^G\",11,\"^14\",[\"^ \",\"^S\",false,\"^W\",3,\"^T\",[\"^N\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^M\",[\"^N\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"screenY()\",\"^I\",3,\"^J\",true,\"^K\",3627,\"^L\",3627,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]]]],\"^Q\",\"Takes a three-dimensional x, y, z position and returns the y value\\n  for where it will appear on a (two-dimensional) screen, once\\n  affected by translate, scale or any other transformations\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/screen-y\",\"^S\",false,\"^E\",\"Coordinates\",\"^F\",\"quil/core.cljc\",\"^G\",11,\"^14\",[\"^ \",\"^S\",false,\"^W\",3,\"^T\",[\"^N\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^M\",[\"^N\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"screenY()\",\"^T\",[\"^N\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",3621,\"^L\",3627,\"^W\",3,\"^X\",true,\"^M\",[\"^N\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^Q\",\"Takes a three-dimensional x, y, z position and returns the y value\\n  for where it will appear on a (two-dimensional) screen, once\\n  affected by translate, scale or any other transformations\"],\"~$fill-float\",[\"^ \",\"^A\",\"Color\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Color\",\"^D\",\"1.0\",\"^E\",\"Setting\",\"^F\",\"^6\",\"^G\",13,\"^14\",[\"^ \",\"^S\",false,\"^W\",4,\"^T\",[\"^N\",[[\"^2=\"],[\"^2=\",\"^2>\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"^2>\"]]],\"^M\",[\"^N\",[[\"^2=\"],[\"^2=\",\"^2>\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"^2>\"]]],\"^V\",[\"^N\",[null,null,null,null]]],\"^H\",\"fill()\",\"^I\",3,\"^J\",true,\"^K\",1705,\"^L\",1705,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^2=\"],[\"^2=\",\"^2>\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"^2>\"]]]]],\"^Q\",\"Sets the color used to fill shapes. For example, (fill 204 102 0),\\n  will specify that all subsequent shapes will be filled with orange.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/fill-float\",\"^S\",false,\"^E\",\"Setting\",\"^F\",\"quil/core.cljc\",\"^G\",13,\"^14\",[\"^ \",\"^S\",false,\"^W\",4,\"^T\",[\"^N\",[[\"^2=\"],[\"^2=\",\"^2>\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"^2>\"]]],\"^M\",[\"^N\",[[\"^2=\"],[\"^2=\",\"^2>\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"^2>\"]]],\"^V\",[\"^N\",[null,null,null,null]]],\"^H\",\"fill()\",\"^T\",[\"^N\",[[\"^2=\"],[\"^2=\",\"^2>\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"^2>\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null,null,null]],\"^I\",1,\"^J\",true,\"^K\",1699,\"^L\",1705,\"^W\",4,\"^X\",true,\"^M\",[\"^N\",[[\"^2=\"],[\"^2=\",\"^2>\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"^2>\"]]],\"^Q\",\"Sets the color used to fill shapes. For example, (fill 204 102 0),\\n  will specify that all subsequent shapes will be filled with orange.\"],\"~$rect\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"2D Primitives\",\"^F\",\"^6\",\"^G\",7,\"^14\",[\"^ \",\"^S\",false,\"^W\",8,\"^T\",[\"^N\",[[\"~$x\",\"~$y\",\"^1?\",\"^1@\"],[\"~$x\",\"~$y\",\"^1?\",\"^1@\",\"~$r\"],[\"~$x\",\"~$y\",\"^1?\",\"^1@\",\"~$top-left-r\",\"~$top-right-r\",\"~$bottom-right-r\",\"~$bottom-left-r\"]]],\"^M\",[\"^N\",[[\"~$x\",\"~$y\",\"^1?\",\"^1@\"],[\"~$x\",\"~$y\",\"^1?\",\"^1@\",\"~$r\"],[\"~$x\",\"~$y\",\"^1?\",\"^1@\",\"^2J\",\"^2K\",\"^2L\",\"^2M\"]]],\"^V\",[\"^N\",[null,null,null]]],\"^H\",\"rect()\",\"^I\",3,\"^J\",true,\"^K\",3250,\"^L\",3250,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$x\",\"~$y\",\"^1?\",\"^1@\"],[\"~$x\",\"~$y\",\"^1?\",\"^1@\",\"~$r\"],[\"~$x\",\"~$y\",\"^1?\",\"^1@\",\"^2J\",\"^2K\",\"^2L\",\"^2M\"]]]]],\"^Q\",\"Draws a rectangle to the screen. A rectangle is a four-sided shape\\n  with every angle at ninety degrees. By default, the first two\\n  parameters set the location of the upper-left corner, the third\\n  sets the width, and the fourth sets the height. These parameters\\n  may be changed with rect-mode.\\n\\n  To draw a rounded rectangle, add a fifth parameter, which is used as\\n  the radius value for all four corners. To use a different radius value\\n  for each corner, include eight parameters.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/rect\",\"^S\",false,\"^E\",\"2D Primitives\",\"^F\",\"quil/core.cljc\",\"^G\",7,\"^14\",[\"^ \",\"^S\",false,\"^W\",8,\"^T\",[\"^N\",[[\"~$x\",\"~$y\",\"^1?\",\"^1@\"],[\"~$x\",\"~$y\",\"^1?\",\"^1@\",\"~$r\"],[\"~$x\",\"~$y\",\"^1?\",\"^1@\",\"^2J\",\"^2K\",\"^2L\",\"^2M\"]]],\"^M\",[\"^N\",[[\"~$x\",\"~$y\",\"^1?\",\"^1@\"],[\"~$x\",\"~$y\",\"^1?\",\"^1@\",\"~$r\"],[\"~$x\",\"~$y\",\"^1?\",\"^1@\",\"^2J\",\"^2K\",\"^2L\",\"^2M\"]]],\"^V\",[\"^N\",[null,null,null]]],\"^H\",\"rect()\",\"^T\",[\"^N\",[[\"~$x\",\"~$y\",\"^1?\",\"^1@\"],[\"~$x\",\"~$y\",\"^1?\",\"^1@\",\"~$r\"],[\"~$x\",\"~$y\",\"^1?\",\"^1@\",\"^2J\",\"^2K\",\"^2L\",\"^2M\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null,null]],\"^I\",1,\"^J\",true,\"^K\",3244,\"^L\",3250,\"^W\",8,\"^X\",true,\"^M\",[\"^N\",[[\"~$x\",\"~$y\",\"^1?\",\"^1@\"],[\"~$x\",\"~$y\",\"^1?\",\"^1@\",\"~$r\"],[\"~$x\",\"~$y\",\"^1?\",\"^1@\",\"^2J\",\"^2K\",\"^2L\",\"^2M\"]]],\"^Q\",\"Draws a rectangle to the screen. A rectangle is a four-sided shape\\n  with every angle at ninety degrees. By default, the first two\\n  parameters set the location of the upper-left corner, the third\\n  sets the width, and the fourth sets the height. These parameters\\n  may be changed with rect-mode.\\n\\n  To draw a rounded rectangle, add a fifth parameter, which is used as\\n  the radius value for all four corners. To use a different radius value\\n  for each corner, include eight parameters.\"],\"~$log\",[\"^ \",\"^A\",\"Math\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Math\",\"^D\",\"1.0\",\"^E\",\"Calculation\",\"^F\",\"^6\",\"^G\",6,\"^H\",\"log()\",\"^I\",3,\"^J\",false,\"^K\",2428,\"^L\",2428,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$val\"]]]]],\"^Q\",\"Calculates the natural logarithm (the base-e logarithm) of a\\n  number. This function expects the values greater than 0.0.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/log\",\"^S\",false,\"^E\",\"Calculation\",\"^F\",\"quil/core.cljc\",\"^G\",6,\"^H\",\"log()\",\"^T\",[\"^N\",[[\"^2P\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",false,\"^K\",2422,\"^L\",2428,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^2P\"]]]]],\"^Q\",\"Calculates the natural logarithm (the base-e logarithm) of a\\n  number. This function expects the values greater than 0.0.\"],\"~$with-stroke\",[\"^ \",\"^A\",\"Color\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Color\",\"^D\",\"1.7\",\"^E\",\"Utility Macros\",\"^F\",\"^6\",\"^G\",15,\"^14\",[\"^ \",\"^S\",true,\"^W\",3,\"^T\",[[\"^N\",[\"^1K\",\"^1L\",\"~$stroke-args\",\"^1N\"]]],\"^M\",[\"^N\",[[\"^1K\",\"^1L\",\"^2S\",\"~$&\",\"^1N\"]]],\"^V\",[\"^N\",[null]]],\"^H\",null,\"^I\",4,\"^J\",true,\"^K\",4623,\"^1O\",true,\"^L\",4623,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^2S\",\"~$&\",\"^1N\"]]]]],\"^Q\",\"Temporarily set the stroke color for the body of this macro.\\n   The code outside of with-stroke form will have the previous stroke color set.\\n\\n   The stroke color has to be in a vector!\\n   Example: (with-stroke [255] ...)\\n            (with-stroke [10 80 98] ...)\"],\"^D\",\"1.7\",\"^5\",\"~$quil.core/with-stroke\",\"^S\",true,\"^E\",\"Utility Macros\",\"^F\",\"quil/core.cljc\",\"^G\",15,\"^14\",[\"^ \",\"^S\",true,\"^W\",3,\"^T\",[[\"^N\",[\"^1K\",\"^1L\",\"^2S\",\"^1N\"]]],\"^M\",[\"^N\",[[\"^1K\",\"^1L\",\"^2S\",\"~$&\",\"^1N\"]]],\"^V\",[\"^N\",[null]]],\"^H\",null,\"^T\",[[\"^N\",[\"^1K\",\"^1L\",\"^2S\",\"^1N\"]]],\"^U\",null,\"^V\",[\"^N\",[null]],\"^I\",1,\"^J\",true,\"^K\",4617,\"^1O\",true,\"^L\",4623,\"^W\",3,\"^X\",false,\"^M\",[\"^N\",[[\"^1K\",\"^1L\",\"^2S\",\"~$&\",\"^1N\"]]],\"^Q\",\"Temporarily set the stroke color for the body of this macro.\\n   The code outside of with-stroke form will have the previous stroke color set.\\n\\n   The stroke color has to be in a vector!\\n   Example: (with-stroke [255] ...)\\n            (with-stroke [10 80 98] ...)\"],\"~$ambient-float\",[\"^ \",\"^A\",\"Lights, Camera\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Lights, Camera\",\"^D\",\"1.0\",\"^E\",\"Material Properties\",\"^F\",\"^6\",\"^G\",16,\"^14\",[\"^ \",\"^S\",false,\"^W\",3,\"^T\",[\"^N\",[[\"^2=\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^M\",[\"^N\",[[\"^2=\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"ambient()\",\"^I\",3,\"^J\",true,\"^K\",324,\"^L\",324,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^2=\"],[\"~$x\",\"~$y\",\"~$z\"]]]]],\"^Q\",\"Sets the ambient reflectance for shapes drawn to the screen. This\\n  is combined with the ambient light component of environment. The\\n  color components set through the parameters define the\\n  reflectance. For example in the default color mode, setting x=255,\\n  y=126, z=0, would cause all the red light to reflect and half of the\\n  green light to reflect. Used in combination with emissive, specular,\\n  and shininess in setting the material properties of shapes.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/ambient-float\",\"^S\",false,\"^E\",\"Material Properties\",\"^F\",\"quil/core.cljc\",\"^G\",16,\"^14\",[\"^ \",\"^S\",false,\"^W\",3,\"^T\",[\"^N\",[[\"^2=\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^M\",[\"^N\",[[\"^2=\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"ambient()\",\"^T\",[\"^N\",[[\"^2=\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",318,\"^L\",324,\"^W\",3,\"^X\",true,\"^M\",[\"^N\",[[\"^2=\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^Q\",\"Sets the ambient reflectance for shapes drawn to the screen. This\\n  is combined with the ambient light component of environment. The\\n  color components set through the parameters define the\\n  reflectance. For example in the default color mode, setting x=255,\\n  y=126, z=0, would cause all the red light to reflect and half of the\\n  green light to reflect. Used in combination with emissive, specular,\\n  and shininess in setting the material properties of shapes.\"],\"~$end-raw\",[\"^ \",\"^A\",\"Output\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Output\",\"^D\",\"1.0\",\"^E\",\"Files\",\"^F\",\"^6\",\"^G\",10,\"^H\",\"endRaw()\",\"^I\",3,\"^J\",true,\"^K\",1638,\"^L\",1638,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Complement to begin-raw; they must always be used together. See\\n  the begin-raw docstring for details.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/end-raw\",\"^S\",false,\"^E\",\"Files\",\"^F\",\"quil/core.cljc\",\"^G\",10,\"^H\",\"endRaw()\",\"^T\",[\"^N\",[[]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",1632,\"^L\",1638,\"^W\",0,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Complement to begin-raw; they must always be used together. See\\n  the begin-raw docstring for details.\"],\"~$radians\",[\"^ \",\"^A\",\"Math\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Math\",\"^D\",\"1.0\",\"^E\",\"Trigonometry\",\"^F\",\"^6\",\"^G\",10,\"^H\",\"radians()\",\"^I\",3,\"^J\",false,\"^K\",3162,\"^L\",3162,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$degrees\"]]]]],\"^Q\",\"Converts a degree measurement to its corresponding value in\\n  radians. Radians and degrees are two ways of measuring the same\\n  thing. There are 360 degrees in a circle and 2*PI radians in a\\n  circle. For example, 90° = PI/2 = 1.5707964. All trigonometric\\n  methods in Processing require their parameters to be specified in\\n  radians.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/radians\",\"^S\",false,\"^E\",\"Trigonometry\",\"^F\",\"quil/core.cljc\",\"^G\",10,\"^H\",\"radians()\",\"^T\",[\"^N\",[[\"^2Z\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",false,\"^K\",3156,\"^L\",3162,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^2Z\"]]]]],\"^Q\",\"Converts a degree measurement to its corresponding value in\\n  radians. Radians and degrees are two ways of measuring the same\\n  thing. There are 360 degrees in a circle and 2*PI radians in a\\n  circle. For example, 90° = PI/2 = 1.5707964. All trigonometric\\n  methods in Processing require their parameters to be specified in\\n  radians.\"],\"^2Z\",[\"^ \",\"^A\",\"Math\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Math\",\"^D\",\"1.0\",\"^E\",\"Trigonometry\",\"^F\",\"^6\",\"^G\",10,\"^H\",\"degrees()\",\"^I\",3,\"^J\",false,\"^K\",1438,\"^L\",1438,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^2Y\"]]]]],\"^Q\",\"Converts a radian measurement to its corresponding value in\\n  degrees. Radians and degrees are two ways of measuring the same\\n  thing. There are 360 degrees in a circle and (* 2 Math/PI) radians\\n  in a circle. For example, (= 90° (/ Math/PI 2) 1.5707964). All\\n  trigonometric methods in Processing require their parameters to be\\n  specified in radians.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/degrees\",\"^S\",false,\"^E\",\"Trigonometry\",\"^F\",\"quil/core.cljc\",\"^G\",10,\"^H\",\"degrees()\",\"^T\",[\"^N\",[[\"^2Y\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",false,\"^K\",1432,\"^L\",1438,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^2Y\"]]]]],\"^Q\",\"Converts a radian measurement to its corresponding value in\\n  degrees. Radians and degrees are two ways of measuring the same\\n  thing. There are 360 degrees in a circle and (* 2 Math/PI) radians\\n  in a circle. For example, (= 90° (/ Math/PI 2) 1.5707964). All\\n  trigonometric methods in Processing require their parameters to be\\n  specified in radians.\"],\"~$acos\",[\"^ \",\"^A\",\"Math\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Math\",\"^D\",\"1.0\",\"^E\",\"Trigonometry\",\"^F\",\"^6\",\"^G\",7,\"^H\",\"acos()\",\"^I\",3,\"^J\",false,\"^K\",299,\"^L\",299,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$n\"]]]]],\"^Q\",\"The inverse of cos, returns the arc cosine of a value. This\\n  function expects the values in the range of -1 to 1 and values are\\n  returned in the range 0 to Math/PI (3.1415927).\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/acos\",\"^S\",false,\"^E\",\"Trigonometry\",\"^F\",\"quil/core.cljc\",\"^G\",7,\"^H\",\"acos()\",\"^T\",[\"^N\",[[\"~$n\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",false,\"^K\",293,\"^L\",299,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$n\"]]]]],\"^Q\",\"The inverse of cos, returns the arc cosine of a value. This\\n  function expects the values in the range of -1 to 1 and values are\\n  returned in the range 0 to Math/PI (3.1415927).\"],\"~$bezier-detail\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"Curves\",\"^F\",\"^6\",\"^G\",16,\"^H\",\"bezierDetail()\",\"^I\",3,\"^J\",true,\"^K\",692,\"^L\",692,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$detail\"]]]]],\"^Q\",\"Sets the resolution at which Beziers display. The default value is\\n  20. This function is only useful when using the :p3d or :opengl\\n  renderer as the default (:java2d) renderer does not use this\\n  information.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/bezier-detail\",\"^S\",false,\"^E\",\"Curves\",\"^F\",\"quil/core.cljc\",\"^G\",16,\"^H\",\"bezierDetail()\",\"^T\",[\"^N\",[[\"^34\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",686,\"^L\",692,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^34\"]]]]],\"^Q\",\"Sets the resolution at which Beziers display. The default value is\\n  20. This function is only useful when using the :p3d or :opengl\\n  renderer as the default (:java2d) renderer does not use this\\n  information.\"],\"~$texture\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"Vertex\",\"^F\",\"^6\",\"^G\",10,\"^H\",\"texture()\",\"^I\",3,\"^J\",true,\"^K\",4321,\"^L\",4321,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^1Y\"]]]]],\"^Q\",\"Sets a texture to be applied to vertex points. The texture fn must\\n  be called between begin-shape and end-shape and before any calls to\\n  vertex.\\n\\n  When textures are in use, the fill color is ignored. Instead, use\\n  tint to specify the color of the texture as it is applied to the\\n  shape.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/texture\",\"^S\",false,\"^E\",\"Vertex\",\"^F\",\"quil/core.cljc\",\"^G\",10,\"^H\",\"texture()\",\"^T\",[\"^N\",[[\"^1Y\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",4315,\"^L\",4321,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^1Y\"]]]]],\"^Q\",\"Sets a texture to be applied to vertex points. The texture fn must\\n  be called between begin-shape and end-shape and before any calls to\\n  vertex.\\n\\n  When textures are in use, the fill color is ignored. Instead, use\\n  tint to specify the color of the texture as it is applied to the\\n  shape.\"],\"~$stroke-int\",[\"^ \",\"^A\",\"Color\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Color\",\"^D\",\"1.0\",\"^E\",\"Setting\",\"^F\",\"^6\",\"^G\",13,\"^14\",[\"^ \",\"^S\",false,\"^W\",2,\"^T\",[\"^N\",[[\"~$rgb\"],[\"^39\",\"^2>\"]]],\"^M\",[\"^N\",[[\"^39\"],[\"^39\",\"^2>\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"stroke()\",\"^I\",3,\"^J\",true,\"^K\",4002,\"^L\",4002,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^39\"],[\"^39\",\"^2>\"]]]]],\"^Q\",\"Sets the color used to draw lines and borders around\\n  shapes. Converts rgb to int and alpha to a float.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/stroke-int\",\"^S\",false,\"^E\",\"Setting\",\"^F\",\"quil/core.cljc\",\"^G\",13,\"^14\",[\"^ \",\"^S\",false,\"^W\",2,\"^T\",[\"^N\",[[\"^39\"],[\"^39\",\"^2>\"]]],\"^M\",[\"^N\",[[\"^39\"],[\"^39\",\"^2>\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"stroke()\",\"^T\",[\"^N\",[[\"^39\"],[\"^39\",\"^2>\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",3996,\"^L\",4002,\"^W\",2,\"^X\",true,\"^M\",[\"^N\",[[\"^39\"],[\"^39\",\"^2>\"]]],\"^Q\",\"Sets the color used to draw lines and borders around\\n  shapes. Converts rgb to int and alpha to a float.\"],\"~$print-camera\",[\"^ \",\"^A\",\"Lights, Camera\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Lights, Camera\",\"^D\",\"1.0\",\"^E\",\"Camera\",\"^F\",\"^6\",\"^G\",15,\"^H\",\"printCamera()\",\"^I\",3,\"^J\",true,\"^K\",3048,\"^L\",3048,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Prints the current camera matrix to std out. Useful for debugging.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/print-camera\",\"^S\",false,\"^E\",\"Camera\",\"^F\",\"quil/core.cljc\",\"^G\",15,\"^H\",\"printCamera()\",\"^T\",[\"^N\",[[]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",3042,\"^L\",3048,\"^W\",0,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Prints the current camera matrix to std out. Useful for debugging.\"],\"~$floor\",[\"^ \",\"^A\",\"Math\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Math\",\"^D\",\"2.0\",\"^E\",\"Calculation\",\"^F\",\"^6\",\"^G\",8,\"^H\",\"floor()\",\"^I\",3,\"^J\",false,\"^K\",1830,\"^L\",1830,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$n\"]]]]],\"^Q\",\"Calculates the closest int value that is less than or equal to the\\n  value of the parameter. For example, (floor 9.03) returns the value 9.\"],\"^D\",\"2.0\",\"^5\",\"~$quil.core/floor\",\"^S\",false,\"^E\",\"Calculation\",\"^F\",\"quil/core.cljc\",\"^G\",8,\"^H\",\"floor()\",\"^T\",[\"^N\",[[\"~$n\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",false,\"^K\",1824,\"^L\",1830,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$n\"]]]]],\"^Q\",\"Calculates the closest int value that is less than or equal to the\\n  value of the parameter. For example, (floor 9.03) returns the value 9.\"],\"~$atan2\",[\"^ \",\"^A\",\"Math\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Math\",\"^D\",\"1.0\",\"^E\",\"Trigonometry\",\"^F\",\"^6\",\"^G\",8,\"^H\",\"atan2()\",\"^I\",3,\"^J\",false,\"^K\",473,\"^L\",473,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$y\",\"~$x\"]]]]],\"^Q\",\"Calculates the angle (in radians) from a specified point to the\\n  coordinate origin as measured from the positive x-axis. Values are\\n  returned as a float in the range from PI to -PI. The atan2 function\\n  is most often used for orienting geometry to the position of the\\n  cursor. Note: The y-coordinate of the point is the first parameter\\n  and the x-coordinate is the second due to the structure of\\n  calculating the tangent.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/atan2\",\"^S\",false,\"^E\",\"Trigonometry\",\"^F\",\"quil/core.cljc\",\"^G\",8,\"^H\",\"atan2()\",\"^T\",[\"^N\",[[\"~$y\",\"~$x\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",false,\"^K\",467,\"^L\",473,\"^W\",2,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$y\",\"~$x\"]]]]],\"^Q\",\"Calculates the angle (in radians) from a specified point to the\\n  coordinate origin as measured from the positive x-axis. Values are\\n  returned as a float in the range from PI to -PI. The atan2 function\\n  is most often used for orienting geometry to the position of the\\n  cursor. Note: The y-coordinate of the point is the first parameter\\n  and the x-coordinate is the second due to the structure of\\n  calculating the tangent.\"],\"~$millis\",[\"^ \",\"^A\",\"Input\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Input\",\"^D\",\"1.0\",\"^E\",\"Time & Date\",\"^F\",\"^6\",\"^G\",9,\"^H\",\"millis()\",\"^I\",3,\"^J\",true,\"^K\",2498,\"^L\",2498,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Returns the number of milliseconds (thousandths of a second) since\\n  starting the sketch. This information is often used for timing\\n  animation sequences.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/millis\",\"^S\",false,\"^E\",\"Time & Date\",\"^F\",\"quil/core.cljc\",\"^G\",9,\"^H\",\"millis()\",\"^T\",[\"^N\",[[]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",2492,\"^L\",2498,\"^W\",0,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Returns the number of milliseconds (thousandths of a second) since\\n  starting the sketch. This information is often used for timing\\n  animation sequences.\"],\"~$lerp-color\",[\"^ \",\"^A\",\"Color\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Color\",\"^D\",\"1.0\",\"^E\",\"Creating & Reading\",\"^F\",\"^6\",\"^G\",13,\"^H\",\"lerpColor()\",\"^I\",3,\"^J\",true,\"^K\",2253,\"^L\",2253,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$c1\",\"~$c2\",\"^2A\"]]]]],\"^Q\",\"Calculates a color or colors between two color at a specific\\n  increment. The amt parameter is the amount to interpolate between\\n  the two values where 0.0 equal to the first point, 0.1 is very near\\n  the first point, 0.5 is half-way in between, etc.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/lerp-color\",\"^S\",false,\"^E\",\"Creating & Reading\",\"^F\",\"quil/core.cljc\",\"^G\",13,\"^H\",\"lerpColor()\",\"^T\",[\"^N\",[[\"^3D\",\"^3E\",\"^2A\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",2247,\"^L\",2253,\"^W\",3,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^3D\",\"^3E\",\"^2A\"]]]]],\"^Q\",\"Calculates a color or colors between two color at a specific\\n  increment. The amt parameter is the amount to interpolate between\\n  the two values where 0.0 equal to the first point, 0.1 is very near\\n  the first point, 0.5 is half-way in between, etc.\"],\"~$image-modes\",[\"^ \",\"^5\",\"~$quil.core/image-modes\",\"^F\",\"quil/core.cljc\",\"^K\",45,\"^I\",1,\"^L\",61,\"^G\",13,\"^C\",[\"^ \",\"^F\",\"^6\",\"^K\",61,\"^I\",2,\"^L\",61,\"^G\",13]],\"~$no-fill-prop\",[\"^ \",\"^5\",\"~$quil.core/no-fill-prop\",\"^F\",\"quil/core.cljc\",\"^K\",24,\"^I\",1,\"^L\",24,\"^G\",35,\"~:private\",true,\"^C\",[\"^ \",\"^F\",\"^6\",\"^K\",24,\"^I\",23,\"^L\",24,\"^G\",35,\"^3K\",true]],\"~$color-mode\",[\"^ \",\"^A\",\"Color\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Color\",\"^D\",\"1.0\",\"^E\",\"Creating & Reading\",\"^F\",\"^6\",\"^G\",13,\"^14\",[\"^ \",\"^S\",false,\"^W\",5,\"^T\",[\"^N\",[[\"^17\"],[\"^17\",\"~$max\"],[\"^17\",\"~$max-x\",\"~$max-y\",\"~$max-z\"],[\"^17\",\"^3N\",\"^3O\",\"^3P\",\"~$max-a\"]]],\"^M\",[\"^N\",[[\"^17\"],[\"^17\",\"^3M\"],[\"^17\",\"^3N\",\"^3O\",\"^3P\"],[\"^17\",\"^3N\",\"^3O\",\"^3P\",\"^3Q\"]]],\"^V\",[\"^N\",[null,null,null,null]]],\"^H\",\"colorMode()\",\"^I\",3,\"^J\",true,\"^K\",1041,\"^L\",1041,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^17\"],[\"^17\",\"^3M\"],[\"^17\",\"^3N\",\"^3O\",\"^3P\"],[\"^17\",\"^3N\",\"^3O\",\"^3P\",\"^3Q\"]]]]],\"^Q\",\"Changes the way Processing interprets color data. Available modes\\n  are :rgb and :hsb.By default, the parameters for fill, stroke,\\n  background, and color are defined by values between 0 and 255 using\\n  the :rgb color model. The color-mode fn is used to change the\\n  numerical range used for specifying colors and to switch color\\n  systems. For example, calling\\n  (color-mode :rgb 1.0) will specify that values are specified between\\n  0 and 1. The limits for defining colors are altered by setting the\\n  parameters range1, range2, range3, and range 4.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/color-mode\",\"^S\",false,\"^E\",\"Creating & Reading\",\"^F\",\"quil/core.cljc\",\"^G\",13,\"^14\",[\"^ \",\"^S\",false,\"^W\",5,\"^T\",[\"^N\",[[\"^17\"],[\"^17\",\"^3M\"],[\"^17\",\"^3N\",\"^3O\",\"^3P\"],[\"^17\",\"^3N\",\"^3O\",\"^3P\",\"^3Q\"]]],\"^M\",[\"^N\",[[\"^17\"],[\"^17\",\"^3M\"],[\"^17\",\"^3N\",\"^3O\",\"^3P\"],[\"^17\",\"^3N\",\"^3O\",\"^3P\",\"^3Q\"]]],\"^V\",[\"^N\",[null,null,null,null]]],\"^H\",\"colorMode()\",\"^T\",[\"^N\",[[\"^17\"],[\"^17\",\"^3M\"],[\"^17\",\"^3N\",\"^3O\",\"^3P\"],[\"^17\",\"^3N\",\"^3O\",\"^3P\",\"^3Q\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null,null,null]],\"^I\",1,\"^J\",true,\"^K\",1035,\"^L\",1041,\"^W\",5,\"^X\",true,\"^M\",[\"^N\",[[\"^17\"],[\"^17\",\"^3M\"],[\"^17\",\"^3N\",\"^3O\",\"^3P\"],[\"^17\",\"^3N\",\"^3O\",\"^3P\",\"^3Q\"]]],\"^Q\",\"Changes the way Processing interprets color data. Available modes\\n  are :rgb and :hsb.By default, the parameters for fill, stroke,\\n  background, and color are defined by values between 0 and 255 using\\n  the :rgb color model. The color-mode fn is used to change the\\n  numerical range used for specifying colors and to switch color\\n  systems. For example, calling\\n  (color-mode :rgb 1.0) will specify that values are specified between\\n  0 and 1. The limits for defining colors are altered by setting the\\n  parameters range1, range2, range3, and range 4.\"],\"~$create-image\",[\"^ \",\"^A\",\"Image\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Image\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^6\",\"^G\",15,\"^H\",\"createImage()\",\"^I\",3,\"^J\",true,\"^K\",1243,\"^L\",1243,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$w\",\"~$h\",\"~$format\"]]]]],\"^Q\",\"Creates a new PImage (the datatype for storing images). This\\n  provides a fresh buffer of pixels to play with. Set the size of the\\n  buffer with the width and height parameters. The format parameter\\n  defines how the pixels are stored. See the PImage reference for more\\n  information.\\n\\n  Possible formats: :rgb, :argb, :alpha (grayscale alpha channel)\\n\\n  Prefer using create-image over initialising new PImage instances\\n  directly.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/create-image\",\"^S\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^G\",15,\"^H\",\"createImage()\",\"^T\",[\"^N\",[[\"~$w\",\"~$h\",\"^3T\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",1237,\"^L\",1243,\"^W\",3,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$w\",\"~$h\",\"^3T\"]]]]],\"^Q\",\"Creates a new PImage (the datatype for storing images). This\\n  provides a fresh buffer of pixels to play with. Set the size of the\\n  buffer with the width and height parameters. The format parameter\\n  defines how the pixels are stored. See the PImage reference for more\\n  information.\\n\\n  Possible formats: :rgb, :argb, :alpha (grayscale alpha channel)\\n\\n  Prefer using create-image over initialising new PImage instances\\n  directly.\"],\"~$sq\",[\"^ \",\"^A\",\"Math\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Math\",\"^D\",\"1.0\",\"^E\",\"Calculation\",\"^F\",\"^6\",\"^G\",5,\"^H\",\"sq()\",\"^I\",3,\"^J\",false,\"^K\",3947,\"^L\",3947,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$a\"]]]]],\"^Q\",\"Squares a number (multiplies a number by itself). The result is\\n  always a positive number, as multiplying two negative numbers always\\n  yields a positive result. For example, -1 * -1 = 1.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/sq\",\"^S\",false,\"^E\",\"Calculation\",\"^F\",\"quil/core.cljc\",\"^G\",5,\"^H\",\"sq()\",\"^T\",[\"^N\",[[\"~$a\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",false,\"^K\",3941,\"^L\",3947,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$a\"]]]]],\"^Q\",\"Squares a number (multiplies a number by itself). The result is\\n  always a positive number, as multiplying two negative numbers always\\n  yields a positive result. For example, -1 * -1 = 1.\"],\"^1@\",[\"^ \",\"^A\",\"Environment\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Environment\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^6\",\"^G\",9,\"^H\",\"getHeight()\",\"^I\",3,\"~:processing-link\",null,\"^J\",true,\"^K\",1970,\"^L\",1970,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Height of the display window. The value of height is zero until\\n  size is called.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/height\",\"^S\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^G\",9,\"^H\",\"getHeight()\",\"^T\",[\"^N\",[[]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^3X\",null,\"^J\",true,\"^K\",1963,\"^L\",1970,\"^W\",0,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Height of the display window. The value of height is zero until\\n  size is called.\"],\"~$no-loop\",[\"^ \",\"^A\",\"Structure\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Structure\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^6\",\"^G\",10,\"^H\",\"noLoop()\",\"^I\",3,\"^J\",true,\"^K\",2771,\"^L\",2771,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Stops Processing from continuously executing the code within\\n  draw. If start-loop is called, the code in draw will begin to run\\n  continuously again. If using no-loop in setup, it should be the last\\n  line inside the block.\\n\\n  When no-loop is used, it's not possible to manipulate or access the\\n  screen inside event handling functions such as mouse-pressed or\\n  key-pressed. Instead, use those functions to call redraw or\\n  loop which will run draw, which can update the screen\\n  properly. This means that when no-loop has been called, no drawing\\n  can happen, and functions like save-frame may not be used.\\n\\n  Note that if the sketch is resized, redraw will be called to\\n  update the sketch, even after no-oop has been\\n  specified. Otherwise, the sketch would enter an odd state until\\n  loop was called.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/no-loop\",\"^S\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^G\",10,\"^H\",\"noLoop()\",\"^T\",[\"^N\",[[]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",2765,\"^L\",2771,\"^W\",0,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Stops Processing from continuously executing the code within\\n  draw. If start-loop is called, the code in draw will begin to run\\n  continuously again. If using no-loop in setup, it should be the last\\n  line inside the block.\\n\\n  When no-loop is used, it's not possible to manipulate or access the\\n  screen inside event handling functions such as mouse-pressed or\\n  key-pressed. Instead, use those functions to call redraw or\\n  loop which will run draw, which can update the screen\\n  properly. This means that when no-loop has been called, no drawing\\n  can happen, and functions like save-frame may not be used.\\n\\n  Note that if the sketch is resized, redraw will be called to\\n  update the sketch, even after no-oop has been\\n  specified. Otherwise, the sketch would enter an odd state until\\n  loop was called.\"],\"~$minute\",[\"^ \",\"^A\",\"Input\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Input\",\"^D\",\"1.0\",\"^E\",\"Time & Date\",\"^F\",\"^6\",\"^G\",9,\"^H\",\"minute()\",\"^I\",3,\"^J\",false,\"^K\",2511,\"^L\",2511,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Returns the current minute as a value from 0 - 59\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/minute\",\"^S\",false,\"^E\",\"Time & Date\",\"^F\",\"quil/core.cljc\",\"^G\",9,\"^H\",\"minute()\",\"^T\",[\"^N\",[[]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",false,\"^K\",2505,\"^L\",2511,\"^W\",0,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Returns the current minute as a value from 0 - 59\"],\"~$text\",[\"^ \",\"^A\",\"Typography\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Typography\",\"^D\",\"1.0\",\"^E\",\"Loading & Displaying\",\"^F\",\"^6\",\"^G\",7,\"^14\",[\"^ \",\"^S\",false,\"^W\",5,\"^T\",[\"^N\",[[\"~$s\",\"~$x\",\"~$y\"],[\"~$s\",\"~$x\",\"~$y\",\"~$z\"],[\"~$s\",\"~$x1\",\"~$y1\",\"~$x2\",\"~$y2\"]]],\"^M\",[\"^N\",[[\"~$s\",\"~$x\",\"~$y\"],[\"~$s\",\"~$x\",\"~$y\",\"~$z\"],[\"~$s\",\"^43\",\"^44\",\"^45\",\"^46\"]]],\"^V\",[\"^N\",[null,null,null]]],\"^H\",\"text()\",\"^I\",3,\"^J\",true,\"^K\",4148,\"^L\",4148,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$s\",\"~$x\",\"~$y\"],[\"~$s\",\"~$x\",\"~$y\",\"~$z\"],[\"~$s\",\"^43\",\"^44\",\"^45\",\"^46\"]]]]],\"^Q\",\"Draws text to the screen in the position specified by the x and y\\n  parameters and the optional z parameter. A default font will be used\\n  unless a font is set with the text-font fn. Change the color of the\\n  text with the fill fn. The text displays in relation to the\\n  text-align fn, which gives the option to draw to the left, right, and\\n  center of the coordinates.\\n\\n  The x1, y1, x2 and y2 parameters define a\\n  rectangular area to display within and may only be used with string\\n  data. For text drawn inside a rectangle, the coordinates are\\n  interpreted based on the current rect-mode setting.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/text\",\"^S\",false,\"^E\",\"Loading & Displaying\",\"^F\",\"quil/core.cljc\",\"^G\",7,\"^14\",[\"^ \",\"^S\",false,\"^W\",5,\"^T\",[\"^N\",[[\"~$s\",\"~$x\",\"~$y\"],[\"~$s\",\"~$x\",\"~$y\",\"~$z\"],[\"~$s\",\"^43\",\"^44\",\"^45\",\"^46\"]]],\"^M\",[\"^N\",[[\"~$s\",\"~$x\",\"~$y\"],[\"~$s\",\"~$x\",\"~$y\",\"~$z\"],[\"~$s\",\"^43\",\"^44\",\"^45\",\"^46\"]]],\"^V\",[\"^N\",[null,null,null]]],\"^H\",\"text()\",\"^T\",[\"^N\",[[\"~$s\",\"~$x\",\"~$y\"],[\"~$s\",\"~$x\",\"~$y\",\"~$z\"],[\"~$s\",\"^43\",\"^44\",\"^45\",\"^46\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null,null]],\"^I\",1,\"^J\",true,\"^K\",4142,\"^L\",4148,\"^W\",5,\"^X\",true,\"^M\",[\"^N\",[[\"~$s\",\"~$x\",\"~$y\"],[\"~$s\",\"~$x\",\"~$y\",\"~$z\"],[\"~$s\",\"^43\",\"^44\",\"^45\",\"^46\"]]],\"^Q\",\"Draws text to the screen in the position specified by the x and y\\n  parameters and the optional z parameter. A default font will be used\\n  unless a font is set with the text-font fn. Change the color of the\\n  text with the fill fn. The text displays in relation to the\\n  text-align fn, which gives the option to draw to the left, right, and\\n  center of the coordinates.\\n\\n  The x1, y1, x2 and y2 parameters define a\\n  rectangular area to display within and may only be used with string\\n  data. For text drawn inside a rectangle, the coordinates are\\n  interpreted based on the current rect-mode setting.\"],\"~$available-fonts\",[\"^ \",\"^A\",\"Typography\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Typography\",\"^D\",\"1.0\",\"^E\",\"Loading & Displaying\",\"^F\",\"^6\",\"^G\",18,\"^H\",\"PFont.list()\",\"^I\",3,\"^J\",false,\"^K\",491,\"^L\",491,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"A sequence of strings representing the fonts on this system\\n  available for use.\\n\\n  Because of limitations in Java, not all fonts can be used and some\\n  might work with one operating system and not others. When sharing a\\n  sketch with other people or posting it on the web, you may need to\\n  include a .ttf or .otf version of your font in the data directory of\\n  the sketch because other people might not have the font installed on\\n  their computer. Only fonts that can legally be distributed should be\\n  included with a sketch.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/available-fonts\",\"^S\",false,\"^E\",\"Loading & Displaying\",\"^F\",\"quil/core.cljc\",\"^G\",18,\"^H\",\"PFont.list()\",\"^T\",[\"^N\",[[]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",false,\"^K\",485,\"^L\",491,\"^W\",0,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"A sequence of strings representing the fonts on this system\\n  available for use.\\n\\n  Because of limitations in Java, not all fonts can be used and some\\n  might work with one operating system and not others. When sharing a\\n  sketch with other people or posting it on the web, you may need to\\n  include a .ttf or .otf version of your font in the data directory of\\n  the sketch because other people might not have the font installed on\\n  their computer. Only fonts that can legally be distributed should be\\n  included with a sketch.\"],\"~$rect-modes\",[\"^ \",\"^5\",\"~$quil.core/rect-modes\",\"^F\",\"quil/core.cljc\",\"^K\",45,\"^I\",1,\"^L\",62,\"^G\",12,\"^C\",[\"^ \",\"^F\",\"^6\",\"^K\",62,\"^I\",2,\"^L\",62,\"^G\",12]],\"~$THIRD-PI\",[\"^ \",\"^5\",\"~$quil.core/THIRD-PI\",\"^F\",\"quil/core.cljc\",\"^K\",78,\"^I\",1,\"^L\",78,\"^G\",14,\"^C\",[\"^ \",\"^F\",\"^6\",\"^K\",78,\"^I\",6,\"^L\",78,\"^G\",14]],\"~$binary\",[\"^ \",\"^A\",\"Data\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Data\",\"~:require-binding\",false,\"^D\",\"1.0\",\"^E\",\"Conversion\",\"^F\",\"^6\",\"^G\",9,\"^14\",[\"^ \",\"^S\",false,\"^W\",2,\"^T\",[\"^N\",[[\"^2P\"],[\"^2P\",\"~$num-digits\"]]],\"^M\",[\"^N\",[[\"^2P\"],[\"^2P\",\"^4@\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"binary()\",\"^I\",3,\"^K\",761,\"^L\",761,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^2P\"],[\"^2P\",\"^4@\"]]]]],\"^Q\",\"Returns a string representing the binary value of an int, char or\\n  byte. When converting an int to a string, it is possible to specify\\n  the number of digits used.\"],\"^4?\",false,\"^D\",\"1.0\",\"^5\",\"~$quil.core/binary\",\"^S\",false,\"^E\",\"Conversion\",\"^F\",\"quil/core.cljc\",\"^G\",9,\"^14\",[\"^ \",\"^S\",false,\"^W\",2,\"^T\",[\"^N\",[[\"^2P\"],[\"^2P\",\"^4@\"]]],\"^M\",[\"^N\",[[\"^2P\"],[\"^2P\",\"^4@\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"binary()\",\"^T\",[\"^N\",[[\"^2P\"],[\"^2P\",\"^4@\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^K\",755,\"^L\",761,\"^W\",2,\"^X\",true,\"^M\",[\"^N\",[[\"^2P\"],[\"^2P\",\"^4@\"]]],\"^Q\",\"Returns a string representing the binary value of an int, char or\\n  byte. When converting an int to a string, it is possible to specify\\n  the number of digits used.\"],\"~$pop-matrix\",[\"^ \",\"^A\",\"Transform\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Transform\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^6\",\"^G\",13,\"^H\",\"popMatrix()\",\"^I\",3,\"^J\",true,\"^K\",2999,\"^L\",2999,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Pops the current transformation matrix off the matrix\\n  stack. Understanding pushing and popping requires understanding the\\n  concept of a matrix stack. The push-matrix fn saves the current\\n  coordinate system to the stack and pop-matrix restores the prior\\n  coordinate system. push-matrix and pop-matrix are used in conjuction\\n  with the other transformation methods and may be embedded to control\\n  the scope of the transformations.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/pop-matrix\",\"^S\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^G\",13,\"^H\",\"popMatrix()\",\"^T\",[\"^N\",[[]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",2993,\"^L\",2999,\"^W\",0,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Pops the current transformation matrix off the matrix\\n  stack. Understanding pushing and popping requires understanding the\\n  concept of a matrix stack. The push-matrix fn saves the current\\n  coordinate system to the stack and pop-matrix restores the prior\\n  coordinate system. push-matrix and pop-matrix are used in conjuction\\n  with the other transformation methods and may be embedded to control\\n  the scope of the transformations.\"],\"~$ceil\",[\"^ \",\"^A\",\"Math\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Math\",\"^D\",\"1.0\",\"^E\",\"Calculation\",\"^F\",\"^6\",\"^G\",7,\"^H\",\"ceil()\",\"^I\",3,\"^J\",false,\"^K\",972,\"^L\",972,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$n\"]]]]],\"^Q\",\"Calculates the closest int value that is greater than or equal to\\n  the value of the parameter. For example, (ceil 9.03) returns the\\n  value 10.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/ceil\",\"^S\",false,\"^E\",\"Calculation\",\"^F\",\"quil/core.cljc\",\"^G\",7,\"^H\",\"ceil()\",\"^T\",[\"^N\",[[\"~$n\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",false,\"^K\",966,\"^L\",972,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$n\"]]]]],\"^Q\",\"Calculates the closest int value that is greater than or equal to\\n  the value of the parameter. For example, (ceil 9.03) returns the\\n  value 10.\"],\"~$key-code\",[\"^ \",\"^A\",\"Input\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Input\",\"^D\",\"1.0\",\"^E\",\"Keyboard\",\"^F\",\"^6\",\"^G\",11,\"^H\",\"keyCode\",\"^I\",3,\"^J\",true,\"^K\",2168,\"^L\",2168,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"The variable keyCode is used to detect special keys such as the UP,\\n  DOWN, LEFT, RIGHT arrow keys and ALT, CONTROL, SHIFT. When checking\\n  for these keys, it's first necessary to check and see if the key is\\n  coded. This is done with the conditional (= (key) CODED).\\n\\n  The keys included in the ASCII specification (BACKSPACE, TAB, ENTER,\\n  RETURN, ESC, and DELETE) do not require checking to see if they key\\n  is coded, and you should simply use the key variable instead of\\n  key-code If you're making cross-platform projects, note that the\\n  ENTER key is commonly used on PCs and Unix and the RETURN key is\\n  used instead on Macintosh. Check for both ENTER and RETURN to make\\n  sure your program will work for all platforms.\\n\\n  For users familiar with Java, the values for UP and DOWN are simply\\n  shorter versions of Java's KeyEvent.VK_UP and\\n  KeyEvent.VK_DOWN. Other keyCode values can be found in the Java\\n  KeyEvent reference.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/key-code\",\"^S\",false,\"^E\",\"Keyboard\",\"^F\",\"quil/core.cljc\",\"^G\",11,\"^H\",\"keyCode\",\"^T\",[\"^N\",[[]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",2162,\"^L\",2168,\"^W\",0,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"The variable keyCode is used to detect special keys such as the UP,\\n  DOWN, LEFT, RIGHT arrow keys and ALT, CONTROL, SHIFT. When checking\\n  for these keys, it's first necessary to check and see if the key is\\n  coded. This is done with the conditional (= (key) CODED).\\n\\n  The keys included in the ASCII specification (BACKSPACE, TAB, ENTER,\\n  RETURN, ESC, and DELETE) do not require checking to see if they key\\n  is coded, and you should simply use the key variable instead of\\n  key-code If you're making cross-platform projects, note that the\\n  ENTER key is commonly used on PCs and Unix and the RETURN key is\\n  used instead on Macintosh. Check for both ENTER and RETURN to make\\n  sure your program will work for all platforms.\\n\\n  For users familiar with Java, the values for UP and DOWN are simply\\n  shorter versions of Java's KeyEvent.VK_UP and\\n  KeyEvent.VK_DOWN. Other keyCode values can be found in the Java\\n  KeyEvent reference.\"],\"~$sphere\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"3D Primitives\",\"^F\",\"^6\",\"^G\",9,\"^H\",\"sphere()\",\"^I\",3,\"^J\",true,\"^K\",3895,\"^L\",3895,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$radius\"]]]]],\"^Q\",\"Generates a hollow ball made from tessellated triangles.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/sphere\",\"^S\",false,\"^E\",\"3D Primitives\",\"^F\",\"quil/core.cljc\",\"^G\",9,\"^H\",\"sphere()\",\"^T\",[\"^N\",[[\"^4I\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",3889,\"^L\",3895,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^4I\"]]]]],\"^Q\",\"Generates a hollow ball made from tessellated triangles.\"],\"~$request-image\",[\"^ \",\"^A\",\"Image\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Image\",\"^D\",\"1.0\",\"^E\",\"Loading & Displaying\",\"^F\",\"^6\",\"^G\",16,\"^H\",\"requestImage()\",\"^I\",3,\"^J\",true,\"^K\",3338,\"^L\",3338,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$filename\"]]]]],\"^Q\",\"This function load images on a separate thread so that your sketch\\n  does not freeze while images load during setup. While the image is\\n  loading, its width and height will be 0. If an error occurs while\\n  loading the image, its width and height will be set to -1. You'll\\n  know when the image has loaded properly because its width and height\\n  will be greater than 0. Asynchronous image loading (particularly\\n  when downloading from a server) can dramatically improve\\n  performance.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/request-image\",\"^S\",false,\"^E\",\"Loading & Displaying\",\"^F\",\"quil/core.cljc\",\"^G\",16,\"^H\",\"requestImage()\",\"^T\",[\"^N\",[[\"^4L\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",3332,\"^L\",3338,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^4L\"]]]]],\"^Q\",\"This function load images on a separate thread so that your sketch\\n  does not freeze while images load during setup. While the image is\\n  loading, its width and height will be 0. If an error occurs while\\n  loading the image, its width and height will be set to -1. You'll\\n  know when the image has loaded properly because its width and height\\n  will be greater than 0. Asynchronous image loading (particularly\\n  when downloading from a server) can dramatically improve\\n  performance.\"],\"~$hue\",[\"^ \",\"^A\",\"Color\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Color\",\"^D\",\"1.0\",\"^E\",\"Creating & Reading\",\"^F\",\"^6\",\"^G\",6,\"^H\",\"hue()\",\"^I\",3,\"^J\",true,\"^K\",2064,\"^L\",2064,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$col\"]]]]],\"^Q\",\"Extracts the hue value from a color.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/hue\",\"^S\",false,\"^E\",\"Creating & Reading\",\"^F\",\"quil/core.cljc\",\"^G\",6,\"^H\",\"hue()\",\"^T\",[\"^N\",[[\"^4O\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",2058,\"^L\",2064,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^4O\"]]]]],\"^Q\",\"Extracts the hue value from a color.\"],\"~$background-int\",[\"^ \",\"^A\",\"Color\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Color\",\"^D\",\"1.0\",\"^E\",\"Setting\",\"^F\",\"^6\",\"^G\",17,\"^14\",[\"^ \",\"^S\",false,\"^W\",2,\"^T\",[\"^N\",[[\"^39\"],[\"^39\",\"^2>\"]]],\"^M\",[\"^N\",[[\"^39\"],[\"^39\",\"^2>\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"background()\",\"^I\",3,\"^J\",true,\"^K\",532,\"^L\",532,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^39\"],[\"^39\",\"^2>\"]]]]],\"^Q\",\"Sets the color used for the background of the Processing\\n  window. The default background is light gray. In the draw function,\\n  the background color is used to clear the display window at the\\n  beginning of each frame.\\n\\n  It is not possible to use transparency (alpha) in background colors\\n  with the main drawing surface, however they will work properly with\\n  create-graphics. Converts rgb to an int and alpha to a float.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/background-int\",\"^S\",false,\"^E\",\"Setting\",\"^F\",\"quil/core.cljc\",\"^G\",17,\"^14\",[\"^ \",\"^S\",false,\"^W\",2,\"^T\",[\"^N\",[[\"^39\"],[\"^39\",\"^2>\"]]],\"^M\",[\"^N\",[[\"^39\"],[\"^39\",\"^2>\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"background()\",\"^T\",[\"^N\",[[\"^39\"],[\"^39\",\"^2>\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",526,\"^L\",532,\"^W\",2,\"^X\",true,\"^M\",[\"^N\",[[\"^39\"],[\"^39\",\"^2>\"]]],\"^Q\",\"Sets the color used for the background of the Processing\\n  window. The default background is light gray. In the draw function,\\n  the background color is used to clear the display window at the\\n  beginning of each frame.\\n\\n  It is not possible to use transparency (alpha) in background colors\\n  with the main drawing surface, however they will work properly with\\n  create-graphics. Converts rgb to an int and alpha to a float.\"],\"~$start-loop\",[\"^ \",\"^A\",\"Structure\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Structure\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^6\",\"^G\",13,\"^H\",\"loop()\",\"^I\",3,\"^J\",true,\"^K\",3976,\"^L\",3976,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Causes Processing to continuously execute the code within\\n  draw. If no-loop is called, the code in draw stops executing.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/start-loop\",\"^S\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^G\",13,\"^H\",\"loop()\",\"^T\",[\"^N\",[[]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",3970,\"^L\",3976,\"^W\",0,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Causes Processing to continuously execute the code within\\n  draw. If no-loop is called, the code in draw stops executing.\"],\"~$no-fill?\",[\"^ \",\"^B\",null,\"^C\",[\"^ \",\"^F\",\"^6\",\"^K\",4104,\"^I\",8,\"^L\",4104,\"^G\",16,\"^3K\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^1M\"]]]]],\"^Q\",\"Returns whether fill is disabled for current graphics.\"],\"^3K\",true,\"^5\",\"~$quil.core/no-fill?\",\"^S\",false,\"^F\",\"quil/core.cljc\",\"^G\",16,\"^T\",[\"^N\",[[\"^1M\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^K\",4104,\"^L\",4104,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^1M\"]]]]],\"^Q\",\"Returns whether fill is disabled for current graphics.\"],\"~$curve-vertex\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"Vertex\",\"^F\",\"^6\",\"^G\",15,\"^14\",[\"^ \",\"^S\",false,\"^W\",3,\"^T\",[\"^N\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^M\",[\"^N\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"curveVertex()\",\"^I\",3,\"^J\",true,\"^K\",1407,\"^L\",1407,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]]]],\"^Q\",\"Specifies vertex coordinates for curves. This function may only be\\n  used between begin-shape and end-shape and only when there is no\\n  mode keyword specified to begin-shape. The first and last points in a\\n  series of curve-vertex lines will be used to guide the beginning and\\n  end of a the curve. A minimum of four points is required to draw a\\n  tiny curve between the second and third points. Adding a fifth point\\n  with curve-vertex will draw the curve between the second, third, and\\n  fourth points. The curve-vertex function is an implementation of\\n  Catmull-Rom splines.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/curve-vertex\",\"^S\",false,\"^E\",\"Vertex\",\"^F\",\"quil/core.cljc\",\"^G\",15,\"^14\",[\"^ \",\"^S\",false,\"^W\",3,\"^T\",[\"^N\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^M\",[\"^N\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"curveVertex()\",\"^T\",[\"^N\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",1401,\"^L\",1407,\"^W\",3,\"^X\",true,\"^M\",[\"^N\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^Q\",\"Specifies vertex coordinates for curves. This function may only be\\n  used between begin-shape and end-shape and only when there is no\\n  mode keyword specified to begin-shape. The first and last points in a\\n  series of curve-vertex lines will be used to guide the beginning and\\n  end of a the curve. A minimum of four points is required to draw a\\n  tiny curve between the second and third points. Adding a fifth point\\n  with curve-vertex will draw the curve between the second, third, and\\n  fourth points. The curve-vertex function is an implementation of\\n  Catmull-Rom splines.\"],\"~$state-atom\",[\"^ \",\"^A\",\"State\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"State\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^6\",\"^G\",13,\"^I\",3,\"^J\",true,\"^K\",199,\"^L\",199,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Retrieve sketch-specific state-atom. All changes to the\\n  atom will be reflected in the state.\\n\\n  (set-state! :foo 1)\\n  (state :foo) ;=> 1\\n  (swap! (state-atom) update-in [:foo] inc)\\n  (state :foo) ;=> 2\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/state-atom\",\"^S\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^G\",13,\"^T\",[\"^N\",[[]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",194,\"^L\",199,\"^W\",0,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Retrieve sketch-specific state-atom. All changes to the\\n  atom will be reflected in the state.\\n\\n  (set-state! :foo 1)\\n  (state :foo) ;=> 1\\n  (swap! (state-atom) update-in [:foo] inc)\\n  (state :foo) ;=> 2\"],\"~$load-image\",[\"^ \",\"^A\",\"Image\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Image\",\"^D\",\"1.0\",\"^E\",\"Loading & Displaying\",\"^F\",\"^6\",\"^G\",13,\"^H\",\"loadImage()\",\"^I\",3,\"^J\",true,\"^K\",2372,\"^L\",2372,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^4L\"]]]]],\"^Q\",\"Loads an image into a variable of type PImage. Four types of\\n  images ( .gif, .jpg, .tga, .png) images may be loaded. To load\\n  correctly, images must be located in the data directory of the\\n  current sketch. In most cases, load all images in setup to preload\\n  them at the start of the program. Loading images inside draw will\\n  reduce the speed of a program.\\n\\n  The filename parameter can also be a URL to a file found online.\\n\\n  If an image is not loaded successfully, the null value is returned\\n  and an error message will be printed to the console. The error\\n  message does not halt the program, however the null value may cause\\n  a NullPointerException if your code does not check whether the value\\n  returned from load-image is nil.\\n\\n  Depending on the type of error, a PImage object may still be\\n  returned, but the width and height of the image will be set to\\n  -1. This happens if bad image data is returned or cannot be decoded\\n  properly. Sometimes this happens with image URLs that produce a 403\\n  error or that redirect to a password prompt, because load-image\\n  will attempt to interpret the HTML as image data.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/load-image\",\"^S\",false,\"^E\",\"Loading & Displaying\",\"^F\",\"quil/core.cljc\",\"^G\",13,\"^H\",\"loadImage()\",\"^T\",[\"^N\",[[\"^4L\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",2366,\"^L\",2372,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^4L\"]]]]],\"^Q\",\"Loads an image into a variable of type PImage. Four types of\\n  images ( .gif, .jpg, .tga, .png) images may be loaded. To load\\n  correctly, images must be located in the data directory of the\\n  current sketch. In most cases, load all images in setup to preload\\n  them at the start of the program. Loading images inside draw will\\n  reduce the speed of a program.\\n\\n  The filename parameter can also be a URL to a file found online.\\n\\n  If an image is not loaded successfully, the null value is returned\\n  and an error message will be printed to the console. The error\\n  message does not halt the program, however the null value may cause\\n  a NullPointerException if your code does not check whether the value\\n  returned from load-image is nil.\\n\\n  Depending on the type of error, a PImage object may still be\\n  returned, but the width and height of the image will be set to\\n  -1. This happens if bad image data is returned or cannot be decoded\\n  properly. Sometimes this happens with image URLs that produce a 403\\n  error or that redirect to a password prompt, because load-image\\n  will attempt to interpret the HTML as image data.\"],\"~$bezier\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"Curves\",\"^F\",\"^6\",\"^G\",9,\"^14\",[\"^ \",\"^S\",false,\"^W\",12,\"^T\",[\"^N\",[[\"^43\",\"^44\",\"~$cx1\",\"~$cy1\",\"~$cx2\",\"~$cy2\",\"^45\",\"^46\"],[\"^43\",\"^44\",\"~$z1\",\"^52\",\"^53\",\"~$cz1\",\"^54\",\"^55\",\"~$cz2\",\"^45\",\"^46\",\"~$z2\"]]],\"^M\",[\"^N\",[[\"^43\",\"^44\",\"^52\",\"^53\",\"^54\",\"^55\",\"^45\",\"^46\"],[\"^43\",\"^44\",\"^56\",\"^52\",\"^53\",\"^57\",\"^54\",\"^55\",\"^58\",\"^45\",\"^46\",\"^59\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"bezier()\",\"^I\",3,\"^J\",true,\"^K\",667,\"^L\",667,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^43\",\"^44\",\"^52\",\"^53\",\"^54\",\"^55\",\"^45\",\"^46\"],[\"^43\",\"^44\",\"^56\",\"^52\",\"^53\",\"^57\",\"^54\",\"^55\",\"^58\",\"^45\",\"^46\",\"^59\"]]]]],\"^Q\",\"Draws a Bezier curve on the screen. These curves are defined by a\\n  series of anchor and control points. The first two parameters\\n  specify the first anchor point and the last two parameters specify\\n  the other anchor point. The middle parameters specify the control\\n  points which define the shape of the curve.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/bezier\",\"^S\",false,\"^E\",\"Curves\",\"^F\",\"quil/core.cljc\",\"^G\",9,\"^14\",[\"^ \",\"^S\",false,\"^W\",12,\"^T\",[\"^N\",[[\"^43\",\"^44\",\"^52\",\"^53\",\"^54\",\"^55\",\"^45\",\"^46\"],[\"^43\",\"^44\",\"^56\",\"^52\",\"^53\",\"^57\",\"^54\",\"^55\",\"^58\",\"^45\",\"^46\",\"^59\"]]],\"^M\",[\"^N\",[[\"^43\",\"^44\",\"^52\",\"^53\",\"^54\",\"^55\",\"^45\",\"^46\"],[\"^43\",\"^44\",\"^56\",\"^52\",\"^53\",\"^57\",\"^54\",\"^55\",\"^58\",\"^45\",\"^46\",\"^59\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"bezier()\",\"^T\",[\"^N\",[[\"^43\",\"^44\",\"^52\",\"^53\",\"^54\",\"^55\",\"^45\",\"^46\"],[\"^43\",\"^44\",\"^56\",\"^52\",\"^53\",\"^57\",\"^54\",\"^55\",\"^58\",\"^45\",\"^46\",\"^59\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",661,\"^L\",667,\"^W\",12,\"^X\",true,\"^M\",[\"^N\",[[\"^43\",\"^44\",\"^52\",\"^53\",\"^54\",\"^55\",\"^45\",\"^46\"],[\"^43\",\"^44\",\"^56\",\"^52\",\"^53\",\"^57\",\"^54\",\"^55\",\"^58\",\"^45\",\"^46\",\"^59\"]]],\"^Q\",\"Draws a Bezier curve on the screen. These curves are defined by a\\n  series of anchor and control points. The first two parameters\\n  specify the first anchor point and the last two parameters specify\\n  the other anchor point. The middle parameters specify the control\\n  points which define the shape of the curve.\"],\"~$smooth\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"Attributes\",\"^F\",\"^6\",\"^G\",9,\"^14\",[\"^ \",\"^S\",false,\"^W\",1,\"^T\",[\"^N\",[[],[\"^18\"]]],\"^M\",[\"^N\",[[],[\"^18\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"smooth()\",\"^I\",3,\"^J\",true,\"^K\",3849,\"^L\",3849,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[],[\"^18\"]]]]],\"^Q\",\"Draws all geometry with smooth (anti-aliased) edges. This will slow\\n  down the frame rate of the application, but will enhance the visual\\n  refinement.\\n\\n  Must be called inside :settings handler.\\n\\n  The level parameter (int) increases the level of smoothness with the\\n  P2D and P3D renderers. This is the level of over sampling applied to\\n  the graphics buffer. The value '2' will double the rendering size\\n  before scaling it down to the display size. This is called '2x\\n  anti-aliasing.' The value 4 is used for 4x anti-aliasing and 8 is\\n  specified for 8x anti-aliasing. If level is set to 0, it will disable\\n  all smoothing; it's the equivalent of the function noSmooth().\\n  The maximum anti-aliasing level is determined by the hardware of the\\n  machine that is running the software.\\n\\n  Note that smooth will also improve image quality of resized images.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/smooth\",\"^S\",false,\"^E\",\"Attributes\",\"^F\",\"quil/core.cljc\",\"^G\",9,\"^14\",[\"^ \",\"^S\",false,\"^W\",1,\"^T\",[\"^N\",[[],[\"^18\"]]],\"^M\",[\"^N\",[[],[\"^18\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"smooth()\",\"^T\",[\"^N\",[[],[\"^18\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",3843,\"^L\",3849,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[[],[\"^18\"]]],\"^Q\",\"Draws all geometry with smooth (anti-aliased) edges. This will slow\\n  down the frame rate of the application, but will enhance the visual\\n  refinement.\\n\\n  Must be called inside :settings handler.\\n\\n  The level parameter (int) increases the level of smoothness with the\\n  P2D and P3D renderers. This is the level of over sampling applied to\\n  the graphics buffer. The value '2' will double the rendering size\\n  before scaling it down to the display size. This is called '2x\\n  anti-aliasing.' The value 4 is used for 4x anti-aliasing and 8 is\\n  specified for 8x anti-aliasing. If level is set to 0, it will disable\\n  all smoothing; it's the equivalent of the function noSmooth().\\n  The maximum anti-aliasing level is determined by the hardware of the\\n  machine that is running the software.\\n\\n  Note that smooth will also improve image quality of resized images.\"],\"~$filter-modes\",[\"^ \",\"^5\",\"~$quil.core/filter-modes\",\"^F\",\"quil/core.cljc\",\"^K\",45,\"^I\",1,\"^L\",71,\"^G\",14,\"^C\",[\"^ \",\"^F\",\"^6\",\"^K\",71,\"^I\",2,\"^L\",71,\"^G\",14]],\"~$shear-x\",[\"^ \",\"^A\",\"Transform\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Transform\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^6\",\"^G\",10,\"^H\",\"shearX()\",\"^I\",3,\"^J\",true,\"^K\",3748,\"^L\",3748,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^P\"]]]]],\"^Q\",\"Shears a shape around the x-axis the amount specified by the angle\\n  parameter. Angles should be specified in radians (values from 0 to\\n  PI*2) or converted to radians with the radians() function. Objects\\n  are always sheared around their relative position to the origin and\\n  positive numbers shear objects in a clockwise direction.\\n  Transformations apply to everything that happens after and\\n  subsequent calls to the function accumulates the effect. For\\n  example, calling (shear-x (/ PI 2)) and then (shear-x (/ PI 2)) is\\n  the same as (shear-x PI). If shear-x is called within the draw fn,\\n  the transformation is reset when the loop begins again. This\\n  function works in P2D or JAVA2D mode.\\n\\n  Technically, shear-x multiplies the current transformation matrix\\n  by a rotation matrix. This function can be further controlled by the\\n  push-matrix and pop-matrix fns.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/shear-x\",\"^S\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^G\",10,\"^H\",\"shearX()\",\"^T\",[\"^N\",[[\"^P\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",3742,\"^L\",3748,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^P\"]]]]],\"^Q\",\"Shears a shape around the x-axis the amount specified by the angle\\n  parameter. Angles should be specified in radians (values from 0 to\\n  PI*2) or converted to radians with the radians() function. Objects\\n  are always sheared around their relative position to the origin and\\n  positive numbers shear objects in a clockwise direction.\\n  Transformations apply to everything that happens after and\\n  subsequent calls to the function accumulates the effect. For\\n  example, calling (shear-x (/ PI 2)) and then (shear-x (/ PI 2)) is\\n  the same as (shear-x PI). If shear-x is called within the draw fn,\\n  the transformation is reset when the loop begins again. This\\n  function works in P2D or JAVA2D mode.\\n\\n  Technically, shear-x multiplies the current transformation matrix\\n  by a rotation matrix. This function can be further controlled by the\\n  push-matrix and pop-matrix fns.\"],\"~$stroke-weight\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"Attributes\",\"^F\",\"^6\",\"^G\",16,\"^H\",\"strokeWeight()\",\"^I\",3,\"^J\",true,\"^K\",4072,\"^L\",4072,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$weight\"]]]]],\"^Q\",\"Sets the width of the stroke used for lines, points, and the border\\n  around shapes. All widths are set in units of pixels. \"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/stroke-weight\",\"^S\",false,\"^E\",\"Attributes\",\"^F\",\"quil/core.cljc\",\"^G\",16,\"^H\",\"strokeWeight()\",\"^T\",[\"^N\",[[\"^5B\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",4066,\"^L\",4072,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^5B\"]]]]],\"^Q\",\"Sets the width of the stroke used for lines, points, and the border\\n  around shapes. All widths are set in units of pixels. \"],\"~$directional-light\",[\"^ \",\"^A\",\"Lights, Camera\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Lights, Camera\",\"^D\",\"1.0\",\"^E\",\"Lights\",\"^F\",\"^6\",\"^G\",20,\"^H\",\"directionalLight()\",\"^I\",3,\"^J\",true,\"^K\",1473,\"^L\",1473,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$r\",\"~$g\",\"~$b\",\"~$nx\",\"~$ny\",\"~$nz\"]]]]],\"^Q\",\"Adds a directional light. Directional light comes from one\\n  direction and is stronger when hitting a surface squarely and weaker\\n  if it hits at a gentle angle. After hitting a surface, a\\n  directional lights scatters in all directions. Lights need to be\\n  included in the draw fn to remain persistent in a looping\\n  program. Placing them in the setup fn of a looping program will cause\\n  them to only have an effect the first time through the loop. The\\n  affect of the r, g, and b parameters is determined by the current\\n  color mode. The nx, ny, and nz parameters specify the direction the\\n  light is facing. For example, setting ny to -1 will cause the\\n  geometry to be lit from below (the light is facing directly upward)\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/directional-light\",\"^S\",false,\"^E\",\"Lights\",\"^F\",\"quil/core.cljc\",\"^G\",20,\"^H\",\"directionalLight()\",\"^T\",[\"^N\",[[\"~$r\",\"~$g\",\"~$b\",\"^5E\",\"^5F\",\"^5G\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",1467,\"^L\",1473,\"^W\",6,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$r\",\"~$g\",\"~$b\",\"^5E\",\"^5F\",\"^5G\"]]]]],\"^Q\",\"Adds a directional light. Directional light comes from one\\n  direction and is stronger when hitting a surface squarely and weaker\\n  if it hits at a gentle angle. After hitting a surface, a\\n  directional lights scatters in all directions. Lights need to be\\n  included in the draw fn to remain persistent in a looping\\n  program. Placing them in the setup fn of a looping program will cause\\n  them to only have an effect the first time through the loop. The\\n  affect of the r, g, and b parameters is determined by the current\\n  color mode. The nx, ny, and nz parameters specify the direction the\\n  light is facing. For example, setting ny to -1 will cause the\\n  geometry to be lit from below (the light is facing directly upward)\"],\"~$frame-rate\",[\"^ \",\"^A\",\"Environment\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Environment\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^6\",\"^G\",13,\"^H\",\"frameRate()\",\"^I\",3,\"^J\",true,\"^K\",1879,\"^L\",1879,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$new-rate\"]]]]],\"^Q\",\"Specifies a new target framerate (number of frames to be displayed every\\n  second). If the processor is not fast enough to maintain the\\n  specified rate, it will not be achieved. For example, the function\\n  call (frame-rate 30) will attempt to refresh 30 times a second. It\\n  is recommended to set the frame rate within setup. The default rate\\n  is 60 frames per second.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/frame-rate\",\"^S\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^G\",13,\"^H\",\"frameRate()\",\"^T\",[\"^N\",[[\"^5J\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",1873,\"^L\",1879,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^5J\"]]]]],\"^Q\",\"Specifies a new target framerate (number of frames to be displayed every\\n  second). If the processor is not fast enough to maintain the\\n  specified rate, it will not be achieved. For example, the function\\n  call (frame-rate 30) will attempt to refresh 30 times a second. It\\n  is recommended to set the frame rate within setup. The default rate\\n  is 60 frames per second.\"],\"~$hour\",[\"^ \",\"^A\",\"Input\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Input\",\"^D\",\"1.0\",\"^E\",\"Time & Date\",\"^F\",\"^6\",\"^G\",7,\"^H\",\"hour()\",\"^I\",3,\"^J\",false,\"^K\",2052,\"^L\",2052,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Returns the current hour as a value from 0 - 23.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/hour\",\"^S\",false,\"^E\",\"Time & Date\",\"^F\",\"quil/core.cljc\",\"^G\",7,\"^H\",\"hour()\",\"^T\",[\"^N\",[[]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",false,\"^K\",2046,\"^L\",2052,\"^W\",0,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Returns the current hour as a value from 0 - 23.\"],\"~$fill-int\",[\"^ \",\"^A\",\"Color\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Color\",\"^D\",\"1.0\",\"^E\",\"Setting\",\"^F\",\"^6\",\"^G\",11,\"^14\",[\"^ \",\"^S\",false,\"^W\",2,\"^T\",[\"^N\",[[\"^39\"],[\"^39\",\"^2>\"]]],\"^M\",[\"^N\",[[\"^39\"],[\"^39\",\"^2>\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"fill()\",\"^I\",3,\"^J\",true,\"^K\",1727,\"^L\",1727,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^39\"],[\"^39\",\"^2>\"]]]]],\"^Q\",\"Sets the color used to fill shapes.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/fill-int\",\"^S\",false,\"^E\",\"Setting\",\"^F\",\"quil/core.cljc\",\"^G\",11,\"^14\",[\"^ \",\"^S\",false,\"^W\",2,\"^T\",[\"^N\",[[\"^39\"],[\"^39\",\"^2>\"]]],\"^M\",[\"^N\",[[\"^39\"],[\"^39\",\"^2>\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"fill()\",\"^T\",[\"^N\",[[\"^39\"],[\"^39\",\"^2>\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",1721,\"^L\",1727,\"^W\",2,\"^X\",true,\"^M\",[\"^N\",[[\"^39\"],[\"^39\",\"^2>\"]]],\"^Q\",\"Sets the color used to fill shapes.\"],\"~$atan\",[\"^ \",\"^A\",\"Math\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Math\",\"^D\",\"1.0\",\"^E\",\"Trigonometry\",\"^F\",\"^6\",\"^G\",7,\"^H\",\"atan()\",\"^I\",3,\"^J\",false,\"^K\",458,\"^L\",458,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$n\"]]]]],\"^Q\",\"The inverse of tan, returns the arc tangent of a value. This\\n  function expects the values in the range of -Infinity to\\n  Infinity (exclusive) and values are returned in the range -PI/2 to\\n  PI/2 .\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/atan\",\"^S\",false,\"^E\",\"Trigonometry\",\"^F\",\"quil/core.cljc\",\"^G\",7,\"^H\",\"atan()\",\"^T\",[\"^N\",[[\"~$n\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",false,\"^K\",452,\"^L\",458,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$n\"]]]]],\"^Q\",\"The inverse of tan, returns the arc tangent of a value. This\\n  function expects the values in the range of -Infinity to\\n  Infinity (exclusive) and values are returned in the range -PI/2 to\\n  PI/2 .\"],\"~$stroke-join-modes\",[\"^ \",\"^5\",\"~$quil.core/stroke-join-modes\",\"^F\",\"quil/core.cljc\",\"^K\",45,\"^I\",1,\"^L\",65,\"^G\",19,\"^C\",[\"^ \",\"^F\",\"^6\",\"^K\",65,\"^I\",2,\"^L\",65,\"^G\",19]],\"~$rotate-y\",[\"^ \",\"^A\",\"Transform\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Transform\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^6\",\"^G\",11,\"^H\",\"rotateY()\",\"^I\",3,\"^J\",true,\"^K\",3457,\"^L\",3457,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^P\"]]]]],\"^Q\",\"Rotates a shape around the y-axis the amount specified by the angle\\n  parameter. Angles should be specified in radians (values from 0\\n  to (* PI 2)) or converted to radians with the radians function.\\n  Objects are always rotated around their relative position to the\\n  origin and positive numbers rotate objects in a counterclockwise\\n  direction. Transformations apply to everything that happens after\\n  and subsequent calls to the function accumulates the effect. For\\n  example, calling (rotate-y HALF-PI) and then (rotate-y HALF-PI) is\\n  the same as (rotate-y PI). If rotate-y is called within the draw fn,\\n  the transformation is reset when the loop begins again. This\\n  function requires either the :p3d or :opengl renderer.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/rotate-y\",\"^S\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^G\",11,\"^H\",\"rotateY()\",\"^T\",[\"^N\",[[\"^P\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",3451,\"^L\",3457,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^P\"]]]]],\"^Q\",\"Rotates a shape around the y-axis the amount specified by the angle\\n  parameter. Angles should be specified in radians (values from 0\\n  to (* PI 2)) or converted to radians with the radians function.\\n  Objects are always rotated around their relative position to the\\n  origin and positive numbers rotate objects in a counterclockwise\\n  direction. Transformations apply to everything that happens after\\n  and subsequent calls to the function accumulates the effect. For\\n  example, calling (rotate-y HALF-PI) and then (rotate-y HALF-PI) is\\n  the same as (rotate-y PI). If rotate-y is called within the draw fn,\\n  the transformation is reset when the loop begins again. This\\n  function requires either the :p3d or :opengl renderer.\"],\"~$day\",[\"^ \",\"^A\",\"Input\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Input\",\"^D\",\"1.0\",\"^E\",\"Time & Date\",\"^F\",\"^6\",\"^G\",6,\"^H\",\"day()\",\"^I\",3,\"^J\",false,\"^K\",1426,\"^L\",1426,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Get the current day of the month (1 through 31).\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/day\",\"^S\",false,\"^E\",\"Time & Date\",\"^F\",\"quil/core.cljc\",\"^G\",6,\"^H\",\"day()\",\"^T\",[\"^N\",[[]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",false,\"^K\",1420,\"^L\",1426,\"^W\",0,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Get the current day of the month (1 through 31).\"],\"~$point-light\",[\"^ \",\"^A\",\"Lights, Camera\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Lights, Camera\",\"^D\",\"1.0\",\"^E\",\"Lights\",\"^F\",\"^6\",\"^G\",14,\"^H\",\"pointLight()\",\"^I\",3,\"^J\",true,\"^K\",2983,\"^L\",2983,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$r\",\"~$g\",\"~$b\",\"~$x\",\"~$y\",\"~$z\"]]]]],\"^Q\",\"Adds a point light. Lights need to be included in the draw() to\\n  remain persistent in a looping program. Placing them in the setup()\\n  of a looping program will cause them to only have an effect the\\n  first time through the loop. The affect of the r, g, and b\\n  parameters is determined by the current color mode. The x, y, and z\\n  parameters set the position of the light\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/point-light\",\"^S\",false,\"^E\",\"Lights\",\"^F\",\"quil/core.cljc\",\"^G\",14,\"^H\",\"pointLight()\",\"^T\",[\"^N\",[[\"~$r\",\"~$g\",\"~$b\",\"~$x\",\"~$y\",\"~$z\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",2977,\"^L\",2983,\"^W\",6,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$r\",\"~$g\",\"~$b\",\"~$x\",\"~$y\",\"~$z\"]]]]],\"^Q\",\"Adds a point light. Lights need to be included in the draw() to\\n  remain persistent in a looping program. Placing them in the setup()\\n  of a looping program will cause them to only have an effect the\\n  first time through the loop. The affect of the r, g, and b\\n  parameters is determined by the current color mode. The x, y, and z\\n  parameters set the position of the light\"],\"~$pmouse-x\",[\"^ \",\"^A\",\"Input\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Input\",\"^D\",\"1.0\",\"^E\",\"Mouse\",\"^F\",\"^6\",\"^G\",11,\"^H\",\"pmouseX\",\"^I\",3,\"^J\",true,\"^K\",2945,\"^L\",2945,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Horizontal coordinate of the mouse in the previous frame\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/pmouse-x\",\"^S\",false,\"^E\",\"Mouse\",\"^F\",\"quil/core.cljc\",\"^G\",11,\"^H\",\"pmouseX\",\"^T\",[\"^N\",[[]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",2939,\"^L\",2945,\"^W\",0,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Horizontal coordinate of the mouse in the previous frame\"],\"~$get-sketch-by-id\",[\"^ \",\"^A\",null,\"^B\",null,\"^C\",[\"^ \",\"^A\",null,\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^6\",\"^G\",22,\"^H\",\"getSketchById()\",\"^I\",6,\"^J\",true,\"^K\",185,\"^L\",185,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$id\"]]]]],\"^Q\",\"Returns sketch object by id of canvas element of sketch.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/get-sketch-by-id\",\"^S\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^G\",22,\"^H\",\"getSketchById()\",\"^T\",[\"^N\",[[\"^61\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",4,\"^J\",true,\"^K\",179,\"^L\",185,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^61\"]]]]],\"^Q\",\"Returns sketch object by id of canvas element of sketch.\"],\"~$stroke\",[\"^ \",\"^A\",\"Color\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Color\",\"^D\",\"1.0\",\"^E\",\"Setting\",\"^F\",\"^6\",\"^G\",9,\"^14\",[\"^ \",\"^S\",false,\"^W\",4,\"^T\",[\"^N\",[[\"^39\"],[\"^39\",\"^2>\"],[\"~$x\",\"~$y\",\"~$z\"],[\"~$x\",\"~$y\",\"~$z\",\"~$a\"]]],\"^M\",[\"^N\",[[\"^39\"],[\"^39\",\"^2>\"],[\"~$x\",\"~$y\",\"~$z\"],[\"~$x\",\"~$y\",\"~$z\",\"~$a\"]]],\"^V\",[\"^N\",[null,null,null,null]]],\"^H\",\"stroke()\",\"^I\",3,\"^J\",true,\"^K\",4014,\"^L\",4014,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^39\"],[\"^39\",\"^2>\"],[\"~$x\",\"~$y\",\"~$z\"],[\"~$x\",\"~$y\",\"~$z\",\"~$a\"]]]]],\"^Q\",\"Sets the color used to draw lines and borders around shapes. This\\n  color is either specified in terms of the RGB or HSB color depending\\n  on the current color-mode (the default color space is RGB, with\\n  each value in the range from 0 to 255).\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/stroke\",\"^S\",false,\"^E\",\"Setting\",\"^F\",\"quil/core.cljc\",\"^G\",9,\"^14\",[\"^ \",\"^S\",false,\"^W\",4,\"^T\",[\"^N\",[[\"^39\"],[\"^39\",\"^2>\"],[\"~$x\",\"~$y\",\"~$z\"],[\"~$x\",\"~$y\",\"~$z\",\"~$a\"]]],\"^M\",[\"^N\",[[\"^39\"],[\"^39\",\"^2>\"],[\"~$x\",\"~$y\",\"~$z\"],[\"~$x\",\"~$y\",\"~$z\",\"~$a\"]]],\"^V\",[\"^N\",[null,null,null,null]]],\"^H\",\"stroke()\",\"^T\",[\"^N\",[[\"^39\"],[\"^39\",\"^2>\"],[\"~$x\",\"~$y\",\"~$z\"],[\"~$x\",\"~$y\",\"~$z\",\"~$a\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null,null,null]],\"^I\",1,\"^J\",true,\"^K\",4008,\"^L\",4014,\"^W\",4,\"^X\",true,\"^M\",[\"^N\",[[\"^39\"],[\"^39\",\"^2>\"],[\"~$x\",\"~$y\",\"~$z\"],[\"~$x\",\"~$y\",\"~$z\",\"~$a\"]]],\"^Q\",\"Sets the color used to draw lines and borders around shapes. This\\n  color is either specified in terms of the RGB or HSB color depending\\n  on the current color-mode (the default color space is RGB, with\\n  each value in the range from 0 to 255).\"],\"~$mouse-pressed?\",[\"^ \",\"^A\",\"Input\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Input\",\"^D\",\"1.0\",\"^E\",\"Mouse\",\"^F\",\"^6\",\"^G\",17,\"^H\",\"mousePressed\",\"^I\",3,\"^J\",true,\"^K\",2605,\"^L\",2605,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Variable storing if a mouse button is pressed. The value of the\\n  system variable mousePressed is true if a mouse button is pressed\\n  and false if a button is not pressed.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/mouse-pressed?\",\"^S\",false,\"^E\",\"Mouse\",\"^F\",\"quil/core.cljc\",\"^G\",17,\"^H\",\"mousePressed\",\"^T\",[\"^N\",[[]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",2599,\"^L\",2605,\"^W\",0,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Variable storing if a mouse button is pressed. The value of the\\n  system variable mousePressed is true if a mouse button is pressed\\n  and false if a button is not pressed.\"],\"~$key-pressed?\",[\"^ \",\"^A\",\"Input\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Input\",\"^D\",\"1.0\",\"^E\",\"Keyboard\",\"^F\",\"^6\",\"^G\",15,\"^H\",\"keyPressed\",\"^I\",3,\"^J\",true,\"^K\",2217,\"^L\",2217,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"true if any key is currently pressed, false otherwise.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/key-pressed?\",\"^S\",false,\"^E\",\"Keyboard\",\"^F\",\"quil/core.cljc\",\"^G\",15,\"^H\",\"keyPressed\",\"^T\",[\"^N\",[[]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",2211,\"^L\",2217,\"^W\",0,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"true if any key is currently pressed, false otherwise.\"],\"~$quadratic-vertex\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"2.0\",\"^E\",\"Vertex\",\"^F\",\"^6\",\"^G\",19,\"^14\",[\"^ \",\"^S\",false,\"^W\",6,\"^T\",[\"^N\",[[\"~$cx\",\"~$cy\",\"~$x3\",\"~$y3\"],[\"^6:\",\"^6;\",\"~$cz\",\"^6<\",\"^6=\",\"~$z3\"]]],\"^M\",[\"^N\",[[\"^6:\",\"^6;\",\"^6<\",\"^6=\"],[\"^6:\",\"^6;\",\"^6>\",\"^6<\",\"^6=\",\"^6?\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"quadraticVertex()\",\"^I\",3,\"^J\",true,\"^K\",3142,\"^L\",3142,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^6:\",\"^6;\",\"^6<\",\"^6=\"],[\"^6:\",\"^6;\",\"^6>\",\"^6<\",\"^6=\",\"^6?\"]]]]],\"^Q\",\"Specifies vertex coordinates for quadratic Bezier curves. Each call to\\n  quadratic-vertex defines the position of one control points and one\\n  anchor point of a Bezier curve, adding a new segment to a line or shape.\\n  The first time quadratic-vertex is used within a begin-shape call, it\\n  must be prefaced with a call to vertex to set the first anchor point.\\n  This function must be used between begin-shape and end-shape and only\\n  when there is no MODE parameter specified to begin-shape. Using the 3D\\n  version requires rendering with :p3d.\"],\"^D\",\"2.0\",\"^5\",\"~$quil.core/quadratic-vertex\",\"^S\",false,\"^E\",\"Vertex\",\"^F\",\"quil/core.cljc\",\"^G\",19,\"^14\",[\"^ \",\"^S\",false,\"^W\",6,\"^T\",[\"^N\",[[\"^6:\",\"^6;\",\"^6<\",\"^6=\"],[\"^6:\",\"^6;\",\"^6>\",\"^6<\",\"^6=\",\"^6?\"]]],\"^M\",[\"^N\",[[\"^6:\",\"^6;\",\"^6<\",\"^6=\"],[\"^6:\",\"^6;\",\"^6>\",\"^6<\",\"^6=\",\"^6?\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"quadraticVertex()\",\"^T\",[\"^N\",[[\"^6:\",\"^6;\",\"^6<\",\"^6=\"],[\"^6:\",\"^6;\",\"^6>\",\"^6<\",\"^6=\",\"^6?\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",3136,\"^L\",3142,\"^W\",6,\"^X\",true,\"^M\",[\"^N\",[[\"^6:\",\"^6;\",\"^6<\",\"^6=\"],[\"^6:\",\"^6;\",\"^6>\",\"^6<\",\"^6=\",\"^6?\"]]],\"^Q\",\"Specifies vertex coordinates for quadratic Bezier curves. Each call to\\n  quadratic-vertex defines the position of one control points and one\\n  anchor point of a Bezier curve, adding a new segment to a line or shape.\\n  The first time quadratic-vertex is used within a begin-shape call, it\\n  must be prefaced with a call to vertex to set the first anchor point.\\n  This function must be used between begin-shape and end-shape and only\\n  when there is no MODE parameter specified to begin-shape. Using the 3D\\n  version requires rendering with :p3d.\"],\"~$texture-wrap-modes\",[\"^ \",\"^5\",\"~$quil.core/texture-wrap-modes\",\"^F\",\"quil/core.cljc\",\"^K\",45,\"^I\",1,\"^L\",70,\"^G\",20,\"^C\",[\"^ \",\"^F\",\"^6\",\"^K\",70,\"^I\",2,\"^L\",70,\"^G\",20]],\"~$noise-seed\",[\"^ \",\"^A\",\"Math\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Math\",\"^D\",\"1.0\",\"^E\",\"Random\",\"^F\",\"^6\",\"^G\",13,\"^H\",\"noiseSeed()\",\"^I\",3,\"^J\",true,\"^K\",2743,\"^L\",2743,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^2P\"]]]]],\"^Q\",\"Sets the seed value for noise. By default, noise produces different\\n  results each time the program is run. Set the value parameter to a\\n  constant to return the same pseudo-random numbers each time the\\n  software is run.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/noise-seed\",\"^S\",false,\"^E\",\"Random\",\"^F\",\"quil/core.cljc\",\"^G\",13,\"^H\",\"noiseSeed()\",\"^T\",[\"^N\",[[\"^2P\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",2737,\"^L\",2743,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^2P\"]]]]],\"^Q\",\"Sets the seed value for noise. By default, noise produces different\\n  results each time the program is run. Set the value parameter to a\\n  constant to return the same pseudo-random numbers each time the\\n  software is run.\"],\"~$apply-matrix\",[\"^ \",\"^A\",\"Transform\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Transform\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^6\",\"^G\",15,\"^H\",\"applyMatrix()\",\"^I\",3,\"^J\",true,\"^K\",396,\"^L\",396,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$n00\",\"~$n01\",\"~$n02\",\"~$n03\",\"~$n10\",\"~$n11\",\"~$n12\",\"~$n13\",\"~$n20\",\"~$n21\",\"~$n22\",\"~$n23\",\"~$n30\",\"~$n31\",\"~$n32\",\"~$n33\"]]]]],\"^Q\",\"Multiplies the current matrix by the one specified through the\\n  parameters. This is very slow because it will try to calculate the\\n  inverse of the transform, so avoid it whenever possible. The\\n  equivalent function in OpenGL is glMultMatrix().\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/apply-matrix\",\"^S\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^G\",15,\"^H\",\"applyMatrix()\",\"^T\",[\"^N\",[[\"^6F\",\"^6G\",\"^6H\",\"^6I\",\"^6J\",\"^6K\",\"^6L\",\"^6M\",\"^6N\",\"^6O\",\"^6P\",\"^6Q\",\"^6R\",\"^6S\",\"^6T\",\"^6U\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",390,\"^L\",396,\"^W\",16,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^6F\",\"^6G\",\"^6H\",\"^6I\",\"^6J\",\"^6K\",\"^6L\",\"^6M\",\"^6N\",\"^6O\",\"^6P\",\"^6Q\",\"^6R\",\"^6S\",\"^6T\",\"^6U\"]]]]],\"^Q\",\"Multiplies the current matrix by the one specified through the\\n  parameters. This is very slow because it will try to calculate the\\n  inverse of the transform, so avoid it whenever possible. The\\n  equivalent function in OpenGL is glMultMatrix().\"],\"~$copy\",[\"^ \",\"^A\",\"Image\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Image\",\"^D\",\"1.0\",\"^E\",\"Pixels\",\"^F\",\"^6\",\"^G\",7,\"^14\",[\"^ \",\"^S\",false,\"^W\",4,\"^T\",[\"^N\",[[[\"~$sx\",\"~$sy\",\"~$swidth\",\"~$sheight\"],[\"^1A\",\"^1B\",\"^1C\",\"^1D\"]],[\"^1E\",[\"^6X\",\"^6Y\",\"^6Z\",\"^6[\"],[\"^1A\",\"^1B\",\"^1C\",\"^1D\"]],[\"^1E\",\"^1F\",[\"^6X\",\"^6Y\",\"^6Z\",\"^6[\"],[\"^1A\",\"^1B\",\"^1C\",\"^1D\"]]]],\"^M\",[\"^N\",[[[\"^6X\",\"^6Y\",\"^6Z\",\"^6[\"],[\"^1A\",\"^1B\",\"^1C\",\"^1D\"]],[\"^1E\",[\"^6X\",\"^6Y\",\"^6Z\",\"^6[\"],[\"^1A\",\"^1B\",\"^1C\",\"^1D\"]],[\"^1E\",\"^1F\",[\"^6X\",\"^6Y\",\"^6Z\",\"^6[\"],[\"^1A\",\"^1B\",\"^1C\",\"^1D\"]]]],\"^V\",[\"^N\",[null,null,null]]],\"^H\",\"copy()\",\"^I\",3,\"^J\",true,\"^K\",1112,\"^L\",1112,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[[\"^6X\",\"^6Y\",\"^6Z\",\"^6[\"],[\"^1A\",\"^1B\",\"^1C\",\"^1D\"]],[\"^1E\",[\"^6X\",\"^6Y\",\"^6Z\",\"^6[\"],[\"^1A\",\"^1B\",\"^1C\",\"^1D\"]],[\"^1E\",\"^1F\",[\"^6X\",\"^6Y\",\"^6Z\",\"^6[\"],[\"^1A\",\"^1B\",\"^1C\",\"^1D\"]]]]]],\"^Q\",\"Copies a region of pixels from the one image to another. If src-img\\n  is not specified it defaults to current-graphics. If dest-img is not\\n  specified - it defaults to current-graphics. If the source\\n  and destination regions aren't the same size, it will automatically\\n  resize the source pixels to fit the specified target region. No\\n  alpha information is used in the process, however if the source\\n  image has an alpha channel set, it will be copied as well. \"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/copy\",\"^S\",false,\"^E\",\"Pixels\",\"^F\",\"quil/core.cljc\",\"^G\",7,\"^14\",[\"^ \",\"^S\",false,\"^W\",4,\"^T\",[\"^N\",[[[\"^6X\",\"^6Y\",\"^6Z\",\"^6[\"],[\"^1A\",\"^1B\",\"^1C\",\"^1D\"]],[\"^1E\",[\"^6X\",\"^6Y\",\"^6Z\",\"^6[\"],[\"^1A\",\"^1B\",\"^1C\",\"^1D\"]],[\"^1E\",\"^1F\",[\"^6X\",\"^6Y\",\"^6Z\",\"^6[\"],[\"^1A\",\"^1B\",\"^1C\",\"^1D\"]]]],\"^M\",[\"^N\",[[[\"^6X\",\"^6Y\",\"^6Z\",\"^6[\"],[\"^1A\",\"^1B\",\"^1C\",\"^1D\"]],[\"^1E\",[\"^6X\",\"^6Y\",\"^6Z\",\"^6[\"],[\"^1A\",\"^1B\",\"^1C\",\"^1D\"]],[\"^1E\",\"^1F\",[\"^6X\",\"^6Y\",\"^6Z\",\"^6[\"],[\"^1A\",\"^1B\",\"^1C\",\"^1D\"]]]],\"^V\",[\"^N\",[null,null,null]]],\"^H\",\"copy()\",\"^T\",[\"^N\",[[[\"^6X\",\"^6Y\",\"^6Z\",\"^6[\"],[\"^1A\",\"^1B\",\"^1C\",\"^1D\"]],[\"^1E\",[\"^6X\",\"^6Y\",\"^6Z\",\"^6[\"],[\"^1A\",\"^1B\",\"^1C\",\"^1D\"]],[\"^1E\",\"^1F\",[\"^6X\",\"^6Y\",\"^6Z\",\"^6[\"],[\"^1A\",\"^1B\",\"^1C\",\"^1D\"]]]],\"^U\",null,\"^V\",[\"^N\",[null,null,null]],\"^I\",1,\"^J\",true,\"^K\",1106,\"^L\",1112,\"^W\",4,\"^X\",true,\"^M\",[\"^N\",[[[\"^6X\",\"^6Y\",\"^6Z\",\"^6[\"],[\"^1A\",\"^1B\",\"^1C\",\"^1D\"]],[\"^1E\",[\"^6X\",\"^6Y\",\"^6Z\",\"^6[\"],[\"^1A\",\"^1B\",\"^1C\",\"^1D\"]],[\"^1E\",\"^1F\",[\"^6X\",\"^6Y\",\"^6Z\",\"^6[\"],[\"^1A\",\"^1B\",\"^1C\",\"^1D\"]]]],\"^Q\",\"Copies a region of pixels from the one image to another. If src-img\\n  is not specified it defaults to current-graphics. If dest-img is not\\n  specified - it defaults to current-graphics. If the source\\n  and destination regions aren't the same size, it will automatically\\n  resize the source pixels to fit the specified target region. No\\n  alpha information is used in the process, however if the source\\n  image has an alpha channel set, it will be copied as well. \"],\"~$begin-shape\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"Vertex\",\"^F\",\"^6\",\"^G\",14,\"^14\",[\"^ \",\"^S\",false,\"^W\",1,\"^T\",[\"^N\",[[],[\"^17\"]]],\"^M\",[\"^N\",[[],[\"^17\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"beginShape()\",\"^I\",3,\"^J\",true,\"^K\",635,\"^L\",635,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[],[\"^17\"]]]]],\"^Q\",\"Enables the creation of complex forms. begin-shape begins recording\\n  vertices for a shape and end-shape stops recording. Use the mode\\n  keyword to specify which shape create from the provided\\n  vertices. With no mode specified, the shape can be any irregular\\n  polygon.\\n\\n  The available mode keywords are :points, :lines, :triangles,\\n                                  :triangle-fan, :triangle-strip,\\n                                  :quads, :quad-strip.\\n\\n  After calling the begin-shape function, a series of vertex commands\\n  must follow. To stop drawing the shape, call end-shape. The vertex\\n  function with two parameters specifies a position in 2D and the\\n  vertex function with three parameters specifies a position in\\n  3D. Each shape will be outlined with the current stroke color and\\n  filled with the fill color.\\n\\n  Transformations such as translate, rotate, and scale do not work\\n  within begin-shape. It is also not possible to use other shapes,\\n  such as ellipse or rect within begin-shape.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/begin-shape\",\"^S\",false,\"^E\",\"Vertex\",\"^F\",\"quil/core.cljc\",\"^G\",14,\"^14\",[\"^ \",\"^S\",false,\"^W\",1,\"^T\",[\"^N\",[[],[\"^17\"]]],\"^M\",[\"^N\",[[],[\"^17\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"beginShape()\",\"^T\",[\"^N\",[[],[\"^17\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",629,\"^L\",635,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[[],[\"^17\"]]],\"^Q\",\"Enables the creation of complex forms. begin-shape begins recording\\n  vertices for a shape and end-shape stops recording. Use the mode\\n  keyword to specify which shape create from the provided\\n  vertices. With no mode specified, the shape can be any irregular\\n  polygon.\\n\\n  The available mode keywords are :points, :lines, :triangles,\\n                                  :triangle-fan, :triangle-strip,\\n                                  :quads, :quad-strip.\\n\\n  After calling the begin-shape function, a series of vertex commands\\n  must follow. To stop drawing the shape, call end-shape. The vertex\\n  function with two parameters specifies a position in 2D and the\\n  vertex function with three parameters specifies a position in\\n  3D. Each shape will be outlined with the current stroke color and\\n  filled with the fill color.\\n\\n  Transformations such as translate, rotate, and scale do not work\\n  within begin-shape. It is also not possible to use other shapes,\\n  such as ellipse or rect within begin-shape.\"],\"~$set-state!\",[\"^ \",\"^A\",\"State\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"State\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^6\",\"^G\",13,\"^14\",[\"^ \",\"^S\",true,\"^W\",0,\"^T\",[[\"^N\",[\"~$state-vals\"]]],\"^M\",[\"^N\",[[\"~$&\",\"^74\"]]],\"^V\",[\"^N\",[null]]],\"^I\",3,\"^J\",true,\"^K\",236,\"^L\",236,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$&\",\"^74\"]]]]],\"^Q\",\"Set sketch-specific state. May only be called once (ideally in the\\n  setup fn).  Subsequent calls have no effect.\\n\\n  Example:\\n  (set-state! :foo 1 :bar (atom true) :baz (/ (width) 2))\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/set-state!\",\"^S\",true,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^G\",13,\"^14\",[\"^ \",\"^S\",true,\"^W\",0,\"^T\",[[\"^N\",[\"^74\"]]],\"^M\",[\"^N\",[[\"~$&\",\"^74\"]]],\"^V\",[\"^N\",[null]]],\"^T\",[[\"^N\",[\"^74\"]]],\"^U\",null,\"^V\",[\"^N\",[null]],\"^I\",1,\"^J\",true,\"^K\",231,\"^L\",236,\"^W\",0,\"^X\",true,\"^M\",[\"^N\",[[\"~$&\",\"^74\"]]],\"^Q\",\"Set sketch-specific state. May only be called once (ideally in the\\n  setup fn).  Subsequent calls have no effect.\\n\\n  Example:\\n  (set-state! :foo 1 :bar (atom true) :baz (/ (width) 2))\"],\"~$stroke-join\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"Attributes\",\"^F\",\"^6\",\"^G\",14,\"^H\",\"strokeJoin()\",\"^I\",3,\"^J\",true,\"^K\",4052,\"^L\",4052,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$join-mode\"]]]]],\"^Q\",\"Sets the style of the joints which connect line\\n  segments. These joints are either mitered, beveled, or rounded and\\n  specified with the corresponding parameters :miter, :bevel, and\\n  :round. The default joint is :miter.\\n\\n  This function is not available with the :p2d, :p3d, or :opengl\\n  renderers.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/stroke-join\",\"^S\",false,\"^E\",\"Attributes\",\"^F\",\"quil/core.cljc\",\"^G\",14,\"^H\",\"strokeJoin()\",\"^T\",[\"^N\",[[\"^77\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",4046,\"^L\",4052,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^77\"]]]]],\"^Q\",\"Sets the style of the joints which connect line\\n  segments. These joints are either mitered, beveled, or rounded and\\n  specified with the corresponding parameters :miter, :bevel, and\\n  :round. The default joint is :miter.\\n\\n  This function is not available with the :p2d, :p3d, or :opengl\\n  renderers.\"],\"~$cos\",[\"^ \",\"^A\",\"Math\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Math\",\"^D\",\"1.0\",\"^E\",\"Trigonometry\",\"^F\",\"^6\",\"^G\",6,\"^H\",\"cos()\",\"^I\",3,\"^J\",false,\"^K\",1138,\"^L\",1138,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^P\"]]]]],\"^Q\",\"Calculates the cosine of an angle. This function expects the values\\n  of the angle parameter to be provided in radians (values from 0 to\\n  Math/PI*2). Values are returned in the range -1 to 1.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/cos\",\"^S\",false,\"^E\",\"Trigonometry\",\"^F\",\"quil/core.cljc\",\"^G\",6,\"^H\",\"cos()\",\"^T\",[\"^N\",[[\"^P\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",false,\"^K\",1132,\"^L\",1138,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^P\"]]]]],\"^Q\",\"Calculates the cosine of an angle. This function expects the values\\n  of the angle parameter to be provided in radians (values from 0 to\\n  Math/PI*2). Values are returned in the range -1 to 1.\"],\"~$curve-tightness\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"Curves\",\"^F\",\"^6\",\"^G\",18,\"^H\",\"curveTightness()\",\"^I\",3,\"^J\",true,\"^K\",1389,\"^L\",1389,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$ti\"]]]]],\"^Q\",\"Modifies the quality of forms created with curve and\\n  curve-vertex. The parameter squishy determines how the curve fits\\n  to the vertex points. The value 0.0 is the default value for\\n  squishy (this value defines the curves to be Catmull-Rom splines)\\n  and the value 1.0 connects all the points with straight\\n  lines. Values within the range -5.0 and 5.0 will deform the curves\\n  but will leave them recognizable and as values increase in\\n  magnitude, they will continue to deform.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/curve-tightness\",\"^S\",false,\"^E\",\"Curves\",\"^F\",\"quil/core.cljc\",\"^G\",18,\"^H\",\"curveTightness()\",\"^T\",[\"^N\",[[\"^7<\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",1383,\"^L\",1389,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^7<\"]]]]],\"^Q\",\"Modifies the quality of forms created with curve and\\n  curve-vertex. The parameter squishy determines how the curve fits\\n  to the vertex points. The value 0.0 is the default value for\\n  squishy (this value defines the curves to be Catmull-Rom splines)\\n  and the value 1.0 connects all the points with straight\\n  lines. Values within the range -5.0 and 5.0 will deform the curves\\n  but will leave them recognizable and as values increase in\\n  magnitude, they will continue to deform.\"],\"~$tan\",[\"^ \",\"^A\",\"Math\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Math\",\"^D\",\"1.0\",\"^E\",\"Trigonometry\",\"^F\",\"^6\",\"^G\",6,\"^H\",\"tan()\",\"^I\",3,\"^J\",false,\"^K\",4084,\"^L\",4084,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^P\"]]]]],\"^Q\",\"Calculates the ratio of the sine and cosine of an angle. This\\n  function expects the values of the angle parameter to be provided in\\n  radians (values from 0 to PI*2). Values are returned in the range\\n  infinity to -infinity.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/tan\",\"^S\",false,\"^E\",\"Trigonometry\",\"^F\",\"quil/core.cljc\",\"^G\",6,\"^H\",\"tan()\",\"^T\",[\"^N\",[[\"^P\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",false,\"^K\",4078,\"^L\",4084,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^P\"]]]]],\"^Q\",\"Calculates the ratio of the sine and cosine of an angle. This\\n  function expects the values of the angle parameter to be provided in\\n  radians (values from 0 to PI*2). Values are returned in the range\\n  infinity to -infinity.\"],\"~$triangle\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"2D Primitives\",\"^F\",\"^6\",\"^G\",11,\"^H\",\"triangle()\",\"^I\",3,\"^J\",true,\"^K\",4481,\"^L\",4481,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^43\",\"^44\",\"^45\",\"^46\",\"^6<\",\"^6=\"]]]]],\"^Q\",\"A triangle is a plane created by connecting three points. The first\\n  two arguments specify the first point, the middle two arguments\\n  specify the second point, and the last two arguments specify the\\n  third point.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/triangle\",\"^S\",false,\"^E\",\"2D Primitives\",\"^F\",\"quil/core.cljc\",\"^G\",11,\"^H\",\"triangle()\",\"^T\",[\"^N\",[[\"^43\",\"^44\",\"^45\",\"^46\",\"^6<\",\"^6=\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",4475,\"^L\",4481,\"^W\",6,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^43\",\"^44\",\"^45\",\"^46\",\"^6<\",\"^6=\"]]]]],\"^Q\",\"A triangle is a plane created by connecting three points. The first\\n  two arguments specify the first point, the middle two arguments\\n  specify the second point, and the last two arguments specify the\\n  third point.\"],\"~$emissive\",[\"^ \",\"^A\",\"Lights, Camera\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Lights, Camera\",\"^D\",\"1.0\",\"^E\",\"Material Properties\",\"^F\",\"^6\",\"^G\",11,\"^14\",[\"^ \",\"^S\",false,\"^W\",3,\"^T\",[\"^N\",[[\"~$c\"],[\"~$r\",\"~$g\",\"~$b\"]]],\"^M\",[\"^N\",[[\"~$c\"],[\"~$r\",\"~$g\",\"~$b\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"emissive()\",\"^I\",3,\"^J\",true,\"^K\",1594,\"^L\",1594,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$c\"],[\"~$r\",\"~$g\",\"~$b\"]]]]],\"^Q\",\"Sets the emissive color of the material used for drawing shapes\\n  drawn to the screen. Used in combination with ambient, specular, and\\n  shininess in setting the material properties of shapes.\\n\\n  If passed one arg - it is assumed to be an int (i.e. a color),\\n  multiple args are converted to floats.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/emissive\",\"^S\",false,\"^E\",\"Material Properties\",\"^F\",\"quil/core.cljc\",\"^G\",11,\"^14\",[\"^ \",\"^S\",false,\"^W\",3,\"^T\",[\"^N\",[[\"~$c\"],[\"~$r\",\"~$g\",\"~$b\"]]],\"^M\",[\"^N\",[[\"~$c\"],[\"~$r\",\"~$g\",\"~$b\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"emissive()\",\"^T\",[\"^N\",[[\"~$c\"],[\"~$r\",\"~$g\",\"~$b\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",1588,\"^L\",1594,\"^W\",3,\"^X\",true,\"^M\",[\"^N\",[[\"~$c\"],[\"~$r\",\"~$g\",\"~$b\"]]],\"^Q\",\"Sets the emissive color of the material used for drawing shapes\\n  drawn to the screen. Used in combination with ambient, specular, and\\n  shininess in setting the material properties of shapes.\\n\\n  If passed one arg - it is assumed to be an int (i.e. a color),\\n  multiple args are converted to floats.\"],\"~$clear-no-fill-cljs\",[\"^ \",\"^B\",null,\"^C\",[\"^ \",\"^F\",\"^6\",\"^K\",1693,\"^I\",11,\"^L\",1693,\"^G\",29,\"^3K\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^1M\"]]]]],\"^Q\",\"Sets custom property on graphcs object indicating that it has\\n  fill color.\"],\"^3K\",true,\"^5\",\"~$quil.core/clear-no-fill-cljs\",\"^S\",false,\"^F\",\"quil/core.cljc\",\"^G\",29,\"^T\",[\"^N\",[[\"^1M\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",4,\"^K\",1693,\"^L\",1693,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^1M\"]]]]],\"^Q\",\"Sets custom property on graphcs object indicating that it has\\n  fill color.\"],\"~$sketch\",[\"^ \",\"^A\",\"Environment\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Environment\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^6\",\"^G\",9,\"^14\",[\"^ \",\"^S\",true,\"^W\",0,\"^T\",[[\"^N\",[\"~$opts\"]]],\"^M\",[\"^N\",[[\"~$&\",\"^7G\"]]],\"^V\",[\"^N\",[null]]],\"^I\",3,\"^J\",false,\"^K\",4696,\"^L\",4696,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$&\",\"^7G\"]]]]],\"^Q\",\"Create and start a new visualisation applet. Can be used to create\\n  new sketches programmatically. See documentation for 'defsketch' for\\n  list of available options.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/sketch\",\"^S\",true,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^G\",9,\"^14\",[\"^ \",\"^S\",true,\"^W\",0,\"^T\",[[\"^N\",[\"^7G\"]]],\"^M\",[\"^N\",[[\"~$&\",\"^7G\"]]],\"^V\",[\"^N\",[null]]],\"^T\",[[\"^N\",[\"^7G\"]]],\"^U\",null,\"^V\",[\"^N\",[null]],\"^I\",1,\"^J\",false,\"^K\",4692,\"^L\",4696,\"^W\",0,\"^X\",true,\"^M\",[\"^N\",[[\"~$&\",\"^7G\"]]],\"^Q\",\"Create and start a new visualisation applet. Can be used to create\\n  new sketches programmatically. See documentation for 'defsketch' for\\n  list of available options.\"],\"~$color\",[\"^ \",\"^A\",\"Color\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Color\",\"^D\",\"1.0\",\"^E\",\"Creating & Reading\",\"^F\",\"^6\",\"^G\",8,\"^14\",[\"^ \",\"^S\",false,\"^W\",4,\"^T\",[\"^N\",[[\"^2=\"],[\"^2=\",\"^2>\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^M\",[\"^N\",[[\"^2=\"],[\"^2=\",\"^2>\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^V\",[\"^N\",[null,null,null,null]]],\"^H\",\"color()\",\"^I\",3,\"^J\",true,\"^K\",1019,\"^L\",1019,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^2=\"],[\"^2=\",\"^2>\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]]]],\"^Q\",\"Creates an integer representation of a color The parameters are\\n  interpreted as RGB or HSB values depending on the current\\n  color-mode. The default mode is RGB values from 0 to 255 and\\n  therefore, the function call (color 255 204 0) will return a bright\\n  yellow. Args are cast to floats.\\n\\n  r - red or hue value\\n  g - green or saturation value\\n  b - blue or brightness value\\n  a - alpha value\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/color\",\"^S\",false,\"^E\",\"Creating & Reading\",\"^F\",\"quil/core.cljc\",\"^G\",8,\"^14\",[\"^ \",\"^S\",false,\"^W\",4,\"^T\",[\"^N\",[[\"^2=\"],[\"^2=\",\"^2>\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^M\",[\"^N\",[[\"^2=\"],[\"^2=\",\"^2>\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^V\",[\"^N\",[null,null,null,null]]],\"^H\",\"color()\",\"^T\",[\"^N\",[[\"^2=\"],[\"^2=\",\"^2>\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null,null,null]],\"^I\",1,\"^J\",true,\"^K\",1013,\"^L\",1019,\"^W\",4,\"^X\",true,\"^M\",[\"^N\",[[\"^2=\"],[\"^2=\",\"^2>\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^Q\",\"Creates an integer representation of a color The parameters are\\n  interpreted as RGB or HSB values depending on the current\\n  color-mode. The default mode is RGB values from 0 to 255 and\\n  therefore, the function call (color 255 204 0) will return a bright\\n  yellow. Args are cast to floats.\\n\\n  r - red or hue value\\n  g - green or saturation value\\n  b - blue or brightness value\\n  a - alpha value\"],\"~$arc\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"2D Primitives\",\"^F\",\"^6\",\"^G\",6,\"^H\",\"arc()\",\"^I\",3,\"^J\",true,\"^K\",422,\"^L\",422,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$x\",\"~$y\",\"^1?\",\"^1@\",\"~$start\",\"~$stop\"]]]]],\"^Q\",\"Draws an arc in the display window. Arcs are drawn along the outer\\n  edge of an ellipse defined by the x, y, width and height\\n  parameters. The origin or the arc's ellipse may be changed with the\\n  ellipse-mode function. The start and stop parameters specify the\\n  angles at which to draw the arc. The mode is either :open, :chord or :pie.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/arc\",\"^S\",false,\"^E\",\"2D Primitives\",\"^F\",\"quil/core.cljc\",\"^G\",6,\"^H\",\"arc()\",\"^T\",[\"^N\",[[\"~$x\",\"~$y\",\"^1?\",\"^1@\",\"^7L\",\"^7M\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",416,\"^L\",422,\"^W\",6,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$x\",\"~$y\",\"^1?\",\"^1@\",\"^7L\",\"^7M\"]]]]],\"^Q\",\"Draws an arc in the display window. Arcs are drawn along the outer\\n  edge of an ellipse defined by the x, y, width and height\\n  parameters. The origin or the arc's ellipse may be changed with the\\n  ellipse-mode function. The start and stop parameters specify the\\n  angles at which to draw the arc. The mode is either :open, :chord or :pie.\"],\"~$text-align\",[\"^ \",\"^A\",\"Typography\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Typography\",\"^D\",\"1.0\",\"^E\",\"Attributes\",\"^F\",\"^6\",\"^G\",13,\"^14\",[\"^ \",\"^S\",false,\"^W\",2,\"^T\",[\"^N\",[[\"~$align\"],[\"~$align-x\",\"~$align-y\"]]],\"^M\",[\"^N\",[[\"^7P\"],[\"^7Q\",\"^7R\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"textAlign()\",\"^I\",3,\"^J\",true,\"^K\",4176,\"^L\",4176,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^7P\"],[\"^7Q\",\"^7R\"]]]]],\"^Q\",\"Sets the current alignment for drawing text. Available modes are:\\n\\n  horizontal - :left, :center, and :right\\n  vertical   - :top, :bottom, :center, and :baseline\\n\\n  An optional second parameter specifies the vertical alignment\\n  mode. :baseline is the default. The :top and :center parameters are\\n  straightforward. The :bottom parameter offsets the line based on the\\n  current text-descent. For multiple lines, the final line will be\\n  aligned to the bottom, with the previous lines appearing above it.\\n\\n  When using text with width and height parameters, :baseline is\\n  ignored, and treated as :top. (Otherwise, text would by default draw\\n  outside the box, since :baseline is the default setting. :baseline is\\n  not a useful drawing mode for text drawn in a rectangle.)\\n\\n  The vertical alignment is based on the value of text-ascent, which\\n  many fonts do not specify correctly. It may be necessary to use a\\n  hack and offset by a few pixels by hand so that the offset looks\\n  correct. To do this as less of a hack, use some percentage of\\n  text-ascent or text-descent so that the hack works even if you\\n  change the size of the font.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/text-align\",\"^S\",false,\"^E\",\"Attributes\",\"^F\",\"quil/core.cljc\",\"^G\",13,\"^14\",[\"^ \",\"^S\",false,\"^W\",2,\"^T\",[\"^N\",[[\"^7P\"],[\"^7Q\",\"^7R\"]]],\"^M\",[\"^N\",[[\"^7P\"],[\"^7Q\",\"^7R\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"textAlign()\",\"^T\",[\"^N\",[[\"^7P\"],[\"^7Q\",\"^7R\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",4170,\"^L\",4176,\"^W\",2,\"^X\",true,\"^M\",[\"^N\",[[\"^7P\"],[\"^7Q\",\"^7R\"]]],\"^Q\",\"Sets the current alignment for drawing text. Available modes are:\\n\\n  horizontal - :left, :center, and :right\\n  vertical   - :top, :bottom, :center, and :baseline\\n\\n  An optional second parameter specifies the vertical alignment\\n  mode. :baseline is the default. The :top and :center parameters are\\n  straightforward. The :bottom parameter offsets the line based on the\\n  current text-descent. For multiple lines, the final line will be\\n  aligned to the bottom, with the previous lines appearing above it.\\n\\n  When using text with width and height parameters, :baseline is\\n  ignored, and treated as :top. (Otherwise, text would by default draw\\n  outside the box, since :baseline is the default setting. :baseline is\\n  not a useful drawing mode for text drawn in a rectangle.)\\n\\n  The vertical alignment is based on the value of text-ascent, which\\n  many fonts do not specify correctly. It may be necessary to use a\\n  hack and offset by a few pixels by hand so that the offset looks\\n  correct. To do this as less of a hack, use some percentage of\\n  text-ascent or text-descent so that the hack works even if you\\n  change the size of the font.\"],\"~$text-width\",[\"^ \",\"^A\",\"Typography\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Typography\",\"^D\",\"1.0\",\"^E\",\"Attributes\",\"^F\",\"^6\",\"^G\",13,\"^H\",\"textWidth()\",\"^I\",3,\"^J\",true,\"^K\",4374,\"^L\",4374,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$data\"]]]]],\"^Q\",\"Calculates and returns the width of any text string.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/text-width\",\"^S\",false,\"^E\",\"Attributes\",\"^F\",\"quil/core.cljc\",\"^G\",13,\"^H\",\"textWidth()\",\"^T\",[\"^N\",[[\"^7U\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",4368,\"^L\",4374,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^7U\"]]]]],\"^Q\",\"Calculates and returns the width of any text string.\"],\"~$mouse-x\",[\"^ \",\"^A\",\"Input\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Input\",\"^D\",\"1.0\",\"^E\",\"Mouse\",\"^F\",\"^6\",\"^G\",10,\"^H\",\"mouseX\",\"^I\",3,\"^J\",true,\"^K\",2618,\"^L\",2618,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Current horizontal coordinate of the mouse.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/mouse-x\",\"^S\",false,\"^E\",\"Mouse\",\"^F\",\"quil/core.cljc\",\"^G\",10,\"^H\",\"mouseX\",\"^T\",[\"^N\",[[]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",2612,\"^L\",2618,\"^W\",0,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Current horizontal coordinate of the mouse.\"],\"~$TWO-PI\",[\"^ \",\"^5\",\"~$quil.core/TWO-PI\",\"^F\",\"quil/core.cljc\",\"^K\",80,\"^I\",1,\"^L\",80,\"^G\",12,\"^C\",[\"^ \",\"^F\",\"^6\",\"^K\",80,\"^I\",6,\"^L\",80,\"^G\",12]],\"~$mag\",[\"^ \",\"^A\",\"Math\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Math\",\"^D\",\"1.0\",\"^E\",\"Calculation\",\"^F\",\"^6\",\"^G\",6,\"^14\",[\"^ \",\"^S\",false,\"^W\",3,\"^T\",[\"^N\",[[\"~$a\",\"~$b\"],[\"~$a\",\"~$b\",\"~$c\"]]],\"^M\",[\"^N\",[[\"~$a\",\"~$b\"],[\"~$a\",\"~$b\",\"~$c\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"mag()\",\"^I\",3,\"^J\",false,\"^K\",2441,\"^L\",2441,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$a\",\"~$b\"],[\"~$a\",\"~$b\",\"~$c\"]]]]],\"^Q\",\"Calculates the magnitude (or length) of a vector. A vector is a\\n  direction in space commonly used in computer graphics and linear\\n  algebra. Because it has no start position, the magnitude of a vector\\n  can be thought of as the distance from coordinate (0,0) to its (x,y)\\n  value. Therefore, mag is a shortcut for writing (dist 0 0 x y).\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/mag\",\"^S\",false,\"^E\",\"Calculation\",\"^F\",\"quil/core.cljc\",\"^G\",6,\"^14\",[\"^ \",\"^S\",false,\"^W\",3,\"^T\",[\"^N\",[[\"~$a\",\"~$b\"],[\"~$a\",\"~$b\",\"~$c\"]]],\"^M\",[\"^N\",[[\"~$a\",\"~$b\"],[\"~$a\",\"~$b\",\"~$c\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"mag()\",\"^T\",[\"^N\",[[\"~$a\",\"~$b\"],[\"~$a\",\"~$b\",\"~$c\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",false,\"^K\",2435,\"^L\",2441,\"^W\",3,\"^X\",true,\"^M\",[\"^N\",[[\"~$a\",\"~$b\"],[\"~$a\",\"~$b\",\"~$c\"]]],\"^Q\",\"Calculates the magnitude (or length) of a vector. A vector is a\\n  direction in space commonly used in computer graphics and linear\\n  algebra. Because it has no start position, the magnitude of a vector\\n  can be thought of as the distance from coordinate (0,0) to its (x,y)\\n  value. Therefore, mag is a shortcut for writing (dist 0 0 x y).\"],\"~$exit\",[\"^ \",\"^A\",\"Structure\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Structure\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^6\",\"^G\",7,\"^H\",\"exit()\",\"^I\",3,\"^J\",true,\"^K\",1671,\"^L\",1671,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Quits/stops/exits the program.  Rather than terminating\\n  immediately, exit will cause the sketch to exit after draw has\\n  completed (or after setup completes if called during the setup\\n  method). \"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/exit\",\"^S\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^G\",7,\"^H\",\"exit()\",\"^T\",[\"^N\",[[]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",1665,\"^L\",1671,\"^W\",0,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Quits/stops/exits the program.  Rather than terminating\\n  immediately, exit will cause the sketch to exit after draw has\\n  completed (or after setup completes if called during the setup\\n  method). \"],\"~$map-range\",[\"^ \",\"^A\",\"Math\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Math\",\"^D\",\"1.0\",\"^E\",\"Calculation\",\"^F\",\"^6\",\"^G\",12,\"^H\",\"map()\",\"^I\",3,\"^J\",false,\"^K\",2460,\"^L\",2460,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^2P\",\"~$low1\",\"~$high1\",\"~$low2\",\"~$high2\"]]]]],\"^Q\",\"Re-maps a number from one range to another.\\n\\n  Numbers outside the range are not clamped to 0 and 1, because\\n  out-of-range values are often intentional and useful.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/map-range\",\"^S\",false,\"^E\",\"Calculation\",\"^F\",\"quil/core.cljc\",\"^G\",12,\"^H\",\"map()\",\"^T\",[\"^N\",[[\"^2P\",\"^84\",\"^85\",\"^86\",\"^87\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",false,\"^K\",2454,\"^L\",2460,\"^W\",5,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^2P\",\"^84\",\"^85\",\"^86\",\"^87\"]]]]],\"^Q\",\"Re-maps a number from one range to another.\\n\\n  Numbers outside the range are not clamped to 0 and 1, because\\n  out-of-range values are often intentional and useful.\"],\"~$model-x\",[\"^ \",\"^A\",\"Lights, Camera\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Lights, Camera\",\"^D\",\"1.0\",\"^E\",\"Coordinates\",\"^F\",\"^6\",\"^G\",10,\"^H\",\"modelX()\",\"^I\",3,\"^J\",true,\"^K\",2523,\"^L\",2523,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$x\",\"~$y\",\"~$z\"]]]]],\"^Q\",\"Returns the three-dimensional x, y, z position in model space. This\\n  returns the x value for a given coordinate based on the current set\\n  of transformations (scale, rotate, translate, etc.) The x value can\\n  be used to place an object in space relative to the location of the\\n  original point once the transformations are no longer in use.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/model-x\",\"^S\",false,\"^E\",\"Coordinates\",\"^F\",\"quil/core.cljc\",\"^G\",10,\"^H\",\"modelX()\",\"^T\",[\"^N\",[[\"~$x\",\"~$y\",\"~$z\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",2517,\"^L\",2523,\"^W\",3,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$x\",\"~$y\",\"~$z\"]]]]],\"^Q\",\"Returns the three-dimensional x, y, z position in model space. This\\n  returns the x value for a given coordinate based on the current set\\n  of transformations (scale, rotate, translate, etc.) The x value can\\n  be used to place an object in space relative to the location of the\\n  original point once the transformations are no longer in use.\"],\"~$sqrt\",[\"^ \",\"^A\",\"Math\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Math\",\"^D\",\"1.0\",\"^E\",\"Calculation\",\"^F\",\"^6\",\"^G\",7,\"^H\",\"sqrt()\",\"^I\",3,\"^J\",false,\"^K\",3961,\"^L\",3961,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$a\"]]]]],\"^Q\",\"Calculates the square root of a number. The square root of a number\\n  is always positive, even though there may be a valid negative\\n  root. The square root s of number a is such that (= a (* s s)) . It\\n  is the opposite of squaring.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/sqrt\",\"^S\",false,\"^E\",\"Calculation\",\"^F\",\"quil/core.cljc\",\"^G\",7,\"^H\",\"sqrt()\",\"^T\",[\"^N\",[[\"~$a\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",false,\"^K\",3955,\"^L\",3961,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$a\"]]]]],\"^Q\",\"Calculates the square root of a number. The square root of a number\\n  is always positive, even though there may be a valid negative\\n  root. The square root s of number a is such that (= a (* s s)) . It\\n  is the opposite of squaring.\"],\"~$saturation\",[\"^ \",\"^A\",\"Color\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Color\",\"^D\",\"1.0\",\"^E\",\"Creating & Reading\",\"^F\",\"^6\",\"^G\",13,\"^H\",\"saturation()\",\"^I\",3,\"^J\",true,\"^K\",3512,\"^L\",3512,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$c\"]]]]],\"^Q\",\"Extracts the saturation value from a color.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/saturation\",\"^S\",false,\"^E\",\"Creating & Reading\",\"^F\",\"quil/core.cljc\",\"^G\",13,\"^H\",\"saturation()\",\"^T\",[\"^N\",[[\"~$c\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",3506,\"^L\",3512,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$c\"]]]]],\"^Q\",\"Extracts the saturation value from a color.\"],\"~$prc-print\",[\"^ \",\"^A\",\"Output\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Output\",\"^D\",\"1.0\",\"^E\",\"Text area\",\"^F\",\"^6\",\"^G\",15,\"^I\",6,\"~:require-bindings\",true,\"^K\",170,\"^L\",170,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$msg\"]]]]],\"^Q\",\"Writes to the console area of the Processing environment.\\n  This is often helpful for looking at the data a program is producing.\\n  The companion function println() works like print(), but creates a new line of text for each call to the function.\\n   Individual elements can be separated with quotes (\\\"\\\") and joined with the addition operator (+). \"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/prc-print\",\"^S\",false,\"^E\",\"Text area\",\"^F\",\"quil/core.cljc\",\"^G\",15,\"^T\",[\"^N\",[[\"^8A\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",4,\"^8@\",true,\"^K\",165,\"^L\",170,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^8A\"]]]]],\"^Q\",\"Writes to the console area of the Processing environment.\\n  This is often helpful for looking at the data a program is producing.\\n  The companion function println() works like print(), but creates a new line of text for each call to the function.\\n   Individual elements can be separated with quotes (\\\"\\\") and joined with the addition operator (+). \"],\"~$text-font\",[\"^ \",\"^A\",\"Typography\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Typography\",\"^D\",\"1.0\",\"^E\",\"Loading & Displaying\",\"^F\",\"^6\",\"^G\",12,\"^14\",[\"^ \",\"^S\",false,\"^W\",2,\"^T\",[\"^N\",[[\"~$font\"],[\"^8D\",\"^28\"]]],\"^M\",[\"^N\",[[\"^8D\"],[\"^8D\",\"^28\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"textFont()\",\"^I\",3,\"^J\",true,\"^K\",4241,\"^L\",4241,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^8D\"],[\"^8D\",\"^28\"]]]]],\"^Q\",\"Sets the current font that will be drawn with the text\\n  function. Fonts must be loaded with load-font before it can be\\n  used. This font will be used in all subsequent calls to the text\\n  function. If no size parameter is input, the font will appear at its\\n  original size until it is changed with text-size.\\n\\n  Because fonts are usually bitmaped, you should create fonts at the\\n  sizes that will be used most commonly. Using textFont without the\\n  size parameter will result in the cleanest-looking text.\\n\\n  With the default (JAVA2D) and PDF renderers, it's also possible to\\n  enable the use of native fonts via the command\\n  (hint :enable-native-fonts). This will produce vector text in JAVA2D\\n  sketches and PDF output in cases where the vector data is available:\\n  when the font is still installed, or the font is created via the\\n  create-font fn\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/text-font\",\"^S\",false,\"^E\",\"Loading & Displaying\",\"^F\",\"quil/core.cljc\",\"^G\",12,\"^14\",[\"^ \",\"^S\",false,\"^W\",2,\"^T\",[\"^N\",[[\"^8D\"],[\"^8D\",\"^28\"]]],\"^M\",[\"^N\",[[\"^8D\"],[\"^8D\",\"^28\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"textFont()\",\"^T\",[\"^N\",[[\"^8D\"],[\"^8D\",\"^28\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",4235,\"^L\",4241,\"^W\",2,\"^X\",true,\"^M\",[\"^N\",[[\"^8D\"],[\"^8D\",\"^28\"]]],\"^Q\",\"Sets the current font that will be drawn with the text\\n  function. Fonts must be loaded with load-font before it can be\\n  used. This font will be used in all subsequent calls to the text\\n  function. If no size parameter is input, the font will appear at its\\n  original size until it is changed with text-size.\\n\\n  Because fonts are usually bitmaped, you should create fonts at the\\n  sizes that will be used most commonly. Using textFont without the\\n  size parameter will result in the cleanest-looking text.\\n\\n  With the default (JAVA2D) and PDF renderers, it's also possible to\\n  enable the use of native fonts via the command\\n  (hint :enable-native-fonts). This will produce vector text in JAVA2D\\n  sketches and PDF output in cases where the vector data is available:\\n  when the font is still installed, or the font is created via the\\n  create-font fn\"],\"~$scale\",[\"^ \",\"^A\",\"Transform\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Transform\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^6\",\"^G\",8,\"^14\",[\"^ \",\"^S\",false,\"^W\",3,\"^T\",[\"^N\",[[\"~$s\"],[\"^6X\",\"^6Y\"],[\"^6X\",\"^6Y\",\"~$sz\"]]],\"^M\",[\"^N\",[[\"~$s\"],[\"^6X\",\"^6Y\"],[\"^6X\",\"^6Y\",\"^8G\"]]],\"^V\",[\"^N\",[null,null,null]]],\"^H\",\"scale()\",\"^I\",3,\"^J\",true,\"^K\",3561,\"^L\",3561,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$s\"],[\"^6X\",\"^6Y\"],[\"^6X\",\"^6Y\",\"^8G\"]]]]],\"^Q\",\"Increases or decreases the size of a shape by expanding and\\n  contracting vertices. Objects always scale from their relative\\n  origin to the coordinate system. Scale values are specified as\\n  decimal percentages. For example, the function call (scale 2)\\n  increases the dimension of a shape by 200%. Transformations apply to\\n  everything that happens after and subsequent calls to the function\\n  multiply the effect. For example, calling (scale 2) and then\\n  (scale 1.5) is the same as (scale 3). If scale is called within\\n  draw, the transformation is reset when the loop begins again. Using\\n  this fuction with the z parameter requires specfying :p3d or :opengl\\n  as the renderer. This function can be further controlled by\\n  push-matrix and pop-matrix.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/scale\",\"^S\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^G\",8,\"^14\",[\"^ \",\"^S\",false,\"^W\",3,\"^T\",[\"^N\",[[\"~$s\"],[\"^6X\",\"^6Y\"],[\"^6X\",\"^6Y\",\"^8G\"]]],\"^M\",[\"^N\",[[\"~$s\"],[\"^6X\",\"^6Y\"],[\"^6X\",\"^6Y\",\"^8G\"]]],\"^V\",[\"^N\",[null,null,null]]],\"^H\",\"scale()\",\"^T\",[\"^N\",[[\"~$s\"],[\"^6X\",\"^6Y\"],[\"^6X\",\"^6Y\",\"^8G\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null,null]],\"^I\",1,\"^J\",true,\"^K\",3555,\"^L\",3561,\"^W\",3,\"^X\",true,\"^M\",[\"^N\",[[\"~$s\"],[\"^6X\",\"^6Y\"],[\"^6X\",\"^6Y\",\"^8G\"]]],\"^Q\",\"Increases or decreases the size of a shape by expanding and\\n  contracting vertices. Objects always scale from their relative\\n  origin to the coordinate system. Scale values are specified as\\n  decimal percentages. For example, the function call (scale 2)\\n  increases the dimension of a shape by 200%. Transformations apply to\\n  everything that happens after and subsequent calls to the function\\n  multiply the effect. For example, calling (scale 2) and then\\n  (scale 1.5) is the same as (scale 3). If scale is called within\\n  draw, the transformation is reset when the loop begins again. Using\\n  this fuction with the z parameter requires specfying :p3d or :opengl\\n  as the renderer. This function can be further controlled by\\n  push-matrix and pop-matrix.\"],\"~$defsketch\",[\"^ \",\"^A\",\"Environment\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Environment\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^6\",\"^G\",13,\"^14\",[\"^ \",\"^S\",true,\"^W\",3,\"^T\",[[\"^N\",[\"^1K\",\"^1L\",\"~$app-name\",\"~$options\"]]],\"^M\",[\"^N\",[[\"^1K\",\"^1L\",\"^8J\",\"~$&\",\"^8K\"]]],\"^V\",[\"^N\",[null]]],\"^I\",4,\"^J\",false,\"^K\",4708,\"^1O\",true,\"^L\",4708,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^8J\",\"~$&\",\"^8K\"]]]]],\"^Q\",\"Define and start a sketch and bind it to a var with the symbol\\n  app-name. If any of the options to the various callbacks are\\n  symbols, it wraps them in a call to var to ensure they aren't\\n  inlined and that redefinitions to the original fns are reflected in\\n  the visualisation.\\n\\n  Available options:\\n\\n   :size           - A vector of width and height for the sketch or :fullscreen.\\n                     Defaults to [500 300]. If you're using :fullscreen you may\\n                     want to enable present mode - :features [:present]\\n\\n   :renderer       - Specifies the renderer type. One of :p2d, :p3d, :java2d,\\n                     :opengl, :pdf). Defaults to :java2d. :dxf renderer\\n                     can't be used as sketch renderer. Use begin-raw method\\n                     instead. In clojurescript only :p2d and :p3d renderers\\n                     are supported.\\n\\n   :output-file    - Specifies an output file path. Only used in :pdf mode.\\n                     Not supported in clojurescript.\\n\\n   :title          - A string which will be displayed at the top of\\n                     the sketch window. Not supported in clojurescript.\\n\\n   :features       - A vector of keywords customizing sketch behaviour.\\n                     Supported features:\\n\\n                     :keep-on-top - Sketch window will always be above other\\n                                    windows. Note: some platforms might not\\n                                    support always-on-top windows.\\n                                    Not supported in clojurescript.\\n\\n                     :exit-on-close - Shutdown JVM  when sketch is closed.\\n                                      Not supported in clojurescript.\\n\\n                     :resizable - Makes sketch resizable.\\n                                  Not supported in clojurescript.\\n\\n                     :no-safe-fns - Do not catch and print exceptions thrown\\n                                    inside functions provided to sketch (like\\n                                    draw, mouse-click, key-pressed and\\n                                    other). By default all exceptions thrown\\n                                    inside these functions are catched. This\\n                                    prevents sketch from breaking when bad\\n                                    function was provided and allows you to\\n                                    fix it and reload it on fly. You can\\n                                    disable this behaviour by enabling\\n                                    :no-safe-fns feature.\\n                                    Not supported in clojurescript.\\n\\n                     :present - Switch to present mode (fullscreen without\\n                                borders, OS panels). You may want to use\\n                                this feature together with :size :fullscreen.\\n                                Not supported in clojurescript.\\n\\n                     :no-start - Disables autostart if sketch was created using\\n                                 defsketch macro. To start sketch you have to\\n                                 call function created defsketch.\\n                                 Supported only in clojurescript.\\n\\n                     :global-key-events - Allows a sketch to receive any\\n                                          keyboard event sent to the page,\\n                                          regardless of whether the canvas it is\\n                                          loaded in has focus or not.\\n                                          Supported only in clojurescript.\\n\\n                     Usage example: :features [:keep-on-top :present]\\n\\n   :bgcolor        - Sets background color for unused space in present mode.\\n                     Color is specified in hex format: #XXXXXX.\\n                     Example: :bgcolor \\\"#00FFFF\\\" (cyan background)\\n                     Not supported in clojurescript.\\n\\n   :display        - Sets what display should be used by this sketch.\\n                     Displays are numbered starting from 0. Example: :display 1.\\n                     Not supported in clojurescript.\\n\\n   :setup          - A function to be called once when setting the sketch up.\\n\\n   :draw           - A function to be repeatedly called at most n times per\\n                     second where n is the target frame-rate set for\\n                     the visualisation.\\n\\n   :host           - String id of canvas element or DOM element itself.\\n                     Specifies host for the sketch. Must be specified in sketch,\\n                     may be omitted in defsketch. If ommitted in defsketch,\\n                     :host is set to the name of the sketch. If element with\\n                     specified id is not found on the page and page is empty -\\n                     new canvas element will be created. Used in clojurescript.\\n\\n   :focus-gained   - Called when the sketch gains focus.\\n                     Not supported in clojurescript.\\n\\n   :focus-lost     - Called when the sketch loses focus.\\n                     Not supported in clojurescript.\\n\\n   :mouse-entered  - Called when the mouse enters the sketch window.\\n\\n   :mouse-exited   - Called when the mouse leaves the sketch window\\n\\n   :mouse-pressed  - Called every time a mouse button is pressed.\\n\\n   :mouse-released - Called every time a mouse button is released.\\n\\n   :mouse-clicked  - called once after a mouse button has been pressed\\n                     and then released.\\n\\n   :mouse-moved    - Called every time the mouse moves and a button is\\n                     not pressed.\\n\\n   :mouse-dragged  - Called every time the mouse moves and a button is\\n                     pressed.\\n\\n   :mouse-wheel    - Called every time mouse wheel is rotated.\\n                     Takes 1 argument - wheel rotation, an int.\\n                     Negative values if the mouse wheel was rotated\\n                     up/away from the user, and positive values\\n                     if the mouse wheel was rotated down/ towards the user\\n\\n   :key-pressed    - Called every time any key is pressed.\\n\\n   :key-released   - Called every time any key is released.\\n\\n   :key-typed      - Called once every time non-modifier keys are\\n                     pressed.\\n\\n   :on-close       - Called once, when sketch is closed\\n                     Not supported in clojurescript.\\n\\n   :middleware     - Vector of middleware to be applied to the sketch.\\n                     Middleware will be applied in the same order as in comp\\n                     function: [f g] will be applied as (f (g options)).\\n\\n   :settings       - cousin of :setup. A function to be called once when\\n                     setting sketch up. Should be used only for (smooth) and\\n                     (no-smooth). Due to Processing limitations these functions\\n                     cannot be used neither in :setup nor in :draw.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/defsketch\",\"^S\",true,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^G\",13,\"^14\",[\"^ \",\"^S\",true,\"^W\",3,\"^T\",[[\"^N\",[\"^1K\",\"^1L\",\"^8J\",\"^8K\"]]],\"^M\",[\"^N\",[[\"^1K\",\"^1L\",\"^8J\",\"~$&\",\"^8K\"]]],\"^V\",[\"^N\",[null]]],\"^T\",[[\"^N\",[\"^1K\",\"^1L\",\"^8J\",\"^8K\"]]],\"^U\",null,\"^V\",[\"^N\",[null]],\"^I\",1,\"^J\",false,\"^K\",4704,\"^1O\",true,\"^L\",4708,\"^W\",3,\"^X\",false,\"^M\",[\"^N\",[[\"^1K\",\"^1L\",\"^8J\",\"~$&\",\"^8K\"]]],\"^Q\",\"Define and start a sketch and bind it to a var with the symbol\\n  app-name. If any of the options to the various callbacks are\\n  symbols, it wraps them in a call to var to ensure they aren't\\n  inlined and that redefinitions to the original fns are reflected in\\n  the visualisation.\\n\\n  Available options:\\n\\n   :size           - A vector of width and height for the sketch or :fullscreen.\\n                     Defaults to [500 300]. If you're using :fullscreen you may\\n                     want to enable present mode - :features [:present]\\n\\n   :renderer       - Specifies the renderer type. One of :p2d, :p3d, :java2d,\\n                     :opengl, :pdf). Defaults to :java2d. :dxf renderer\\n                     can't be used as sketch renderer. Use begin-raw method\\n                     instead. In clojurescript only :p2d and :p3d renderers\\n                     are supported.\\n\\n   :output-file    - Specifies an output file path. Only used in :pdf mode.\\n                     Not supported in clojurescript.\\n\\n   :title          - A string which will be displayed at the top of\\n                     the sketch window. Not supported in clojurescript.\\n\\n   :features       - A vector of keywords customizing sketch behaviour.\\n                     Supported features:\\n\\n                     :keep-on-top - Sketch window will always be above other\\n                                    windows. Note: some platforms might not\\n                                    support always-on-top windows.\\n                                    Not supported in clojurescript.\\n\\n                     :exit-on-close - Shutdown JVM  when sketch is closed.\\n                                      Not supported in clojurescript.\\n\\n                     :resizable - Makes sketch resizable.\\n                                  Not supported in clojurescript.\\n\\n                     :no-safe-fns - Do not catch and print exceptions thrown\\n                                    inside functions provided to sketch (like\\n                                    draw, mouse-click, key-pressed and\\n                                    other). By default all exceptions thrown\\n                                    inside these functions are catched. This\\n                                    prevents sketch from breaking when bad\\n                                    function was provided and allows you to\\n                                    fix it and reload it on fly. You can\\n                                    disable this behaviour by enabling\\n                                    :no-safe-fns feature.\\n                                    Not supported in clojurescript.\\n\\n                     :present - Switch to present mode (fullscreen without\\n                                borders, OS panels). You may want to use\\n                                this feature together with :size :fullscreen.\\n                                Not supported in clojurescript.\\n\\n                     :no-start - Disables autostart if sketch was created using\\n                                 defsketch macro. To start sketch you have to\\n                                 call function created defsketch.\\n                                 Supported only in clojurescript.\\n\\n                     :global-key-events - Allows a sketch to receive any\\n                                          keyboard event sent to the page,\\n                                          regardless of whether the canvas it is\\n                                          loaded in has focus or not.\\n                                          Supported only in clojurescript.\\n\\n                     Usage example: :features [:keep-on-top :present]\\n\\n   :bgcolor        - Sets background color for unused space in present mode.\\n                     Color is specified in hex format: #XXXXXX.\\n                     Example: :bgcolor \\\"#00FFFF\\\" (cyan background)\\n                     Not supported in clojurescript.\\n\\n   :display        - Sets what display should be used by this sketch.\\n                     Displays are numbered starting from 0. Example: :display 1.\\n                     Not supported in clojurescript.\\n\\n   :setup          - A function to be called once when setting the sketch up.\\n\\n   :draw           - A function to be repeatedly called at most n times per\\n                     second where n is the target frame-rate set for\\n                     the visualisation.\\n\\n   :host           - String id of canvas element or DOM element itself.\\n                     Specifies host for the sketch. Must be specified in sketch,\\n                     may be omitted in defsketch. If ommitted in defsketch,\\n                     :host is set to the name of the sketch. If element with\\n                     specified id is not found on the page and page is empty -\\n                     new canvas element will be created. Used in clojurescript.\\n\\n   :focus-gained   - Called when the sketch gains focus.\\n                     Not supported in clojurescript.\\n\\n   :focus-lost     - Called when the sketch loses focus.\\n                     Not supported in clojurescript.\\n\\n   :mouse-entered  - Called when the mouse enters the sketch window.\\n\\n   :mouse-exited   - Called when the mouse leaves the sketch window\\n\\n   :mouse-pressed  - Called every time a mouse button is pressed.\\n\\n   :mouse-released - Called every time a mouse button is released.\\n\\n   :mouse-clicked  - called once after a mouse button has been pressed\\n                     and then released.\\n\\n   :mouse-moved    - Called every time the mouse moves and a button is\\n                     not pressed.\\n\\n   :mouse-dragged  - Called every time the mouse moves and a button is\\n                     pressed.\\n\\n   :mouse-wheel    - Called every time mouse wheel is rotated.\\n                     Takes 1 argument - wheel rotation, an int.\\n                     Negative values if the mouse wheel was rotated\\n                     up/away from the user, and positive values\\n                     if the mouse wheel was rotated down/ towards the user\\n\\n   :key-pressed    - Called every time any key is pressed.\\n\\n   :key-released   - Called every time any key is released.\\n\\n   :key-typed      - Called once every time non-modifier keys are\\n                     pressed.\\n\\n   :on-close       - Called once, when sketch is closed\\n                     Not supported in clojurescript.\\n\\n   :middleware     - Vector of middleware to be applied to the sketch.\\n                     Middleware will be applied in the same order as in comp\\n                     function: [f g] will be applied as (f (g options)).\\n\\n   :settings       - cousin of :setup. A function to be called once when\\n                     setting sketch up. Should be used only for (smooth) and\\n                     (no-smooth). Due to Processing limitations these functions\\n                     cannot be used neither in :setup nor in :draw.\"],\"~$no-stroke\",[\"^ \",\"^A\",\"Color\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Color\",\"^D\",\"1.0\",\"^E\",\"Setting\",\"^F\",\"^6\",\"^G\",12,\"^H\",\"noStroke()\",\"^I\",3,\"^J\",true,\"^K\",2836,\"^L\",2836,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Disables drawing the stroke (outline). If both no-stroke and\\n  no-fill are called, nothing will be drawn to the screen.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/no-stroke\",\"^S\",false,\"^E\",\"Setting\",\"^F\",\"quil/core.cljc\",\"^G\",12,\"^H\",\"noStroke()\",\"^T\",[\"^N\",[[]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",2830,\"^L\",2836,\"^W\",0,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Disables drawing the stroke (outline). If both no-stroke and\\n  no-fill are called, nothing will be drawn to the screen.\"],\"~$end-camera\",[\"^ \",\"^A\",\"Lights, Camera\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Lights, Camera\",\"^D\",\"1.0\",\"^E\",\"Camera\",\"^F\",\"^6\",\"^G\",13,\"^H\",\"endCamera()\",\"^I\",3,\"^J\",true,\"^K\",1612,\"^L\",1612,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Unsets the matrix mode from the camera matrix. See begin-camera.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/end-camera\",\"^S\",false,\"^E\",\"Camera\",\"^F\",\"quil/core.cljc\",\"^G\",13,\"^H\",\"endCamera()\",\"^T\",[\"^N\",[[]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",1606,\"^L\",1612,\"^W\",0,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Unsets the matrix mode from the camera matrix. See begin-camera.\"],\"~$random-seed\",[\"^ \",\"^A\",\"Math\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Math\",\"^D\",\"1.0\",\"^E\",\"Random\",\"^F\",\"^6\",\"^G\",14,\"^H\",\"randomSeed()\",\"^I\",3,\"^J\",true,\"^K\",3215,\"^L\",3215,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$w\"]]]]],\"^Q\",\"Sets the seed value for random. By default, random produces\\n  different results each time the program is run. Set the value\\n  parameter to a constant to return the same pseudo-random numbers\\n  each time the software is run.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/random-seed\",\"^S\",false,\"^E\",\"Random\",\"^F\",\"quil/core.cljc\",\"^G\",14,\"^H\",\"randomSeed()\",\"^T\",[\"^N\",[[\"~$w\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",3209,\"^L\",3215,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$w\"]]]]],\"^Q\",\"Sets the seed value for random. By default, random produces\\n  different results each time the program is run. Set the value\\n  parameter to a constant to return the same pseudo-random numbers\\n  each time the software is run.\"],\"~$model-z\",[\"^ \",\"^A\",\"Lights, Camera\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Lights, Camera\",\"^D\",\"1.0\",\"^E\",\"Coordinates\",\"^F\",\"^6\",\"^G\",10,\"^H\",\"modelZ()\",\"^I\",3,\"^J\",true,\"^K\",2553,\"^L\",2553,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$x\",\"~$y\",\"~$z\"]]]]],\"^Q\",\"Returns the three-dimensional x, y, z position in model space. This\\n  returns the z value for a given coordinate based on the current set\\n  of transformations (scale, rotate, translate, etc.) The z value can\\n  be used to place an object in space relative to the location of the\\n  original point once the transformations are no longer in use.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/model-z\",\"^S\",false,\"^E\",\"Coordinates\",\"^F\",\"quil/core.cljc\",\"^G\",10,\"^H\",\"modelZ()\",\"^T\",[\"^N\",[[\"~$x\",\"~$y\",\"~$z\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",2547,\"^L\",2553,\"^W\",3,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$x\",\"~$y\",\"~$z\"]]]]],\"^Q\",\"Returns the three-dimensional x, y, z position in model space. This\\n  returns the z value for a given coordinate based on the current set\\n  of transformations (scale, rotate, translate, etc.) The z value can\\n  be used to place an object in space relative to the location of the\\n  original point once the transformations are no longer in use.\"],\"~$light-specular\",[\"^ \",\"^A\",\"Lights, Camera\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Lights, Camera\",\"^D\",\"1.0\",\"^E\",\"Lights\",\"^F\",\"^6\",\"^G\",17,\"^H\",\"lightSpecular()\",\"^I\",3,\"^J\",true,\"^K\",2306,\"^L\",2306,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$r\",\"~$g\",\"~$b\"]]]]],\"^Q\",\"Sets the specular color for lights. Like fill, it affects only the\\n  elements which are created after it in the code. Specular refers to\\n  light which bounces off a surface in a perferred direction (rather\\n  than bouncing in all directions like a diffuse light) and is used\\n  for creating highlights. The specular quality of a light interacts\\n  with the specular material qualities set through the specular and\\n  shininess functions.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/light-specular\",\"^S\",false,\"^E\",\"Lights\",\"^F\",\"quil/core.cljc\",\"^G\",17,\"^H\",\"lightSpecular()\",\"^T\",[\"^N\",[[\"~$r\",\"~$g\",\"~$b\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",2300,\"^L\",2306,\"^W\",3,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$r\",\"~$g\",\"~$b\"]]]]],\"^Q\",\"Sets the specular color for lights. Like fill, it affects only the\\n  elements which are created after it in the code. Specular refers to\\n  light which bounces off a surface in a perferred direction (rather\\n  than bouncing in all directions like a diffuse light) and is used\\n  for creating highlights. The specular quality of a light interacts\\n  with the specular material qualities set through the specular and\\n  shininess functions.\"],\"~$key-as-keyword\",[\"^ \",\"^A\",\"Input\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Input\",\"^D\",\"1.6\",\"^E\",\"Keyboard\",\"^F\",\"^6\",\"^G\",17,\"^H\",null,\"^I\",3,\"^J\",true,\"^K\",4873,\"^L\",4873,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Returns a keyword representing the currently pressed key. Modifier\\n  keys are represented as: :up, :down, :left, :right, :alt, :control,\\n  :shift, :command, :f1-24\"],\"^D\",\"1.6\",\"^5\",\"~$quil.core/key-as-keyword\",\"^S\",false,\"^E\",\"Keyboard\",\"^F\",\"quil/core.cljc\",\"^G\",17,\"^H\",null,\"^T\",[\"^N\",[[]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",4868,\"^L\",4873,\"^W\",0,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Returns a keyword representing the currently pressed key. Modifier\\n  keys are represented as: :up, :down, :left, :right, :alt, :control,\\n  :shift, :command, :f1-24\"],\"~$dist\",[\"^ \",\"^A\",\"Math\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Math\",\"^D\",\"1.0\",\"^E\",\"Calculation\",\"^F\",\"^6\",\"^G\",7,\"^14\",[\"^ \",\"^S\",false,\"^W\",6,\"^T\",[\"^N\",[[\"^43\",\"^44\",\"^45\",\"^46\"],[\"^43\",\"^44\",\"^56\",\"^45\",\"^46\",\"^59\"]]],\"^M\",[\"^N\",[[\"^43\",\"^44\",\"^45\",\"^46\"],[\"^43\",\"^44\",\"^56\",\"^45\",\"^46\",\"^59\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"dist()\",\"^I\",3,\"^J\",false,\"^K\",1495,\"^L\",1495,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^43\",\"^44\",\"^45\",\"^46\"],[\"^43\",\"^44\",\"^56\",\"^45\",\"^46\",\"^59\"]]]]],\"^Q\",\"Calculates the distance between two points\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/dist\",\"^S\",false,\"^E\",\"Calculation\",\"^F\",\"quil/core.cljc\",\"^G\",7,\"^14\",[\"^ \",\"^S\",false,\"^W\",6,\"^T\",[\"^N\",[[\"^43\",\"^44\",\"^45\",\"^46\"],[\"^43\",\"^44\",\"^56\",\"^45\",\"^46\",\"^59\"]]],\"^M\",[\"^N\",[[\"^43\",\"^44\",\"^45\",\"^46\"],[\"^43\",\"^44\",\"^56\",\"^45\",\"^46\",\"^59\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"dist()\",\"^T\",[\"^N\",[[\"^43\",\"^44\",\"^45\",\"^46\"],[\"^43\",\"^44\",\"^56\",\"^45\",\"^46\",\"^59\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",false,\"^K\",1489,\"^L\",1495,\"^W\",6,\"^X\",true,\"^M\",[\"^N\",[[\"^43\",\"^44\",\"^45\",\"^46\"],[\"^43\",\"^44\",\"^56\",\"^45\",\"^46\",\"^59\"]]],\"^Q\",\"Calculates the distance between two points\"],\"~$PI\",[\"^ \",\"^5\",\"~$quil.core/PI\",\"^F\",\"quil/core.cljc\",\"^K\",76,\"^I\",10,\"^L\",76,\"^G\",17,\"^C\",[\"^ \",\"^F\",\"^6\",\"^K\",76,\"^I\",15,\"^L\",76,\"^G\",17]],\"~$norm\",[\"^ \",\"^A\",\"Math\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Math\",\"^D\",\"1.0\",\"^E\",\"Calculation\",\"^F\",\"^6\",\"^G\",7,\"^H\",\"norm()\",\"^I\",3,\"^J\",true,\"^K\",2797,\"^L\",2797,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^2P\",\"^7L\",\"^7M\"]]]]],\"^Q\",\"Normalize a value to exist between 0 and 1 (inclusive).\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/norm\",\"^S\",false,\"^E\",\"Calculation\",\"^F\",\"quil/core.cljc\",\"^G\",7,\"^H\",\"norm()\",\"^T\",[\"^N\",[[\"^2P\",\"^7L\",\"^7M\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",2791,\"^L\",2797,\"^W\",3,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^2P\",\"^7L\",\"^7M\"]]]]],\"^Q\",\"Normalize a value to exist between 0 and 1 (inclusive).\"],\"~$end-shape\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"Vertex\",\"^F\",\"^6\",\"^G\",12,\"^14\",[\"^ \",\"^S\",false,\"^W\",1,\"^T\",[\"^N\",[[],[\"^17\"]]],\"^M\",[\"^N\",[[],[\"^17\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"endShape()\",\"^I\",3,\"^J\",true,\"^K\",1651,\"^L\",1651,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[],[\"^17\"]]]]],\"^Q\",\"May only be called after begin-shape. When end-shape is called,\\n  all of image data defined since the previous call to begin-shape is\\n  written into the image buffer. The keyword :close may be passed to\\n  close the shape (to connect the beginning and the end).\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/end-shape\",\"^S\",false,\"^E\",\"Vertex\",\"^F\",\"quil/core.cljc\",\"^G\",12,\"^14\",[\"^ \",\"^S\",false,\"^W\",1,\"^T\",[\"^N\",[[],[\"^17\"]]],\"^M\",[\"^N\",[[],[\"^17\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"endShape()\",\"^T\",[\"^N\",[[],[\"^17\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",1645,\"^L\",1651,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[[],[\"^17\"]]],\"^Q\",\"May only be called after begin-shape. When end-shape is called,\\n  all of image data defined since the previous call to begin-shape is\\n  written into the image buffer. The keyword :close may be passed to\\n  close the shape (to connect the beginning and the end).\"],\"~$fill\",[\"^ \",\"^A\",\"Color\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Color\",\"^D\",\"1.0\",\"^E\",\"Setting\",\"^F\",\"^6\",\"^G\",7,\"^14\",[\"^ \",\"^S\",false,\"^W\",4,\"^T\",[\"^N\",[[\"^39\"],[\"^39\",\"^2>\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^M\",[\"^N\",[[\"^39\"],[\"^39\",\"^2>\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^V\",[\"^N\",[null,null,null,null]]],\"^H\",\"fill()\",\"^I\",3,\"^J\",true,\"^K\",1742,\"^L\",1742,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^39\"],[\"^39\",\"^2>\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]]]],\"^Q\",\"Sets the color used to fill shapes.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/fill\",\"^S\",false,\"^E\",\"Setting\",\"^F\",\"quil/core.cljc\",\"^G\",7,\"^14\",[\"^ \",\"^S\",false,\"^W\",4,\"^T\",[\"^N\",[[\"^39\"],[\"^39\",\"^2>\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^M\",[\"^N\",[[\"^39\"],[\"^39\",\"^2>\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^V\",[\"^N\",[null,null,null,null]]],\"^H\",\"fill()\",\"^T\",[\"^N\",[[\"^39\"],[\"^39\",\"^2>\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null,null,null]],\"^I\",1,\"^J\",true,\"^K\",1736,\"^L\",1742,\"^W\",4,\"^X\",true,\"^M\",[\"^N\",[[\"^39\"],[\"^39\",\"^2>\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^Q\",\"Sets the color used to fill shapes.\"],\"~$with-translation\",[\"^ \",\"^A\",\"Transform\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Transform\",\"^D\",\"1.0\",\"^E\",\"Utility Macros\",\"^F\",\"^6\",\"^G\",19,\"^14\",[\"^ \",\"^S\",true,\"^W\",3,\"^T\",[[\"^N\",[\"^1K\",\"^1L\",\"~$translation-vector\",\"^1N\"]]],\"^M\",[\"^N\",[[\"^1K\",\"^1L\",\"^98\",\"~$&\",\"^1N\"]]],\"^V\",[\"^N\",[null]]],\"^H\",null,\"^I\",3,\"^J\",true,\"^K\",4642,\"^1O\",true,\"^L\",4642,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^98\",\"~$&\",\"^1N\"]]]]],\"^Q\",\"Performs body with translation, restores current transformation on\\n  exit.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/with-translation\",\"^S\",true,\"^E\",\"Utility Macros\",\"^F\",\"quil/core.cljc\",\"^G\",19,\"^14\",[\"^ \",\"^S\",true,\"^W\",3,\"^T\",[[\"^N\",[\"^1K\",\"^1L\",\"^98\",\"^1N\"]]],\"^M\",[\"^N\",[[\"^1K\",\"^1L\",\"^98\",\"~$&\",\"^1N\"]]],\"^V\",[\"^N\",[null]]],\"^H\",null,\"^T\",[[\"^N\",[\"^1K\",\"^1L\",\"^98\",\"^1N\"]]],\"^U\",null,\"^V\",[\"^N\",[null]],\"^I\",1,\"^J\",true,\"^K\",4636,\"^1O\",true,\"^L\",4642,\"^W\",3,\"^X\",false,\"^M\",[\"^N\",[[\"^1K\",\"^1L\",\"^98\",\"~$&\",\"^1N\"]]],\"^Q\",\"Performs body with translation, restores current transformation on\\n  exit.\"],\"~$reset-matrix\",[\"^ \",\"^A\",\"Transform\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Transform\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^6\",\"^G\",15,\"^H\",\"resetMatrix()\",\"^I\",3,\"^J\",true,\"^K\",3355,\"^L\",3355,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Replaces the current matrix with the identity matrix. The\\n  equivalent function in OpenGL is glLoadIdentity()\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/reset-matrix\",\"^S\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^G\",15,\"^H\",\"resetMatrix()\",\"^T\",[\"^N\",[[]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",3349,\"^L\",3355,\"^W\",0,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Replaces the current matrix with the identity matrix. The\\n  equivalent function in OpenGL is glLoadIdentity()\"],\"~$emissive-float\",[\"^ \",\"^A\",\"Lights, Camera\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Lights, Camera\",\"^D\",\"1.0\",\"^E\",\"Material Properties\",\"^F\",\"^6\",\"^G\",17,\"^14\",[\"^ \",\"^S\",false,\"^W\",3,\"^T\",[\"^N\",[[\"~$float-val\"],[\"~$r\",\"~$g\",\"~$b\"]]],\"^M\",[\"^N\",[[\"^9=\"],[\"~$r\",\"~$g\",\"~$b\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"emissive()\",\"^I\",3,\"^J\",true,\"^K\",1566,\"^L\",1566,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^9=\"],[\"~$r\",\"~$g\",\"~$b\"]]]]],\"^Q\",\"Sets the emissive color of the material used for drawing shapes\\n drawn to the screen. Used in combination with ambient, specular, and\\n shininess in setting the material properties of shapes. Converts all\\n args to floats\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/emissive-float\",\"^S\",false,\"^E\",\"Material Properties\",\"^F\",\"quil/core.cljc\",\"^G\",17,\"^14\",[\"^ \",\"^S\",false,\"^W\",3,\"^T\",[\"^N\",[[\"^9=\"],[\"~$r\",\"~$g\",\"~$b\"]]],\"^M\",[\"^N\",[[\"^9=\"],[\"~$r\",\"~$g\",\"~$b\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"emissive()\",\"^T\",[\"^N\",[[\"^9=\"],[\"~$r\",\"~$g\",\"~$b\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",1560,\"^L\",1566,\"^W\",3,\"^X\",true,\"^M\",[\"^N\",[[\"^9=\"],[\"~$r\",\"~$g\",\"~$b\"]]],\"^Q\",\"Sets the emissive color of the material used for drawing shapes\\n drawn to the screen. Used in combination with ambient, specular, and\\n shininess in setting the material properties of shapes. Converts all\\n args to floats\"],\"~$shape-modes\",[\"^ \",\"^5\",\"~$quil.core/shape-modes\",\"^F\",\"quil/core.cljc\",\"^K\",45,\"^I\",1,\"^L\",47,\"^G\",13,\"^C\",[\"^ \",\"^F\",\"^6\",\"^K\",47,\"^I\",2,\"^L\",47,\"^G\",13]],\"~$green\",[\"^ \",\"^A\",\"Color\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Color\",\"^D\",\"1.0\",\"^E\",\"Creating & Reading\",\"^F\",\"^6\",\"^G\",8,\"^H\",\"green()\",\"^I\",3,\"^J\",true,\"^K\",1939,\"^L\",1939,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^4O\"]]]]],\"^Q\",\"Extracts the green value from a color, scaled to match current\\n  color-mode. This value is always returned as a float so be careful\\n  not to assign it to an int value.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/green\",\"^S\",false,\"^E\",\"Creating & Reading\",\"^F\",\"quil/core.cljc\",\"^G\",8,\"^H\",\"green()\",\"^T\",[\"^N\",[[\"^4O\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",1933,\"^L\",1939,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^4O\"]]]]],\"^Q\",\"Extracts the green value from a color, scaled to match current\\n  color-mode. This value is always returned as a float so be careful\\n  not to assign it to an int value.\"],\"~$HALF-PI\",[\"^ \",\"^5\",\"~$quil.core/HALF-PI\",\"^F\",\"quil/core.cljc\",\"^K\",77,\"^I\",1,\"^L\",77,\"^G\",13,\"^C\",[\"^ \",\"^F\",\"^6\",\"^K\",77,\"^I\",6,\"^L\",77,\"^G\",13]],\"~$begin-contour\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"2.0\",\"^E\",\"Vertex\",\"^F\",\"^6\",\"^G\",16,\"^H\",\"beginContour()\",\"^I\",3,\"^J\",true,\"^K\",602,\"^L\",602,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Use the begin-contour and end-contour function to create negative\\n  shapes within shapes. These functions can only be within a\\n  begin-shape/end-shape pair and they only work with the :p2d and :p3d\\n  renderers.\"],\"^D\",\"2.0\",\"^5\",\"~$quil.core/begin-contour\",\"^S\",false,\"^E\",\"Vertex\",\"^F\",\"quil/core.cljc\",\"^G\",16,\"^H\",\"beginContour()\",\"^T\",[\"^N\",[[]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",596,\"^L\",602,\"^W\",0,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Use the begin-contour and end-contour function to create negative\\n  shapes within shapes. These functions can only be within a\\n  begin-shape/end-shape pair and they only work with the :p2d and :p3d\\n  renderers.\"],\"~$DEG-TO-RAD\",[\"^ \",\"^5\",\"~$quil.core/DEG-TO-RAD\",\"^F\",\"quil/core.cljc\",\"^K\",82,\"^I\",1,\"^L\",82,\"^G\",16,\"^C\",[\"^ \",\"^F\",\"^6\",\"^K\",82,\"^I\",6,\"^L\",82,\"^G\",16]],\"~$pow\",[\"^ \",\"^A\",\"Math\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Math\",\"^D\",\"1.0\",\"^E\",\"Calculation\",\"^F\",\"^6\",\"^G\",6,\"^H\",\"pow()\",\"^I\",3,\"^J\",false,\"^K\",3032,\"^L\",3032,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$num\",\"~$exponent\"]]]]],\"^Q\",\"Facilitates exponential expressions. The pow() function is an\\n  efficient way of multiplying numbers by themselves (or their\\n  reciprocal) in large quantities. For example, (pow 3 5) is\\n  equivalent to the expression (* 3 3 3 3 3) and (pow 3 -5) is\\n  equivalent to (/ 1 (* 3 3 3 3 3)).\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/pow\",\"^S\",false,\"^E\",\"Calculation\",\"^F\",\"quil/core.cljc\",\"^G\",6,\"^H\",\"pow()\",\"^T\",[\"^N\",[[\"^9J\",\"^9K\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",false,\"^K\",3026,\"^L\",3032,\"^W\",2,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^9J\",\"^9K\"]]]]],\"^Q\",\"Facilitates exponential expressions. The pow() function is an\\n  efficient way of multiplying numbers by themselves (or their\\n  reciprocal) in large quantities. For example, (pow 3 5) is\\n  equivalent to the expression (* 3 3 3 3 3) and (pow 3 -5) is\\n  equivalent to (/ 1 (* 3 3 3 3 3)).\"],\"~$box\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"3D Primitives\",\"^F\",\"^6\",\"^G\",6,\"^14\",[\"^ \",\"^S\",false,\"^W\",3,\"^T\",[\"^N\",[[\"^28\"],[\"^1?\",\"^1@\",\"~$depth\"]]],\"^M\",[\"^N\",[[\"^28\"],[\"^1?\",\"^1@\",\"^9N\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"box()\",\"^I\",3,\"^J\",true,\"^K\",917,\"^L\",917,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^28\"],[\"^1?\",\"^1@\",\"^9N\"]]]]],\"^Q\",\"Creates an extruded rectangle.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/box\",\"^S\",false,\"^E\",\"3D Primitives\",\"^F\",\"quil/core.cljc\",\"^G\",6,\"^14\",[\"^ \",\"^S\",false,\"^W\",3,\"^T\",[\"^N\",[[\"^28\"],[\"^1?\",\"^1@\",\"^9N\"]]],\"^M\",[\"^N\",[[\"^28\"],[\"^1?\",\"^1@\",\"^9N\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"box()\",\"^T\",[\"^N\",[[\"^28\"],[\"^1?\",\"^1@\",\"^9N\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",911,\"^L\",917,\"^W\",3,\"^X\",true,\"^M\",[\"^N\",[[\"^28\"],[\"^1?\",\"^1@\",\"^9N\"]]],\"^Q\",\"Creates an extruded rectangle.\"],\"~$exp\",[\"^ \",\"^A\",\"Math\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Math\",\"^D\",\"1.0\",\"^E\",\"Calculation\",\"^F\",\"^6\",\"^G\",6,\"^H\",\"exp()\",\"^I\",3,\"^J\",false,\"^K\",1685,\"^L\",1685,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^2P\"]]]]],\"^Q\",\"Returns Euler's number e (2.71828...) raised to the power of the\\n  value parameter.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/exp\",\"^S\",false,\"^E\",\"Calculation\",\"^F\",\"quil/core.cljc\",\"^G\",6,\"^H\",\"exp()\",\"^T\",[\"^N\",[[\"^2P\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",false,\"^K\",1679,\"^L\",1685,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^2P\"]]]]],\"^Q\",\"Returns Euler's number e (2.71828...) raised to the power of the\\n  value parameter.\"],\"~$with-sketch\",[\"^ \",\"^B\",null,\"^C\",[\"^ \",\"^F\",\"^6\",\"^K\",190,\"^I\",11,\"^L\",190,\"^G\",22,\"^1O\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$applet\",\"~$&\",\"^1N\"]]]]],\"^14\",[\"^ \",\"^S\",true,\"^W\",3,\"^T\",[[\"^N\",[\"^1K\",\"^1L\",\"^9S\",\"^1N\"]]],\"^M\",[\"^N\",[[\"^1K\",\"^1L\",\"^9S\",\"~$&\",\"^1N\"]]],\"^V\",[\"^N\",[null]]]],\"^5\",\"~$quil.core/with-sketch\",\"^S\",true,\"^F\",\"quil/core.cljc\",\"^G\",22,\"^14\",[\"^ \",\"^S\",true,\"^W\",3,\"^T\",[[\"^N\",[\"^1K\",\"^1L\",\"^9S\",\"^1N\"]]],\"^M\",[\"^N\",[[\"^1K\",\"^1L\",\"^9S\",\"~$&\",\"^1N\"]]],\"^V\",[\"^N\",[null]]],\"^T\",[[\"^N\",[\"^1K\",\"^1L\",\"^9S\",\"^1N\"]]],\"^U\",null,\"^V\",[\"^N\",[null]],\"^I\",1,\"^K\",190,\"^1O\",true,\"^L\",190,\"^W\",3,\"^X\",false,\"^M\",[\"^N\",[[\"^1K\",\"^1L\",\"^9S\",\"~$&\",\"^1N\"]]]],\"~$text-ascent\",[\"^ \",\"^A\",\"Typography\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Typography\",\"^D\",\"1.0\",\"^E\",\"Metrics\",\"^F\",\"^6\",\"^G\",14,\"^H\",\"textAscent()\",\"^I\",3,\"^J\",true,\"^K\",4213,\"^L\",4213,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Returns the ascent of the current font at its current size. This\\n  information is useful for determining the height of the font above\\n  the baseline. For example, adding the text-ascent and text-descent\\n  values will give you the total height of the line.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/text-ascent\",\"^S\",false,\"^E\",\"Metrics\",\"^F\",\"quil/core.cljc\",\"^G\",14,\"^H\",\"textAscent()\",\"^T\",[\"^N\",[[]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",4207,\"^L\",4213,\"^W\",0,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Returns the ascent of the current font at its current size. This\\n  information is useful for determining the height of the font above\\n  the baseline. For example, adding the text-ascent and text-descent\\n  values will give you the total height of the line.\"],\"~$tint-int\",[\"^ \",\"^A\",\"Image\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Image\",\"^D\",\"1.0\",\"^E\",\"Loading & Displaying\",\"^F\",\"^6\",\"^G\",11,\"^14\",[\"^ \",\"^S\",false,\"^W\",2,\"^T\",[\"^N\",[[\"^39\"],[\"^39\",\"^2>\"]]],\"^M\",[\"^N\",[[\"^39\"],[\"^39\",\"^2>\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"tint()\",\"^I\",3,\"^J\",true,\"^K\",4410,\"^L\",4410,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^39\"],[\"^39\",\"^2>\"]]]]],\"^Q\",\"Sets the fill value for displaying images. Images can be tinted to\\n  specified colors or made transparent by setting the alpha.\\n\\n  To make an image transparent, but not change it's color, use white\\n  as the tint color and specify an alpha value. For instance,\\n  tint(255, 128) will make an image 50% transparent (unless\\n  colorMode() has been used).\\n\\n  The value for the parameter gray must be less than or equal to the\\n  current maximum value as specified by colorMode(). The default\\n  maximum value is 255.\\n\\n  Also used to control the coloring of textures in 3D.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/tint-int\",\"^S\",false,\"^E\",\"Loading & Displaying\",\"^F\",\"quil/core.cljc\",\"^G\",11,\"^14\",[\"^ \",\"^S\",false,\"^W\",2,\"^T\",[\"^N\",[[\"^39\"],[\"^39\",\"^2>\"]]],\"^M\",[\"^N\",[[\"^39\"],[\"^39\",\"^2>\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"tint()\",\"^T\",[\"^N\",[[\"^39\"],[\"^39\",\"^2>\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",4404,\"^L\",4410,\"^W\",2,\"^X\",true,\"^M\",[\"^N\",[[\"^39\"],[\"^39\",\"^2>\"]]],\"^Q\",\"Sets the fill value for displaying images. Images can be tinted to\\n  specified colors or made transparent by setting the alpha.\\n\\n  To make an image transparent, but not change it's color, use white\\n  as the tint color and specify an alpha value. For instance,\\n  tint(255, 128) will make an image 50% transparent (unless\\n  colorMode() has been used).\\n\\n  The value for the parameter gray must be less than or equal to the\\n  current maximum value as specified by colorMode(). The default\\n  maximum value is 255.\\n\\n  Also used to control the coloring of textures in 3D.\"],\"~$shininess\",[\"^ \",\"^A\",\"Lights, Camera\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Lights, Camera\",\"^D\",\"1.0\",\"^E\",\"Material Properties\",\"^F\",\"^6\",\"^G\",12,\"^H\",\"shininess()\",\"^I\",3,\"^J\",true,\"^K\",3822,\"^L\",3822,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$shine\"]]]]],\"^Q\",\"Sets the amount of gloss in the surface of shapes. Used in\\n  combination with ambient, specular, and emissive in setting\\n  the material properties of shapes.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/shininess\",\"^S\",false,\"^E\",\"Material Properties\",\"^F\",\"quil/core.cljc\",\"^G\",12,\"^H\",\"shininess()\",\"^T\",[\"^N\",[[\"^9Z\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",3816,\"^L\",3822,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^9Z\"]]]]],\"^Q\",\"Sets the amount of gloss in the surface of shapes. Used in\\n  combination with ambient, specular, and emissive in setting\\n  the material properties of shapes.\"],\"~$rect-mode\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"Attributes\",\"^F\",\"^6\",\"^G\",12,\"^H\",\"rectMode()\",\"^I\",3,\"^J\",true,\"^K\",3274,\"^L\",3274,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^17\"]]]]],\"^Q\",\"Modifies the location from which rectangles draw. The default mode\\n  is :corner. Available modes are:\\n\\n\\n  :corner  - Specifies the location to be the upper left corner of the\\n             shape and uses the third and fourth parameters of rect to\\n             specify the width and height.\\n\\n  :corners - Uses the first and second parameters of rect to set the\\n             location of one corner and uses the third and fourth\\n             parameters to set the opposite corner.\\n\\n  :center  - Draws the image from its center point and uses the third\\n             and forth parameters of rect to specify the image's width\\n             and height.\\n\\n  :radius  - Draws the image from its center point and uses the third\\n             and forth parameters of rect() to specify half of the\\n             image's width and height.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/rect-mode\",\"^S\",false,\"^E\",\"Attributes\",\"^F\",\"quil/core.cljc\",\"^G\",12,\"^H\",\"rectMode()\",\"^T\",[\"^N\",[[\"^17\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",3268,\"^L\",3274,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^17\"]]]]],\"^Q\",\"Modifies the location from which rectangles draw. The default mode\\n  is :corner. Available modes are:\\n\\n\\n  :corner  - Specifies the location to be the upper left corner of the\\n             shape and uses the third and fourth parameters of rect to\\n             specify the width and height.\\n\\n  :corners - Uses the first and second parameters of rect to set the\\n             location of one corner and uses the third and fourth\\n             parameters to set the opposite corner.\\n\\n  :center  - Draws the image from its center point and uses the third\\n             and forth parameters of rect to specify the image's width\\n             and height.\\n\\n  :radius  - Draws the image from its center point and uses the third\\n             and forth parameters of rect() to specify half of the\\n             image's width and height.\"],\"~$ellipse-mode\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"Attributes\",\"^F\",\"^6\",\"^G\",15,\"^H\",\"ellipseMode()\",\"^I\",3,\"^J\",true,\"^K\",1544,\"^L\",1544,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^17\"]]]]],\"^Q\",\"Modifies the origin of the ellispse according to the specified mode:\\n\\n  :center  - specifies the location of the ellipse as\\n             the center of the shape. (Default).\\n  :radius  - similar to center, but the width and height parameters to\\n             ellipse specify the radius of the ellipse, rather than the\\n             diameter.\\n  :corner  - draws the shape from the upper-left corner of its bounding\\n             box.\\n  :corners - uses the four parameters to ellipse to set two opposing\\n             corners of the ellipse's bounding box.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/ellipse-mode\",\"^S\",false,\"^E\",\"Attributes\",\"^F\",\"quil/core.cljc\",\"^G\",15,\"^H\",\"ellipseMode()\",\"^T\",[\"^N\",[[\"^17\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",1538,\"^L\",1544,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^17\"]]]]],\"^Q\",\"Modifies the origin of the ellispse according to the specified mode:\\n\\n  :center  - specifies the location of the ellipse as\\n             the center of the shape. (Default).\\n  :radius  - similar to center, but the width and height parameters to\\n             ellipse specify the radius of the ellipse, rather than the\\n             diameter.\\n  :corner  - draws the shape from the upper-left corner of its bounding\\n             box.\\n  :corners - uses the four parameters to ellipse to set two opposing\\n             corners of the ellipse's bounding box.\"],\"~$month\",[\"^ \",\"^A\",\"Input\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Input\",\"^D\",\"1.0\",\"^E\",\"Time & Date\",\"^F\",\"^6\",\"^G\",8,\"^H\",\"month()\",\"^I\",3,\"^J\",false,\"^K\",2568,\"^L\",2568,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Returns the current month as a value from 1 - 12.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/month\",\"^S\",false,\"^E\",\"Time & Date\",\"^F\",\"quil/core.cljc\",\"^G\",8,\"^H\",\"month()\",\"^T\",[\"^N\",[[]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",false,\"^K\",2562,\"^L\",2568,\"^W\",0,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Returns the current month as a value from 1 - 12.\"],\"~$texture-modes\",[\"^ \",\"^5\",\"~$quil.core/texture-modes\",\"^F\",\"quil/core.cljc\",\"^K\",45,\"^I\",1,\"^L\",69,\"^G\",15,\"^C\",[\"^ \",\"^F\",\"^6\",\"^K\",69,\"^I\",2,\"^L\",69,\"^G\",15]],\"~$tint-float\",[\"^ \",\"^A\",\"Image\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Image\",\"^D\",\"1.0\",\"^E\",\"Loading & Displaying\",\"^F\",\"^6\",\"^G\",13,\"^14\",[\"^ \",\"^S\",false,\"^W\",4,\"^T\",[\"^N\",[[\"^2=\"],[\"^2=\",\"^2>\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^M\",[\"^N\",[[\"^2=\"],[\"^2=\",\"^2>\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^V\",[\"^N\",[null,null,null,null]]],\"^H\",\"tint()\",\"^I\",3,\"^J\",true,\"^K\",4385,\"^L\",4385,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^2=\"],[\"^2=\",\"^2>\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]]]],\"^Q\",\"Sets the fill value for displaying images. Images can be tinted to\\n  specified colors or made transparent by setting the alpha.\\n\\n  To make an image transparent, but not change it's color, use white\\n  as the tint color and specify an alpha value. For instance,\\n  tint(255, 128) will make an image 50% transparent (unless\\n  colorMode() has been used).\\n\\n  The value for the parameter gray must be less than or equal to the\\n  current maximum value as specified by colorMode(). The default\\n  maximum value is 255.\\n\\n  Also used to control the coloring of textures in 3D.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/tint-float\",\"^S\",false,\"^E\",\"Loading & Displaying\",\"^F\",\"quil/core.cljc\",\"^G\",13,\"^14\",[\"^ \",\"^S\",false,\"^W\",4,\"^T\",[\"^N\",[[\"^2=\"],[\"^2=\",\"^2>\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^M\",[\"^N\",[[\"^2=\"],[\"^2=\",\"^2>\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^V\",[\"^N\",[null,null,null,null]]],\"^H\",\"tint()\",\"^T\",[\"^N\",[[\"^2=\"],[\"^2=\",\"^2>\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null,null,null]],\"^I\",1,\"^J\",true,\"^K\",4379,\"^L\",4385,\"^W\",4,\"^X\",true,\"^M\",[\"^N\",[[\"^2=\"],[\"^2=\",\"^2>\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^Q\",\"Sets the fill value for displaying images. Images can be tinted to\\n  specified colors or made transparent by setting the alpha.\\n\\n  To make an image transparent, but not change it's color, use white\\n  as the tint color and specify an alpha value. For instance,\\n  tint(255, 128) will make an image 50% transparent (unless\\n  colorMode() has been used).\\n\\n  The value for the parameter gray must be less than or equal to the\\n  current maximum value as specified by colorMode(). The default\\n  maximum value is 255.\\n\\n  Also used to control the coloring of textures in 3D.\"],\"^1?\",[\"^ \",\"^A\",\"Environment\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Environment\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^6\",\"^G\",8,\"^H\",\"getWidth()\",\"^I\",3,\"^3X\",null,\"^J\",true,\"^K\",4592,\"^L\",4592,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Width of the display window. The value of width is zero until size is\\n  called.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/width\",\"^S\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^G\",8,\"^H\",\"getWidth()\",\"^T\",[\"^N\",[[]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^3X\",null,\"^J\",true,\"^K\",4585,\"^L\",4592,\"^W\",0,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Width of the display window. The value of width is zero until size is\\n  called.\"],\"~$background\",[\"^ \",\"^A\",\"Color\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Color\",\"^D\",\"1.0\",\"^E\",\"Setting\",\"^F\",\"^6\",\"^G\",13,\"^14\",[\"^ \",\"^S\",false,\"^W\",4,\"^T\",[\"^N\",[[\"^39\"],[\"^39\",\"^2>\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^M\",[\"^N\",[[\"^39\"],[\"^39\",\"^2>\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^V\",[\"^N\",[null,null,null,null]]],\"^H\",\"background()\",\"^I\",3,\"^J\",true,\"^K\",550,\"^L\",550,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^39\"],[\"^39\",\"^2>\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]]]],\"^Q\",\"Sets the color used for the background of the Processing\\n  window. The default background is light gray. In the draw function,\\n  the background color is used to clear the display window at the\\n  beginning of each frame.\\n\\n  It is not possible to use transparency (alpha) in background colors\\n  with the main drawing surface, however they will work properly with\\n  create-graphics. Converts args to floats.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/background\",\"^S\",false,\"^E\",\"Setting\",\"^F\",\"quil/core.cljc\",\"^G\",13,\"^14\",[\"^ \",\"^S\",false,\"^W\",4,\"^T\",[\"^N\",[[\"^39\"],[\"^39\",\"^2>\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^M\",[\"^N\",[[\"^39\"],[\"^39\",\"^2>\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^V\",[\"^N\",[null,null,null,null]]],\"^H\",\"background()\",\"^T\",[\"^N\",[[\"^39\"],[\"^39\",\"^2>\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null,null,null]],\"^I\",1,\"^J\",true,\"^K\",544,\"^L\",550,\"^W\",4,\"^X\",true,\"^M\",[\"^N\",[[\"^39\"],[\"^39\",\"^2>\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^Q\",\"Sets the color used for the background of the Processing\\n  window. The default background is light gray. In the draw function,\\n  the background color is used to clear the display window at the\\n  beginning of each frame.\\n\\n  It is not possible to use transparency (alpha) in background colors\\n  with the main drawing surface, however they will work properly with\\n  create-graphics. Converts args to floats.\"],\"~$ortho\",[\"^ \",\"^A\",\"Lights, Camera\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Lights, Camera\",\"^D\",\"1.0\",\"^E\",\"Camera\",\"^F\",\"^6\",\"^G\",8,\"^14\",[\"^ \",\"^S\",false,\"^W\",6,\"^T\",[\"^N\",[[],[\"~$left\",\"~$right\",\"~$bottom\",\"~$top\"],[\"^:>\",\"^:?\",\"^:@\",\"^:A\",\"~$near\",\"~$far\"]]],\"^M\",[\"^N\",[[],[\"^:>\",\"^:?\",\"^:@\",\"^:A\"],[\"^:>\",\"^:?\",\"^:@\",\"^:A\",\"^:B\",\"^:C\"]]],\"^V\",[\"^N\",[null,null,null]]],\"^H\",\"ortho()\",\"^I\",3,\"^J\",true,\"^K\",2860,\"^L\",2860,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[],[\"^:>\",\"^:?\",\"^:@\",\"^:A\"],[\"^:>\",\"^:?\",\"^:@\",\"^:A\",\"^:B\",\"^:C\"]]]]],\"^Q\",\"Sets an orthographic projection and defines a parallel clipping\\n  volume. All objects with the same dimension appear the same size,\\n  regardless of whether they are near or far from the camera. The\\n  parameters to this function specify the clipping volume where left\\n  and right are the minimum and maximum x values, top and bottom are\\n  the minimum and maximum y values, and near and far are the minimum\\n  and maximum z values. If no parameters are given, the default is\\n  used: (ortho 0 width 0 height -10 10)\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/ortho\",\"^S\",false,\"^E\",\"Camera\",\"^F\",\"quil/core.cljc\",\"^G\",8,\"^14\",[\"^ \",\"^S\",false,\"^W\",6,\"^T\",[\"^N\",[[],[\"^:>\",\"^:?\",\"^:@\",\"^:A\"],[\"^:>\",\"^:?\",\"^:@\",\"^:A\",\"^:B\",\"^:C\"]]],\"^M\",[\"^N\",[[],[\"^:>\",\"^:?\",\"^:@\",\"^:A\"],[\"^:>\",\"^:?\",\"^:@\",\"^:A\",\"^:B\",\"^:C\"]]],\"^V\",[\"^N\",[null,null,null]]],\"^H\",\"ortho()\",\"^T\",[\"^N\",[[],[\"^:>\",\"^:?\",\"^:@\",\"^:A\"],[\"^:>\",\"^:?\",\"^:@\",\"^:A\",\"^:B\",\"^:C\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null,null]],\"^I\",1,\"^J\",true,\"^K\",2854,\"^L\",2860,\"^W\",6,\"^X\",true,\"^M\",[\"^N\",[[],[\"^:>\",\"^:?\",\"^:@\",\"^:A\"],[\"^:>\",\"^:?\",\"^:@\",\"^:A\",\"^:B\",\"^:C\"]]],\"^Q\",\"Sets an orthographic projection and defines a parallel clipping\\n  volume. All objects with the same dimension appear the same size,\\n  regardless of whether they are near or far from the camera. The\\n  parameters to this function specify the clipping volume where left\\n  and right are the minimum and maximum x values, top and bottom are\\n  the minimum and maximum y values, and near and far are the minimum\\n  and maximum z values. If no parameters are given, the default is\\n  used: (ortho 0 width 0 height -10 10)\"],\"~$hint-options\",[\"^ \",\"^5\",\"~$quil.core/hint-options\",\"^F\",\"quil/core.cljc\",\"^K\",45,\"^I\",1,\"^L\",53,\"^G\",14,\"^C\",[\"^ \",\"^F\",\"^6\",\"^K\",53,\"^I\",2,\"^L\",53,\"^G\",14]],\"~$prc-println\",[\"^ \",\"^A\",\"Output\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Output\",\"^D\",\"1.0\",\"^E\",\"Text area\",\"^F\",\"^6\",\"^G\",17,\"^I\",6,\"^8@\",true,\"^K\",152,\"^L\",152,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^8A\"]]]]],\"^Q\",\"Writes to the text area of the Processing environment's console.\\n  This is often helpful for looking at the data a program is producing.\\n  Each call to this function creates a new line of output.\\n  Individual elements can be separated with quotes (\\\"\\\") and joined with the string concatenation operator (+).\\n  Also writes the content of an array to the text area of the Processing environment.\\n  This is often helpful for looking at the data a program is producing.\\n  A new line is put between each element of the array. This function can only print 1D arrays,\\n  but can test to see if the content are null or not null for 2+ dimensional arrays.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/prc-println\",\"^S\",false,\"^E\",\"Text area\",\"^F\",\"quil/core.cljc\",\"^G\",17,\"^T\",[\"^N\",[[\"^8A\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",4,\"^8@\",true,\"^K\",147,\"^L\",152,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^8A\"]]]]],\"^Q\",\"Writes to the text area of the Processing environment's console.\\n  This is often helpful for looking at the data a program is producing.\\n  Each call to this function creates a new line of output.\\n  Individual elements can be separated with quotes (\\\"\\\") and joined with the string concatenation operator (+).\\n  Also writes the content of an array to the text area of the Processing environment.\\n  This is often helpful for looking at the data a program is producing.\\n  A new line is put between each element of the array. This function can only print 1D arrays,\\n  but can test to see if the content are null or not null for 2+ dimensional arrays.\"],\"~$brightness\",[\"^ \",\"^A\",\"Color\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Color\",\"^D\",\"1.0\",\"^E\",\"Creating & Reading\",\"^F\",\"^6\",\"^G\",13,\"^H\",\"brightness()\",\"^I\",3,\"^J\",true,\"^K\",928,\"^L\",928,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^7I\"]]]]],\"^Q\",\"Extracts the brightness value from a color. Returns a float.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/brightness\",\"^S\",false,\"^E\",\"Creating & Reading\",\"^F\",\"quil/core.cljc\",\"^G\",13,\"^H\",\"brightness()\",\"^T\",[\"^N\",[[\"^7I\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",922,\"^L\",928,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^7I\"]]]]],\"^Q\",\"Extracts the brightness value from a color. Returns a float.\"],\"~$arc-modes\",[\"^ \",\"^5\",\"~$quil.core/arc-modes\",\"^F\",\"quil/core.cljc\",\"^K\",45,\"^I\",1,\"^L\",46,\"^G\",11,\"^C\",[\"^ \",\"^F\",\"^6\",\"^K\",46,\"^I\",2,\"^L\",46,\"^G\",11]],\"~$specular\",[\"^ \",\"^A\",\"Lights, Camera\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Lights, Camera\",\"^D\",\"1.0\",\"^E\",\"Material Properties\",\"^F\",\"^6\",\"^G\",11,\"^14\",[\"^ \",\"^S\",false,\"^W\",3,\"^T\",[\"^N\",[[\"^2=\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^M\",[\"^N\",[[\"^2=\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"specular()\",\"^I\",3,\"^J\",true,\"^K\",3879,\"^L\",3879,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^2=\"],[\"~$x\",\"~$y\",\"~$z\"]]]]],\"^Q\",\"Sets the specular color of the materials used for shapes drawn to\\n  the screen, which sets the color of hightlights. Specular refers to\\n  light which bounces off a surface in a perferred direction (rather\\n  than bouncing in all directions like a diffuse light). Used in\\n  combination with emissive, ambient, and shininess in setting\\n  the material properties of shapes.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/specular\",\"^S\",false,\"^E\",\"Material Properties\",\"^F\",\"quil/core.cljc\",\"^G\",11,\"^14\",[\"^ \",\"^S\",false,\"^W\",3,\"^T\",[\"^N\",[[\"^2=\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^M\",[\"^N\",[[\"^2=\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"specular()\",\"^T\",[\"^N\",[[\"^2=\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",3873,\"^L\",3879,\"^W\",3,\"^X\",true,\"^M\",[\"^N\",[[\"^2=\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^Q\",\"Sets the specular color of the materials used for shapes drawn to\\n  the screen, which sets the color of hightlights. Specular refers to\\n  light which bounces off a surface in a perferred direction (rather\\n  than bouncing in all directions like a diffuse light). Used in\\n  combination with emissive, ambient, and shininess in setting\\n  the material properties of shapes.\"],\"~$save-frame\",[\"^ \",\"^A\",\"Output\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Output\",\"^D\",\"1.0\",\"^E\",\"Image\",\"^F\",\"^6\",\"^G\",13,\"^14\",[\"^ \",\"^S\",false,\"^W\",1,\"^T\",[\"^N\",[[],[\"~$name\"]]],\"^M\",[\"^N\",[[],[\"^:P\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"saveFrame()\",\"^I\",3,\"^J\",true,\"^K\",3541,\"^L\",3541,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[],[\"^:P\"]]]]],\"^Q\",\"Saves an image identical to the current display window as a\\n  file. May be called multple times - each file saved will have a\\n  unique name. Name and image formate may be modified by passing a\\n  string parameter of the form \\\"foo-####.ext\\\" where foo- can be any\\n  arbitrary string, #### will be replaced with the current frame id\\n  and .ext is one of .tiff, .targa, .png, .jpeg or .jpg\\n\\n  Examples:\\n  (save-frame)\\n  (save-frame \\\"pretty-pic-####.jpg\\\")\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/save-frame\",\"^S\",false,\"^E\",\"Image\",\"^F\",\"quil/core.cljc\",\"^G\",13,\"^14\",[\"^ \",\"^S\",false,\"^W\",1,\"^T\",[\"^N\",[[],[\"^:P\"]]],\"^M\",[\"^N\",[[],[\"^:P\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"saveFrame()\",\"^T\",[\"^N\",[[],[\"^:P\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",3535,\"^L\",3541,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[[],[\"^:P\"]]],\"^Q\",\"Saves an image identical to the current display window as a\\n  file. May be called multple times - each file saved will have a\\n  unique name. Name and image formate may be modified by passing a\\n  string parameter of the form \\\"foo-####.ext\\\" where foo- can be any\\n  arbitrary string, #### will be replaced with the current frame id\\n  and .ext is one of .tiff, .targa, .png, .jpeg or .jpg\\n\\n  Examples:\\n  (save-frame)\\n  (save-frame \\\"pretty-pic-####.jpg\\\")\"],\"~$cursor\",[\"^ \",\"^A\",\"Environment\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Environment\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^6\",\"^G\",9,\"^14\",[\"^ \",\"^S\",false,\"^W\",1,\"^T\",[\"^N\",[[],[\"~$cursor-mode\"]]],\"^M\",[\"^N\",[[],[\"^:S\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"cursor()\",\"^I\",3,\"^J\",true,\"^K\",1286,\"^L\",1286,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[],[\"^:S\"]]]]],\"^Q\",\"Sets the cursor to a predefined symbol or makes it\\n  visible if already hidden (after no-cursor was called).\\n\\n  Available modes: :arrow, :cross, :hand, :move, :text, :wait\\n\\n  See cursor-image for specifying a generic image as the cursor\\n  symbol.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/cursor\",\"^S\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^G\",9,\"^14\",[\"^ \",\"^S\",false,\"^W\",1,\"^T\",[\"^N\",[[],[\"^:S\"]]],\"^M\",[\"^N\",[[],[\"^:S\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"cursor()\",\"^T\",[\"^N\",[[],[\"^:S\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",1280,\"^L\",1286,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[[],[\"^:S\"]]],\"^Q\",\"Sets the cursor to a predefined symbol or makes it\\n  visible if already hidden (after no-cursor was called).\\n\\n  Available modes: :arrow, :cross, :hand, :move, :text, :wait\\n\\n  See cursor-image for specifying a generic image as the cursor\\n  symbol.\"],\"~$noise\",[\"^ \",\"^A\",\"Math\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Math\",\"^D\",\"1.0\",\"^E\",\"Random\",\"^F\",\"^6\",\"^G\",8,\"^14\",[\"^ \",\"^S\",false,\"^W\",3,\"^T\",[\"^N\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^M\",[\"^N\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^V\",[\"^N\",[null,null,null]]],\"^H\",\"noise()\",\"^I\",3,\"^J\",true,\"^K\",2676,\"^L\",2676,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]]]],\"^Q\",\"Returns the Perlin noise value at specified coordinates. Perlin\\n  noise is a random sequence generator producing a more natural\\n  ordered, harmonic succession of numbers compared to the standard\\n  random function. It was invented by Ken Perlin in the 1980s and\\n  been used since in graphical applications to produce procedural\\n  textures, natural motion, shapes, terrains etc.\\n\\n  The main difference to the random function is that Perlin noise is\\n  defined in an infinite n-dimensional space where each pair of\\n  coordinates corresponds to a fixed semi-random value (fixed only for\\n  the lifespan of the program). The resulting value will always be\\n  between 0.0 and 1.0. Processing can compute 1D, 2D and 3D noise,\\n  depending on the number of coordinates given. The noise value can be\\n  animated by moving through the noise space and the 2nd and 3rd\\n  dimensions can also be interpreted as time.\\n\\n  The actual noise is structured similar to an audio signal, in\\n  respect to the function's use of frequencies. Similar to the concept\\n  of harmonics in physics, perlin noise is computed over several\\n  octaves which are added together for the final result.\\n\\n  Another way to adjust the character of the resulting sequence is the\\n  scale of the input coordinates. As the function works within an\\n  infinite space the value of the coordinates doesn't matter as such,\\n  only the distance between successive coordinates does (eg. when\\n  using noise within a loop). As a general rule the smaller the\\n  difference between coordinates, the smoother the resulting noise\\n  sequence will be. Steps of 0.005-0.03 work best for most\\n  applications, but this will differ depending on use.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/noise\",\"^S\",false,\"^E\",\"Random\",\"^F\",\"quil/core.cljc\",\"^G\",8,\"^14\",[\"^ \",\"^S\",false,\"^W\",3,\"^T\",[\"^N\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^M\",[\"^N\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^V\",[\"^N\",[null,null,null]]],\"^H\",\"noise()\",\"^T\",[\"^N\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null,null]],\"^I\",1,\"^J\",true,\"^K\",2670,\"^L\",2676,\"^W\",3,\"^X\",true,\"^M\",[\"^N\",[[\"~$x\"],[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^Q\",\"Returns the Perlin noise value at specified coordinates. Perlin\\n  noise is a random sequence generator producing a more natural\\n  ordered, harmonic succession of numbers compared to the standard\\n  random function. It was invented by Ken Perlin in the 1980s and\\n  been used since in graphical applications to produce procedural\\n  textures, natural motion, shapes, terrains etc.\\n\\n  The main difference to the random function is that Perlin noise is\\n  defined in an infinite n-dimensional space where each pair of\\n  coordinates corresponds to a fixed semi-random value (fixed only for\\n  the lifespan of the program). The resulting value will always be\\n  between 0.0 and 1.0. Processing can compute 1D, 2D and 3D noise,\\n  depending on the number of coordinates given. The noise value can be\\n  animated by moving through the noise space and the 2nd and 3rd\\n  dimensions can also be interpreted as time.\\n\\n  The actual noise is structured similar to an audio signal, in\\n  respect to the function's use of frequencies. Similar to the concept\\n  of harmonics in physics, perlin noise is computed over several\\n  octaves which are added together for the final result.\\n\\n  Another way to adjust the character of the resulting sequence is the\\n  scale of the input coordinates. As the function works within an\\n  infinite space the value of the coordinates doesn't matter as such,\\n  only the distance between successive coordinates does (eg. when\\n  using noise within a loop). As a general rule the smaller the\\n  difference between coordinates, the smoother the resulting noise\\n  sequence will be. Steps of 0.005-0.03 work best for most\\n  applications, but this will differ depending on use.\"],\"~$push-style\",[\"^ \",\"^A\",\"Structure\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Structure\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^6\",\"^G\",13,\"^H\",\"pushStyle()\",\"^I\",3,\"^J\",true,\"^K\",3100,\"^L\",3100,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Saves the current style settings onto a 'style stack'. Use with\\n  pop-style which restores the prior settings. Note that these\\n  functions are always used together. They allow you to change the\\n  style settings and later return to what you had. When a new style is\\n  started with push-style, it builds on the current style\\n  information. The push-style and pop-style fns can be embedded to\\n  provide more control.\\n\\n  The style information controlled by the following functions are\\n  included in the style: fill, stroke, tint, stroke-weight,\\n  stroke-cap, stroke-join, image-mode, rect-mode, ellipse-mode,\\n  shape-mode, color-mode, text-align, text-font, text-mode, text-size,\\n  text-leading, emissive, specular, shininess, and ambient\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/push-style\",\"^S\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^G\",13,\"^H\",\"pushStyle()\",\"^T\",[\"^N\",[[]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",3094,\"^L\",3100,\"^W\",0,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Saves the current style settings onto a 'style stack'. Use with\\n  pop-style which restores the prior settings. Note that these\\n  functions are always used together. They allow you to change the\\n  style settings and later return to what you had. When a new style is\\n  started with push-style, it builds on the current style\\n  information. The push-style and pop-style fns can be embedded to\\n  provide more control.\\n\\n  The style information controlled by the following functions are\\n  included in the style: fill, stroke, tint, stroke-weight,\\n  stroke-cap, stroke-join, image-mode, rect-mode, ellipse-mode,\\n  shape-mode, color-mode, text-align, text-font, text-mode, text-size,\\n  text-leading, emissive, specular, shininess, and ambient\"],\"~$bezier-vertex\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"Vertex\",\"^F\",\"^6\",\"^G\",16,\"^14\",[\"^ \",\"^S\",false,\"^W\",9,\"^T\",[\"^N\",[[\"^52\",\"^53\",\"^54\",\"^55\",\"~$x\",\"~$y\"],[\"^52\",\"^53\",\"^57\",\"^54\",\"^55\",\"^58\",\"~$x\",\"~$y\",\"~$z\"]]],\"^M\",[\"^N\",[[\"^52\",\"^53\",\"^54\",\"^55\",\"~$x\",\"~$y\"],[\"^52\",\"^53\",\"^57\",\"^54\",\"^55\",\"^58\",\"~$x\",\"~$y\",\"~$z\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"bezierVertex()\",\"^I\",3,\"^J\",true,\"^K\",735,\"^L\",735,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^52\",\"^53\",\"^54\",\"^55\",\"~$x\",\"~$y\"],[\"^52\",\"^53\",\"^57\",\"^54\",\"^55\",\"^58\",\"~$x\",\"~$y\",\"~$z\"]]]]],\"^Q\",\"Specifies vertex coordinates for Bezier curves. Each call to\\n  bezier-vertex defines the position of two control points and one\\n  anchor point of a Bezier curve, adding a new segment to a line or\\n  shape. The first time bezier-vertex is used within a begin-shape\\n  call, it must be prefaced with a call to vertex to set the first\\n  anchor point. This function must be used between begin-shape and\\n  end-shape and only when there is no parameter specified to\\n  begin-shape.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/bezier-vertex\",\"^S\",false,\"^E\",\"Vertex\",\"^F\",\"quil/core.cljc\",\"^G\",16,\"^14\",[\"^ \",\"^S\",false,\"^W\",9,\"^T\",[\"^N\",[[\"^52\",\"^53\",\"^54\",\"^55\",\"~$x\",\"~$y\"],[\"^52\",\"^53\",\"^57\",\"^54\",\"^55\",\"^58\",\"~$x\",\"~$y\",\"~$z\"]]],\"^M\",[\"^N\",[[\"^52\",\"^53\",\"^54\",\"^55\",\"~$x\",\"~$y\"],[\"^52\",\"^53\",\"^57\",\"^54\",\"^55\",\"^58\",\"~$x\",\"~$y\",\"~$z\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"bezierVertex()\",\"^T\",[\"^N\",[[\"^52\",\"^53\",\"^54\",\"^55\",\"~$x\",\"~$y\"],[\"^52\",\"^53\",\"^57\",\"^54\",\"^55\",\"^58\",\"~$x\",\"~$y\",\"~$z\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",729,\"^L\",735,\"^W\",9,\"^X\",true,\"^M\",[\"^N\",[[\"^52\",\"^53\",\"^54\",\"^55\",\"~$x\",\"~$y\"],[\"^52\",\"^53\",\"^57\",\"^54\",\"^55\",\"^58\",\"~$x\",\"~$y\",\"~$z\"]]],\"^Q\",\"Specifies vertex coordinates for Bezier curves. Each call to\\n  bezier-vertex defines the position of two control points and one\\n  anchor point of a Bezier curve, adding a new segment to a line or\\n  shape. The first time bezier-vertex is used within a begin-shape\\n  call, it must be prefaced with a call to vertex to set the first\\n  anchor point. This function must be used between begin-shape and\\n  end-shape and only when there is no parameter specified to\\n  begin-shape.\"],\"~$light-falloff\",[\"^ \",\"^A\",\"Lights, Camera\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Lights, Camera\",\"^D\",\"1.0\",\"^E\",\"Lights\",\"^F\",\"^6\",\"^G\",16,\"^H\",\"lightFalloff()\",\"^I\",3,\"^J\",true,\"^K\",2228,\"^L\",2228,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$constant\",\"~$linear\",\"~$quadratic\"]]]]],\"^Q\",\"Sets the falloff rates for point lights, spot lights, and ambient\\n  lights. The parameters are used to determine the falloff with the\\n  following equation:\\n\\n  d = distance from light position to vertex position\\n  falloff = 1 / (CONSTANT + d * LINEAR + (d*d) * QUADRATIC)\\n\\n  Like fill, it affects only the elements which are created after it\\n  in the code. The default value is (light-falloff 1.0 0.0 0.0).\\n  Thinking about an ambient light with a falloff can be tricky. It is\\n  used, for example, if you wanted a region of your scene to be lit\\n  ambiently one color and another region to be lit ambiently by\\n  another color, you would use an ambient light with location and\\n  falloff. You can think of it as a point light that doesn't care\\n  which direction a surface is facing.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/light-falloff\",\"^S\",false,\"^E\",\"Lights\",\"^F\",\"quil/core.cljc\",\"^G\",16,\"^H\",\"lightFalloff()\",\"^T\",[\"^N\",[[\"^;0\",\"^;1\",\"^;2\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",2222,\"^L\",2228,\"^W\",3,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^;0\",\"^;1\",\"^;2\"]]]]],\"^Q\",\"Sets the falloff rates for point lights, spot lights, and ambient\\n  lights. The parameters are used to determine the falloff with the\\n  following equation:\\n\\n  d = distance from light position to vertex position\\n  falloff = 1 / (CONSTANT + d * LINEAR + (d*d) * QUADRATIC)\\n\\n  Like fill, it affects only the elements which are created after it\\n  in the code. The default value is (light-falloff 1.0 0.0 0.0).\\n  Thinking about an ambient light with a falloff can be tricky. It is\\n  used, for example, if you wanted a region of your scene to be lit\\n  ambiently one color and another region to be lit ambiently by\\n  another color, you would use an ambient light with location and\\n  falloff. You can think of it as a point light that doesn't care\\n  which direction a surface is facing.\"],\"~$noise-detail\",[\"^ \",\"^A\",\"Math\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Math\",\"^D\",\"1.0\",\"^E\",\"Random\",\"^F\",\"^6\",\"^G\",15,\"^14\",[\"^ \",\"^S\",false,\"^W\",2,\"^T\",[\"^N\",[[\"~$octaves\"],[\"^;5\",\"~$falloff\"]]],\"^M\",[\"^N\",[[\"^;5\"],[\"^;5\",\"^;6\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"noiseDetail()\",\"^I\",3,\"^J\",true,\"^K\",2716,\"^L\",2716,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^;5\"],[\"^;5\",\"^;6\"]]]]],\"^Q\",\"Adjusts the character and level of detail produced by the Perlin\\n  noise function. Similar to harmonics in physics, noise is computed\\n  over several octaves. Lower octaves contribute more to the output\\n  signal and as such define the overal intensity of the noise, whereas\\n  higher octaves create finer grained details in the noise\\n  sequence. By default, noise is computed over 4 octaves with each\\n  octave contributing exactly half than its predecessor, starting at\\n  50% strength for the 1st octave. This falloff amount can be changed\\n  by adding an additional function parameter. Eg. a falloff factor of\\n  0.75 means each octave will now have 75% impact (25% less) of the\\n  previous lower octave. Any value between 0.0 and 1.0 is valid,\\n  however note that values greater than 0.5 might result in greater\\n  than 1.0 values returned by noise.\\n\\n  By changing these parameters, the signal created by the noise\\n  function can be adapted to fit very specific needs and\\n  characteristics.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/noise-detail\",\"^S\",false,\"^E\",\"Random\",\"^F\",\"quil/core.cljc\",\"^G\",15,\"^14\",[\"^ \",\"^S\",false,\"^W\",2,\"^T\",[\"^N\",[[\"^;5\"],[\"^;5\",\"^;6\"]]],\"^M\",[\"^N\",[[\"^;5\"],[\"^;5\",\"^;6\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"noiseDetail()\",\"^T\",[\"^N\",[[\"^;5\"],[\"^;5\",\"^;6\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",2710,\"^L\",2716,\"^W\",2,\"^X\",true,\"^M\",[\"^N\",[[\"^;5\"],[\"^;5\",\"^;6\"]]],\"^Q\",\"Adjusts the character and level of detail produced by the Perlin\\n  noise function. Similar to harmonics in physics, noise is computed\\n  over several octaves. Lower octaves contribute more to the output\\n  signal and as such define the overal intensity of the noise, whereas\\n  higher octaves create finer grained details in the noise\\n  sequence. By default, noise is computed over 4 octaves with each\\n  octave contributing exactly half than its predecessor, starting at\\n  50% strength for the 1st octave. This falloff amount can be changed\\n  by adding an additional function parameter. Eg. a falloff factor of\\n  0.75 means each octave will now have 75% impact (25% less) of the\\n  previous lower octave. Any value between 0.0 and 1.0 is valid,\\n  however note that values greater than 0.5 might result in greater\\n  than 1.0 values returned by noise.\\n\\n  By changing these parameters, the signal created by the noise\\n  function can be adapted to fit very specific needs and\\n  characteristics.\"],\"~$save\",[\"^ \",\"^A\",\"Output\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Output\",\"^D\",\"1.0\",\"^E\",\"Image\",\"^F\",\"^6\",\"^G\",7,\"^H\",\"save()\",\"^I\",3,\"^J\",true,\"^K\",3523,\"^L\",3523,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^4L\"]]]]],\"^Q\",\"Saves an image from the display window. Images are saved in TIFF,\\n  TARGA, JPEG, and PNG format depending on the extension within the\\n  filename parameter. For example, image.tif will have a TIFF image\\n  and image.png will save a PNG image. If no extension is included in\\n  the filename, the image will save in TIFF format and .tif will be\\n  added to the name. All images saved from the main drawing window\\n  will be opaque. To save images without a background, use\\n  create-graphics.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/save\",\"^S\",false,\"^E\",\"Image\",\"^F\",\"quil/core.cljc\",\"^G\",7,\"^H\",\"save()\",\"^T\",[\"^N\",[[\"^4L\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",3517,\"^L\",3523,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^4L\"]]]]],\"^Q\",\"Saves an image from the display window. Images are saved in TIFF,\\n  TARGA, JPEG, and PNG format depending on the extension within the\\n  filename parameter. For example, image.tif will have a TIFF image\\n  and image.png will save a PNG image. If no extension is included in\\n  the filename, the image will save in TIFF format and .tif will be\\n  added to the name. All images saved from the main drawing window\\n  will be opaque. To save images without a background, use\\n  create-graphics.\"],\"~$curve-point\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"Curves\",\"^F\",\"^6\",\"^G\",14,\"^H\",\"curvePoint()\",\"^I\",3,\"^J\",true,\"^K\",1362,\"^L\",1362,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$t\"]]]]],\"^Q\",\"Evalutes the curve at point t for points a, b, c, d. The parameter\\n  t varies between 0 and 1, a and d are points on the curve, and b c\\n  and are the control points. This can be done once with the x\\n  coordinates and a second time with the y coordinates to get the\\n  location of a curve at t.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/curve-point\",\"^S\",false,\"^E\",\"Curves\",\"^F\",\"quil/core.cljc\",\"^G\",14,\"^H\",\"curvePoint()\",\"^T\",[\"^N\",[[\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$t\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",1356,\"^L\",1362,\"^W\",5,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$t\"]]]]],\"^Q\",\"Evalutes the curve at point t for points a, b, c, d. The parameter\\n  t varies between 0 and 1, a and d are points on the curve, and b c\\n  and are the control points. This can be done once with the x\\n  coordinates and a second time with the y coordinates to get the\\n  location of a curve at t.\"],\"~$state\",[\"^ \",\"^A\",\"State\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"State\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^6\",\"^G\",8,\"^14\",[\"^ \",\"^S\",false,\"^W\",1,\"^T\",[\"^N\",[[],[\"~$key\"]]],\"^M\",[\"^N\",[[],[\"^;=\"]]],\"^V\",[\"^N\",[null,null]]],\"^I\",3,\"^J\",true,\"^K\",215,\"^L\",215,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[],[\"^;=\"]]]]],\"^Q\",\"Retrieve sketch-specific state by key. Must initially call\\n  set-state! to store state. If no parameter passed whole\\n  state map is returned.\\n\\n  (set-state! :foo 1)\\n  (state :foo) ;=> 1\\n  (state) ;=> {:foo 1}\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/state\",\"^S\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^G\",8,\"^14\",[\"^ \",\"^S\",false,\"^W\",1,\"^T\",[\"^N\",[[],[\"^;=\"]]],\"^M\",[\"^N\",[[],[\"^;=\"]]],\"^V\",[\"^N\",[null,null]]],\"^T\",[\"^N\",[[],[\"^;=\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",210,\"^L\",215,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[[],[\"^;=\"]]],\"^Q\",\"Retrieve sketch-specific state by key. Must initially call\\n  set-state! to store state. If no parameter passed whole\\n  state map is returned.\\n\\n  (set-state! :foo 1)\\n  (state :foo) ;=> 1\\n  (state) ;=> {:foo 1}\"],\"~$load-shader\",[\"^ \",\"^A\",\"Rendering\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Rendering\",\"^D\",\"2.0\",\"^E\",\"Shaders\",\"^F\",\"^6\",\"^G\",14,\"^14\",[\"^ \",\"^S\",false,\"^W\",2,\"^T\",[\"^N\",[[\"~$fragment-filename\"],[\"^;@\",\"~$vertex-filename\"]]],\"^M\",[\"^N\",[[\"^;@\"],[\"^;@\",\"^;A\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"loadShader()\",\"^I\",3,\"^J\",true,\"^K\",2403,\"^L\",2403,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^;@\"],[\"^;@\",\"^;A\"]]]]],\"^Q\",\"Loads a shader into the PShader object. Shaders are compatible with the\\n  P2D and P3D renderers, but not with the default renderer.\"],\"^D\",\"2.0\",\"^5\",\"~$quil.core/load-shader\",\"^S\",false,\"^E\",\"Shaders\",\"^F\",\"quil/core.cljc\",\"^G\",14,\"^14\",[\"^ \",\"^S\",false,\"^W\",2,\"^T\",[\"^N\",[[\"^;@\"],[\"^;@\",\"^;A\"]]],\"^M\",[\"^N\",[[\"^;@\"],[\"^;@\",\"^;A\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"loadShader()\",\"^T\",[\"^N\",[[\"^;@\"],[\"^;@\",\"^;A\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",2397,\"^L\",2403,\"^W\",2,\"^X\",true,\"^M\",[\"^N\",[[\"^;@\"],[\"^;@\",\"^;A\"]]],\"^Q\",\"Loads a shader into the PShader object. Shaders are compatible with the\\n  P2D and P3D renderers, but not with the default renderer.\"],\"~$resize\",[\"^ \",\"^A\",\"Image\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Image\",\"^D\",\"2.1.0\",\"^F\",\"^6\",\"^G\",9,\"^H\",\"resize()\",\"^I\",3,\"^3X\",\"http://processing.org/reference/PImage_resize_.html\",\"^J\",true,\"^K\",3389,\"^L\",3389,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^1Y\",\"~$w\",\"~$h\"]]]]],\"^Q\",\"Resize the image to a new width and height.\\n  To make the image scale proportionally, use 0 as the value for the wide or\\n  high parameter. For instance, to make the width of an image 150 pixels,\\n  and change the height using the same proportion, use resize(150, 0).\\n\\n  Even though a PGraphics is technically a PImage, it is not possible\\n  to rescale the image data found in a PGraphics.\\n  (It's simply not possible to do this consistently across renderers:\\n  technically infeasible with P3D, or what would it even do with PDF?)\\n  If you want to resize PGraphics content, first get a copy of its image data\\n  using the get() method, and call resize() on the PImage that is returned.\"],\"^D\",\"2.1.0\",\"^5\",\"~$quil.core/resize\",\"^S\",false,\"^F\",\"quil/core.cljc\",\"^G\",9,\"^H\",\"resize()\",\"^T\",[\"^N\",[[\"^1Y\",\"~$w\",\"~$h\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^3X\",\"http://processing.org/reference/PImage_resize_.html\",\"^J\",true,\"^K\",3383,\"^L\",3389,\"^W\",3,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^1Y\",\"~$w\",\"~$h\"]]]]],\"^Q\",\"Resize the image to a new width and height.\\n  To make the image scale proportionally, use 0 as the value for the wide or\\n  high parameter. For instance, to make the width of an image 150 pixels,\\n  and change the height using the same proportion, use resize(150, 0).\\n\\n  Even though a PGraphics is technically a PImage, it is not possible\\n  to rescale the image data found in a PGraphics.\\n  (It's simply not possible to do this consistently across renderers:\\n  technically infeasible with P3D, or what would it even do with PDF?)\\n  If you want to resize PGraphics content, first get a copy of its image data\\n  using the get() method, and call resize() on the PImage that is returned.\"],\"~$normal\",[\"^ \",\"^A\",\"Lights, Camera\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Lights, Camera\",\"^D\",\"1.0\",\"^E\",\"Lights\",\"^F\",\"^6\",\"^G\",9,\"^H\",\"normal()\",\"^I\",3,\"^J\",true,\"^K\",2809,\"^L\",2809,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^5E\",\"^5F\",\"^5G\"]]]]],\"^Q\",\"Sets the current normal vector. This is for drawing three\\n  dimensional shapes and surfaces and specifies a vector perpendicular\\n  to the surface of the shape which determines how lighting affects\\n  it. Processing attempts to automatically assign normals to shapes,\\n  but since that's imperfect, this is a better option when you want\\n  more control. This function is identical to glNormal3f() in OpenGL.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/normal\",\"^S\",false,\"^E\",\"Lights\",\"^F\",\"quil/core.cljc\",\"^G\",9,\"^H\",\"normal()\",\"^T\",[\"^N\",[[\"^5E\",\"^5F\",\"^5G\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",2803,\"^L\",2809,\"^W\",3,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^5E\",\"^5F\",\"^5G\"]]]]],\"^Q\",\"Sets the current normal vector. This is for drawing three\\n  dimensional shapes and surfaces and specifies a vector perpendicular\\n  to the surface of the shape which determines how lighting affects\\n  it. Processing attempts to automatically assign normals to shapes,\\n  but since that's imperfect, this is a better option when you want\\n  more control. This function is identical to glNormal3f() in OpenGL.\"],\"~$perspective\",[\"^ \",\"^A\",\"Lights, Camera\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Lights, Camera\",\"^D\",\"1.0\",\"^E\",\"Camera\",\"^F\",\"^6\",\"^G\",14,\"^14\",[\"^ \",\"^S\",false,\"^W\",4,\"^T\",[\"^N\",[[],[\"~$fovy\",\"~$aspect\",\"~$z-near\",\"~$z-far\"]]],\"^M\",[\"^N\",[[],[\"^;H\",\"^;I\",\"^;J\",\"^;K\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"perspective()\",\"^I\",3,\"^J\",true,\"^K\",2881,\"^L\",2881,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[],[\"^;H\",\"^;I\",\"^;J\",\"^;K\"]]]]],\"^Q\",\"Sets a perspective projection applying foreshortening, making\\n  distant objects appear smaller than closer ones. The parameters\\n  define a viewing volume with the shape of truncated pyramid. Objects\\n  near to the front of the volume appear their actual size, while\\n  farther objects appear smaller. This projection simulates the\\n  perspective of the world more accurately than orthographic\\n  projection. The version of perspective without parameters sets the\\n  default perspective and the version with four parameters allows the\\n  programmer to set the area precisely. The default values are:\\n  perspective(PI/3.0, width/height, cameraZ/10.0, cameraZ*10.0) where\\n  cameraZ is ((height/2.0) / tan(PI*60.0/360.0));\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/perspective\",\"^S\",false,\"^E\",\"Camera\",\"^F\",\"quil/core.cljc\",\"^G\",14,\"^14\",[\"^ \",\"^S\",false,\"^W\",4,\"^T\",[\"^N\",[[],[\"^;H\",\"^;I\",\"^;J\",\"^;K\"]]],\"^M\",[\"^N\",[[],[\"^;H\",\"^;I\",\"^;J\",\"^;K\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"perspective()\",\"^T\",[\"^N\",[[],[\"^;H\",\"^;I\",\"^;J\",\"^;K\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",2875,\"^L\",2881,\"^W\",4,\"^X\",true,\"^M\",[\"^N\",[[],[\"^;H\",\"^;I\",\"^;J\",\"^;K\"]]],\"^Q\",\"Sets a perspective projection applying foreshortening, making\\n  distant objects appear smaller than closer ones. The parameters\\n  define a viewing volume with the shape of truncated pyramid. Objects\\n  near to the front of the volume appear their actual size, while\\n  farther objects appear smaller. This projection simulates the\\n  perspective of the world more accurately than orthographic\\n  projection. The version of perspective without parameters sets the\\n  default perspective and the version with four parameters allows the\\n  programmer to set the area precisely. The default values are:\\n  perspective(PI/3.0, width/height, cameraZ/10.0, cameraZ*10.0) where\\n  cameraZ is ((height/2.0) / tan(PI*60.0/360.0));\"],\"~$seconds\",[\"^ \",\"^A\",\"Input\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Input\",\"^D\",\"1.0\",\"^E\",\"Time & Date\",\"^F\",\"^6\",\"^G\",10,\"^H\",\"second()\",\"^I\",3,\"^J\",false,\"^K\",3656,\"^L\",3656,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Returns the current second as a value from 0 - 59.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/seconds\",\"^S\",false,\"^E\",\"Time & Date\",\"^F\",\"quil/core.cljc\",\"^G\",10,\"^H\",\"second()\",\"^T\",[\"^N\",[[]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",false,\"^K\",3650,\"^L\",3656,\"^W\",0,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Returns the current second as a value from 0 - 59.\"],\"~$hint\",[\"^ \",\"^A\",\"Rendering\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Rendering\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^6\",\"^G\",7,\"^H\",\"hint()\",\"^I\",3,\"^3X\",null,\"^J\",true,\"^K\",1983,\"^L\",1983,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$hint-type\"]]]]],\"^Q\",\"Set various hints and hacks for the renderer. This is used to\\n  handle obscure rendering features that cannot be implemented in a\\n  consistent manner across renderers. Many options will often graduate\\n  to standard features instead of hints over time.\\n\\n  Options:\\n\\n  :enable-native-fonts - Use the native version fonts when they are\\n    installed, rather than the bitmapped version from a .vlw\\n    file. This is useful with the default (or JAVA2D) renderer\\n    setting, as it will improve font rendering speed. This is not\\n    enabled by default, because it can be misleading while testing\\n    because the type will look great on your machine (because you have\\n    the font installed) but lousy on others' machines if the identical\\n    font is unavailable. This option can only be set per-sketch, and\\n    must be called before any use of text-font.\\n\\n  :disable-native-fonts - Disables native font support.\\n\\n  :disable-depth-test - Disable the zbuffer, allowing you to draw on\\n    top of everything at will. When depth testing is disabled, items\\n    will be drawn to the screen sequentially, like a painting. This\\n    hint is most often used to draw in 3D, then draw in 2D on top of\\n    it (for instance, to draw GUI controls in 2D on top of a 3D\\n    interface). Starting in release 0149, this will also clear the\\n    depth buffer. Restore the default with :enable-depth-test\\n    but note that with the depth buffer cleared, any 3D drawing that\\n    happens later in draw will ignore existing shapes on the screen.\\n\\n  :enable-depth-test - Enables the zbuffer.\\n\\n  :enable-depth-sort - Enable primitive z-sorting of triangles and\\n    lines in :p3d and :opengl rendering modes. This can slow\\n    performance considerably, and the algorithm is not yet perfect.\\n\\n  :disable-depth-sort - Disables hint :enable-depth-sort\\n\\n  :disable-opengl-errors - Speeds up the OPENGL renderer setting\\n     by not checking for errors while running.\\n\\n  :enable-opengl-errors - Turns on OpenGL error checking\\n\\n  :enable-depth-mask\\n  :disable-depth-mask\\n\\n  :enable-optimized-stroke\\n  :disable-optimized-stroke\\n  :enable-retina-pixels\\n  :disable-retina-pixels\\n  :enable-stroke-perspective\\n  :disable-stroke-perspective\\n  :enable-stroke-pure\\n  :disable-stroke-pure\\n  :enable-texture-mipmaps\\n  :disable-texture-mipmaps\\n\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/hint\",\"^S\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^G\",7,\"^H\",\"hint()\",\"^T\",[\"^N\",[[\"^;P\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^3X\",null,\"^J\",true,\"^K\",1976,\"^L\",1983,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^;P\"]]]]],\"^Q\",\"Set various hints and hacks for the renderer. This is used to\\n  handle obscure rendering features that cannot be implemented in a\\n  consistent manner across renderers. Many options will often graduate\\n  to standard features instead of hints over time.\\n\\n  Options:\\n\\n  :enable-native-fonts - Use the native version fonts when they are\\n    installed, rather than the bitmapped version from a .vlw\\n    file. This is useful with the default (or JAVA2D) renderer\\n    setting, as it will improve font rendering speed. This is not\\n    enabled by default, because it can be misleading while testing\\n    because the type will look great on your machine (because you have\\n    the font installed) but lousy on others' machines if the identical\\n    font is unavailable. This option can only be set per-sketch, and\\n    must be called before any use of text-font.\\n\\n  :disable-native-fonts - Disables native font support.\\n\\n  :disable-depth-test - Disable the zbuffer, allowing you to draw on\\n    top of everything at will. When depth testing is disabled, items\\n    will be drawn to the screen sequentially, like a painting. This\\n    hint is most often used to draw in 3D, then draw in 2D on top of\\n    it (for instance, to draw GUI controls in 2D on top of a 3D\\n    interface). Starting in release 0149, this will also clear the\\n    depth buffer. Restore the default with :enable-depth-test\\n    but note that with the depth buffer cleared, any 3D drawing that\\n    happens later in draw will ignore existing shapes on the screen.\\n\\n  :enable-depth-test - Enables the zbuffer.\\n\\n  :enable-depth-sort - Enable primitive z-sorting of triangles and\\n    lines in :p3d and :opengl rendering modes. This can slow\\n    performance considerably, and the algorithm is not yet perfect.\\n\\n  :disable-depth-sort - Disables hint :enable-depth-sort\\n\\n  :disable-opengl-errors - Speeds up the OPENGL renderer setting\\n     by not checking for errors while running.\\n\\n  :enable-opengl-errors - Turns on OpenGL error checking\\n\\n  :enable-depth-mask\\n  :disable-depth-mask\\n\\n  :enable-optimized-stroke\\n  :disable-optimized-stroke\\n  :enable-retina-pixels\\n  :disable-retina-pixels\\n  :enable-stroke-perspective\\n  :disable-stroke-perspective\\n  :enable-stroke-pure\\n  :disable-stroke-pure\\n  :enable-texture-mipmaps\\n  :disable-texture-mipmaps\\n\"],\"~$sphere-detail\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"3D Primitives\",\"^F\",\"^6\",\"^G\",16,\"^14\",[\"^ \",\"^S\",false,\"^W\",2,\"^T\",[\"^N\",[[\"~$res\"],[\"~$ures\",\"~$vres\"]]],\"^M\",[\"^N\",[[\"^;S\"],[\"^;T\",\"^;U\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"sphereDetail()\",\"^I\",3,\"^J\",true,\"^K\",3905,\"^L\",3905,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^;S\"],[\"^;T\",\"^;U\"]]]]],\"^Q\",\"Controls the detail used to render a sphere by adjusting the number\\n  of vertices of the sphere mesh. The default resolution is 30, which\\n  creates a fairly detailed sphere definition with vertices every\\n  360/30 = 12 degrees. If you're going to render a great number of\\n  spheres per frame, it is advised to reduce the level of detail using\\n  this function. The setting stays active until sphere-detail is\\n  called again with a new parameter and so should not be called prior\\n  to every sphere statement, unless you wish to render spheres with\\n  different settings, e.g. using less detail for smaller spheres or\\n  ones further away from the camera. To controla the detail of the\\n  horizontal and vertical resolution independently, use the version of\\n  the functions with two parameters.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/sphere-detail\",\"^S\",false,\"^E\",\"3D Primitives\",\"^F\",\"quil/core.cljc\",\"^G\",16,\"^14\",[\"^ \",\"^S\",false,\"^W\",2,\"^T\",[\"^N\",[[\"^;S\"],[\"^;T\",\"^;U\"]]],\"^M\",[\"^N\",[[\"^;S\"],[\"^;T\",\"^;U\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"sphereDetail()\",\"^T\",[\"^N\",[[\"^;S\"],[\"^;T\",\"^;U\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",3899,\"^L\",3905,\"^W\",2,\"^X\",true,\"^M\",[\"^N\",[[\"^;S\"],[\"^;T\",\"^;U\"]]],\"^Q\",\"Controls the detail used to render a sphere by adjusting the number\\n  of vertices of the sphere mesh. The default resolution is 30, which\\n  creates a fairly detailed sphere definition with vertices every\\n  360/30 = 12 degrees. If you're going to render a great number of\\n  spheres per frame, it is advised to reduce the level of detail using\\n  this function. The setting stays active until sphere-detail is\\n  called again with a new parameter and so should not be called prior\\n  to every sphere statement, unless you wish to render spheres with\\n  different settings, e.g. using less detail for smaller spheres or\\n  ones further away from the camera. To controla the detail of the\\n  horizontal and vertical resolution independently, use the version of\\n  the functions with two parameters.\"],\"~$vertex\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"Vertex\",\"^F\",\"^6\",\"^G\",9,\"^14\",[\"^ \",\"^S\",false,\"^W\",5,\"^T\",[\"^N\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"],[\"~$x\",\"~$y\",\"~$u\",\"~$v\"],[\"~$x\",\"~$y\",\"~$z\",\"~$u\",\"~$v\"]]],\"^M\",[\"^N\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"],[\"~$x\",\"~$y\",\"~$u\",\"~$v\"],[\"~$x\",\"~$y\",\"~$z\",\"~$u\",\"~$v\"]]],\"^V\",[\"^N\",[null,null,null,null]]],\"^H\",\"vertex()\",\"^I\",3,\"^J\",true,\"^K\",4552,\"^L\",4552,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"],[\"~$x\",\"~$y\",\"~$u\",\"~$v\"],[\"~$x\",\"~$y\",\"~$z\",\"~$u\",\"~$v\"]]]]],\"^Q\",\"All shapes are constructed by connecting a series of\\n  vertices. vertex is used to specify the vertex coordinates for\\n  points, lines, triangles, quads, and polygons and is used\\n  exclusively within the begin-shape and end-shape fns.\\n\\n  Drawing a vertex in 3D using the z parameter requires the :p3d or\\n  :opengl renderers to be used.\\n\\n  This function is also used to map a texture onto the geometry. The\\n  texture fn declares the texture to apply to the geometry and the u\\n  and v coordinates set define the mapping of this texture to the\\n  form. By default, the coordinates used for u and v are specified in\\n  relation to the image's size in pixels, but this relation can be\\n  changed with texture-mode.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/vertex\",\"^S\",false,\"^E\",\"Vertex\",\"^F\",\"quil/core.cljc\",\"^G\",9,\"^14\",[\"^ \",\"^S\",false,\"^W\",5,\"^T\",[\"^N\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"],[\"~$x\",\"~$y\",\"~$u\",\"~$v\"],[\"~$x\",\"~$y\",\"~$z\",\"~$u\",\"~$v\"]]],\"^M\",[\"^N\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"],[\"~$x\",\"~$y\",\"~$u\",\"~$v\"],[\"~$x\",\"~$y\",\"~$z\",\"~$u\",\"~$v\"]]],\"^V\",[\"^N\",[null,null,null,null]]],\"^H\",\"vertex()\",\"^T\",[\"^N\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"],[\"~$x\",\"~$y\",\"~$u\",\"~$v\"],[\"~$x\",\"~$y\",\"~$z\",\"~$u\",\"~$v\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null,null,null]],\"^I\",1,\"^J\",true,\"^K\",4546,\"^L\",4552,\"^W\",5,\"^X\",true,\"^M\",[\"^N\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"],[\"~$x\",\"~$y\",\"~$u\",\"~$v\"],[\"~$x\",\"~$y\",\"~$z\",\"~$u\",\"~$v\"]]],\"^Q\",\"All shapes are constructed by connecting a series of\\n  vertices. vertex is used to specify the vertex coordinates for\\n  points, lines, triangles, quads, and polygons and is used\\n  exclusively within the begin-shape and end-shape fns.\\n\\n  Drawing a vertex in 3D using the z parameter requires the :p3d or\\n  :opengl renderers to be used.\\n\\n  This function is also used to map a texture onto the geometry. The\\n  texture fn declares the texture to apply to the geometry and the u\\n  and v coordinates set define the mapping of this texture to the\\n  form. By default, the coordinates used for u and v are specified in\\n  relation to the image's size in pixels, but this relation can be\\n  changed with texture-mode.\"],\"~$delay-frame\",[\"^ \",\"^A\",\"Structure\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Structure\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^6\",\"^G\",14,\"^H\",\"delay()\",\"^I\",3,\"^3X\",null,\"^J\",true,\"^K\",1456,\"^L\",1456,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$freeze-ms\"]]]]],\"^Q\",\"Forces the program to stop running for a specified time. Delay\\n  times are specified in thousandths of a second, therefore the\\n  function call (delay 3000) will stop the program for three\\n  seconds. Because the screen is updated only at the end of draw,\\n  the program may appear to 'freeze', because the screen will not\\n  update when the delay fn is used. This function has no affect\\n  inside setup.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/delay-frame\",\"^S\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^G\",14,\"^H\",\"delay()\",\"^T\",[\"^N\",[[\"^;Z\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^3X\",null,\"^J\",true,\"^K\",1449,\"^L\",1456,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^;Z\"]]]]],\"^Q\",\"Forces the program to stop running for a specified time. Delay\\n  times are specified in thousandths of a second, therefore the\\n  function call (delay 3000) will stop the program for three\\n  seconds. Because the screen is updated only at the end of draw,\\n  the program may appear to 'freeze', because the screen will not\\n  update when the delay fn is used. This function has no affect\\n  inside setup.\"],\"~$horizontal-alignment-modes\",[\"^ \",\"^5\",\"~$quil.core/horizontal-alignment-modes\",\"^F\",\"quil/core.cljc\",\"^K\",45,\"^I\",1,\"^L\",66,\"^G\",28,\"^C\",[\"^ \",\"^F\",\"^6\",\"^K\",66,\"^I\",2,\"^L\",66,\"^G\",28]],\"~$spot-light\",[\"^ \",\"^A\",\"Lights, Camera\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Lights, Camera\",\"^D\",\"1.0\",\"^E\",\"Lights\",\"^F\",\"^6\",\"^G\",13,\"^14\",[\"^ \",\"^S\",false,\"^W\",11,\"^T\",[\"^N\",[[\"~$r\",\"~$g\",\"~$b\",\"~$x\",\"~$y\",\"~$z\",\"^5E\",\"^5F\",\"^5G\",\"^P\",\"~$concentration\"],[[\"~$r\",\"~$g\",\"~$b\"],[\"~$x\",\"~$y\",\"~$z\"],[\"^5E\",\"^5F\",\"^5G\"],\"^P\",\"^<3\"]]],\"^M\",[\"^N\",[[\"~$r\",\"~$g\",\"~$b\",\"~$x\",\"~$y\",\"~$z\",\"^5E\",\"^5F\",\"^5G\",\"^P\",\"^<3\"],[[\"~$r\",\"~$g\",\"~$b\"],[\"~$x\",\"~$y\",\"~$z\"],[\"^5E\",\"^5F\",\"^5G\"],\"^P\",\"^<3\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"spotLight()\",\"^I\",3,\"^J\",true,\"^K\",3927,\"^L\",3927,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$r\",\"~$g\",\"~$b\",\"~$x\",\"~$y\",\"~$z\",\"^5E\",\"^5F\",\"^5G\",\"^P\",\"^<3\"],[[\"~$r\",\"~$g\",\"~$b\"],[\"~$x\",\"~$y\",\"~$z\"],[\"^5E\",\"^5F\",\"^5G\"],\"^P\",\"^<3\"]]]]],\"^Q\",\"Adds a spot light. Lights need to be included in the draw to\\n  remain persistent in a looping program. Placing them in the setup\\n  of a looping program will cause them to only have an effect the\\n  first time through the loop. The affect of the r, g, and b\\n  parameters is determined by the current color mode. The x, y, and z\\n  parameters specify the position of the light and nx, ny, nz specify\\n  the direction or light. The angle parameter affects angle of the\\n  spotlight cone.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/spot-light\",\"^S\",false,\"^E\",\"Lights\",\"^F\",\"quil/core.cljc\",\"^G\",13,\"^14\",[\"^ \",\"^S\",false,\"^W\",11,\"^T\",[\"^N\",[[\"~$r\",\"~$g\",\"~$b\",\"~$x\",\"~$y\",\"~$z\",\"^5E\",\"^5F\",\"^5G\",\"^P\",\"^<3\"],[[\"~$r\",\"~$g\",\"~$b\"],[\"~$x\",\"~$y\",\"~$z\"],[\"^5E\",\"^5F\",\"^5G\"],\"^P\",\"^<3\"]]],\"^M\",[\"^N\",[[\"~$r\",\"~$g\",\"~$b\",\"~$x\",\"~$y\",\"~$z\",\"^5E\",\"^5F\",\"^5G\",\"^P\",\"^<3\"],[[\"~$r\",\"~$g\",\"~$b\"],[\"~$x\",\"~$y\",\"~$z\"],[\"^5E\",\"^5F\",\"^5G\"],\"^P\",\"^<3\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"spotLight()\",\"^T\",[\"^N\",[[\"~$r\",\"~$g\",\"~$b\",\"~$x\",\"~$y\",\"~$z\",\"^5E\",\"^5F\",\"^5G\",\"^P\",\"^<3\"],[[\"~$r\",\"~$g\",\"~$b\"],[\"~$x\",\"~$y\",\"~$z\"],[\"^5E\",\"^5F\",\"^5G\"],\"^P\",\"^<3\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",3921,\"^L\",3927,\"^W\",11,\"^X\",true,\"^M\",[\"^N\",[[\"~$r\",\"~$g\",\"~$b\",\"~$x\",\"~$y\",\"~$z\",\"^5E\",\"^5F\",\"^5G\",\"^P\",\"^<3\"],[[\"~$r\",\"~$g\",\"~$b\"],[\"~$x\",\"~$y\",\"~$z\"],[\"^5E\",\"^5F\",\"^5G\"],\"^P\",\"^<3\"]]],\"^Q\",\"Adds a spot light. Lights need to be included in the draw to\\n  remain persistent in a looping program. Placing them in the setup\\n  of a looping program will cause them to only have an effect the\\n  first time through the loop. The affect of the r, g, and b\\n  parameters is determined by the current color mode. The x, y, and z\\n  parameters specify the position of the light and nx, ny, nz specify\\n  the direction or light. The angle parameter affects angle of the\\n  spotlight cone.\"],\"~$target-frame-rate\",[\"^ \",\"^A\",\"Environment\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Environment\",\"^D\",\"1.5.0\",\"^E\",null,\"^F\",\"^6\",\"^G\",20,\"^I\",3,\"^J\",true,\"^K\",4098,\"^L\",4098,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Returns the target framerate specified with the fn frame-rate\"],\"^D\",\"1.5.0\",\"^5\",\"~$quil.core/target-frame-rate\",\"^S\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^G\",20,\"^T\",[\"^N\",[[]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",4093,\"^L\",4098,\"^W\",0,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Returns the target framerate specified with the fn frame-rate\"],\"~$tint\",[\"^ \",\"^A\",\"Image\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Image\",\"^D\",\"1.0\",\"^E\",\"Loading & Displaying\",\"^F\",\"^6\",\"^G\",7,\"^14\",[\"^ \",\"^S\",false,\"^W\",4,\"^T\",[\"^N\",[[\"^39\"],[\"^39\",\"^2>\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^M\",[\"^N\",[[\"^39\"],[\"^39\",\"^2>\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^V\",[\"^N\",[null,null,null,null]]],\"^H\",\"tint()\",\"^I\",3,\"^J\",true,\"^K\",4433,\"^L\",4433,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^39\"],[\"^39\",\"^2>\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]]]],\"^Q\",\"Sets the fill value for displaying images. Images can be tinted to\\n  specified colors or made transparent by setting the alpha.\\n\\n  To make an image transparent, but not change it's color, use white\\n  as the tint color and specify an alpha value. For instance,\\n  tint(255, 128) will make an image 50% transparent (unless\\n  colorMode() has been used).\\n\\n  The value for the parameter gray must be less than or equal to the\\n  current maximum value as specified by colorMode(). The default\\n  maximum value is 255.\\n\\n  Also used to control the coloring of textures in 3D.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/tint\",\"^S\",false,\"^E\",\"Loading & Displaying\",\"^F\",\"quil/core.cljc\",\"^G\",7,\"^14\",[\"^ \",\"^S\",false,\"^W\",4,\"^T\",[\"^N\",[[\"^39\"],[\"^39\",\"^2>\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^M\",[\"^N\",[[\"^39\"],[\"^39\",\"^2>\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^V\",[\"^N\",[null,null,null,null]]],\"^H\",\"tint()\",\"^T\",[\"^N\",[[\"^39\"],[\"^39\",\"^2>\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null,null,null]],\"^I\",1,\"^J\",true,\"^K\",4427,\"^L\",4433,\"^W\",4,\"^X\",true,\"^M\",[\"^N\",[[\"^39\"],[\"^39\",\"^2>\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^Q\",\"Sets the fill value for displaying images. Images can be tinted to\\n  specified colors or made transparent by setting the alpha.\\n\\n  To make an image transparent, but not change it's color, use white\\n  as the tint color and specify an alpha value. For instance,\\n  tint(255, 128) will make an image 50% transparent (unless\\n  colorMode() has been used).\\n\\n  The value for the parameter gray must be less than or equal to the\\n  current maximum value as specified by colorMode(). The default\\n  maximum value is 255.\\n\\n  Also used to control the coloring of textures in 3D.\"],\"~$bezier-tangent\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"Curves\",\"^F\",\"^6\",\"^G\",17,\"^H\",\"bezierTangent()\",\"^I\",3,\"^J\",true,\"^K\",722,\"^L\",722,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$t\"]]]]],\"^Q\",\"Calculates the tangent of a point on a Bezier curve.\\n  (See http://en.wikipedia.org/wiki/Tangent)\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/bezier-tangent\",\"^S\",false,\"^E\",\"Curves\",\"^F\",\"quil/core.cljc\",\"^G\",17,\"^H\",\"bezierTangent()\",\"^T\",[\"^N\",[[\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$t\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",716,\"^L\",722,\"^W\",5,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$t\"]]]]],\"^Q\",\"Calculates the tangent of a point on a Bezier curve.\\n  (See http://en.wikipedia.org/wiki/Tangent)\"],\"~$asin\",[\"^ \",\"^A\",\"Math\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Math\",\"^D\",\"1.0\",\"^E\",\"Trigonometry\",\"^F\",\"^6\",\"^G\",7,\"^H\",\"asin()\",\"^I\",3,\"^J\",false,\"^K\",444,\"^L\",444,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$n\"]]]]],\"^Q\",\"The inverse of sin, returns the arc sine of a value. This function\\n  expects the values in the range of -1 to 1 and values are returned\\n  in the range -PI/2 to PI/2.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/asin\",\"^S\",false,\"^E\",\"Trigonometry\",\"^F\",\"quil/core.cljc\",\"^G\",7,\"^H\",\"asin()\",\"^T\",[\"^N\",[[\"~$n\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",false,\"^K\",438,\"^L\",444,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$n\"]]]]],\"^Q\",\"The inverse of sin, returns the arc sine of a value. This function\\n  expects the values in the range of -1 to 1 and values are returned\\n  in the range -PI/2 to PI/2.\"],\"~$lerp\",[\"^ \",\"^A\",\"Math\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Math\",\"^D\",\"1.0\",\"^E\",\"Calculation\",\"^F\",\"^6\",\"^G\",7,\"^H\",\"lerp()\",\"^I\",3,\"^J\",false,\"^K\",2267,\"^L\",2267,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^7L\",\"^7M\",\"^2A\"]]]]],\"^Q\",\"Calculates a number between two numbers at a specific\\n  increment. The amt parameter is the amount to interpolate between\\n  the two values where 0.0 equal to the first point, 0.1 is very near\\n  the first point, 0.5 is half-way in between, etc. The lerp function\\n  is convenient for creating motion along a straight path and for\\n  drawing dotted lines.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/lerp\",\"^S\",false,\"^E\",\"Calculation\",\"^F\",\"quil/core.cljc\",\"^G\",7,\"^H\",\"lerp()\",\"^T\",[\"^N\",[[\"^7L\",\"^7M\",\"^2A\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",false,\"^K\",2261,\"^L\",2267,\"^W\",3,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^7L\",\"^7M\",\"^2A\"]]]]],\"^Q\",\"Calculates a number between two numbers at a specific\\n  increment. The amt parameter is the amount to interpolate between\\n  the two values where 0.0 equal to the first point, 0.1 is very near\\n  the first point, 0.5 is half-way in between, etc. The lerp function\\n  is convenient for creating motion along a straight path and for\\n  drawing dotted lines.\"],\"~$unhex\",[\"^ \",\"^A\",\"Data\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Data\",\"^4?\",false,\"^E\",\"Conversion\",\"^F\",\"^6\",\"^G\",8,\"^H\",\"hex()\",\"^I\",3,\"^K\",4510,\"^L\",4510,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$hex-str\"]]]]],\"^Q\",\"Converts a String representation of a hexadecimal number to its\\n  equivalent integer value.\"],\"^4?\",false,\"^5\",\"~$quil.core/unhex\",\"^S\",false,\"^E\",\"Conversion\",\"^F\",\"quil/core.cljc\",\"^G\",8,\"^H\",\"hex()\",\"^T\",[\"^N\",[[\"^<@\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^K\",4505,\"^L\",4510,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^<@\"]]]]],\"^Q\",\"Converts a String representation of a hexadecimal number to its\\n  equivalent integer value.\"],\"~$begin-camera\",[\"^ \",\"^A\",\"Lights, Camera\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Lights, Camera\",\"^D\",\"1.0\",\"^E\",\"Camera\",\"^F\",\"^6\",\"^G\",15,\"^H\",\"beginCamera()\",\"^I\",3,\"^J\",true,\"^K\",585,\"^L\",585,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Sets the matrix mode to the camera matrix so calls such as\\n  translate, rotate, apply-matrix and reset-matrix affect the\\n  camera. begin-camera should always be used with a following\\n  end-camera and pairs of begin-camera and end-camera cannot be\\n  nested.\\n\\n  For most situations the camera function will be sufficient.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/begin-camera\",\"^S\",false,\"^E\",\"Camera\",\"^F\",\"quil/core.cljc\",\"^G\",15,\"^H\",\"beginCamera()\",\"^T\",[\"^N\",[[]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",579,\"^L\",585,\"^W\",0,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Sets the matrix mode to the camera matrix so calls such as\\n  translate, rotate, apply-matrix and reset-matrix affect the\\n  camera. begin-camera should always be used with a following\\n  end-camera and pairs of begin-camera and end-camera cannot be\\n  nested.\\n\\n  For most situations the camera function will be sufficient.\"],\"~$text-num\",[\"^ \",\"^A\",\"Typography\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Typography\",\"^D\",\"1.0\",\"^E\",\"Loading & Displaying\",\"^F\",\"^6\",\"^G\",11,\"^14\",[\"^ \",\"^S\",false,\"^W\",4,\"^T\",[\"^N\",[[\"^9J\",\"~$x\",\"~$y\"],[\"^9J\",\"~$x\",\"~$y\",\"~$z\"]]],\"^M\",[\"^N\",[[\"^9J\",\"~$x\",\"~$y\"],[\"^9J\",\"~$x\",\"~$y\",\"~$z\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"text()\",\"^I\",3,\"^J\",true,\"^K\",4132,\"^L\",4132,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^9J\",\"~$x\",\"~$y\"],[\"^9J\",\"~$x\",\"~$y\",\"~$z\"]]]]],\"^Q\",\"Draws a number to the screen in the specified position. See text fn\\n  for more details.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/text-num\",\"^S\",false,\"^E\",\"Loading & Displaying\",\"^F\",\"quil/core.cljc\",\"^G\",11,\"^14\",[\"^ \",\"^S\",false,\"^W\",4,\"^T\",[\"^N\",[[\"^9J\",\"~$x\",\"~$y\"],[\"^9J\",\"~$x\",\"~$y\",\"~$z\"]]],\"^M\",[\"^N\",[[\"^9J\",\"~$x\",\"~$y\"],[\"^9J\",\"~$x\",\"~$y\",\"~$z\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"text()\",\"^T\",[\"^N\",[[\"^9J\",\"~$x\",\"~$y\"],[\"^9J\",\"~$x\",\"~$y\",\"~$z\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",4126,\"^L\",4132,\"^W\",4,\"^X\",true,\"^M\",[\"^N\",[[\"^9J\",\"~$x\",\"~$y\"],[\"^9J\",\"~$x\",\"~$y\",\"~$z\"]]],\"^Q\",\"Draws a number to the screen in the specified position. See text fn\\n  for more details.\"],\"~$round\",[\"^ \",\"^A\",\"Math\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Math\",\"^D\",\"1.0\",\"^E\",\"Calculation\",\"^F\",\"^6\",\"^G\",8,\"^H\",\"round()\",\"^I\",3,\"^J\",false,\"^K\",3499,\"^L\",3499,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^2P\"]]]]],\"^Q\",\"Calculates the integer closest to the value parameter. For example,\\n  (round 9.2) returns the value 9.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/round\",\"^S\",false,\"^E\",\"Calculation\",\"^F\",\"quil/core.cljc\",\"^G\",8,\"^H\",\"round()\",\"^T\",[\"^N\",[[\"^2P\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",false,\"^K\",3493,\"^L\",3499,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^2P\"]]]]],\"^Q\",\"Calculates the integer closest to the value parameter. For example,\\n  (round 9.2) returns the value 9.\"],\"~$background-image\",[\"^ \",\"^A\",\"Color\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Color\",\"^D\",\"1.0\",\"^E\",\"Setting\",\"^F\",\"^6\",\"^G\",19,\"^H\",\"background()\",\"^I\",3,\"^J\",true,\"^K\",572,\"^L\",572,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^1Y\"]]]]],\"^Q\",\"Specify an image to be used as the background for a sketch. Its\\n  width and height must be the same size as the sketch window. Images\\n  used as background will ignore the current tint setting.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/background-image\",\"^S\",false,\"^E\",\"Setting\",\"^F\",\"quil/core.cljc\",\"^G\",19,\"^H\",\"background()\",\"^T\",[\"^N\",[[\"^1Y\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",566,\"^L\",572,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^1Y\"]]]]],\"^Q\",\"Specify an image to be used as the background for a sketch. Its\\n  width and height must be the same size as the sketch window. Images\\n  used as background will ignore the current tint setting.\"],\"~$load-shape\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"Loading & Displaying\",\"^F\",\"^6\",\"^G\",13,\"^H\",\"loadShape()\",\"^I\",3,\"^J\",true,\"^K\",2417,\"^L\",2417,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^4L\"]]]]],\"^Q\",\"Load a geometry from a file as a PShape.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/load-shape\",\"^S\",false,\"^E\",\"Loading & Displaying\",\"^F\",\"quil/core.cljc\",\"^G\",13,\"^H\",\"loadShape()\",\"^T\",[\"^N\",[[\"^4L\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",2411,\"^L\",2417,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^4L\"]]]]],\"^Q\",\"Load a geometry from a file as a PShape.\"],\"~$vertical-alignment-modes\",[\"^ \",\"^5\",\"~$quil.core/vertical-alignment-modes\",\"^F\",\"quil/core.cljc\",\"^K\",45,\"^I\",1,\"^L\",67,\"^G\",26,\"^C\",[\"^ \",\"^F\",\"^6\",\"^K\",67,\"^I\",2,\"^L\",67,\"^G\",26]],\"~$blend-color\",[\"^ \",\"^A\",\"Color\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Color\",\"^D\",\"1.0\",\"^E\",\"Creating & Reading\",\"^F\",\"^6\",\"^G\",14,\"^H\",\"blendColor()\",\"^I\",3,\"^3X\",null,\"^J\",false,\"^K\",828,\"^L\",828,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^3D\",\"^3E\",\"^17\"]]]]],\"^Q\",\"Blends two color values together based on the blending mode given specified\\n  with the mode keyword.\\n\\n  Available blend modes are:\\n\\n  :blend      - linear interpolation of colours: C = A*factor + B\\n  :add        - additive blending with white clip:\\n                                            C = min(A*factor + B, 255)\\n  :subtract   - subtractive blending with black clip:\\n                                            C = max(B - A*factor, 0)\\n  :darkest    - only the darkest colour succeeds:\\n                                            C = min(A*factor, B)\\n  :lightest   - only the lightest colour succeeds:\\n                                            C = max(A*factor, B)\\n  :difference - subtract colors from underlying image.\\n  :exclusion  - similar to :difference, but less extreme.\\n  :multiply   - Multiply the colors, result will always be darker.\\n  :screen     - Opposite multiply, uses inverse values of the colors.\\n  :overlay    - A mix of :multiply and :screen. Multiplies dark values\\n                and screens light values.\\n  :hard-light - :screen when greater than 50% gray, :multiply when\\n                lower.\\n  :soft-light - Mix of :darkest and :lightest. Works like :overlay,\\n                but not as harsh.\\n  :dodge      - Lightens light tones and increases contrast, ignores\\n                darks.\\n                Called \\\"Color Dodge\\\" in Illustrator and Photoshop.\\n  :burn       - Darker areas are applied, increasing contrast, ignores\\n                lights. Called \\\"Color Burn\\\" in Illustrator and\\n                Photoshop.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/blend-color\",\"^S\",false,\"^E\",\"Creating & Reading\",\"^F\",\"quil/core.cljc\",\"^G\",14,\"^H\",\"blendColor()\",\"^T\",[\"^N\",[[\"^3D\",\"^3E\",\"^17\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^3X\",null,\"^J\",false,\"^K\",821,\"^L\",828,\"^W\",3,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^3D\",\"^3E\",\"^17\"]]]]],\"^Q\",\"Blends two color values together based on the blending mode given specified\\n  with the mode keyword.\\n\\n  Available blend modes are:\\n\\n  :blend      - linear interpolation of colours: C = A*factor + B\\n  :add        - additive blending with white clip:\\n                                            C = min(A*factor + B, 255)\\n  :subtract   - subtractive blending with black clip:\\n                                            C = max(B - A*factor, 0)\\n  :darkest    - only the darkest colour succeeds:\\n                                            C = min(A*factor, B)\\n  :lightest   - only the lightest colour succeeds:\\n                                            C = max(A*factor, B)\\n  :difference - subtract colors from underlying image.\\n  :exclusion  - similar to :difference, but less extreme.\\n  :multiply   - Multiply the colors, result will always be darker.\\n  :screen     - Opposite multiply, uses inverse values of the colors.\\n  :overlay    - A mix of :multiply and :screen. Multiplies dark values\\n                and screens light values.\\n  :hard-light - :screen when greater than 50% gray, :multiply when\\n                lower.\\n  :soft-light - Mix of :darkest and :lightest. Works like :overlay,\\n                but not as harsh.\\n  :dodge      - Lightens light tones and increases contrast, ignores\\n                darks.\\n                Called \\\"Color Dodge\\\" in Illustrator and Photoshop.\\n  :burn       - Darker areas are applied, increasing contrast, ignores\\n                lights. Called \\\"Color Burn\\\" in Illustrator and\\n                Photoshop.\"],\"~$QUARTER-PI\",[\"^ \",\"^5\",\"~$quil.core/QUARTER-PI\",\"^F\",\"quil/core.cljc\",\"^K\",79,\"^I\",1,\"^L\",79,\"^G\",16,\"^C\",[\"^ \",\"^F\",\"^6\",\"^K\",79,\"^I\",6,\"^L\",79,\"^G\",16]],\"~$stroke-cap\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"Attributes\",\"^F\",\"^6\",\"^G\",13,\"^H\",\"strokeCap()\",\"^I\",3,\"^J\",true,\"^K\",4036,\"^L\",4036,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$cap-mode\"]]]]],\"^Q\",\"Sets the style for rendering line endings. These ends are either\\n  squared, extended, or rounded and specified with the corresponding\\n  parameters :square, :project, and :round. The default cap is :round.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/stroke-cap\",\"^S\",false,\"^E\",\"Attributes\",\"^F\",\"quil/core.cljc\",\"^G\",13,\"^H\",\"strokeCap()\",\"^T\",[\"^N\",[[\"^<S\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",4030,\"^L\",4036,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^<S\"]]]]],\"^Q\",\"Sets the style for rendering line endings. These ends are either\\n  squared, extended, or rounded and specified with the corresponding\\n  parameters :square, :project, and :round. The default cap is :round.\"],\"~$blend-modes\",[\"^ \",\"^5\",\"~$quil.core/blend-modes\",\"^F\",\"quil/core.cljc\",\"^K\",45,\"^I\",1,\"^L\",48,\"^G\",13,\"^C\",[\"^ \",\"^F\",\"^6\",\"^K\",48,\"^I\",2,\"^L\",48,\"^G\",13]],\"~$no-fill\",[\"^ \",\"^A\",\"Color\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Color\",\"^D\",\"1.0\",\"^E\",\"Setting\",\"^F\",\"^6\",\"^G\",10,\"^H\",\"noFill()\",\"^I\",3,\"^J\",true,\"^K\",2664,\"^L\",2664,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Disables filling geometry. If both no-stroke and no-fill are called,\\n  nothing will be drawn to the screen.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/no-fill\",\"^S\",false,\"^E\",\"Setting\",\"^F\",\"quil/core.cljc\",\"^G\",10,\"^H\",\"noFill()\",\"^T\",[\"^N\",[[]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",2658,\"^L\",2664,\"^W\",0,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Disables filling geometry. If both no-stroke and no-fill are called,\\n  nothing will be drawn to the screen.\"],\"~$year\",[\"^ \",\"^A\",\"Input\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Input\",\"^D\",\"1.0\",\"^E\",\"Time & Date\",\"^F\",\"^6\",\"^G\",7,\"^H\",\"year()\",\"^I\",3,\"^J\",false,\"^K\",4579,\"^L\",4579,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Returns the current year as an integer (2003, 2004, 2005, etc).\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/year\",\"^S\",false,\"^E\",\"Time & Date\",\"^F\",\"quil/core.cljc\",\"^G\",7,\"^H\",\"year()\",\"^T\",[\"^N\",[[]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",false,\"^K\",4573,\"^L\",4579,\"^W\",0,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Returns the current year as an integer (2003, 2004, 2005, etc).\"],\"~$key-coded?\",[\"^ \",\"^A\",\"Input\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Input\",\"^D\",\"1.6\",\"^E\",\"Keyboard\",\"^F\",\"^6\",\"^G\",13,\"^H\",null,\"^I\",3,\"^J\",false,\"^K\",4859,\"^L\",4859,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$c\"]]]]],\"^Q\",\"Returns true if char c is a 'coded' char i.e. it is necessary to\\n  fetch the key-code as an integer and use that to determine the\\n  specific key pressed. See key-keyword.\"],\"^D\",\"1.6\",\"^5\",\"~$quil.core/key-coded?\",\"^S\",false,\"^E\",\"Keyboard\",\"^F\",\"quil/core.cljc\",\"^G\",13,\"^H\",null,\"^T\",[\"^N\",[[\"~$c\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",false,\"^K\",4854,\"^L\",4859,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$c\"]]]]],\"^Q\",\"Returns true if char c is a 'coded' char i.e. it is necessary to\\n  fetch the key-code as an integer and use that to determine the\\n  specific key pressed. See key-keyword.\"],\"~$curve-tangent\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"Curves\",\"^F\",\"^6\",\"^G\",16,\"^H\",\"curveTangent()\",\"^I\",3,\"^J\",true,\"^K\",1377,\"^L\",1377,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$t\"]]]]],\"^Q\",\"Calculates the tangent of a point on a curve.\\n  See: http://en.wikipedia.org/wiki/Tangent\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/curve-tangent\",\"^S\",false,\"^E\",\"Curves\",\"^F\",\"quil/core.cljc\",\"^G\",16,\"^H\",\"curveTangent()\",\"^T\",[\"^N\",[[\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$t\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",1371,\"^L\",1377,\"^W\",5,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$t\"]]]]],\"^Q\",\"Calculates the tangent of a point on a curve.\\n  See: http://en.wikipedia.org/wiki/Tangent\"],\"~$ellipse-modes\",[\"^ \",\"^5\",\"~$quil.core/ellipse-modes\",\"^F\",\"quil/core.cljc\",\"^K\",45,\"^I\",1,\"^L\",52,\"^G\",15,\"^C\",[\"^ \",\"^F\",\"^6\",\"^K\",52,\"^I\",2,\"^L\",52,\"^G\",15]],\"~$pmouse-y\",[\"^ \",\"^A\",\"Input\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Input\",\"^D\",\"1.0\",\"^E\",\"Mouse\",\"^F\",\"^6\",\"^G\",11,\"^H\",\"pmouseY\",\"^I\",3,\"^J\",true,\"^K\",2956,\"^L\",2956,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Vertical coordinate of the mouse in the previous frame\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/pmouse-y\",\"^S\",false,\"^E\",\"Mouse\",\"^F\",\"quil/core.cljc\",\"^G\",11,\"^H\",\"pmouseY\",\"^T\",[\"^N\",[[]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",2950,\"^L\",2956,\"^W\",0,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Vertical coordinate of the mouse in the previous frame\"],\"~$hex\",[\"^ \",\"^A\",\"Data\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Data\",\"^4?\",false,\"^E\",\"Conversion\",\"^F\",\"^6\",\"^G\",6,\"^14\",[\"^ \",\"^S\",false,\"^W\",2,\"^T\",[\"^N\",[[\"^2P\"],[\"^2P\",\"^4@\"]]],\"^M\",[\"^N\",[[\"^2P\"],[\"^2P\",\"^4@\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"hex()\",\"^I\",3,\"^K\",1951,\"^L\",1951,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^2P\"],[\"^2P\",\"^4@\"]]]]],\"^Q\",\"Converts a byte, char, int, or color to a String containing the\\n  equivalent hexadecimal notation. For example color(0, 102, 153) will\\n  convert to the String \\\"FF006699\\\". This function can help make your\\n  geeky debugging sessions much happier. \"],\"^4?\",false,\"^5\",\"~$quil.core/hex\",\"^S\",false,\"^E\",\"Conversion\",\"^F\",\"quil/core.cljc\",\"^G\",6,\"^14\",[\"^ \",\"^S\",false,\"^W\",2,\"^T\",[\"^N\",[[\"^2P\"],[\"^2P\",\"^4@\"]]],\"^M\",[\"^N\",[[\"^2P\"],[\"^2P\",\"^4@\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"hex()\",\"^T\",[\"^N\",[[\"^2P\"],[\"^2P\",\"^4@\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^K\",1946,\"^L\",1951,\"^W\",2,\"^X\",true,\"^M\",[\"^N\",[[\"^2P\"],[\"^2P\",\"^4@\"]]],\"^Q\",\"Converts a byte, char, int, or color to a String containing the\\n  equivalent hexadecimal notation. For example color(0, 102, 153) will\\n  convert to the String \\\"FF006699\\\". This function can help make your\\n  geeky debugging sessions much happier. \"],\"~$with-fill\",[\"^ \",\"^A\",\"Color\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Color\",\"^D\",\"1.7\",\"^E\",\"Utility Macros\",\"^F\",\"^6\",\"^G\",13,\"^14\",[\"^ \",\"^S\",true,\"^W\",3,\"^T\",[[\"^N\",[\"^1K\",\"^1L\",\"~$fill-args\",\"^1N\"]]],\"^M\",[\"^N\",[[\"^1K\",\"^1L\",\"^=:\",\"~$&\",\"^1N\"]]],\"^V\",[\"^N\",[null]]],\"^H\",null,\"^I\",4,\"^J\",true,\"^K\",4604,\"^1O\",true,\"^L\",4604,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^=:\",\"~$&\",\"^1N\"]]]]],\"^Q\",\"Temporarily set the fill color for the body of this macro.\\n   The code outside of with-fill form will have the previous fill color set.\\n\\n   The fill color has to be in a vector!\\n   Example: (with-fill [255] ...)\\n            (with-fill [10 80 98] ...)\"],\"^D\",\"1.7\",\"^5\",\"~$quil.core/with-fill\",\"^S\",true,\"^E\",\"Utility Macros\",\"^F\",\"quil/core.cljc\",\"^G\",13,\"^14\",[\"^ \",\"^S\",true,\"^W\",3,\"^T\",[[\"^N\",[\"^1K\",\"^1L\",\"^=:\",\"^1N\"]]],\"^M\",[\"^N\",[[\"^1K\",\"^1L\",\"^=:\",\"~$&\",\"^1N\"]]],\"^V\",[\"^N\",[null]]],\"^H\",null,\"^T\",[[\"^N\",[\"^1K\",\"^1L\",\"^=:\",\"^1N\"]]],\"^U\",null,\"^V\",[\"^N\",[null]],\"^I\",1,\"^J\",true,\"^K\",4598,\"^1O\",true,\"^L\",4604,\"^W\",3,\"^X\",false,\"^M\",[\"^N\",[[\"^1K\",\"^1L\",\"^=:\",\"~$&\",\"^1N\"]]],\"^Q\",\"Temporarily set the fill color for the body of this macro.\\n   The code outside of with-fill form will have the previous fill color set.\\n\\n   The fill color has to be in a vector!\\n   Example: (with-fill [255] ...)\\n            (with-fill [10 80 98] ...)\"],\"~$no-cursor\",[\"^ \",\"^A\",\"Environment\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Environment\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^6\",\"^G\",12,\"^H\",\"noCursor()\",\"^I\",3,\"^J\",true,\"^K\",2652,\"^L\",2652,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Hides the cursor from view. Will not work when running the in full\\n  screen (Present) mode.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/no-cursor\",\"^S\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^G\",12,\"^H\",\"noCursor()\",\"^T\",[\"^N\",[[]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",2646,\"^L\",2652,\"^W\",0,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Hides the cursor from view. Will not work when running the in full\\n  screen (Present) mode.\"],\"~$create-font\",[\"^ \",\"^A\",\"Typography\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Typography\",\"^D\",\"1.0\",\"^E\",\"Loading & Displaying\",\"^F\",\"^6\",\"^G\",14,\"^14\",[\"^ \",\"^S\",false,\"^W\",4,\"^T\",[\"^N\",[[\"^:P\",\"^28\"],[\"^:P\",\"^28\",\"^5;\"],[\"^:P\",\"^28\",\"^5;\",\"~$charset\"]]],\"^M\",[\"^N\",[[\"^:P\",\"^28\"],[\"^:P\",\"^28\",\"^5;\"],[\"^:P\",\"^28\",\"^5;\",\"^=?\"]]],\"^V\",[\"^N\",[null,null,null]]],\"^H\",\"createFont()\",\"^I\",3,\"^J\",true,\"^K\",1167,\"^L\",1167,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^:P\",\"^28\"],[\"^:P\",\"^28\",\"^5;\"],[\"^:P\",\"^28\",\"^5;\",\"^=?\"]]]]],\"^Q\",\"Dynamically converts a font to the format used by Processing (a\\n  PFont) from either a font name that's installed on the computer, or\\n  from a .ttf or .otf file inside the sketches 'data' folder. This\\n  function is an advanced feature for precise control.\\n\\n  Use available-fonts to obtain the names for the fonts recognized by\\n  the computer and are compatible with this function.\\n\\n  The size parameter states the font size you want to generate. The\\n  smooth parameter specifies if the font should be antialiased or not,\\n  and the charset parameter is an array of chars that specifies the\\n  characters to generate.\\n\\n  This function creates a bitmapped version of a font It loads a font\\n  by name, and converts it to a series of images based on the size of\\n  the font. When possible, the text function will use a native font\\n  rather than the bitmapped version created behind the scenes with\\n  create-font. For instance, when using the default renderer\\n  setting (JAVA2D), the actual native version of the font will be\\n  employed by the sketch, improving drawing quality and\\n  performance. With the :p2d, :p3d, and :opengl renderer settings, the\\n  bitmapped version will be used. While this can drastically improve\\n  speed and appearance, results are poor when exporting if the sketch\\n  does not include the .otf or .ttf file, and the requested font is\\n  not available on the machine running the sketch.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/create-font\",\"^S\",false,\"^E\",\"Loading & Displaying\",\"^F\",\"quil/core.cljc\",\"^G\",14,\"^14\",[\"^ \",\"^S\",false,\"^W\",4,\"^T\",[\"^N\",[[\"^:P\",\"^28\"],[\"^:P\",\"^28\",\"^5;\"],[\"^:P\",\"^28\",\"^5;\",\"^=?\"]]],\"^M\",[\"^N\",[[\"^:P\",\"^28\"],[\"^:P\",\"^28\",\"^5;\"],[\"^:P\",\"^28\",\"^5;\",\"^=?\"]]],\"^V\",[\"^N\",[null,null,null]]],\"^H\",\"createFont()\",\"^T\",[\"^N\",[[\"^:P\",\"^28\"],[\"^:P\",\"^28\",\"^5;\"],[\"^:P\",\"^28\",\"^5;\",\"^=?\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null,null]],\"^I\",1,\"^J\",true,\"^K\",1161,\"^L\",1167,\"^W\",4,\"^X\",true,\"^M\",[\"^N\",[[\"^:P\",\"^28\"],[\"^:P\",\"^28\",\"^5;\"],[\"^:P\",\"^28\",\"^5;\",\"^=?\"]]],\"^Q\",\"Dynamically converts a font to the format used by Processing (a\\n  PFont) from either a font name that's installed on the computer, or\\n  from a .ttf or .otf file inside the sketches 'data' folder. This\\n  function is an advanced feature for precise control.\\n\\n  Use available-fonts to obtain the names for the fonts recognized by\\n  the computer and are compatible with this function.\\n\\n  The size parameter states the font size you want to generate. The\\n  smooth parameter specifies if the font should be antialiased or not,\\n  and the charset parameter is an array of chars that specifies the\\n  characters to generate.\\n\\n  This function creates a bitmapped version of a font It loads a font\\n  by name, and converts it to a series of images based on the size of\\n  the font. When possible, the text function will use a native font\\n  rather than the bitmapped version created behind the scenes with\\n  create-font. For instance, when using the default renderer\\n  setting (JAVA2D), the actual native version of the font will be\\n  employed by the sketch, improving drawing quality and\\n  performance. With the :p2d, :p3d, and :opengl renderer settings, the\\n  bitmapped version will be used. While this can drastically improve\\n  speed and appearance, results are poor when exporting if the sketch\\n  does not include the .otf or .ttf file, and the requested font is\\n  not available on the machine running the sketch.\"],\"~$current-graphics\",[\"^ \",\"^A\",\"Environment\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Environment\",\"^D\",\"2.0\",\"^E\",null,\"^F\",\"^6\",\"^G\",19,\"^I\",3,\"^J\",true,\"^K\",32,\"^L\",32,\"~:tag\",\"~$PGraphics\",\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Graphics currently used for drawing. By default it is sketch graphics,\\n  but if called inside with-graphics macro - graphics passed to the macro\\n  is returned. This method should be used if you need to call some methods\\n  that are not implemented by quil. Example:\\n  (.beginDraw (current-graphics)).\"],\"^D\",\"2.0\",\"^5\",\"~$quil.core/current-graphics\",\"^S\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^G\",19,\"^T\",[\"^N\",[[]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",26,\"~:ret-tag\",\"^=C\",\"^L\",32,\"^W\",0,\"^=B\",\"^=C\",\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Graphics currently used for drawing. By default it is sketch graphics,\\n  but if called inside with-graphics macro - graphics passed to the macro\\n  is returned. This method should be used if you need to call some methods\\n  that are not implemented by quil. Example:\\n  (.beginDraw (current-graphics)).\"],\"~$abs\",[\"^ \",\"^A\",\"Math\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Math\",\"^D\",\"1.0\",\"^E\",\"Calculation\",\"^F\",\"^6\",\"^G\",6,\"^H\",\"abs()\",\"^I\",3,\"^J\",false,\"^K\",281,\"^L\",281,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$n\"]]]]],\"^Q\",\"Calculates the absolute value (magnitude) of a number. The\\n  absolute value of a number is always positive. Dynamically casts to\\n  an int or float appropriately\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/abs\",\"^S\",false,\"^E\",\"Calculation\",\"^F\",\"quil/core.cljc\",\"^G\",6,\"^H\",\"abs()\",\"^T\",[\"^N\",[[\"~$n\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",false,\"^K\",275,\"^L\",281,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$n\"]]]]],\"^Q\",\"Calculates the absolute value (magnitude) of a number. The\\n  absolute value of a number is always positive. Dynamically casts to\\n  an int or float appropriately\"],\"~$pop-style\",[\"^ \",\"^A\",\"Structure\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Structure\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^6\",\"^G\",12,\"^H\",\"popStyle()\",\"^I\",3,\"^J\",true,\"^K\",3016,\"^L\",3016,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Restores the prior settings on the 'style stack'. Used in\\n  conjunction with push-style. Together they allow you to change the\\n  style settings and later return to what you had. When a new style is\\n  started with push-style, it builds on the current style information.\\n  The push-style and pop-style functions can be nested to provide more\\n  control\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/pop-style\",\"^S\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^G\",12,\"^H\",\"popStyle()\",\"^T\",[\"^N\",[[]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",3010,\"^L\",3016,\"^W\",0,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Restores the prior settings on the 'style stack'. Used in\\n  conjunction with push-style. Together they allow you to change the\\n  style settings and later return to what you had. When a new style is\\n  started with push-style, it builds on the current style information.\\n  The push-style and pop-style functions can be nested to provide more\\n  control\"],\"~$focused\",[\"^ \",\"^A\",\"Environment\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Environment\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^6\",\"^G\",10,\"^H\",\"focused\",\"^I\",3,\"^J\",true,\"^K\",1843,\"^L\",1843,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Returns a boolean value representing whether the applet has focus.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/focused\",\"^S\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^G\",10,\"^H\",\"focused\",\"^T\",[\"^N\",[[]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",1837,\"^L\",1843,\"^W\",0,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Returns a boolean value representing whether the applet has focus.\"],\"~$background-float\",[\"^ \",\"^A\",\"Color\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Color\",\"^D\",\"1.0\",\"^E\",\"Setting\",\"^F\",\"^6\",\"^G\",19,\"^14\",[\"^ \",\"^S\",false,\"^W\",4,\"^T\",[\"^N\",[[\"^2=\"],[\"^2=\",\"^2>\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^M\",[\"^N\",[[\"^2=\"],[\"^2=\",\"^2>\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^V\",[\"^N\",[null,null,null,null]]],\"^H\",\"background()\",\"^I\",3,\"^J\",true,\"^K\",512,\"^L\",512,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^2=\"],[\"^2=\",\"^2>\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]]]],\"^Q\",\"Sets the color used for the background of the Processing\\n  window. The default background is light gray. In the draw function,\\n  the background color is used to clear the display window at the\\n  beginning of each frame.\\n\\n  It is not possible to use transparency (alpha) in background colors\\n  with the main drawing surface, however they will work properly with\\n  create-graphics. Converts args to floats.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/background-float\",\"^S\",false,\"^E\",\"Setting\",\"^F\",\"quil/core.cljc\",\"^G\",19,\"^14\",[\"^ \",\"^S\",false,\"^W\",4,\"^T\",[\"^N\",[[\"^2=\"],[\"^2=\",\"^2>\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^M\",[\"^N\",[[\"^2=\"],[\"^2=\",\"^2>\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^V\",[\"^N\",[null,null,null,null]]],\"^H\",\"background()\",\"^T\",[\"^N\",[[\"^2=\"],[\"^2=\",\"^2>\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null,null,null]],\"^I\",1,\"^J\",true,\"^K\",506,\"^L\",512,\"^W\",4,\"^X\",true,\"^M\",[\"^N\",[[\"^2=\"],[\"^2=\",\"^2>\"],[\"~$r\",\"~$g\",\"~$b\"],[\"~$r\",\"~$g\",\"~$b\",\"~$a\"]]],\"^Q\",\"Sets the color used for the background of the Processing\\n  window. The default background is light gray. In the draw function,\\n  the background color is used to clear the display window at the\\n  beginning of each frame.\\n\\n  It is not possible to use transparency (alpha) in background colors\\n  with the main drawing surface, however they will work properly with\\n  create-graphics. Converts args to floats.\"],\"~$text-mode\",[\"^ \",\"^A\",\"Typography\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Typography\",\"^D\",\"1.0\",\"^E\",\"Attributes\",\"^F\",\"^6\",\"^G\",12,\"^H\",\"textMode()\",\"^I\",3,\"^J\",true,\"^K\",4279,\"^L\",4279,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^17\"]]]]],\"^Q\",\"Sets the way text draws to the screen - available modes\\n  are :model and :shape\\n\\n  In the default configuration (the :model mode), it's possible to\\n  rotate, scale, and place letters in two and three dimensional space.\\n\\n  The :shape mode draws text using the glyph outlines of individual\\n  characters rather than as textures. This mode is only supported with\\n  the PDF and OPENGL renderer settings. With the PDF renderer, you\\n  must specify the :shape text-mode before any other drawing occurs.\\n  If the outlines are not available, then :shape will be ignored and\\n  :model will be used instead.\\n\\n  The :shape option in OPENGL mode can be combined with begin-raw to\\n  write vector-accurate text to 2D and 3D output files, for instance\\n  DXF or PDF. :shape is not currently optimized for OPENGL, so if\\n  recording shape data, use :model until you're ready to capture the\\n  geometry with begin-raw.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/text-mode\",\"^S\",false,\"^E\",\"Attributes\",\"^F\",\"quil/core.cljc\",\"^G\",12,\"^H\",\"textMode()\",\"^T\",[\"^N\",[[\"^17\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",4273,\"^L\",4279,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^17\"]]]]],\"^Q\",\"Sets the way text draws to the screen - available modes\\n  are :model and :shape\\n\\n  In the default configuration (the :model mode), it's possible to\\n  rotate, scale, and place letters in two and three dimensional space.\\n\\n  The :shape mode draws text using the glyph outlines of individual\\n  characters rather than as textures. This mode is only supported with\\n  the PDF and OPENGL renderer settings. With the PDF renderer, you\\n  must specify the :shape text-mode before any other drawing occurs.\\n  If the outlines are not available, then :shape will be ignored and\\n  :model will be used instead.\\n\\n  The :shape option in OPENGL mode can be combined with begin-raw to\\n  write vector-accurate text to 2D and 3D output files, for instance\\n  DXF or PDF. :shape is not currently optimized for OPENGL, so if\\n  recording shape data, use :model until you're ready to capture the\\n  geometry with begin-raw.\"],\"~$image-mode\",[\"^ \",\"^A\",\"Image\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Image\",\"^D\",\"1.0\",\"^E\",\"Loading & Displaying\",\"^F\",\"^6\",\"^G\",13,\"^H\",\"imageMode()\",\"^I\",3,\"^J\",true,\"^K\",2145,\"^L\",2145,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^17\"]]]]],\"^Q\",\"Modifies the location from which images draw. The default mode is :corner.\\n   Available modes are:\\n\\n  :corner  - specifies the location to be the upper left corner and\\n             uses the fourth and fifth parameters of image to set the\\n             image's width and height.\\n\\n  :corners - uses the second and third parameters of image to set the\\n             location of one corner of the image and uses the fourth\\n             and fifth parameters to set the opposite corner.\\n\\n  :center  - draw images centered at the given x and y position.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/image-mode\",\"^S\",false,\"^E\",\"Loading & Displaying\",\"^F\",\"quil/core.cljc\",\"^G\",13,\"^H\",\"imageMode()\",\"^T\",[\"^N\",[[\"^17\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",2139,\"^L\",2145,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^17\"]]]]],\"^Q\",\"Modifies the location from which images draw. The default mode is :corner.\\n   Available modes are:\\n\\n  :corner  - specifies the location to be the upper left corner and\\n             uses the fourth and fifth parameters of image to set the\\n             image's width and height.\\n\\n  :corners - uses the second and third parameters of image to set the\\n             location of one corner of the image and uses the fourth\\n             and fifth parameters to set the opposite corner.\\n\\n  :center  - draw images centered at the given x and y position.\"],\"~$line\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"2D Primitives\",\"^F\",\"^6\",\"^G\",7,\"^14\",[\"^ \",\"^S\",false,\"^W\",6,\"^T\",[\"^N\",[[\"~$p1\",\"~$p2\"],[\"^43\",\"^44\",\"^45\",\"^46\"],[\"^43\",\"^44\",\"^56\",\"^45\",\"^46\",\"^59\"]]],\"^M\",[\"^N\",[[\"^=S\",\"^=T\"],[\"^43\",\"^44\",\"^45\",\"^46\"],[\"^43\",\"^44\",\"^56\",\"^45\",\"^46\",\"^59\"]]],\"^V\",[\"^N\",[null,null,null]]],\"^H\",\"line()\",\"^I\",3,\"^J\",true,\"^K\",2323,\"^L\",2323,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^=S\",\"^=T\"],[\"^43\",\"^44\",\"^45\",\"^46\"],[\"^43\",\"^44\",\"^56\",\"^45\",\"^46\",\"^59\"]]]]],\"^Q\",\"Draws a line (a direct path between two points) to the screen. The\\n  version of line with four parameters draws the line in 2D. To color\\n  a line, use the stroke function. A line cannot be filled, therefore\\n  the fill method will not affect the color of a line. 2D lines are\\n  drawn with a width of one pixel by default, but this can be changed\\n  with the stroke-weight function. The version with six parameters\\n  allows the line to be placed anywhere within XYZ space. \"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/line\",\"^S\",false,\"^E\",\"2D Primitives\",\"^F\",\"quil/core.cljc\",\"^G\",7,\"^14\",[\"^ \",\"^S\",false,\"^W\",6,\"^T\",[\"^N\",[[\"^=S\",\"^=T\"],[\"^43\",\"^44\",\"^45\",\"^46\"],[\"^43\",\"^44\",\"^56\",\"^45\",\"^46\",\"^59\"]]],\"^M\",[\"^N\",[[\"^=S\",\"^=T\"],[\"^43\",\"^44\",\"^45\",\"^46\"],[\"^43\",\"^44\",\"^56\",\"^45\",\"^46\",\"^59\"]]],\"^V\",[\"^N\",[null,null,null]]],\"^H\",\"line()\",\"^T\",[\"^N\",[[\"^=S\",\"^=T\"],[\"^43\",\"^44\",\"^45\",\"^46\"],[\"^43\",\"^44\",\"^56\",\"^45\",\"^46\",\"^59\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null,null]],\"^I\",1,\"^J\",true,\"^K\",2317,\"^L\",2323,\"^W\",6,\"^X\",true,\"^M\",[\"^N\",[[\"^=S\",\"^=T\"],[\"^43\",\"^44\",\"^45\",\"^46\"],[\"^43\",\"^44\",\"^56\",\"^45\",\"^46\",\"^59\"]]],\"^Q\",\"Draws a line (a direct path between two points) to the screen. The\\n  version of line with four parameters draws the line in 2D. To color\\n  a line, use the stroke function. A line cannot be filled, therefore\\n  the fill method will not affect the color of a line. 2D lines are\\n  drawn with a width of one pixel by default, but this can be changed\\n  with the stroke-weight function. The version with six parameters\\n  allows the line to be placed anywhere within XYZ space. \"],\"~$do-record\",[\"^ \",\"^A\",\"Output\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Output\",\"^D\",\"2.5\",\"^E\",\"Files\",\"^F\",\"^6\",\"^G\",12,\"^14\",[\"^ \",\"^S\",true,\"^W\",3,\"^T\",[[\"^N\",[\"^1K\",\"^1L\",\"^1M\",\"^1N\"]]],\"^M\",[\"^N\",[[\"^1K\",\"^1L\",\"^1M\",\"~$&\",\"^1N\"]]],\"^V\",[\"^N\",[null]]],\"^H\",null,\"^I\",3,\"^J\",true,\"^K\",1510,\"^1O\",true,\"^L\",1510,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^1M\",\"~$&\",\"^1N\"]]]]],\"^Q\",\"Macro for drawing on graphics which saves result in the file at the end.\\n  Similar to 'with-graphics' macro. do-record assumed to be used with :pdf\\n  graphics. Example:\\n\\n  (q/do-record (q/create-graphics 200 200 :pdf \\\"output.pdf\\\")\\n    (q/fill 250 0 0)\\n    (q/ellipse 100 100 150 150))\\n  \"],\"^D\",\"2.5\",\"^5\",\"~$quil.core/do-record\",\"^S\",true,\"^E\",\"Files\",\"^F\",\"quil/core.cljc\",\"^G\",12,\"^14\",[\"^ \",\"^S\",true,\"^W\",3,\"^T\",[[\"^N\",[\"^1K\",\"^1L\",\"^1M\",\"^1N\"]]],\"^M\",[\"^N\",[[\"^1K\",\"^1L\",\"^1M\",\"~$&\",\"^1N\"]]],\"^V\",[\"^N\",[null]]],\"^H\",null,\"^T\",[[\"^N\",[\"^1K\",\"^1L\",\"^1M\",\"^1N\"]]],\"^U\",null,\"^V\",[\"^N\",[null]],\"^I\",1,\"^J\",true,\"^K\",1504,\"^1O\",true,\"^L\",1510,\"^W\",3,\"^X\",false,\"^M\",[\"^N\",[[\"^1K\",\"^1L\",\"^1M\",\"~$&\",\"^1N\"]]],\"^Q\",\"Macro for drawing on graphics which saves result in the file at the end.\\n  Similar to 'with-graphics' macro. do-record assumed to be used with :pdf\\n  graphics. Example:\\n\\n  (q/do-record (q/create-graphics 200 200 :pdf \\\"output.pdf\\\")\\n    (q/fill 250 0 0)\\n    (q/ellipse 100 100 150 150))\\n  \"],\"~$red\",[\"^ \",\"^A\",\"Color\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Color\",\"^D\",\"1.0\",\"^E\",\"Creating & Reading\",\"^F\",\"^6\",\"^G\",6,\"^H\",\"red()\",\"^I\",3,\"^J\",true,\"^K\",3305,\"^L\",3305,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$c\"]]]]],\"^Q\",\"Extracts the red value from a color, scaled to match current color-mode.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/red\",\"^S\",false,\"^E\",\"Creating & Reading\",\"^F\",\"quil/core.cljc\",\"^G\",6,\"^H\",\"red()\",\"^T\",[\"^N\",[[\"~$c\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",3299,\"^L\",3305,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$c\"]]]]],\"^Q\",\"Extracts the red value from a color, scaled to match current color-mode.\"],\"~$current-fill\",[\"^ \",\"^A\",\"Color\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Color\",\"^E\",\"Creating & Reading\",\"^F\",\"^6\",\"^G\",15,\"^H\",\"PGraphics.fillColor\",\"^I\",3,\"^3X\",\"http://processing.github.io/processing-javadocs/core/processing/core/PGraphics.html#fillColor\",\"^J\",true,\"^K\",1264,\"^L\",1264,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Return the current fill color.\"],\"^5\",\"~$quil.core/current-fill\",\"^S\",false,\"^E\",\"Creating & Reading\",\"^F\",\"quil/core.cljc\",\"^G\",15,\"^H\",\"PGraphics.fillColor\",\"^T\",[\"^N\",[[]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^3X\",\"http://processing.github.io/processing-javadocs/core/processing/core/PGraphics.html#fillColor\",\"^J\",true,\"^K\",1258,\"^L\",1264,\"^W\",0,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Return the current fill color.\"],\"~$color-modes\",[\"^ \",\"^5\",\"~$quil.core/color-modes\",\"^F\",\"quil/core.cljc\",\"^K\",45,\"^I\",1,\"^L\",50,\"^G\",13,\"^C\",[\"^ \",\"^F\",\"^6\",\"^K\",50,\"^I\",2,\"^L\",50,\"^G\",13]],\"~$blue\",[\"^ \",\"^A\",\"Color\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Color\",\"^D\",\"1.0\",\"^E\",\"Creating & Reading\",\"^F\",\"^6\",\"^G\",7,\"^H\",\"blue()\",\"^I\",3,\"^J\",true,\"^K\",905,\"^L\",905,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^7I\"]]]]],\"^Q\",\"Extracts the blue value from a color, scaled to match current color-mode.\\n  Returns a float.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/blue\",\"^S\",false,\"^E\",\"Creating & Reading\",\"^F\",\"quil/core.cljc\",\"^G\",7,\"^H\",\"blue()\",\"^T\",[\"^N\",[[\"^7I\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",899,\"^L\",905,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^7I\"]]]]],\"^Q\",\"Extracts the blue value from a color, scaled to match current color-mode.\\n  Returns a float.\"],\"~$frustum\",[\"^ \",\"^A\",\"Lights, Camera\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Lights, Camera\",\"^D\",\"1.0\",\"^E\",\"Camera\",\"^F\",\"^6\",\"^G\",10,\"^H\",\"frustum()\",\"^I\",3,\"^J\",true,\"^K\",1897,\"^L\",1897,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^:>\",\"^:?\",\"^:@\",\"^:A\",\"^:B\",\"^:C\"]]]]],\"^Q\",\"Sets a perspective matrix defined through the parameters. Works\\n  like glFrustum, except it wipes out the current perspective matrix\\n  rather than muliplying itself with it.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/frustum\",\"^S\",false,\"^E\",\"Camera\",\"^F\",\"quil/core.cljc\",\"^G\",10,\"^H\",\"frustum()\",\"^T\",[\"^N\",[[\"^:>\",\"^:?\",\"^:@\",\"^:A\",\"^:B\",\"^:C\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",1891,\"^L\",1897,\"^W\",6,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^:>\",\"^:?\",\"^:@\",\"^:A\",\"^:B\",\"^:C\"]]]]],\"^Q\",\"Sets a perspective matrix defined through the parameters. Works\\n  like glFrustum, except it wipes out the current perspective matrix\\n  rather than muliplying itself with it.\"],\"~$with-rotation\",[\"^ \",\"^A\",\"Transform\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Transform\",\"^D\",\"1.0\",\"^E\",\"Utility Macros\",\"^F\",\"^6\",\"^G\",16,\"^14\",[\"^ \",\"^S\",true,\"^W\",3,\"^T\",[[\"^N\",[\"^1K\",\"^1L\",\"~$rotation\",\"^1N\"]]],\"^M\",[\"^N\",[[\"^1K\",\"^1L\",\"^>7\",\"~$&\",\"^1N\"]]],\"^V\",[\"^N\",[null]]],\"^H\",null,\"^I\",3,\"^J\",true,\"^K\",4660,\"^1O\",true,\"^L\",4660,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^>7\",\"~$&\",\"^1N\"]]]]],\"^Q\",\"Performs body with rotation, restores current transformation on exit.\\n  Accepts a vector [angle] or [angle x-axis y-axis z-axis].\\n\\n  Example:\\n    (with-rotation [angle]\\n      (vertex 1 2))\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/with-rotation\",\"^S\",true,\"^E\",\"Utility Macros\",\"^F\",\"quil/core.cljc\",\"^G\",16,\"^14\",[\"^ \",\"^S\",true,\"^W\",3,\"^T\",[[\"^N\",[\"^1K\",\"^1L\",\"^>7\",\"^1N\"]]],\"^M\",[\"^N\",[[\"^1K\",\"^1L\",\"^>7\",\"~$&\",\"^1N\"]]],\"^V\",[\"^N\",[null]]],\"^H\",null,\"^T\",[[\"^N\",[\"^1K\",\"^1L\",\"^>7\",\"^1N\"]]],\"^U\",null,\"^V\",[\"^N\",[null]],\"^I\",1,\"^J\",true,\"^K\",4654,\"^1O\",true,\"^L\",4660,\"^W\",3,\"^X\",false,\"^M\",[\"^N\",[[\"^1K\",\"^1L\",\"^>7\",\"~$&\",\"^1N\"]]],\"^Q\",\"Performs body with rotation, restores current transformation on exit.\\n  Accepts a vector [angle] or [angle x-axis y-axis z-axis].\\n\\n  Example:\\n    (with-rotation [angle]\\n      (vertex 1 2))\"],\"~$print-matrix\",[\"^ \",\"^A\",\"Transform\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Transform\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^6\",\"^G\",15,\"^H\",\"printMatrix()\",\"^I\",3,\"^J\",true,\"^K\",3059,\"^L\",3059,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Prints the current matrix to std out. Useful for debugging.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/print-matrix\",\"^S\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^G\",15,\"^H\",\"printMatrix()\",\"^T\",[\"^N\",[[]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",3053,\"^L\",3059,\"^W\",0,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Prints the current matrix to std out. Useful for debugging.\"],\"~$ambient-light\",[\"^ \",\"^A\",\"Lights, Camera\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Lights, Camera\",\"^D\",\"1.0\",\"^E\",\"Lights\",\"^F\",\"^6\",\"^G\",16,\"^14\",[\"^ \",\"^S\",false,\"^W\",6,\"^T\",[\"^N\",[[\"^=X\",\"^9A\",\"^>2\"],[\"^=X\",\"^9A\",\"^>2\",\"~$x\",\"~$y\",\"~$z\"]]],\"^M\",[\"^N\",[[\"^=X\",\"^9A\",\"^>2\"],[\"^=X\",\"^9A\",\"^>2\",\"~$x\",\"~$y\",\"~$z\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"ambientLight()\",\"^I\",3,\"^J\",true,\"^K\",375,\"^L\",375,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^=X\",\"^9A\",\"^>2\"],[\"^=X\",\"^9A\",\"^>2\",\"~$x\",\"~$y\",\"~$z\"]]]]],\"^Q\",\"Adds an ambient light. Ambient light doesn't come from a specific direction,\\n  the rays have light have bounced around so much that objects are\\n  evenly lit from all sides. Ambient lights are almost always used in\\n  combination with other types of lights. Lights need to be included\\n  in the draw to remain persistent in a looping program. Placing them\\n  in the setup of a looping program will cause them to only have an\\n  effect the first time through the loop. The effect of the\\n  parameters is determined by the current color mode.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/ambient-light\",\"^S\",false,\"^E\",\"Lights\",\"^F\",\"quil/core.cljc\",\"^G\",16,\"^14\",[\"^ \",\"^S\",false,\"^W\",6,\"^T\",[\"^N\",[[\"^=X\",\"^9A\",\"^>2\"],[\"^=X\",\"^9A\",\"^>2\",\"~$x\",\"~$y\",\"~$z\"]]],\"^M\",[\"^N\",[[\"^=X\",\"^9A\",\"^>2\"],[\"^=X\",\"^9A\",\"^>2\",\"~$x\",\"~$y\",\"~$z\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"ambientLight()\",\"^T\",[\"^N\",[[\"^=X\",\"^9A\",\"^>2\"],[\"^=X\",\"^9A\",\"^>2\",\"~$x\",\"~$y\",\"~$z\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",369,\"^L\",375,\"^W\",6,\"^X\",true,\"^M\",[\"^N\",[[\"^=X\",\"^9A\",\"^>2\"],[\"^=X\",\"^9A\",\"^>2\",\"~$x\",\"~$y\",\"~$z\"]]],\"^Q\",\"Adds an ambient light. Ambient light doesn't come from a specific direction,\\n  the rays have light have bounced around so much that objects are\\n  evenly lit from all sides. Ambient lights are almost always used in\\n  combination with other types of lights. Lights need to be included\\n  in the draw to remain persistent in a looping program. Placing them\\n  in the setup of a looping program will cause them to only have an\\n  effect the first time through the loop. The effect of the\\n  parameters is determined by the current color mode.\"],\"~$bezier-point\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"Curves\",\"^F\",\"^6\",\"^G\",15,\"^H\",\"bezierPoint()\",\"^I\",3,\"^J\",true,\"^K\",706,\"^L\",706,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$t\"]]]]],\"^Q\",\"Evaluates the Bezier at point t for points a, b, c, d. The\\n  parameter t varies between 0 and 1, a and d are points on the curve,\\n  and b and c are the control points. This can be done once with the x\\n  coordinates and a second time with the y coordinates to get the\\n  location of a bezier curve at t.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/bezier-point\",\"^S\",false,\"^E\",\"Curves\",\"^F\",\"quil/core.cljc\",\"^G\",15,\"^H\",\"bezierPoint()\",\"^T\",[\"^N\",[[\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$t\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",700,\"^L\",706,\"^W\",5,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$a\",\"~$b\",\"~$c\",\"~$d\",\"~$t\"]]]]],\"^Q\",\"Evaluates the Bezier at point t for points a, b, c, d. The\\n  parameter t varies between 0 and 1, a and d are points on the curve,\\n  and b and c are the control points. This can be done once with the x\\n  coordinates and a second time with the y coordinates to get the\\n  location of a bezier curve at t.\"],\"~$stroke-cap-modes\",[\"^ \",\"^5\",\"~$quil.core/stroke-cap-modes\",\"^F\",\"quil/core.cljc\",\"^K\",45,\"^I\",1,\"^L\",64,\"^G\",18,\"^C\",[\"^ \",\"^F\",\"^6\",\"^K\",64,\"^I\",2,\"^L\",64,\"^G\",18]],\"~$quad\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"2D Primitives\",\"^F\",\"^6\",\"^G\",7,\"^H\",\"quad()\",\"^I\",3,\"^J\",true,\"^K\",3123,\"^L\",3123,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^43\",\"^44\",\"^45\",\"^46\",\"^6<\",\"^6=\",\"~$x4\",\"~$y4\"]]]]],\"^Q\",\"A quad is a quadrilateral, a four sided polygon. It is similar to a\\n  rectangle, but the angles between its edges are not constrained to\\n  be ninety degrees. The first pair of parameters (x1,y1) sets the\\n  first vertex and the subsequent pairs should proceed clockwise or\\n  counter-clockwise around the defined shape.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/quad\",\"^S\",false,\"^E\",\"2D Primitives\",\"^F\",\"quil/core.cljc\",\"^G\",7,\"^H\",\"quad()\",\"^T\",[\"^N\",[[\"^43\",\"^44\",\"^45\",\"^46\",\"^6<\",\"^6=\",\"^>B\",\"^>C\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",3117,\"^L\",3123,\"^W\",8,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^43\",\"^44\",\"^45\",\"^46\",\"^6<\",\"^6=\",\"^>B\",\"^>C\"]]]]],\"^Q\",\"A quad is a quadrilateral, a four sided polygon. It is similar to a\\n  rectangle, but the angles between its edges are not constrained to\\n  be ninety degrees. The first pair of parameters (x1,y1) sets the\\n  first vertex and the subsequent pairs should proceed clockwise or\\n  counter-clockwise around the defined shape.\"],\"~$screen-x\",[\"^ \",\"^A\",\"Lights, Camera\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Lights, Camera\",\"^D\",\"1.0\",\"^E\",\"Coordinates\",\"^F\",\"^6\",\"^G\",11,\"^14\",[\"^ \",\"^S\",false,\"^W\",3,\"^T\",[\"^N\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^M\",[\"^N\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"screenX()\",\"^I\",3,\"^J\",true,\"^K\",3614,\"^L\",3614,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]]]],\"^Q\",\"Takes a three-dimensional x, y, z position and returns the x value\\n  for where it will appear on a (two-dimensional) screen, once\\n  affected by translate, scale or any other transformations\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/screen-x\",\"^S\",false,\"^E\",\"Coordinates\",\"^F\",\"quil/core.cljc\",\"^G\",11,\"^14\",[\"^ \",\"^S\",false,\"^W\",3,\"^T\",[\"^N\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^M\",[\"^N\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"screenX()\",\"^T\",[\"^N\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",3608,\"^L\",3614,\"^W\",3,\"^X\",true,\"^M\",[\"^N\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^Q\",\"Takes a three-dimensional x, y, z position and returns the x value\\n  for where it will appear on a (two-dimensional) screen, once\\n  affected by translate, scale or any other transformations\"],\"~$lights\",[\"^ \",\"^A\",\"Lights, Camera\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Lights, Camera\",\"^D\",\"1.0\",\"^E\",\"Lights\",\"^F\",\"^6\",\"^G\",9,\"^H\",\"lights()\",\"^I\",3,\"^J\",true,\"^K\",2284,\"^L\",2284,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Sets the default ambient light, directional light, falloff, and\\n  specular values. The defaults are:\\n\\n  (ambient-light 128 128 128)\\n  (directional-light 128 128 128 0 0 -1)\\n  (light-falloff 1 0 0)\\n  (light-specular 0 0 0).\\n\\n  Lights need to be included in the draw to remain persistent in a\\n  looping program. Placing them in the setup of a looping program\\n  will cause them to only have an effect the first time through the\\n  loop.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/lights\",\"^S\",false,\"^E\",\"Lights\",\"^F\",\"quil/core.cljc\",\"^G\",9,\"^H\",\"lights()\",\"^T\",[\"^N\",[[]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",2278,\"^L\",2284,\"^W\",0,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Sets the default ambient light, directional light, falloff, and\\n  specular values. The defaults are:\\n\\n  (ambient-light 128 128 128)\\n  (directional-light 128 128 128 0 0 -1)\\n  (light-falloff 1 0 0)\\n  (light-specular 0 0 0).\\n\\n  Lights need to be included in the draw to remain persistent in a\\n  looping program. Placing them in the setup of a looping program\\n  will cause them to only have an effect the first time through the\\n  loop.\"],\"~$*graphics*\",[\"^ \",\"^C\",[\"^ \",\"^F\",\"^6\",\"^K\",22,\"^I\",3,\"^L\",22,\"^G\",13,\"^3K\",true,\"~:dynamic\",true],\"^3K\",true,\"^5\",\"~$quil.core/*graphics*\",\"^F\",\"quil/core.cljc\",\"^G\",13,\"^I\",1,\"^>J\",true,\"^K\",20,\"^L\",22],\"~$KEY-CODES\",[\"^ \",\"^5\",\"~$quil.core/KEY-CODES\",\"^F\",\"quil/core.cljc\",\"^K\",122,\"^I\",4,\"^L\",123,\"^G\",15,\"^3K\",true,\"^C\",[\"^ \",\"^F\",\"^6\",\"^K\",123,\"^I\",6,\"^L\",123,\"^G\",15,\"^3K\",true]],\"~$curve-detail\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"Curves\",\"^F\",\"^6\",\"^G\",15,\"^H\",\"curveDetail()\",\"^I\",3,\"^J\",true,\"^K\",1348,\"^L\",1348,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^34\"]]]]],\"^Q\",\"Sets the resolution at which curves display. The default value is\\n  20. This function is only useful when using the :p3d or :opengl\\n  renderer as the default (:java2d) renderer does not use this\\n  information.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/curve-detail\",\"^S\",false,\"^E\",\"Curves\",\"^F\",\"quil/core.cljc\",\"^G\",15,\"^H\",\"curveDetail()\",\"^T\",[\"^N\",[[\"^34\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",1342,\"^L\",1348,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^34\"]]]]],\"^Q\",\"Sets the resolution at which curves display. The default value is\\n  20. This function is only useful when using the :p3d or :opengl\\n  renderer as the default (:java2d) renderer does not use this\\n  information.\"],\"~$current-frame-rate\",[\"^ \",\"^A\",\"Environment\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Environment\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^6\",\"^G\",21,\"^H\",\"frameRate\",\"^I\",3,\"^J\",true,\"^K\",1867,\"^L\",1867,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Returns the current framerate\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/current-frame-rate\",\"^S\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^G\",21,\"^H\",\"frameRate\",\"^T\",[\"^N\",[[]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",1861,\"^L\",1867,\"^W\",0,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Returns the current framerate\"],\"~$end-contour\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"2.0\",\"^E\",\"Vertex\",\"^F\",\"^6\",\"^G\",14,\"^H\",\"endContour()\",\"^I\",3,\"^J\",true,\"^K\",1624,\"^L\",1624,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Use the begin-contour and end-contour function to create negative\\n  shapes within shapes. These functions can only be within a\\n  begin-shape/end-shape pair and they only work with the :p2d and :p3d\\n  renderers.\"],\"^D\",\"2.0\",\"^5\",\"~$quil.core/end-contour\",\"^S\",false,\"^E\",\"Vertex\",\"^F\",\"quil/core.cljc\",\"^G\",14,\"^H\",\"endContour()\",\"^T\",[\"^N\",[[]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",1618,\"^L\",1624,\"^W\",0,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Use the begin-contour and end-contour function to create negative\\n  shapes within shapes. These functions can only be within a\\n  begin-shape/end-shape pair and they only work with the :p2d and :p3d\\n  renderers.\"],\"~$sin\",[\"^ \",\"^A\",\"Math\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Math\",\"^D\",\"1.0\",\"^E\",\"Trigonometry\",\"^F\",\"^6\",\"^G\",6,\"^H\",\"sin()\",\"^I\",3,\"^J\",false,\"^K\",3835,\"^L\",3835,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^P\"]]]]],\"^Q\",\"Calculates the sine of an angle. This function expects the values\\n  of the angle parameter to be provided in radians (values from 0 to\\n  6.28). A float within the range -1 to 1 is returned.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/sin\",\"^S\",false,\"^E\",\"Trigonometry\",\"^F\",\"quil/core.cljc\",\"^G\",6,\"^H\",\"sin()\",\"^T\",[\"^N\",[[\"^P\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",false,\"^K\",3829,\"^L\",3835,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^P\"]]]]],\"^Q\",\"Calculates the sine of an angle. This function expects the values\\n  of the angle parameter to be provided in radians (values from 0 to\\n  6.28). A float within the range -1 to 1 is returned.\"],\"~$current-stroke\",[\"^ \",\"^A\",\"Color\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Color\",\"^E\",\"Creating & Reading\",\"^F\",\"^6\",\"^G\",17,\"^H\",\"PGraphics.strokeColor\",\"^I\",3,\"^3X\",\"http://processing.github.io/processing-javadocs/core/processing/core/PGraphics.html#strokeColor\",\"^J\",true,\"^K\",1275,\"^L\",1275,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Return the current stroke color.\"],\"^5\",\"~$quil.core/current-stroke\",\"^S\",false,\"^E\",\"Creating & Reading\",\"^F\",\"quil/core.cljc\",\"^G\",17,\"^H\",\"PGraphics.strokeColor\",\"^T\",[\"^N\",[[]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^3X\",\"http://processing.github.io/processing-javadocs/core/processing/core/PGraphics.html#strokeColor\",\"^J\",true,\"^K\",1269,\"^L\",1275,\"^W\",0,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Return the current stroke color.\"],\"~$curve\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"Curves\",\"^F\",\"^6\",\"^G\",8,\"^14\",[\"^ \",\"^S\",false,\"^W\",12,\"^T\",[\"^N\",[[\"^43\",\"^44\",\"^45\",\"^46\",\"^6<\",\"^6=\",\"^>B\",\"^>C\"],[\"^43\",\"^44\",\"^56\",\"^45\",\"^46\",\"^59\",\"^6<\",\"^6=\",\"^6?\",\"^>B\",\"^>C\",\"~$z4\"]]],\"^M\",[\"^N\",[[\"^43\",\"^44\",\"^45\",\"^46\",\"^6<\",\"^6=\",\"^>B\",\"^>C\"],[\"^43\",\"^44\",\"^56\",\"^45\",\"^46\",\"^59\",\"^6<\",\"^6=\",\"^6?\",\"^>B\",\"^>C\",\"^>Y\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"curve()\",\"^I\",3,\"^J\",true,\"^K\",1320,\"^L\",1320,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^43\",\"^44\",\"^45\",\"^46\",\"^6<\",\"^6=\",\"^>B\",\"^>C\"],[\"^43\",\"^44\",\"^56\",\"^45\",\"^46\",\"^59\",\"^6<\",\"^6=\",\"^6?\",\"^>B\",\"^>C\",\"^>Y\"]]]]],\"^Q\",\"Draws a curved line on the screen. The first and second parameters\\n  specify the beginning control point and the last two parameters\\n  specify the ending control point. The middle parameters specify the\\n  start and stop of the curve. Longer curves can be created by putting\\n  a series of curve fns together or using curve-vertex. An additional\\n  fn called curve-tightness provides control for the visual quality of\\n  the curve. The curve fn is an implementation of Catmull-Rom\\n  splines.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/curve\",\"^S\",false,\"^E\",\"Curves\",\"^F\",\"quil/core.cljc\",\"^G\",8,\"^14\",[\"^ \",\"^S\",false,\"^W\",12,\"^T\",[\"^N\",[[\"^43\",\"^44\",\"^45\",\"^46\",\"^6<\",\"^6=\",\"^>B\",\"^>C\"],[\"^43\",\"^44\",\"^56\",\"^45\",\"^46\",\"^59\",\"^6<\",\"^6=\",\"^6?\",\"^>B\",\"^>C\",\"^>Y\"]]],\"^M\",[\"^N\",[[\"^43\",\"^44\",\"^45\",\"^46\",\"^6<\",\"^6=\",\"^>B\",\"^>C\"],[\"^43\",\"^44\",\"^56\",\"^45\",\"^46\",\"^59\",\"^6<\",\"^6=\",\"^6?\",\"^>B\",\"^>C\",\"^>Y\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"curve()\",\"^T\",[\"^N\",[[\"^43\",\"^44\",\"^45\",\"^46\",\"^6<\",\"^6=\",\"^>B\",\"^>C\"],[\"^43\",\"^44\",\"^56\",\"^45\",\"^46\",\"^59\",\"^6<\",\"^6=\",\"^6?\",\"^>B\",\"^>C\",\"^>Y\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",1314,\"^L\",1320,\"^W\",12,\"^X\",true,\"^M\",[\"^N\",[[\"^43\",\"^44\",\"^45\",\"^46\",\"^6<\",\"^6=\",\"^>B\",\"^>C\"],[\"^43\",\"^44\",\"^56\",\"^45\",\"^46\",\"^59\",\"^6<\",\"^6=\",\"^6?\",\"^>B\",\"^>C\",\"^>Y\"]]],\"^Q\",\"Draws a curved line on the screen. The first and second parameters\\n  specify the beginning control point and the last two parameters\\n  specify the ending control point. The middle parameters specify the\\n  start and stop of the curve. Longer curves can be created by putting\\n  a series of curve fns together or using curve-vertex. An additional\\n  fn called curve-tightness provides control for the visual quality of\\n  the curve. The curve fn is an implementation of Catmull-Rom\\n  splines.\"],\"~$shape\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"Loading & Displaying\",\"^F\",\"^6\",\"^G\",8,\"^14\",[\"^ \",\"^S\",false,\"^W\",5,\"^T\",[\"^N\",[[\"~$sh\"],[\"^?0\",\"~$x\",\"~$y\"],[\"^?0\",\"~$x\",\"~$y\",\"^1?\",\"^1@\"]]],\"^M\",[\"^N\",[[\"^?0\"],[\"^?0\",\"~$x\",\"~$y\"],[\"^?0\",\"~$x\",\"~$y\",\"^1?\",\"^1@\"]]],\"^V\",[\"^N\",[null,null,null]]],\"^H\",\"shape()\",\"^I\",3,\"^J\",true,\"^K\",3723,\"^L\",3723,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^?0\"],[\"^?0\",\"~$x\",\"~$y\"],[\"^?0\",\"~$x\",\"~$y\",\"^1?\",\"^1@\"]]]]],\"^Q\",\"Displays shapes to the screen. The shapes must have been loaded\\n  with load-shape. Processing currently works with SVG shapes\\n  only. The sh parameter specifies the shape to display and the x and\\n  y parameters define the location of the shape from its upper-left\\n  corner. The shape is displayed at its original size unless the width\\n  and height parameters specify a different size. The shape-mode\\n  fn changes the way the parameters work. A call to\\n  (shape-mode :corners), for example, will change the width and height\\n  parameters to define the x and y values of the opposite corner of\\n  the shape.\\n\\n  Note complex shapes may draw awkwardly with the renderers :p2d, :p3d, and\\n  :opengl. Those renderers do not yet support shapes that have holes\\n  or complicated breaks.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/shape\",\"^S\",false,\"^E\",\"Loading & Displaying\",\"^F\",\"quil/core.cljc\",\"^G\",8,\"^14\",[\"^ \",\"^S\",false,\"^W\",5,\"^T\",[\"^N\",[[\"^?0\"],[\"^?0\",\"~$x\",\"~$y\"],[\"^?0\",\"~$x\",\"~$y\",\"^1?\",\"^1@\"]]],\"^M\",[\"^N\",[[\"^?0\"],[\"^?0\",\"~$x\",\"~$y\"],[\"^?0\",\"~$x\",\"~$y\",\"^1?\",\"^1@\"]]],\"^V\",[\"^N\",[null,null,null]]],\"^H\",\"shape()\",\"^T\",[\"^N\",[[\"^?0\"],[\"^?0\",\"~$x\",\"~$y\"],[\"^?0\",\"~$x\",\"~$y\",\"^1?\",\"^1@\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null,null]],\"^I\",1,\"^J\",true,\"^K\",3717,\"^L\",3723,\"^W\",5,\"^X\",true,\"^M\",[\"^N\",[[\"^?0\"],[\"^?0\",\"~$x\",\"~$y\"],[\"^?0\",\"~$x\",\"~$y\",\"^1?\",\"^1@\"]]],\"^Q\",\"Displays shapes to the screen. The shapes must have been loaded\\n  with load-shape. Processing currently works with SVG shapes\\n  only. The sh parameter specifies the shape to display and the x and\\n  y parameters define the location of the shape from its upper-left\\n  corner. The shape is displayed at its original size unless the width\\n  and height parameters specify a different size. The shape-mode\\n  fn changes the way the parameters work. A call to\\n  (shape-mode :corners), for example, will change the width and height\\n  parameters to define the x and y values of the opposite corner of\\n  the shape.\\n\\n  Note complex shapes may draw awkwardly with the renderers :p2d, :p3d, and\\n  :opengl. Those renderers do not yet support shapes that have holes\\n  or complicated breaks.\"],\"~$image-formats\",[\"^ \",\"^5\",\"~$quil.core/image-formats\",\"^F\",\"quil/core.cljc\",\"^K\",45,\"^I\",1,\"^L\",51,\"^G\",15,\"^C\",[\"^ \",\"^F\",\"^6\",\"^K\",51,\"^I\",2,\"^L\",51,\"^G\",15]],\"~$text-descent\",[\"^ \",\"^A\",\"Typography\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Typography\",\"^D\",\"1.0\",\"^E\",\"Metrics\",\"^F\",\"^6\",\"^G\",15,\"^H\",\"textDescent()\",\"^I\",3,\"^J\",true,\"^K\",4227,\"^L\",4227,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Returns descent of the current font at its current size. This\\n  information is useful for determining the height of the font below\\n  the baseline. For example, adding the text-ascent and text-descent\\n  values will give you the total height of the line.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/text-descent\",\"^S\",false,\"^E\",\"Metrics\",\"^F\",\"quil/core.cljc\",\"^G\",15,\"^H\",\"textDescent()\",\"^T\",[\"^N\",[[]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",4221,\"^L\",4227,\"^W\",0,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Returns descent of the current font at its current size. This\\n  information is useful for determining the height of the font below\\n  the baseline. For example, adding the text-ascent and text-descent\\n  values will give you the total height of the line.\"],\"~$screen-z\",[\"^ \",\"^A\",\"Lights, Camera\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Lights, Camera\",\"^D\",\"1.0\",\"^E\",\"Coordinates\",\"^F\",\"^6\",\"^G\",11,\"^H\",\"screenZ()\",\"^I\",3,\"^J\",true,\"^K\",3640,\"^L\",3640,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$x\",\"~$y\",\"~$z\"]]]]],\"^Q\",\"Given an x, y, z coordinate, returns its z value.\\n   This value can be used to determine if an x, y, z coordinate is in\\n   front or in back of another (x, y, z) coordinate. The units are\\n   based on how the zbuffer is set up, and don't relate to anything\\n   'real'. They're only useful for in comparison to another value\\n   obtained from screen-z, or directly out of the zbuffer\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/screen-z\",\"^S\",false,\"^E\",\"Coordinates\",\"^F\",\"quil/core.cljc\",\"^G\",11,\"^H\",\"screenZ()\",\"^T\",[\"^N\",[[\"~$x\",\"~$y\",\"~$z\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",3634,\"^L\",3640,\"^W\",3,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$x\",\"~$y\",\"~$z\"]]]]],\"^Q\",\"Given an x, y, z coordinate, returns its z value.\\n   This value can be used to determine if an x, y, z coordinate is in\\n   front or in back of another (x, y, z) coordinate. The units are\\n   based on how the zbuffer is set up, and don't relate to anything\\n   'real'. They're only useful for in comparison to another value\\n   obtained from screen-z, or directly out of the zbuffer\"],\"~$ambient-int\",[\"^ \",\"^A\",\"Lights, Camera\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Lights, Camera\",\"^D\",\"1.0\",\"^E\",\"Material Properties\",\"^F\",\"^6\",\"^G\",14,\"^H\",\"ambient()\",\"^I\",3,\"^J\",true,\"^K\",341,\"^L\",341,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^39\"]]]]],\"^Q\",\"Sets the ambient reflectance for shapes drawn to the screen. This\\n  is combined with the ambient light component of environment. The rgb\\n  color components set define the reflectance. Used in combination\\n  with emissive, specular, and shininess in setting the material\\n  properties of shapes.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/ambient-int\",\"^S\",false,\"^E\",\"Material Properties\",\"^F\",\"quil/core.cljc\",\"^G\",14,\"^H\",\"ambient()\",\"^T\",[\"^N\",[[\"^39\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",335,\"^L\",341,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^39\"]]]]],\"^Q\",\"Sets the ambient reflectance for shapes drawn to the screen. This\\n  is combined with the ambient light component of environment. The rgb\\n  color components set define the reflectance. Used in combination\\n  with emissive, specular, and shininess in setting the material\\n  properties of shapes.\"],\"~$ellipse\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"2D Primitives\",\"^F\",\"^6\",\"^G\",10,\"^H\",\"ellipse()\",\"^I\",3,\"^J\",true,\"^K\",1531,\"^L\",1531,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$x\",\"~$y\",\"^1?\",\"^1@\"]]]]],\"^Q\",\"Draws an ellipse (oval) in the display window. An ellipse with an\\n  equal width and height is a circle.  The origin may be changed with\\n  the ellipse-mode function\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/ellipse\",\"^S\",false,\"^E\",\"2D Primitives\",\"^F\",\"quil/core.cljc\",\"^G\",10,\"^H\",\"ellipse()\",\"^T\",[\"^N\",[[\"~$x\",\"~$y\",\"^1?\",\"^1@\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",1525,\"^L\",1531,\"^W\",4,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$x\",\"~$y\",\"^1?\",\"^1@\"]]]]],\"^Q\",\"Draws an ellipse (oval) in the display window. An ellipse with an\\n  equal width and height is a circle.  The origin may be changed with\\n  the ellipse-mode function\"],\"~$text-leading\",[\"^ \",\"^A\",\"Typography\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Typography\",\"^D\",\"1.0\",\"^E\",\"Attributes\",\"^F\",\"^6\",\"^G\",15,\"^H\",\"textLeading()\",\"^I\",3,\"^J\",true,\"^K\",4267,\"^L\",4267,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$leading\"]]]]],\"^Q\",\"Sets the spacing between lines of text in units of pixels. This\\n  setting will be used in all subsequent calls to the text function.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/text-leading\",\"^S\",false,\"^E\",\"Attributes\",\"^F\",\"quil/core.cljc\",\"^G\",15,\"^H\",\"textLeading()\",\"^T\",[\"^N\",[[\"^?=\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",4261,\"^L\",4267,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^?=\"]]]]],\"^Q\",\"Sets the spacing between lines of text in units of pixels. This\\n  setting will be used in all subsequent calls to the text function.\"],\"~$image-filter\",[\"^ \",\"^A\",\"Image\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Image\",\"^D\",\"2.0\",\"^E\",\"Pixels\",\"^F\",\"^6\",\"^G\",15,\"^14\",[\"^ \",\"^S\",false,\"^W\",3,\"^T\",[\"^N\",[[\"^1Y\",\"^17\"],[\"^1Y\",\"^17\",\"^18\"]]],\"^M\",[\"^N\",[[\"^1Y\",\"^17\"],[\"^1Y\",\"^17\",\"^18\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"PImage.filter()\",\"^I\",3,\"^J\",true,\"^K\",2105,\"^L\",2105,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^1Y\",\"^17\"],[\"^1Y\",\"^17\",\"^18\"]]]]],\"^Q\",\"Originally named filter in Processing Language.\\n  Filters given image with the specified mode and level.\\n  Level defines the quality of the filter and mode may be one of\\n  the following keywords:\\n\\n  :threshold - converts the image to black and white pixels depending\\n               if they are above or below the threshold defined by\\n               the level parameter. The level must be between\\n               0.0 (black) and 1.0 (white). If no level is specified,\\n               0.5 is used.\\n  :gray      - converts any colors in the image to grayscale\\n               equivalents. Doesn't work with level.\\n  :invert    - sets each pixel to its inverse value. Doesn't work with\\n               level.\\n  :posterize - limits each channel of the image to the number of\\n               colors specified as the level parameter. The parameter can\\n               be set to values between 2 and 255, but results are most\\n               noticeable in the lower ranges.\\n  :blur      - executes a Guassian blur with the level parameter\\n               specifying the extent of the blurring. If no level\\n               parameter is used, the blur is equivalent to Guassian\\n               blur of radius 1.\\n  :opaque    - sets the alpha channel to entirely opaque. Doesn't work\\n               with level.\\n  :erode     - reduces the light areas. Doesn't work with level.\\n  :dilate    - increases the light areas.  Doesn't work with level.\"],\"^D\",\"2.0\",\"^5\",\"~$quil.core/image-filter\",\"^S\",false,\"^E\",\"Pixels\",\"^F\",\"quil/core.cljc\",\"^G\",15,\"^14\",[\"^ \",\"^S\",false,\"^W\",3,\"^T\",[\"^N\",[[\"^1Y\",\"^17\"],[\"^1Y\",\"^17\",\"^18\"]]],\"^M\",[\"^N\",[[\"^1Y\",\"^17\"],[\"^1Y\",\"^17\",\"^18\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"PImage.filter()\",\"^T\",[\"^N\",[[\"^1Y\",\"^17\"],[\"^1Y\",\"^17\",\"^18\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",2099,\"^L\",2105,\"^W\",3,\"^X\",true,\"^M\",[\"^N\",[[\"^1Y\",\"^17\"],[\"^1Y\",\"^17\",\"^18\"]]],\"^Q\",\"Originally named filter in Processing Language.\\n  Filters given image with the specified mode and level.\\n  Level defines the quality of the filter and mode may be one of\\n  the following keywords:\\n\\n  :threshold - converts the image to black and white pixels depending\\n               if they are above or below the threshold defined by\\n               the level parameter. The level must be between\\n               0.0 (black) and 1.0 (white). If no level is specified,\\n               0.5 is used.\\n  :gray      - converts any colors in the image to grayscale\\n               equivalents. Doesn't work with level.\\n  :invert    - sets each pixel to its inverse value. Doesn't work with\\n               level.\\n  :posterize - limits each channel of the image to the number of\\n               colors specified as the level parameter. The parameter can\\n               be set to values between 2 and 255, but results are most\\n               noticeable in the lower ranges.\\n  :blur      - executes a Guassian blur with the level parameter\\n               specifying the extent of the blurring. If no level\\n               parameter is used, the blur is equivalent to Guassian\\n               blur of radius 1.\\n  :opaque    - sets the alpha channel to entirely opaque. Doesn't work\\n               with level.\\n  :erode     - reduces the light areas. Doesn't work with level.\\n  :dilate    - increases the light areas.  Doesn't work with level.\"],\"~$random\",[\"^ \",\"^A\",\"Math\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Math\",\"^D\",\"1.0\",\"^E\",\"Random\",\"^F\",\"^6\",\"^G\",9,\"^14\",[\"^ \",\"^S\",false,\"^W\",2,\"^T\",[\"^N\",[[\"^3M\"],[\"~$min\",\"^3M\"]]],\"^M\",[\"^N\",[[\"^3M\"],[\"^?B\",\"^3M\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"random()\",\"^I\",3,\"^J\",true,\"^K\",3179,\"^L\",3179,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^3M\"],[\"^?B\",\"^3M\"]]]]],\"^Q\",\"Generates random numbers. Each time the random function is called,\\n  it returns an unexpected value within the specified range. If one\\n  parameter is passed to the function it will return a float between\\n  zero and the value of the high parameter. The function call (random\\n  5) returns values between 0 and 5 (starting at zero, up to but not\\n  including 5). If two parameters are passed, it will return a float\\n  with a value between the parameters. The function call\\n  (random -5 10.2) returns values starting at -5 up to (but not\\n  including) 10.2.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/random\",\"^S\",false,\"^E\",\"Random\",\"^F\",\"quil/core.cljc\",\"^G\",9,\"^14\",[\"^ \",\"^S\",false,\"^W\",2,\"^T\",[\"^N\",[[\"^3M\"],[\"^?B\",\"^3M\"]]],\"^M\",[\"^N\",[[\"^3M\"],[\"^?B\",\"^3M\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"random()\",\"^T\",[\"^N\",[[\"^3M\"],[\"^?B\",\"^3M\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",3173,\"^L\",3179,\"^W\",2,\"^X\",true,\"^M\",[\"^N\",[[\"^3M\"],[\"^?B\",\"^3M\"]]],\"^Q\",\"Generates random numbers. Each time the random function is called,\\n  it returns an unexpected value within the specified range. If one\\n  parameter is passed to the function it will return a float between\\n  zero and the value of the high parameter. The function call (random\\n  5) returns values between 0 and 5 (starting at zero, up to but not\\n  including 5). If two parameters are passed, it will return a float\\n  with a value between the parameters. The function call\\n  (random -5 10.2) returns values starting at -5 up to (but not\\n  including) 10.2.\"],\"~$texture-mode\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"Vertex\",\"^F\",\"^6\",\"^G\",15,\"^H\",\"textureMode()\",\"^I\",3,\"^J\",true,\"^K\",4339,\"^L\",4339,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^17\"]]]]],\"^Q\",\"Sets the coordinate space for texture mapping. There are two\\n  options, :image and :normal.\\n\\n  :image refers to the actual coordinates of the image and :normal\\n  refers to a normalized space of values ranging from 0 to 1. The\\n  default mode is :image. In :image, if an image is 100 x 200 pixels,\\n  mapping the image onto the entire size of a quad would require the\\n  points (0,0) (0,100) (100,200) (0,200). The same mapping in\\n  NORMAL_SPACE is (0,0) (0,1) (1,1) (0,1).\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/texture-mode\",\"^S\",false,\"^E\",\"Vertex\",\"^F\",\"quil/core.cljc\",\"^G\",15,\"^H\",\"textureMode()\",\"^T\",[\"^N\",[[\"^17\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",4333,\"^L\",4339,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^17\"]]]]],\"^Q\",\"Sets the coordinate space for texture mapping. There are two\\n  options, :image and :normal.\\n\\n  :image refers to the actual coordinates of the image and :normal\\n  refers to a normalized space of values ranging from 0 to 1. The\\n  default mode is :image. In :image, if an image is 100 x 200 pixels,\\n  mapping the image onto the entire size of a quad would require the\\n  points (0,0) (0,100) (100,200) (0,200). The same mapping in\\n  NORMAL_SPACE is (0,0) (0,1) (1,1) (0,1).\"],\"~$redraw\",[\"^ \",\"^A\",\"Structure\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Structure\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^6\",\"^G\",9,\"^H\",\"redraw()\",\"^I\",3,\"^J\",true,\"^K\",3316,\"^L\",3316,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Executes the code within the draw fn one time. This functions\\n  allows the program to update the display window only when necessary,\\n  for example when an event registered by mouse-pressed or\\n  key-pressed occurs.\\n\\n  In structuring a program, it only makes sense to call redraw\\n  within events such as mouse-pressed. This is because redraw does\\n  not run draw immediately (it only sets a flag that indicates an\\n  update is needed).\\n\\n  Calling redraw within draw has no effect because draw is\\n  continuously called anyway.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/redraw\",\"^S\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^G\",9,\"^H\",\"redraw()\",\"^T\",[\"^N\",[[]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",3310,\"^L\",3316,\"^W\",0,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Executes the code within the draw fn one time. This functions\\n  allows the program to update the display window only when necessary,\\n  for example when an event registered by mouse-pressed or\\n  key-pressed occurs.\\n\\n  In structuring a program, it only makes sense to call redraw\\n  within events such as mouse-pressed. This is because redraw does\\n  not run draw immediately (it only sets a flag that indicates an\\n  update is needed).\\n\\n  Calling redraw within draw has no effect because draw is\\n  continuously called anyway.\"],\"~$RAD-TO-DEG\",[\"^ \",\"^5\",\"~$quil.core/RAD-TO-DEG\",\"^F\",\"quil/core.cljc\",\"^K\",83,\"^I\",1,\"^L\",83,\"^G\",16,\"^C\",[\"^ \",\"^F\",\"^6\",\"^K\",83,\"^I\",6,\"^L\",83,\"^G\",16]],\"~$get-pixel\",[\"^ \",\"^A\",\"Image\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Image\",\"^D\",\"1.0\",\"^E\",\"Pixels\",\"^F\",\"^6\",\"^G\",12,\"^14\",[\"^ \",\"^S\",false,\"^W\",5,\"^T\",[\"^N\",[[],[\"^1Y\"],[\"~$x\",\"~$y\"],[\"^1Y\",\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$w\",\"~$h\"],[\"^1Y\",\"~$x\",\"~$y\",\"~$w\",\"~$h\"]]],\"^M\",[\"^N\",[[],[\"^1Y\"],[\"~$x\",\"~$y\"],[\"^1Y\",\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$w\",\"~$h\"],[\"^1Y\",\"~$x\",\"~$y\",\"~$w\",\"~$h\"]]],\"^V\",[\"^N\",[null,null,null,null,null,null]]],\"^H\",\"get()\",\"^I\",3,\"^J\",true,\"^K\",1911,\"^L\",1911,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[],[\"^1Y\"],[\"~$x\",\"~$y\"],[\"^1Y\",\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$w\",\"~$h\"],[\"^1Y\",\"~$x\",\"~$y\",\"~$w\",\"~$h\"]]]]],\"^Q\",\"Reads the color of any pixel or grabs a section of an image. If no\\n  parameters are specified, a copy of entire image is returned. Get the\\n  value of one pixel by specifying an x,y coordinate. Get a section of\\n  the image by specifying an additional width and height parameter.\\n  If the pixel requested is outside of the image window, black is returned.\\n  The numbers returned are scaled according to the current color ranges,\\n  but only RGB values are returned by this function. For example, even though\\n  you may have drawn a shape with (color-mode :hsb), the numbers returned\\n  will be in RGB.\\n\\n  Getting the color of a single pixel with (get x y) is easy, but not\\n  as fast as grabbing the data directly using the pixels fn.\\n\\n  If no img specified - current-graphics is used.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/get-pixel\",\"^S\",false,\"^E\",\"Pixels\",\"^F\",\"quil/core.cljc\",\"^G\",12,\"^14\",[\"^ \",\"^S\",false,\"^W\",5,\"^T\",[\"^N\",[[],[\"^1Y\"],[\"~$x\",\"~$y\"],[\"^1Y\",\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$w\",\"~$h\"],[\"^1Y\",\"~$x\",\"~$y\",\"~$w\",\"~$h\"]]],\"^M\",[\"^N\",[[],[\"^1Y\"],[\"~$x\",\"~$y\"],[\"^1Y\",\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$w\",\"~$h\"],[\"^1Y\",\"~$x\",\"~$y\",\"~$w\",\"~$h\"]]],\"^V\",[\"^N\",[null,null,null,null,null,null]]],\"^H\",\"get()\",\"^T\",[\"^N\",[[],[\"^1Y\"],[\"~$x\",\"~$y\"],[\"^1Y\",\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$w\",\"~$h\"],[\"^1Y\",\"~$x\",\"~$y\",\"~$w\",\"~$h\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null,null,null,null,null]],\"^I\",1,\"^J\",true,\"^K\",1905,\"^L\",1911,\"^W\",5,\"^X\",true,\"^M\",[\"^N\",[[],[\"^1Y\"],[\"~$x\",\"~$y\"],[\"^1Y\",\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$w\",\"~$h\"],[\"^1Y\",\"~$x\",\"~$y\",\"~$w\",\"~$h\"]]],\"^Q\",\"Reads the color of any pixel or grabs a section of an image. If no\\n  parameters are specified, a copy of entire image is returned. Get the\\n  value of one pixel by specifying an x,y coordinate. Get a section of\\n  the image by specifying an additional width and height parameter.\\n  If the pixel requested is outside of the image window, black is returned.\\n  The numbers returned are scaled according to the current color ranges,\\n  but only RGB values are returned by this function. For example, even though\\n  you may have drawn a shape with (color-mode :hsb), the numbers returned\\n  will be in RGB.\\n\\n  Getting the color of a single pixel with (get x y) is easy, but not\\n  as fast as grabbing the data directly using the pixels fn.\\n\\n  If no img specified - current-graphics is used.\"],\"~$rotate\",[\"^ \",\"^A\",\"Transform\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Transform\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^6\",\"^G\",9,\"^14\",[\"^ \",\"^S\",false,\"^W\",4,\"^T\",[\"^N\",[[\"^P\"],[\"^P\",\"~$vx\",\"~$vy\",\"~$vz\"]]],\"^M\",[\"^N\",[[\"^P\"],[\"^P\",\"^?M\",\"^?N\",\"^?O\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"rotate()\",\"^I\",3,\"^J\",true,\"^K\",3410,\"^L\",3410,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^P\"],[\"^P\",\"^?M\",\"^?N\",\"^?O\"]]]]],\"^Q\",\"Rotates a shape the amount specified by the angle parameter. Angles\\n  should be specified in radians (values from 0 to TWO-PI) or\\n  converted to radians with the radians function.\\n\\n  Objects are always rotated around their relative position to the\\n  origin and positive numbers rotate objects in a clockwise\\n  direction. Transformations apply to everything that happens after\\n  and subsequent calls to the function accumulates the effect. For\\n  example, calling (rotate HALF-PI) and then (rotate HALF-PI) is the\\n  same as (rotate PI). All tranformations are reset when draw begins\\n  again.\\n\\n  Technically, rotate multiplies the current transformation matrix by\\n  a rotation matrix. This function can be further controlled by the\\n  push-matrix and pop-matrix.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/rotate\",\"^S\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^G\",9,\"^14\",[\"^ \",\"^S\",false,\"^W\",4,\"^T\",[\"^N\",[[\"^P\"],[\"^P\",\"^?M\",\"^?N\",\"^?O\"]]],\"^M\",[\"^N\",[[\"^P\"],[\"^P\",\"^?M\",\"^?N\",\"^?O\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"rotate()\",\"^T\",[\"^N\",[[\"^P\"],[\"^P\",\"^?M\",\"^?N\",\"^?O\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",3404,\"^L\",3410,\"^W\",4,\"^X\",true,\"^M\",[\"^N\",[[\"^P\"],[\"^P\",\"^?M\",\"^?N\",\"^?O\"]]],\"^Q\",\"Rotates a shape the amount specified by the angle parameter. Angles\\n  should be specified in radians (values from 0 to TWO-PI) or\\n  converted to radians with the radians function.\\n\\n  Objects are always rotated around their relative position to the\\n  origin and positive numbers rotate objects in a clockwise\\n  direction. Transformations apply to everything that happens after\\n  and subsequent calls to the function accumulates the effect. For\\n  example, calling (rotate HALF-PI) and then (rotate HALF-PI) is the\\n  same as (rotate PI). All tranformations are reset when draw begins\\n  again.\\n\\n  Technically, rotate multiplies the current transformation matrix by\\n  a rotation matrix. This function can be further controlled by the\\n  push-matrix and pop-matrix.\"],\"~$set-pixel\",[\"^ \",\"^A\",\"Image\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Image\",\"^D\",\"1.0\",\"^E\",\"Pixels\",\"^F\",\"^6\",\"^G\",12,\"^14\",[\"^ \",\"^S\",false,\"^W\",4,\"^T\",[\"^N\",[[\"~$x\",\"~$y\",\"~$c\"],[\"^1Y\",\"~$x\",\"~$y\",\"~$c\"]]],\"^M\",[\"^N\",[[\"~$x\",\"~$y\",\"~$c\"],[\"^1Y\",\"~$x\",\"~$y\",\"~$c\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"set()\",\"^I\",3,\"^J\",true,\"^K\",3668,\"^L\",3668,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$x\",\"~$y\",\"~$c\"],[\"^1Y\",\"~$x\",\"~$y\",\"~$c\"]]]]],\"^Q\",\"Changes the color of any pixel in the display window. The x and y\\n  parameters specify the pixel to change and the color parameter\\n  specifies the color value. The color parameter is affected by the\\n  current color mode (the default is RGB values from 0 to 255).\\n\\n  Setting the color of a single pixel with (set x, y) is easy, but not\\n  as fast as putting the data directly into pixels[].\\n\\n  This function ignores imageMode().\\n\\n  Due to what appears to be a bug in Apple's Java implementation, the\\n  point() and set() methods are extremely slow in some circumstances\\n  when used with the default renderer. Using :p2d or :p3d will fix the\\n  problem. Grouping many calls to point or set-pixel together can also\\n  help. (Bug 1094)\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/set-pixel\",\"^S\",false,\"^E\",\"Pixels\",\"^F\",\"quil/core.cljc\",\"^G\",12,\"^14\",[\"^ \",\"^S\",false,\"^W\",4,\"^T\",[\"^N\",[[\"~$x\",\"~$y\",\"~$c\"],[\"^1Y\",\"~$x\",\"~$y\",\"~$c\"]]],\"^M\",[\"^N\",[[\"~$x\",\"~$y\",\"~$c\"],[\"^1Y\",\"~$x\",\"~$y\",\"~$c\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"set()\",\"^T\",[\"^N\",[[\"~$x\",\"~$y\",\"~$c\"],[\"^1Y\",\"~$x\",\"~$y\",\"~$c\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",3662,\"^L\",3668,\"^W\",4,\"^X\",true,\"^M\",[\"^N\",[[\"~$x\",\"~$y\",\"~$c\"],[\"^1Y\",\"~$x\",\"~$y\",\"~$c\"]]],\"^Q\",\"Changes the color of any pixel in the display window. The x and y\\n  parameters specify the pixel to change and the color parameter\\n  specifies the color value. The color parameter is affected by the\\n  current color mode (the default is RGB values from 0 to 255).\\n\\n  Setting the color of a single pixel with (set x, y) is easy, but not\\n  as fast as putting the data directly into pixels[].\\n\\n  This function ignores imageMode().\\n\\n  Due to what appears to be a bug in Apple's Java implementation, the\\n  point() and set() methods are extremely slow in some circumstances\\n  when used with the default renderer. Using :p2d or :p3d will fix the\\n  problem. Grouping many calls to point or set-pixel together can also\\n  help. (Bug 1094)\"],\"~$push-matrix\",[\"^ \",\"^A\",\"Transform\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Transform\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^6\",\"^G\",14,\"^H\",\"pushMatrix()\",\"^I\",3,\"^J\",true,\"^K\",3082,\"^L\",3082,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Pushes the current transformation matrix onto the matrix\\n  stack. Understanding push-matrix and pop-matrix requires\\n  understanding the concept of a matrix stack. The push-matrix\\n  function saves the current coordinate system to the stack and\\n  pop-matrix restores the prior coordinate system. push-matrix and\\n  pop-matrix are used in conjuction with the other transformation\\n  methods and may be embedded to control the scope of the\\n  transformations.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/push-matrix\",\"^S\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^G\",14,\"^H\",\"pushMatrix()\",\"^T\",[\"^N\",[[]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",3076,\"^L\",3082,\"^W\",0,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Pushes the current transformation matrix onto the matrix\\n  stack. Understanding push-matrix and pop-matrix requires\\n  understanding the concept of a matrix stack. The push-matrix\\n  function saves the current coordinate system to the stack and\\n  pop-matrix restores the prior coordinate system. push-matrix and\\n  pop-matrix are used in conjuction with the other transformation\\n  methods and may be embedded to control the scope of the\\n  transformations.\"],\"~$no-smooth\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"Attributes\",\"^F\",\"^6\",\"^G\",12,\"^H\",\"noSmooth()\",\"^I\",3,\"^J\",true,\"^K\",2825,\"^L\",2825,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Draws all geometry with jagged (aliased) edges. Must be called inside\\n  :settings handler.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/no-smooth\",\"^S\",false,\"^E\",\"Attributes\",\"^F\",\"quil/core.cljc\",\"^G\",12,\"^H\",\"noSmooth()\",\"^T\",[\"^N\",[[]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",2819,\"^L\",2825,\"^W\",0,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Draws all geometry with jagged (aliased) edges. Must be called inside\\n  :settings handler.\"],\"^2>\",[\"^ \",\"^A\",\"Color\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Color\",\"^D\",\"1.0\",\"^E\",\"Creating & Reading\",\"^F\",\"^6\",\"^G\",8,\"^H\",\"alpha()\",\"^I\",3,\"^J\",true,\"^K\",313,\"^L\",313,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^7I\"]]]]],\"^Q\",\"Extracts the alpha value from a color.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/alpha\",\"^S\",false,\"^E\",\"Creating & Reading\",\"^F\",\"quil/core.cljc\",\"^G\",8,\"^H\",\"alpha()\",\"^T\",[\"^N\",[[\"^7I\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",307,\"^L\",313,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^7I\"]]]]],\"^Q\",\"Extracts the alpha value from a color.\"],\"~$camera\",[\"^ \",\"^A\",\"Lights, Camera\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Lights, Camera\",\"^D\",\"1.0\",\"^E\",\"Camera\",\"^F\",\"^6\",\"^G\",9,\"^14\",[\"^ \",\"^S\",false,\"^W\",9,\"^T\",[\"^N\",[[],[\"~$eyeX\",\"~$eyeY\",\"~$eyeZ\",\"~$centerX\",\"~$centerY\",\"~$centerZ\",\"~$upX\",\"~$upY\",\"~$upZ\"]]],\"^M\",[\"^N\",[[],[\"^?Y\",\"^?Z\",\"^?[\",\"^@0\",\"^@1\",\"^@2\",\"^@3\",\"^@4\",\"^@5\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"camera()\",\"^I\",3,\"^J\",true,\"^K\",939,\"^L\",939,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[],[\"^?Y\",\"^?Z\",\"^?[\",\"^@0\",\"^@1\",\"^@2\",\"^@3\",\"^@4\",\"^@5\"]]]]],\"^Q\",\"Sets the position of the camera through setting the eye position,\\n  the center of the scene, and which axis is facing upward. Moving the\\n  eye position and the direction it is pointing (the center of the\\n  scene) allows the images to be seen from different angles. The\\n  version without any parameters sets the camera to the default\\n  position, pointing to the center of the display window with the Y\\n  axis as up. The default values are:\\n\\n  eyeX:     (/ (width) 2.0)\\n  eyeY:     (/ (height) 2.0)\\n  eyeZ:     (/ (/ (height) 2.0) (tan (/ (* Math/PI 60.0) 360.0)))\\n  centerX:  (/ (width) 2.0)\\n  centerY:  (/ (height) 2.0)\\n  centerZ:  0\\n  upX:      0\\n  upY:      1\\n  upZ:      0\\n\\n  Similar imilar to gluLookAt() in OpenGL, but it first clears the\\n  current camera settings.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/camera\",\"^S\",false,\"^E\",\"Camera\",\"^F\",\"quil/core.cljc\",\"^G\",9,\"^14\",[\"^ \",\"^S\",false,\"^W\",9,\"^T\",[\"^N\",[[],[\"^?Y\",\"^?Z\",\"^?[\",\"^@0\",\"^@1\",\"^@2\",\"^@3\",\"^@4\",\"^@5\"]]],\"^M\",[\"^N\",[[],[\"^?Y\",\"^?Z\",\"^?[\",\"^@0\",\"^@1\",\"^@2\",\"^@3\",\"^@4\",\"^@5\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"camera()\",\"^T\",[\"^N\",[[],[\"^?Y\",\"^?Z\",\"^?[\",\"^@0\",\"^@1\",\"^@2\",\"^@3\",\"^@4\",\"^@5\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",933,\"^L\",939,\"^W\",9,\"^X\",true,\"^M\",[\"^N\",[[],[\"^?Y\",\"^?Z\",\"^?[\",\"^@0\",\"^@1\",\"^@2\",\"^@3\",\"^@4\",\"^@5\"]]],\"^Q\",\"Sets the position of the camera through setting the eye position,\\n  the center of the scene, and which axis is facing upward. Moving the\\n  eye position and the direction it is pointing (the center of the\\n  scene) allows the images to be seen from different angles. The\\n  version without any parameters sets the camera to the default\\n  position, pointing to the center of the display window with the Y\\n  axis as up. The default values are:\\n\\n  eyeX:     (/ (width) 2.0)\\n  eyeY:     (/ (height) 2.0)\\n  eyeZ:     (/ (/ (height) 2.0) (tan (/ (* Math/PI 60.0) 360.0)))\\n  centerX:  (/ (width) 2.0)\\n  centerY:  (/ (height) 2.0)\\n  centerZ:  0\\n  upX:      0\\n  upY:      1\\n  upZ:      0\\n\\n  Similar imilar to gluLookAt() in OpenGL, but it first clears the\\n  current camera settings.\"],\"~$translate\",[\"^ \",\"^A\",\"Transform\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Transform\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^6\",\"^G\",12,\"^14\",[\"^ \",\"^S\",false,\"^W\",3,\"^T\",[\"^N\",[[\"~$v\"],[\"~$tx\",\"~$ty\"],[\"^@8\",\"^@9\",\"~$tz\"]]],\"^M\",[\"^N\",[[\"~$v\"],[\"^@8\",\"^@9\"],[\"^@8\",\"^@9\",\"^@:\"]]],\"^V\",[\"^N\",[null,null,null]]],\"^H\",\"translate()\",\"^I\",3,\"^J\",true,\"^K\",4460,\"^L\",4460,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$v\"],[\"^@8\",\"^@9\"],[\"^@8\",\"^@9\",\"^@:\"]]]]],\"^Q\",\"Specifies an amount to displace objects within the display\\n  window. The x parameter specifies left/right translation, the y\\n  parameter specifies up/down translation, and the z parameter\\n  specifies translations toward/away from the screen.  Transformations\\n  apply to everything that happens after and subsequent calls to the\\n  function accumulates the effect. For example, calling (translate 50\\n  0) and then (translate 20, 0) is the same as (translate 70, 0). If\\n  translate is called within draw, the transformation is reset when\\n  the loop begins again. This function can be further controlled by\\n  the push-matrix and pop-matrix.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/translate\",\"^S\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^G\",12,\"^14\",[\"^ \",\"^S\",false,\"^W\",3,\"^T\",[\"^N\",[[\"~$v\"],[\"^@8\",\"^@9\"],[\"^@8\",\"^@9\",\"^@:\"]]],\"^M\",[\"^N\",[[\"~$v\"],[\"^@8\",\"^@9\"],[\"^@8\",\"^@9\",\"^@:\"]]],\"^V\",[\"^N\",[null,null,null]]],\"^H\",\"translate()\",\"^T\",[\"^N\",[[\"~$v\"],[\"^@8\",\"^@9\"],[\"^@8\",\"^@9\",\"^@:\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null,null]],\"^I\",1,\"^J\",true,\"^K\",4454,\"^L\",4460,\"^W\",3,\"^X\",true,\"^M\",[\"^N\",[[\"~$v\"],[\"^@8\",\"^@9\"],[\"^@8\",\"^@9\",\"^@:\"]]],\"^Q\",\"Specifies an amount to displace objects within the display\\n  window. The x parameter specifies left/right translation, the y\\n  parameter specifies up/down translation, and the z parameter\\n  specifies translations toward/away from the screen.  Transformations\\n  apply to everything that happens after and subsequent calls to the\\n  function accumulates the effect. For example, calling (translate 50\\n  0) and then (translate 20, 0) is the same as (translate 70, 0). If\\n  translate is called within draw, the transformation is reset when\\n  the loop begins again. This function can be further controlled by\\n  the push-matrix and pop-matrix.\"],\"~$load-font\",[\"^ \",\"^A\",\"Typography\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Typography\",\"^D\",\"1.0\",\"^E\",\"Loading & Displaying\",\"^F\",\"^6\",\"^G\",12,\"^H\",\"loadFont()\",\"^I\",3,\"^J\",true,\"^K\",2343,\"^L\",2343,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^4L\"]]]]],\"^Q\",\"Loads a font into a variable of type PFont. To load correctly,\\n  fonts must be located in the data directory of the current sketch.\\n  To create a font to use with Processing use the create-font fn.\\n\\n  Like load-image and other methods that load data, the load-font fn\\n  should not be used inside draw, because it will slow down the sketch\\n  considerably, as the font will be re-loaded from the disk (or\\n  network) on each frame.\\n\\n  For most renderers, Processing displays fonts using the .vlw font\\n  format, which uses images for each letter, rather than defining them\\n  through vector data. When hint :enable-native-fonts is used with the\\n  JAVA2D renderer, the native version of a font will be used if it is\\n  installed on the user's machine.\\n\\n  Using create-font (instead of load-font) enables vector data to be\\n  used with the JAVA2D (default) renderer setting. This can be helpful\\n  when many font sizes are needed, or when using any renderer based on\\n  JAVA2D, such as the PDF library.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/load-font\",\"^S\",false,\"^E\",\"Loading & Displaying\",\"^F\",\"quil/core.cljc\",\"^G\",12,\"^H\",\"loadFont()\",\"^T\",[\"^N\",[[\"^4L\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",2337,\"^L\",2343,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^4L\"]]]]],\"^Q\",\"Loads a font into a variable of type PFont. To load correctly,\\n  fonts must be located in the data directory of the current sketch.\\n  To create a font to use with Processing use the create-font fn.\\n\\n  Like load-image and other methods that load data, the load-font fn\\n  should not be used inside draw, because it will slow down the sketch\\n  considerably, as the font will be re-loaded from the disk (or\\n  network) on each frame.\\n\\n  For most renderers, Processing displays fonts using the .vlw font\\n  format, which uses images for each letter, rather than defining them\\n  through vector data. When hint :enable-native-fonts is used with the\\n  JAVA2D renderer, the native version of a font will be used if it is\\n  installed on the user's machine.\\n\\n  Using create-font (instead of load-font) enables vector data to be\\n  used with the JAVA2D (default) renderer setting. This can be helpful\\n  when many font sizes are needed, or when using any renderer based on\\n  JAVA2D, such as the PDF library.\"],\"~$ambient\",[\"^ \",\"^A\",\"Lights, Camera\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Lights, Camera\",\"^D\",\"1.0\",\"^E\",\"Material Properties\",\"^F\",\"^6\",\"^G\",10,\"^14\",[\"^ \",\"^S\",false,\"^W\",3,\"^T\",[\"^N\",[[\"^39\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^M\",[\"^N\",[[\"^39\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"ambient()\",\"^I\",3,\"^J\",true,\"^K\",356,\"^L\",356,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^39\"],[\"~$x\",\"~$y\",\"~$z\"]]]]],\"^Q\",\"Sets the ambient reflectance for shapes drawn to the screen. This\\n  is combined with the ambient light component of environment. The\\n  color components set through the parameters define the\\n  reflectance. For example in the default color mode, setting x=255,\\n  y=126, z=0, would cause all the red light to reflect and half of the\\n  green light to reflect. Used in combination with emissive, specular,\\n  and shininess in setting the material properties of shapes.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/ambient\",\"^S\",false,\"^E\",\"Material Properties\",\"^F\",\"quil/core.cljc\",\"^G\",10,\"^14\",[\"^ \",\"^S\",false,\"^W\",3,\"^T\",[\"^N\",[[\"^39\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^M\",[\"^N\",[[\"^39\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"ambient()\",\"^T\",[\"^N\",[[\"^39\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",350,\"^L\",356,\"^W\",3,\"^X\",true,\"^M\",[\"^N\",[[\"^39\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^Q\",\"Sets the ambient reflectance for shapes drawn to the screen. This\\n  is combined with the ambient light component of environment. The\\n  color components set through the parameters define the\\n  reflectance. For example in the default color mode, setting x=255,\\n  y=126, z=0, would cause all the red light to reflect and half of the\\n  green light to reflect. Used in combination with emissive, specular,\\n  and shininess in setting the material properties of shapes.\"],\"~$shear-y\",[\"^ \",\"^A\",\"Transform\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Transform\",\"^D\",\"1.0\",\"^E\",null,\"^F\",\"^6\",\"^G\",10,\"^H\",\"shearY()\",\"^I\",3,\"^J\",true,\"^K\",3773,\"^L\",3773,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^P\"]]]]],\"^Q\",\"Shears a shape around the y-axis the amount specified by the angle\\n  parameter. Angles should be specified in radians (values from 0 to\\n  PI*2) or converted to radians with the radians() function. Objects\\n  are always sheared around their relative position to the origin and\\n  positive numbers shear objects in a clockwise direction.\\n  Transformations apply to everything that happens after and\\n  subsequent calls to the function accumulates the effect. For\\n  example, calling (shear-y (/ PI 2)) and then (shear-y (/ PI 2)) is\\n  the same as (shear-y PI). If shear-y is called within the draw fn,\\n  the transformation is reset when the loop begins again. This\\n  function works in P2D or JAVA2D mode.\\n\\n  Technically, shear-y multiplies the current transformation matrix\\n  by a rotation matrix. This function can be further controlled by the\\n  push-matrix and pop-matrix fns.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/shear-y\",\"^S\",false,\"^E\",null,\"^F\",\"quil/core.cljc\",\"^G\",10,\"^H\",\"shearY()\",\"^T\",[\"^N\",[[\"^P\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",3767,\"^L\",3773,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^P\"]]]]],\"^Q\",\"Shears a shape around the y-axis the amount specified by the angle\\n  parameter. Angles should be specified in radians (values from 0 to\\n  PI*2) or converted to radians with the radians() function. Objects\\n  are always sheared around their relative position to the origin and\\n  positive numbers shear objects in a clockwise direction.\\n  Transformations apply to everything that happens after and\\n  subsequent calls to the function accumulates the effect. For\\n  example, calling (shear-y (/ PI 2)) and then (shear-y (/ PI 2)) is\\n  the same as (shear-y PI). If shear-y is called within the draw fn,\\n  the transformation is reset when the loop begins again. This\\n  function works in P2D or JAVA2D mode.\\n\\n  Technically, shear-y multiplies the current transformation matrix\\n  by a rotation matrix. This function can be further controlled by the\\n  push-matrix and pop-matrix fns.\"],\"~$cursor-modes\",[\"^ \",\"^5\",\"~$quil.core/cursor-modes\",\"^F\",\"quil/core.cljc\",\"^K\",45,\"^I\",1,\"^L\",72,\"^G\",14,\"^C\",[\"^ \",\"^F\",\"^6\",\"^K\",72,\"^I\",2,\"^L\",72,\"^G\",14]],\"~$mouse-y\",[\"^ \",\"^A\",\"Input\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Input\",\"^D\",\"1.0\",\"^E\",\"Mouse\",\"^F\",\"^6\",\"^G\",10,\"^H\",\"mouseY\",\"^I\",3,\"^J\",true,\"^K\",2629,\"^L\",2629,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Current vertical coordinate of the mouse.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/mouse-y\",\"^S\",false,\"^E\",\"Mouse\",\"^F\",\"quil/core.cljc\",\"^G\",10,\"^H\",\"mouseY\",\"^T\",[\"^N\",[[]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",2623,\"^L\",2629,\"^W\",0,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Current vertical coordinate of the mouse.\"],\"~$mouse-button\",[\"^ \",\"^A\",\"Input\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Input\",\"^D\",\"1.0\",\"^E\",\"Mouse\",\"^F\",\"^6\",\"^G\",15,\"^H\",\"mouseButton\",\"^I\",3,\"^J\",true,\"^K\",2580,\"^L\",2580,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"The value of the system variable mouseButton is either :left, :right,\\n  or :center depending on which button is pressed. nil if no button pressed\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/mouse-button\",\"^S\",false,\"^E\",\"Mouse\",\"^F\",\"quil/core.cljc\",\"^G\",15,\"^H\",\"mouseButton\",\"^T\",[\"^N\",[[]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",2574,\"^L\",2580,\"^W\",0,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"The value of the system variable mouseButton is either :left, :right,\\n  or :center depending on which button is pressed. nil if no button pressed\"],\"~$p-shape-modes\",[\"^ \",\"^5\",\"~$quil.core/p-shape-modes\",\"^F\",\"quil/core.cljc\",\"^K\",45,\"^I\",1,\"^L\",63,\"^G\",15,\"^C\",[\"^ \",\"^F\",\"^6\",\"^K\",63,\"^I\",2,\"^L\",63,\"^G\",15]],\"~$image\",[\"^ \",\"^A\",\"Image\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Image\",\"^D\",\"1.0\",\"^E\",\"Loading & Displaying\",\"^F\",\"^6\",\"^G\",8,\"^14\",[\"^ \",\"^S\",false,\"^W\",5,\"^T\",[\"^N\",[[\"^1Y\",\"~$x\",\"~$y\"],[\"^1Y\",\"~$x\",\"~$y\",\"~$c\",\"~$d\"]]],\"^M\",[\"^N\",[[\"^1Y\",\"~$x\",\"~$y\"],[\"^1Y\",\"~$x\",\"~$y\",\"~$c\",\"~$d\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"image()\",\"^I\",3,\"^J\",true,\"^K\",2076,\"^L\",2076,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^1Y\",\"~$x\",\"~$y\"],[\"^1Y\",\"~$x\",\"~$y\",\"~$c\",\"~$d\"]]]]],\"^Q\",\"Displays images to the screen. Processing currently works with GIF,\\n  JPEG, and Targa images. The color of an image may be modified with\\n  the tint function and if a GIF has transparency, it will maintain\\n  its transparency. The img parameter specifies the image to display\\n  and the x and y parameters define the location of the image from its\\n  upper-left corner. The image is displayed at its original size\\n  unless the width and height parameters specify a different size. The\\n  image-mode fn changes the way the parameters work. A call to\\n  (image-mode :corners) will change the width and height parameters to\\n  define the x and y values of the opposite corner of the image.\\n\\n  Starting with release 0124, when using the default (JAVA2D)\\n  renderer, smooth will also improve image quality of resized\\n  images.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/image\",\"^S\",false,\"^E\",\"Loading & Displaying\",\"^F\",\"quil/core.cljc\",\"^G\",8,\"^14\",[\"^ \",\"^S\",false,\"^W\",5,\"^T\",[\"^N\",[[\"^1Y\",\"~$x\",\"~$y\"],[\"^1Y\",\"~$x\",\"~$y\",\"~$c\",\"~$d\"]]],\"^M\",[\"^N\",[[\"^1Y\",\"~$x\",\"~$y\"],[\"^1Y\",\"~$x\",\"~$y\",\"~$c\",\"~$d\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"image()\",\"^T\",[\"^N\",[[\"^1Y\",\"~$x\",\"~$y\"],[\"^1Y\",\"~$x\",\"~$y\",\"~$c\",\"~$d\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",2070,\"^L\",2076,\"^W\",5,\"^X\",true,\"^M\",[\"^N\",[[\"^1Y\",\"~$x\",\"~$y\"],[\"^1Y\",\"~$x\",\"~$y\",\"~$c\",\"~$d\"]]],\"^Q\",\"Displays images to the screen. Processing currently works with GIF,\\n  JPEG, and Targa images. The color of an image may be modified with\\n  the tint function and if a GIF has transparency, it will maintain\\n  its transparency. The img parameter specifies the image to display\\n  and the x and y parameters define the location of the image from its\\n  upper-left corner. The image is displayed at its original size\\n  unless the width and height parameters specify a different size. The\\n  image-mode fn changes the way the parameters work. A call to\\n  (image-mode :corners) will change the width and height parameters to\\n  define the x and y values of the opposite corner of the image.\\n\\n  Starting with release 0124, when using the default (JAVA2D)\\n  renderer, smooth will also improve image quality of resized\\n  images.\"],\"~$unbinary\",[\"^ \",\"^A\",\"Data\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Data\",\"^4?\",false,\"^D\",\"1.0\",\"^E\",\"Conversion\",\"^F\",\"^6\",\"^G\",11,\"^H\",\"unbinary()\",\"^I\",3,\"^K\",4498,\"^L\",4498,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$str-val\"]]]]],\"^Q\",\"Unpack a binary string to an integer. See binary for converting\\n  integers to strings.\"],\"^4?\",false,\"^D\",\"1.0\",\"^5\",\"~$quil.core/unbinary\",\"^S\",false,\"^E\",\"Conversion\",\"^F\",\"quil/core.cljc\",\"^G\",11,\"^H\",\"unbinary()\",\"^T\",[\"^N\",[[\"^@M\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^K\",4492,\"^L\",4498,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^@M\"]]]]],\"^Q\",\"Unpack a binary string to an integer. See binary for converting\\n  integers to strings.\"],\"~$no-tint\",[\"^ \",\"^A\",\"Image\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Image\",\"^D\",\"1.0\",\"^E\",\"Loading & Displaying\",\"^F\",\"^6\",\"^G\",10,\"^H\",\"noTint()\",\"^I\",3,\"^J\",true,\"^K\",2848,\"^L\",2848,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Removes the current fill value for displaying images and reverts to\\n  displaying images with their original hues.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/no-tint\",\"^S\",false,\"^E\",\"Loading & Displaying\",\"^F\",\"quil/core.cljc\",\"^G\",10,\"^H\",\"noTint()\",\"^T\",[\"^N\",[[]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",2842,\"^L\",2848,\"^W\",0,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Removes the current fill value for displaying images and reverts to\\n  displaying images with their original hues.\"],\"~$no-lights\",[\"^ \",\"^A\",\"Lights, Camera\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Lights, Camera\",\"^D\",\"1.0\",\"^E\",\"Lights\",\"^F\",\"^6\",\"^G\",12,\"^H\",\"noLights()\",\"^I\",3,\"^J\",true,\"^K\",2757,\"^L\",2757,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Disable all lighting. Lighting is turned off by default and enabled\\n  with the lights fn. This function can be used to disable lighting so\\n  that 2D geometry (which does not require lighting) can be drawn\\n  after a set of lighted 3D geometry.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/no-lights\",\"^S\",false,\"^E\",\"Lights\",\"^F\",\"quil/core.cljc\",\"^G\",12,\"^H\",\"noLights()\",\"^T\",[\"^N\",[[]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",2751,\"^L\",2757,\"^W\",0,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[]]]]],\"^Q\",\"Disable all lighting. Lighting is turned off by default and enabled\\n  with the lights fn. This function can be used to disable lighting so\\n  that 2D geometry (which does not require lighting) can be drawn\\n  after a set of lighted 3D geometry.\"],\"~$emissive-int\",[\"^ \",\"^A\",\"Lights, Camera\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Lights, Camera\",\"^D\",\"1.0\",\"^E\",\"Material Properties\",\"^F\",\"^6\",\"^G\",15,\"^H\",\"emissive()\",\"^I\",3,\"^J\",true,\"^K\",1580,\"^L\",1580,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$int-val\"]]]]],\"^Q\",\"Sets the emissive color of the material used for drawing shapes\\n  drawn to the screen. Used in combination with ambient, specular, and\\n  shininess in setting the material properties of shapes. Converts all\\n  args to ints\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/emissive-int\",\"^S\",false,\"^E\",\"Material Properties\",\"^F\",\"quil/core.cljc\",\"^G\",15,\"^H\",\"emissive()\",\"^T\",[\"^N\",[[\"^@T\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",1574,\"^L\",1580,\"^W\",1,\"^X\",true,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"^@T\"]]]]],\"^Q\",\"Sets the emissive color of the material used for drawing shapes\\n  drawn to the screen. Used in combination with ambient, specular, and\\n  shininess in setting the material properties of shapes. Converts all\\n  args to ints\"],\"~$point\",[\"^ \",\"^A\",\"Shape\",\"^B\",null,\"^C\",[\"^ \",\"^A\",\"Shape\",\"^D\",\"1.0\",\"^E\",\"2D Primitives\",\"^F\",\"^6\",\"^G\",8,\"^14\",[\"^ \",\"^S\",false,\"^W\",3,\"^T\",[\"^N\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^M\",[\"^N\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"point()\",\"^I\",3,\"^J\",true,\"^K\",2967,\"^L\",2967,\"^M\",[\"^N\",[\"^O\",[\"^N\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]]]],\"^Q\",\"Draws a point, a coordinate in space at the dimension of one\\n  pixel. The first parameter is the horizontal value for the point,\\n  the second value is the vertical value for the point, and the\\n  optional third value is the depth value. Drawing this shape in 3D\\n  using the z parameter requires the :P3D or :opengl renderer to be\\n  used.\"],\"^D\",\"1.0\",\"^5\",\"~$quil.core/point\",\"^S\",false,\"^E\",\"2D Primitives\",\"^F\",\"quil/core.cljc\",\"^G\",8,\"^14\",[\"^ \",\"^S\",false,\"^W\",3,\"^T\",[\"^N\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^M\",[\"^N\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^V\",[\"^N\",[null,null]]],\"^H\",\"point()\",\"^T\",[\"^N\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^U\",null,\"^V\",[\"^N\",[null,null]],\"^I\",1,\"^J\",true,\"^K\",2961,\"^L\",2967,\"^W\",3,\"^X\",true,\"^M\",[\"^N\",[[\"~$x\",\"~$y\"],[\"~$x\",\"~$y\",\"~$z\"]]],\"^Q\",\"Draws a point, a coordinate in space at the dimension of one\\n  pixel. The first parameter is the horizontal value for the point,\\n  the second value is the vertical value for the point, and the\\n  optional third value is the depth value. Drawing this shape in 3D\\n  using the z parameter requires the :P3D or :opengl renderer to be\\n  used.\"]],\"~:require-macros\",[\"^ \",\"^;\",\"^<\",\"^<\",\"^<\",\"~$u\",\"^=\",\"^=\",\"^=\"],\"~:cljs.analyzer/constants\",[\"^ \",\"~:seen\",[\"^4\",[\"~:shift\",\"~$.endDraw\",\"~:open\",\"~:baseline\",\"~:disable-stroke-perspective\",\"~:hsb\",\"~:quads\",\"~:arrow\",\"~:dilate\",\"^=[\",\"~$try\",\"^>K\",\"~:quad-strip\",\"~:down\",\"~:disable-depth-mask\",\"~$cljs.core/binding\",\"~:burn\",\"~:posterize\",\"~$quil.sketch/with-sketch\",\"~:f8\",\"^@;\",\"~:screen\",\"~:enable-depth-test\",\"~:gray\",\"~:enable-depth-sort\",\"~:f1\",\"~:corner\",\"~:disable-texture-mipmaps\",\"~:darkest\",\"~:f10\",\"~:dodge\",\"~:bottom\",\"~$tr__19__auto__\",\"~$gr__21__auto__\",\"~:bevel\",\"~:disable-stroke-pure\",\"~:replace\",\"~:alt\",\"~:top\",\"~$cljs.core/apply\",\"~:disable-depth-test\",\"~$finally\",\"~:pie\",\"^4C\",\"~:enable-stroke-perspective\",\"~:chord\",\"~:rgb\",\"~$.dispose\",\"~:lines\",\"~:argb\",\"~:move\",\"~:f5\",\"~:command\",\"~$tr__20__auto__\",\"^64\",\"~:miter\",\"~:points\",\"~:hand\",\"~:close\",\"~:radius\",\"~:normal\",\"~$old-stroke__18__auto__\",\"~:threshold\",\"~:up\",\"~:center\",\"~:round\",\"~:disable-optimized-stroke\",\"~$cljs.core/let\",\"~:corners\",\"~:f11\",\"~:opaque\",\"~:overlay\",\"~$quil.sketch/defsketch\",\"~:enable-opengl-errors\",\"~:enable-stroke-pure\",\"~:blur\",\"~:project\",\"~:triangle-fan\",\"~:f3\",\"~:enable-depth-mask\",\"~:f2\",\"~:control\",\"~:difference\",\"^?T\",\"~:square\",\"~:enable-optimized-stroke\",\"~:p2d\",\"~:shape\",\"~:f12\",\"~:exclusion\",\"^96\",\"~:disable-opengl-errors\",\"~:unknown-key\",\"~:alpha\",\"~:wait\",\"~:right\",\"^>W\",\"~$gr__16__auto__\",\"~:repeat\",\"~:hard-light\",\"~:image\",\"~:multiply\",\"~:lightest\",\"^?P\",\"~:f7\",\"~$old-fill__17__auto__\",\"~:blend\",\"~:disable-depth-sort\",\"~:f9\",\"~:erode\",\"~:add\",\"~:soft-light\",\"^1P\",\"~:subtract\",\"~:clamp\",\"~:f6\",\"~:f4\",\"~:triangle-strip\",\"~:cross\",\"~:triangles\",\"~$.beginDraw\",\"~:left\",\"~:invert\",\"~:text\",\"~:enable-texture-mipmaps\",\"~:model\"]],\"~:order\",[\"^A1\",\"^AX\",\"^AV\",\"^A6\",\"^CC\",\"^B7\",\"^B1\",\"^CH\",\"^BZ\",\"^B6\",\"^A[\",\"^CD\",\"^BK\",\"^CB\",\"^A5\",\"^A9\",\"^A=\",\"^AA\",\"^AH\",\"^AJ\",\"^AP\",\"^BE\",\"^BP\",\"^BV\",\"^C2\",\"^C4\",\"^C5\",\"^C8\",\"^C<\",\"^C=\",\"^C>\",\"^AY\",\"^A4\",\"^B0\",\"^BY\",\"^B>\",\"^B9\",\"^AF\",\"^BB\",\"^A3\",\"^A;\",\"^AB\",\"^AD\",\"^AG\",\"^AO\",\"^AT\",\"^AW\",\"^B@\",\"^BG\",\"^BH\",\"^BM\",\"^BR\",\"^BW\",\"^C9\",\"^CI\",\"^BQ\",\"^B?\",\"^BJ\",\"^CJ\",\"^B5\",\"^AN\",\"^CF\",\"^B[\",\"^AR\",\"^AK\",\"^A2\",\"^BT\",\"^C3\",\"^B:\",\"^C?\",\"^C1\",\"^B<\",\"^AC\",\"^CG\",\"^A>\",\"^BI\",\"^BD\",\"^C;\",\"^A7\",\"^B=\",\"^A:\",\"^@[\",\"^AE\",\"^BO\",\"^BN\",\"^AQ\",\"^BL\",\"^CA\",\"^B2\",\"^C@\",\"^C6\",\"^A@\",\"^C:\",\"^AI\",\"^BC\",\"^BU\",\"^B3\",\"^A?\",\"^BS\",\"^BA\",\"^C0\",\"^1P\",\"^AZ\",\"^B8\",\"^C7\",\"^=[\",\"^AS\",\"^96\",\"^B;\",\"^>W\",\"^64\",\"^AL\",\"^?T\",\"^A8\",\"^@;\",\"^AU\",\"^4C\",\"^B4\",\"^?P\",\"^AM\",\"^A<\",\"^>K\",\"^CE\",\"^A0\",\"^BF\",\"^BX\"]],\"^Q\",\"Wrappers and extensions around the core Processing.org API.\"]","org/processingjs/Processing.js":"(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\nmodule.exports={\n  \"name\": \"processing-js\",\n  \"version\": \"1.6.3\",\n  \"author\": \"Processing.js\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git@github.com/processing-js/processing-js.git\"\n  },\n  \"main\": \"processing.min.js\",\n  \"bugs\": \"https://github.com/processing-js/processing-js/issues\",\n  \"devDependencies\": {\n    \"argv\": \"~0.0.2\",\n    \"browserify\": \"^11.0.1\",\n    \"express\": \"~3.3.3\",\n    \"grunt\": \"~0.4.1\",\n    \"grunt-cli\": \"~0.1.8\",\n    \"grunt-contrib-jshint\": \"~0.4.3\",\n    \"http-server\": \"^0.9.0\",\n    \"minifier\": \"^0.7.1\",\n    \"node-minify\": \"~0.7.3\",\n    \"nunjucks\": \"~0.1.9\",\n    \"open\": \"0.0.3\"\n  },\n  \"scripts\": {\n    \"test\": \"node test\",\n    \"test:manual\": \"http-server -o test/manual\",\n    \"start\": \"browserify build.js -o processing.js && minify --output processing.min.js processing.js\"\n  },\n  \"license\": \"MIT\",\n  \"dependencies\": {\n    \"minifier\": \"^0.7.1\"\n  }\n}\n\n},{}],2:[function(require,module,exports){\n/**\n* A ObjectIterator is an iterator wrapper for objects. If passed object contains\n* the iterator method, the object instance will be replaced by the result returned by\n* this method call. If passed object is an array, the ObjectIterator instance iterates\n* through its items.\n*\n* @param {Object} obj The object to be iterated.\n*/\nmodule.exports = function ObjectIterator(obj) {\n  if (obj instanceof Array) {\n    // iterate through array items\n    var index = -1;\n    this.hasNext = function() {\n      return ++index < obj.length;\n    };\n    this.next = function() {\n      return obj[index];\n    };\n  } else if (obj.iterator instanceof Function) {\n    return obj.iterator();\n  } else {\n    throw \"Unable to iterate: \" + obj;\n  }\n};\n\n},{}],3:[function(require,module,exports){\n/**\n * Processing.js environment constants\n */\nmodule.exports = {\n    X: 0,\n    Y: 1,\n    Z: 2,\n\n    R: 3,\n    G: 4,\n    B: 5,\n    A: 6,\n\n    U: 7,\n    V: 8,\n\n    NX: 9,\n    NY: 10,\n    NZ: 11,\n\n    EDGE: 12,\n\n    // Stroke\n    SR: 13,\n    SG: 14,\n    SB: 15,\n    SA: 16,\n\n    SW: 17,\n\n    // Transformations (2D and 3D)\n    TX: 18,\n    TY: 19,\n    TZ: 20,\n\n    VX: 21,\n    VY: 22,\n    VZ: 23,\n    VW: 24,\n\n    // Material properties\n    AR: 25,\n    AG: 26,\n    AB: 27,\n\n    DR: 3,\n    DG: 4,\n    DB: 5,\n    DA: 6,\n\n    SPR: 28,\n    SPG: 29,\n    SPB: 30,\n\n    SHINE: 31,\n\n    ER: 32,\n    EG: 33,\n    EB: 34,\n\n    BEEN_LIT: 35,\n\n    VERTEX_FIELD_COUNT: 36,\n\n    // Renderers\n    P2D:    1,\n    JAVA2D: 1,\n    WEBGL:  2,\n    P3D:    2,\n    OPENGL: 2,\n    PDF:    0,\n    DXF:    0,\n\n    // Platform IDs\n    OTHER:   0,\n    WINDOWS: 1,\n    MAXOSX:  2,\n    LINUX:   3,\n\n    EPSILON: 0.0001,\n\n    MAX_FLOAT:  3.4028235e+38,\n    MIN_FLOAT: -3.4028235e+38,\n    MAX_INT:    2147483647,\n    MIN_INT:   -2147483648,\n\n    PI:         Math.PI,\n    TWO_PI:     2 * Math.PI,\n    TAU:        2 * Math.PI,\n    HALF_PI:    Math.PI / 2,\n    THIRD_PI:   Math.PI / 3,\n    QUARTER_PI: Math.PI / 4,\n\n    DEG_TO_RAD: Math.PI / 180,\n    RAD_TO_DEG: 180 / Math.PI,\n\n    WHITESPACE: \" \\t\\n\\r\\f\\u00A0\",\n\n    // Color modes\n    RGB:   1,\n    ARGB:  2,\n    HSB:   3,\n    ALPHA: 4,\n    CMYK:  5,\n\n    // Image file types\n    TIFF:  0,\n    TARGA: 1,\n    JPEG:  2,\n    GIF:   3,\n\n    // Filter/convert types\n    BLUR:      11,\n    GRAY:      12,\n    INVERT:    13,\n    OPAQUE:    14,\n    POSTERIZE: 15,\n    THRESHOLD: 16,\n    ERODE:     17,\n    DILATE:    18,\n\n    // Blend modes\n    REPLACE:    0,\n    BLEND:      1 << 0,\n    ADD:        1 << 1,\n    SUBTRACT:   1 << 2,\n    LIGHTEST:   1 << 3,\n    DARKEST:    1 << 4,\n    DIFFERENCE: 1 << 5,\n    EXCLUSION:  1 << 6,\n    MULTIPLY:   1 << 7,\n    SCREEN:     1 << 8,\n    OVERLAY:    1 << 9,\n    HARD_LIGHT: 1 << 10,\n    SOFT_LIGHT: 1 << 11,\n    DODGE:      1 << 12,\n    BURN:       1 << 13,\n\n    // Color component bit masks\n    ALPHA_MASK: 0xff000000,\n    RED_MASK:   0x00ff0000,\n    GREEN_MASK: 0x0000ff00,\n    BLUE_MASK:  0x000000ff,\n\n    // Projection matrices\n    CUSTOM:       0,\n    ORTHOGRAPHIC: 2,\n    PERSPECTIVE:  3,\n\n    // Shapes\n    POINT:          2,\n    POINTS:         2,\n    LINE:           4,\n    LINES:          4,\n    TRIANGLE:       8,\n    TRIANGLES:      9,\n    TRIANGLE_STRIP: 10,\n    TRIANGLE_FAN:   11,\n    QUAD:           16,\n    QUADS:          16,\n    QUAD_STRIP:     17,\n    POLYGON:        20,\n    PATH:           21,\n    RECT:           30,\n    ELLIPSE:        31,\n    ARC:            32,\n    SPHERE:         40,\n    BOX:            41,\n\n    // Arc drawing modes\n    //OPEN:          1, // shared with Shape closing modes   \n    CHORD:           2,\n    PIE:             3, \n\n\n    GROUP:          0,\n    PRIMITIVE:      1,\n    //PATH:         21, // shared with Shape PATH\n    GEOMETRY:       3,\n\n    // Shape Vertex\n    VERTEX:        0,\n    BEZIER_VERTEX: 1,\n    CURVE_VERTEX:  2,\n    BREAK:         3,\n    CLOSESHAPE:    4,\n\n    // Shape closing modes\n    OPEN:  1,\n    CLOSE: 2,\n\n    // Shape drawing modes\n    CORNER:          0, // Draw mode convention to use (x, y) to (width, height)\n    CORNERS:         1, // Draw mode convention to use (x1, y1) to (x2, y2) coordinates\n    RADIUS:          2, // Draw mode from the center, and using the radius\n    CENTER_RADIUS:   2, // Deprecated! Use RADIUS instead\n    CENTER:          3, // Draw from the center, using second pair of values as the diameter\n    DIAMETER:        3, // Synonym for the CENTER constant. Draw from the center\n    CENTER_DIAMETER: 3, // Deprecated! Use DIAMETER instead\n\n    // Text vertical alignment modes\n    BASELINE: 0,   // Default vertical alignment for text placement\n    TOP:      101, // Align text to the top\n    BOTTOM:   102, // Align text from the bottom, using the baseline\n\n    // UV Texture coordinate modes\n    NORMAL:     1,\n    NORMALIZED: 1,\n    IMAGE:      2,\n\n    // Text placement modes\n    MODEL: 4,\n    SHAPE: 5,\n\n    // Stroke modes\n    SQUARE:  'butt',\n    ROUND:   'round',\n    PROJECT: 'square',\n    MITER:   'miter',\n    BEVEL:   'bevel',\n\n    // Lighting modes\n    AMBIENT:     0,\n    DIRECTIONAL: 1,\n    //POINT:     2, Shared with Shape constant\n    SPOT:        3,\n\n    // Key constants\n\n    // Both key and keyCode will be equal to these values\n    BACKSPACE: 8,\n    TAB:       9,\n    ENTER:     10,\n    RETURN:    13,\n    ESC:       27,\n    DELETE:    127,\n    CODED:     0xffff,\n\n    // p.key will be CODED and p.keyCode will be this value\n    SHIFT:     16,\n    CONTROL:   17,\n    ALT:       18,\n    CAPSLK:    20,\n    PGUP:      33,\n    PGDN:      34,\n    END:       35,\n    HOME:      36,\n    LEFT:      37,\n    UP:        38,\n    RIGHT:     39,\n    DOWN:      40,\n    F1:        112,\n    F2:        113,\n    F3:        114,\n    F4:        115,\n    F5:        116,\n    F6:        117,\n    F7:        118,\n    F8:        119,\n    F9:        120,\n    F10:       121,\n    F11:       122,\n    F12:       123,\n    NUMLK:     144,\n    META:      157,\n    INSERT:    155,\n\n    // Cursor types\n    ARROW:    'default',\n    CROSS:    'crosshair',\n    HAND:     'pointer',\n    MOVE:     'move',\n    TEXT:     'text',\n    WAIT:     'wait',\n    NOCURSOR: \"url('data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=='), auto\",\n\n    // Hints\n    DISABLE_OPENGL_2X_SMOOTH:     1,\n    ENABLE_OPENGL_2X_SMOOTH:     -1,\n    ENABLE_OPENGL_4X_SMOOTH:      2,\n    ENABLE_NATIVE_FONTS:          3,\n    DISABLE_DEPTH_TEST:           4,\n    ENABLE_DEPTH_TEST:           -4,\n    ENABLE_DEPTH_SORT:            5,\n    DISABLE_DEPTH_SORT:          -5,\n    DISABLE_OPENGL_ERROR_REPORT:  6,\n    ENABLE_OPENGL_ERROR_REPORT:  -6,\n    ENABLE_ACCURATE_TEXTURES:     7,\n    DISABLE_ACCURATE_TEXTURES:   -7,\n    HINT_COUNT:                  10,\n\n    // PJS defined constants\n    SINCOS_LENGTH:      720,       // every half degree\n    PRECISIONB:         15,        // fixed point precision is limited to 15 bits!!\n    PRECISIONF:         1 << 15,\n    PREC_MAXVAL:        (1 << 15) - 1,\n    PREC_ALPHA_SHIFT:   24 - 15,\n    PREC_RED_SHIFT:     16 - 15,\n    NORMAL_MODE_AUTO:   0,\n    NORMAL_MODE_SHAPE:  1,\n    NORMAL_MODE_VERTEX: 2,\n    MAX_LIGHTS:         8\n};\n\n},{}],4:[function(require,module,exports){\n// the logger for print() and println()\nmodule.exports = function PjsConsole(document) {\n  var e = { BufferMax: 200 },\n      style = document.createElement(\"style\"),\n      added = false;\n\n  style.textContent = [\n    \".pjsconsole.hidden {\",\n    \"  display: none!important;\",\n    \"}\"\n  ].join('\\n');\n\n  e.wrapper = document.createElement(\"div\");\n  style.textContent += [\n    \"\",\n    \".pjsconsole {\",\n    \"  opacity: .75;\",\n    \"  display: block;\",\n    \"  position: fixed;\",\n    \"  bottom: 0px;\",\n    \"  left: 0px;\",\n    \"  right: 0px;\",\n    \"  height: 50px;\",\n    \"  background-color: #aaa;\",\n    \"}\"\n  ].join('\\n');\n  e.wrapper.classList.add(\"pjsconsole\");\n\n  e.dragger = document.createElement(\"div\");\n  style.textContent += [\n    \"\",\n    \".pjsconsole .dragger {\",\n    \"  display: block;\",\n    \"  border: 3px black raised;\",\n    \"  cursor: n-resize;\",\n    \"  position: absolute;\",\n    \"  top: 0px;\",\n    \"  left: 0px;\",\n    \"  right: 0px;\",\n    \"  height: 5px;\",\n    \"  background-color: #333;\",\n    \"}\"\n  ].join('\\n');\n  e.dragger.classList.add(\"dragger\");\n\n  e.closer = document.createElement(\"div\");\n  style.textContent += [\n    \"\",\n    \".pjsconsole .closer {\",\n    \"  opacity: .5;\",\n    \"  display: block;\",\n    \"  border: 3px black raised;\",\n    \"  position: absolute;\",\n    \"  top: 10px;\",\n    \"  right: 30px;\",\n    \"  height: 20px;\",\n    \"  width: 20px;\",\n    \"  background-color: #ddd;\",\n    \"  color: #000;\",\n    \"  line-height: 20px;\",\n    \"  text-align: center;\",\n    \"  cursor: pointer\",\n    \"}\"\n  ].join('\\n');\n  e.closer.classList.add(\"closer\");\n  e.closer.innerHTML = \"&#10006;\";\n\n  e.javaconsole = document.createElement(\"div\");\n  style.textContent += [\n    \"\",\n    \".pjsconsole .console {\",\n    \"  overflow-x: auto;\",\n    \"  display: block;\",\n    \"  position: absolute;\",\n    \"  left: 10px;\",\n    \"  right: 0px;\",\n    \"  bottom: 5px;\",\n    \"  top: 10px;\",\n    \"  overflow-y: scroll;\",\n    \"  height: 40px;\",\n    \"}\"\n  ].join('\\n');\n  e.javaconsole.setAttribute(\"class\", \"console\");\n\n  e.wrapper.appendChild(e.dragger);\n  e.wrapper.appendChild(e.javaconsole);\n  e.wrapper.appendChild(e.closer);\n\n  e.dragger.onmousedown = function (t) {\n    e.divheight = e.wrapper.style.height;\n    if (document.selection) document.selection.empty();\n    else window.getSelection().removeAllRanges();\n    var n = t.screenY;\n    window.onmousemove = function (t) {\n      e.wrapper.style.height = parseFloat(e.divheight) + (n - t.screenY) + \"px\";\n      e.javaconsole.style.height = parseFloat(e.divheight) + (n - t.screenY) - 10 + \"px\";\n    };\n    window.onmouseup = function (t) {\n      if (document.selection) document.selection.empty();\n      else window.getSelection().removeAllRanges();\n      e.wrapper.style.height = parseFloat(e.divheight) + (n - t.screenY) + \"px\";\n      e.javaconsole.style.height = parseFloat(e.divheight) + (n - t.screenY) - 10 + \"px\";\n      window.onmousemove = null;\n      window.onmouseup = null;\n    };\n  };\n\n  e.BufferArray = [];\n\n  e.print = e.log = function () {\n    if(!added) {\n      document.body.appendChild(style);\n      document.body.appendChild(e.wrapper);\n      added = true;\n    }\n    var args = Array.prototype.slice.call(arguments);\n    t = args.map(function(t, idx) { return t + (idx+1 === args.length ? \"\" : \" \"); }).join('');\n    if (e.BufferArray[e.BufferArray.length - 1]) e.BufferArray[e.BufferArray.length - 1] += (t) + \"\";\n    else e.BufferArray.push(t);\n    e.javaconsole.innerHTML = e.BufferArray.join('');\n    e.showconsole();\n  };\n\n  e.println = function () {\n    var args = Array.prototype.slice.call(arguments);\n    args.push('<br>');\n    e.print.apply(e, args);\n    if (e.BufferArray.length > e.BufferMax) {\n      e.BufferArray.splice(0, 1);\n    } else {\n      e.javaconsole.scrollTop = e.javaconsole.scrollHeight;\n    }\n  };\n\n  e.showconsole = function () { e.wrapper.classList.remove(\"hidden\"); };\n  e.hideconsole = function () { e.wrapper.classList.add(\"hidden\"); };\n\n  e.closer.onclick = function () { e.hideconsole(); };\n\n  e.hideconsole();\n\n  return e;\n};\n\n},{}],5:[function(require,module,exports){\n/**\n * Processing.js default scope\n */\nmodule.exports = function(options) {\n\n  // Building defaultScope. Changing of the prototype protects\n  // internal Processing code from the changes in defaultScope\n  function DefaultScope() {}\n  DefaultScope.prototype = options.PConstants;\n\n  var defaultScope = new DefaultScope();\n\n  // copy over all known Object types and helper objects\n  Object.keys(options).forEach(function(prop) {\n    defaultScope[prop] = options[prop];\n  });\n\n  ////////////////////////////////////////////////////////////////////////////\n  // Class inheritance helper methods\n  ////////////////////////////////////////////////////////////////////////////\n\n  defaultScope.defineProperty = function(obj, name, desc) {\n    if(\"defineProperty\" in Object) {\n      Object.defineProperty(obj, name, desc);\n    } else {\n      if (desc.hasOwnProperty(\"get\")) {\n        obj.__defineGetter__(name, desc.get);\n      }\n      if (desc.hasOwnProperty(\"set\")) {\n        obj.__defineSetter__(name, desc.set);\n      }\n    }\n  };\n\n  /**\n   * class overloading, part 1\n   */\n  function overloadBaseClassFunction(object, name, basefn) {\n    if (!object.hasOwnProperty(name) || typeof object[name] !== 'function') {\n      // object method is not a function or just inherited from Object.prototype\n      object[name] = basefn;\n      return;\n    }\n    var fn = object[name];\n    if (\"$overloads\" in fn) {\n      // the object method already overloaded (see defaultScope.addMethod)\n      // let's just change a fallback method\n      fn.$defaultOverload = basefn;\n      return;\n    }\n    if (!(\"$overloads\" in basefn) && fn.length === basefn.length) {\n      // special case when we just overriding the method\n      return;\n    }\n    var overloads, defaultOverload;\n    if (\"$overloads\" in basefn) {\n      // let's inherit base class overloads to speed up things\n      overloads = basefn.$overloads.slice(0);\n      overloads[fn.length] = fn;\n      defaultOverload = basefn.$defaultOverload;\n    } else {\n      overloads = [];\n      overloads[basefn.length] = basefn;\n      overloads[fn.length] = fn;\n      defaultOverload = fn;\n    }\n    var hubfn = function() {\n      var fn = hubfn.$overloads[arguments.length] ||\n               (\"$methodArgsIndex\" in hubfn && arguments.length > hubfn.$methodArgsIndex ?\n               hubfn.$overloads[hubfn.$methodArgsIndex] : null) ||\n               hubfn.$defaultOverload;\n      return fn.apply(this, arguments);\n    };\n    hubfn.$overloads = overloads;\n    if (\"$methodArgsIndex\" in basefn) {\n      hubfn.$methodArgsIndex = basefn.$methodArgsIndex;\n    }\n    hubfn.$defaultOverload = defaultOverload;\n    hubfn.name = name;\n    object[name] = hubfn;\n  }\n\n  /**\n   * class overloading, part 2\n   */\n\n  function extendClass(subClass, baseClass) {\n    function extendGetterSetter(propertyName) {\n      defaultScope.defineProperty(subClass, propertyName, {\n        get: function() {\n          return baseClass[propertyName];\n        },\n        set: function(v) {\n          baseClass[propertyName]=v;\n        },\n        enumerable: true\n      });\n    }\n\n    var properties = [];\n    for (var propertyName in baseClass) {\n      if (typeof baseClass[propertyName] === 'function') {\n        overloadBaseClassFunction(subClass, propertyName, baseClass[propertyName]);\n      } else if(propertyName.charAt(0) !== \"$\" && !(propertyName in subClass)) {\n        // Delaying the properties extension due to the IE9 bug (see #918).\n        properties.push(propertyName);\n      }\n    }\n    while (properties.length > 0) {\n      extendGetterSetter(properties.shift());\n    }\n\n    subClass.$super = baseClass;\n  }\n\n  /**\n   * class overloading, part 3\n   */\n  defaultScope.extendClassChain = function(base) {\n    var path = [base];\n    for (var self = base.$upcast; self; self = self.$upcast) {\n      extendClass(self, base);\n      path.push(self);\n      base = self;\n    }\n    while (path.length > 0) {\n      path.pop().$self=base;\n    }\n  };\n\n  // static\n  defaultScope.extendStaticMembers = function(derived, base) {\n    extendClass(derived, base);\n  };\n\n  // interface\n  defaultScope.extendInterfaceMembers = function(derived, base) {\n    extendClass(derived, base);\n  };\n\n  /**\n   * Java methods and JavaScript functions differ enough that\n   * we need a special function to make sure it all links up\n   * as classical hierarchical class chains.\n   */\n  defaultScope.addMethod = function(object, name, fn, hasMethodArgs) {\n    var existingfn = object[name];\n    if (existingfn || hasMethodArgs) {\n      var args = fn.length;\n      // builds the overload methods table\n      if (\"$overloads\" in existingfn) {\n        existingfn.$overloads[args] = fn;\n      } else {\n        var hubfn = function() {\n          var fn = hubfn.$overloads[arguments.length] ||\n                   (\"$methodArgsIndex\" in hubfn && arguments.length > hubfn.$methodArgsIndex ?\n                   hubfn.$overloads[hubfn.$methodArgsIndex] : null) ||\n                   hubfn.$defaultOverload;\n          return fn.apply(this, arguments);\n        };\n        var overloads = [];\n        if (existingfn) {\n          overloads[existingfn.length] = existingfn;\n        }\n        overloads[args] = fn;\n        hubfn.$overloads = overloads;\n        hubfn.$defaultOverload = existingfn || fn;\n        if (hasMethodArgs) {\n          hubfn.$methodArgsIndex = args;\n        }\n        hubfn.name = name;\n        object[name] = hubfn;\n      }\n    } else {\n      object[name] = fn;\n    }\n  };\n\n  // internal helper function\n  function isNumericalJavaType(type) {\n    if (typeof type !== \"string\") {\n      return false;\n    }\n    return [\"byte\", \"int\", \"char\", \"color\", \"float\", \"long\", \"double\"].indexOf(type) !== -1;\n  }\n\n  /**\n   * Java's arrays are pre-filled when declared with\n   * an initial size, but no content. JS arrays are not.\n   */\n  defaultScope.createJavaArray = function(type, bounds) {\n    var result = null,\n        defaultValue = null;\n    if (typeof type === \"string\") {\n      if (type === \"boolean\") {\n        defaultValue = false;\n      } else if (isNumericalJavaType(type)) {\n        defaultValue = 0;\n      }\n    }\n    if (typeof bounds[0] === 'number') {\n      var itemsCount = 0 | bounds[0];\n      if (bounds.length <= 1) {\n        result = [];\n        result.length = itemsCount;\n        for (var i = 0; i < itemsCount; ++i) {\n          result[i] = defaultValue;\n        }\n      } else {\n        result = [];\n        var newBounds = bounds.slice(1);\n        for (var j = 0; j < itemsCount; ++j) {\n          result.push(defaultScope.createJavaArray(type, newBounds));\n        }\n      }\n    }\n    return result;\n  };\n\n  // screenWidth and screenHeight are shared by all instances.\n  // and return the width/height of the browser's viewport.\n  defaultScope.defineProperty(defaultScope, 'screenWidth',\n    { get: function() { return window.innerWidth; } });\n\n  defaultScope.defineProperty(defaultScope, 'screenHeight',\n    { get: function() { return window.innerHeight; } });\n\n  return defaultScope;\n};\n\n},{}],6:[function(require,module,exports){\n/**\n * Finalise the Processing.js object.\n */\nmodule.exports = function finalizeProcessing(Processing, options) {\n\n  // unpack options\n  var window = options.window,\n      document = options.document,\n      XMLHttpRequest = window.XMLHttpRequest,\n      noop = options.noop,\n      isDOMPresent = options.isDOMPresent,\n      version = options.version,\n      undef;\n\n  // versioning\n  Processing.version = (version ? version : \"@DEV-VERSION@\");\n\n  // Share lib space\n  Processing.lib = {};\n\n  /**\n   * External libraries can be added to the global Processing\n   * objects with the `registerLibrary` function.\n   */\n  Processing.registerLibrary = function(name, library) {\n    Processing.lib[name] = library;\n    if(library.hasOwnProperty(\"init\")) {\n      library.init(defaultScope);\n    }\n  };\n\n  /**\n   * This is the object that acts as our version of PApplet.\n   * This can be called as Processing.Sketch() or as\n   * Processing.Sketch(function) in which case the function\n   * must be an already-compiled-to-JS sketch function.\n   */\n  Processing.Sketch = function(attachFunction) {\n    this.attachFunction = attachFunction;\n    this.options = {\n      pauseOnBlur: false,\n      globalKeyEvents: false\n    };\n\n    /* Optional Sketch event hooks:\n     *   onLoad       - parsing/preloading is done, before sketch starts\n     *   onSetup      - setup() has been called, before first draw()\n     *   onPause      - noLoop() has been called, pausing draw loop\n     *   onLoop       - loop() has been called, resuming draw loop\n     *   onFrameStart - draw() loop about to begin\n     *   onFrameEnd   - draw() loop finished\n     *   onExit       - exit() done being called\n     */\n    this.onLoad = noop;\n    this.onSetup = noop;\n    this.onPause = noop;\n    this.onLoop = noop;\n    this.onFrameStart = noop;\n    this.onFrameEnd = noop;\n    this.onExit = noop;\n\n    this.params = {};\n    this.imageCache = {\n      pending: 0,\n      images: {},\n      // Opera requires special administration for preloading\n      operaCache: {},\n      // Specify an optional img arg if the image is already loaded in the DOM,\n      // otherwise href will get loaded.\n      add: function(href, img) {\n        // Prevent muliple loads for an image, in case it gets\n        // preloaded more than once, or is added via JS and then preloaded.\n        if (this.images[href]) {\n          return;\n        }\n\n        if (!isDOMPresent) {\n          this.images[href] = null;\n        }\n\n        // No image in the DOM, kick-off a background load\n        if (!img) {\n          img = new Image();\n          img.onload = (function(owner) {\n            return function() {\n              owner.pending--;\n            };\n          }(this));\n          this.pending++;\n          img.src = href;\n        }\n\n        this.images[href] = img;\n\n        // Opera will not load images until they are inserted into the DOM.\n        if (window.opera) {\n          var div = document.createElement(\"div\");\n          div.appendChild(img);\n          // we can't use \"display: none\", since that makes it invisible, and thus not load\n          div.style.position = \"absolute\";\n          div.style.opacity = 0;\n          div.style.width = \"1px\";\n          div.style.height= \"1px\";\n          if (!this.operaCache[href]) {\n            document.body.appendChild(div);\n            this.operaCache[href] = div;\n          }\n        }\n      }\n    };\n\n    this.sourceCode = undefined;\n    this.attach = function(processing) {\n      // either attachFunction or sourceCode must be present on attach\n      if(typeof this.attachFunction === \"function\") {\n        this.attachFunction(processing);\n      } else if(this.sourceCode) {\n        var func = ((new Function(\"return (\" + this.sourceCode + \");\"))());\n        func(processing);\n        this.attachFunction = func;\n      } else {\n        throw \"Unable to attach sketch to the processing instance\";\n      }\n    };\n\n    this.toString = function() {\n      var i;\n      var code = \"((function(Sketch) {\\n\";\n      code += \"var sketch = new Sketch(\\n\" + this.sourceCode + \");\\n\";\n      for(i in this.options) {\n        if(this.options.hasOwnProperty(i)) {\n          var value = this.options[i];\n          code += \"sketch.options.\" + i + \" = \" +\n            (typeof value === 'string' ? '\\\"' + value + '\\\"' : \"\" + value) + \";\\n\";\n        }\n      }\n      for(i in this.imageCache) {\n        if(this.options.hasOwnProperty(i)) {\n          code += \"sketch.imageCache.add(\\\"\" + i + \"\\\");\\n\";\n        }\n      }\n      // TODO serialize fonts\n      code += \"return sketch;\\n})(Processing.Sketch))\";\n      return code;\n    };\n  };\n\n  /**\n   * aggregate all source code into a single file, then rewrite that\n   * source and bind to canvas via new Processing(canvas, sourcestring).\n   * @param {CANVAS} canvas The html canvas element to bind to\n   * @param {String[]} source The array of files that must be loaded\n   * @param {Function} onComplete A callback, called with the sketch as the argument.\n   */\n  var loadSketchFromSources = Processing.loadSketchFromSources = function(canvas, sources, onComplete) {\n    var code = [], errors = [], sourcesCount = sources.length, loaded = 0;\n\n    function ajaxAsync(url, callback) {\n      var xhr = new XMLHttpRequest();\n      xhr.onreadystatechange = function() {\n        if (xhr.readyState === 4) {\n          var error;\n          if (xhr.status !== 200 && xhr.status !== 0) {\n            error = \"Invalid XHR status \" + xhr.status;\n          } else if (xhr.responseText === \"\") {\n            // Give a hint when loading fails due to same-origin issues on file:/// urls\n            if ( (\"withCredentials\" in new XMLHttpRequest()) &&\n                 (new XMLHttpRequest()).withCredentials === false &&\n                 window.location.protocol === \"file:\" ) {\n              error = \"XMLHttpRequest failure, possibly due to a same-origin policy violation. You can try loading this page in another browser, or load it from http://localhost using a local webserver. See the Processing.js README for a more detailed explanation of this problem and solutions.\";\n            } else {\n              error = \"File is empty.\";\n            }\n          }\n\n          callback(xhr.responseText, error);\n        }\n      };\n      xhr.open(\"GET\", url, true);\n      if (xhr.overrideMimeType) {\n        xhr.overrideMimeType(\"application/json\");\n      }\n      xhr.setRequestHeader(\"If-Modified-Since\", \"Fri, 01 Jan 1960 00:00:00 GMT\"); // no cache\n      xhr.send(null);\n    }\n\n    function loadBlock(index, filename) {\n      function callback(block, error) {\n        code[index] = block;\n        ++loaded;\n        if (error) {\n          errors.push(filename + \" ==> \" + error);\n        }\n        if (loaded === sourcesCount) {\n          if (errors.length === 0) {\n            // This used to throw, but it was constantly getting in the way of debugging where things go wrong!\n            var sketch = new Processing(canvas, code.join(\"\\n\"));\n            if (onComplete) {\n              onComplete(sketch);\n            }\n          } else {\n            throw \"Processing.js: Unable to load pjs sketch files: \" + errors.join(\"\\n\");\n          }\n        }\n      }\n      if (filename.charAt(0) === '#') {\n        // trying to get script from the element\n        var scriptElement = document.getElementById(filename.substring(1));\n        if (scriptElement) {\n          callback(scriptElement.text || scriptElement.textContent);\n        } else {\n          callback(\"\", \"Unable to load pjs sketch: element with id \\'\" + filename.substring(1) + \"\\' was not found\");\n        }\n        return;\n      }\n\n      ajaxAsync(filename, callback);\n    }\n\n    for (var i = 0; i < sourcesCount; ++i) {\n      loadBlock(i, sources[i]);\n    }\n  };\n\n  /**\n   * Automatic initialization function.\n   */\n  var init = function() {\n    document.removeEventListener('DOMContentLoaded', init, false);\n    var i;\n\n    // before running through init, clear the instances list, to prevent\n    // sketch duplication when page content is dynamically swapped without\n    // swapping out processing.js\n    while (Processing.instances.length > 0) {\n      for (i = Processing.instances.length - 1; i >= 0; i--) {\n        if (Processing.instances[i]) {\n          Processing.instances[i].exit();\n        }\n      }\n    }\n\n    var canvas = document.getElementsByTagName('canvas'),\n      filenames;\n\n    for (i = 0, l = canvas.length; i < l; i++) {\n      // datasrc and data-src are deprecated.\n      var processingSources = canvas[i].getAttribute('data-processing-sources');\n      if (processingSources === null) {\n        // Temporary fallback for datasrc and data-src\n        processingSources = canvas[i].getAttribute('data-src');\n        if (processingSources === null) {\n          processingSources = canvas[i].getAttribute('datasrc');\n        }\n      }\n      if (processingSources) {\n        filenames = processingSources.split(/\\s+/g);\n        for (var j = 0; j < filenames.length;) {\n          if (filenames[j]) {\n            j++;\n          } else {\n            filenames.splice(j, 1);\n          }\n        }\n        loadSketchFromSources(canvas[i], filenames);\n      }\n    }\n\n    // also process all <script>-indicated sketches, if there are any\n    var s, last, source, instance,\n        nodelist = document.getElementsByTagName('script'),\n        scripts=[];\n\n    // snapshot the DOM, as the nodelist is only a DOM view, and is\n    // updated instantly when a script element is added or removed.\n    for (s = nodelist.length - 1; s >= 0; s--) {\n      scripts.push(nodelist[s]);\n    }\n\n    // iterate over all script elements to see if they contain Processing code\n    for (s = 0, last = scripts.length; s < last; s++) {\n      var script = scripts[s];\n      if (!script.getAttribute) {\n        continue;\n      }\n\n      var type = script.getAttribute(\"type\");\n      if (type && (type.toLowerCase() === \"text/processing\" || type.toLowerCase() === \"application/processing\")) {\n        var target = script.getAttribute(\"data-processing-target\");\n        canvas = undef;\n        if (target) {\n          canvas = document.getElementById(target);\n        } else {\n          var nextSibling = script.nextSibling;\n          while (nextSibling && nextSibling.nodeType !== 1) {\n            nextSibling = nextSibling.nextSibling;\n          }\n          if (nextSibling && nextSibling.nodeName.toLowerCase() === \"canvas\") {\n            canvas = nextSibling;\n          }\n        }\n\n        if (canvas) {\n          if (script.getAttribute(\"src\")) {\n            filenames = script.getAttribute(\"src\").split(/\\s+/);\n            loadSketchFromSources(canvas, filenames);\n            continue;\n          }\n          source =  script.textContent || script.text;\n          instance = new Processing(canvas, source);\n        }\n      }\n    }\n  };\n\n  /**\n   * automatic loading of all sketches on the page\n   */\n  document.addEventListener('DOMContentLoaded', init, false);\n\n  /**\n   * Make Processing run through init after already having\n   * been set up for a page. This function exists mostly for pages\n   * that swap content in/out without reloading a page.\n   */\n  Processing.reload = init;\n\n  /**\n   * Disable the automatic loading of all sketches on the page.\n   * This will work as long as it's issued before DOMContentLoaded.\n   */\n  Processing.disableInit = function() {\n    document.removeEventListener('DOMContentLoaded', init, false);\n  };\n\n  // done.\n  return Processing;\n};\n\n},{}],7:[function(require,module,exports){\n/**\n * Returns Java equals() result for two objects. If the first object\n * has the \"equals\" function, it preforms the call of this function.\n * Otherwise the method uses the JavaScript === operator.\n *\n * @param {Object} obj          The first object.\n * @param {Object} other        The second object.\n *\n * @returns {boolean}           true if the objects are equal.\n */\nmodule.exports = function virtEquals(obj, other) {\n  if (obj === null || other === null) {\n    return (obj === null) && (other === null);\n  }\n  if (typeof (obj) === \"string\") {\n    return obj === other;\n  }\n  if (typeof(obj) !== \"object\") {\n    return obj === other;\n  }\n  if (obj.equals instanceof Function) {\n    return obj.equals(other);\n  }\n  return obj === other;\n};\n\n},{}],8:[function(require,module,exports){\n/**\n * Returns Java hashCode() result for the object. If the object has the \"hashCode\" function,\n * it preforms the call of this function. Otherwise it uses/creates the \"$id\" property,\n * which is used as the hashCode.\n *\n * @param {Object} obj          The object.\n * @returns {int}               The object's hash code.\n */\nmodule.exports = function virtHashCode(obj, undef) {\n  if (typeof(obj) === \"string\") {\n    var hash = 0;\n    for (var i = 0; i < obj.length; ++i) {\n      hash = (hash * 31 + obj.charCodeAt(i)) & 0xFFFFFFFF;\n    }\n    return hash;\n  }\n  if (typeof(obj) !== \"object\") {\n    return obj & 0xFFFFFFFF;\n  }\n  if (obj.hashCode instanceof Function) {\n    return obj.hashCode();\n  }\n  if (obj.$id === undef) {\n      obj.$id = ((Math.floor(Math.random() * 0x10000) - 0x8000) << 16) | Math.floor(Math.random() * 0x10000);\n  }\n  return obj.$id;\n};\n\n},{}],9:[function(require,module,exports){\n/**\n * An ArrayList stores a variable number of objects.\n *\n * @param {int} initialCapacity optional defines the initial capacity of the list, it's empty by default\n *\n * @returns {ArrayList} new ArrayList object\n */\nmodule.exports = function(options) {\n  var virtHashCode = options.virtHashCode,\n      virtEquals = options.virtEquals;\n\n  function Iterator(array) {\n    var index = -1;\n    this.hasNext = function() {\n      return (index + 1) < array.length;\n    };\n\n    this.next = function() {\n      return array[++index];\n    };\n\n    this.remove = function() {\n      array.splice(index--, 1);\n    };\n  }\n\n  function ArrayList(a) {\n    var array = [];\n\n    if (a && a.toArray) {\n      array = a.toArray();\n    }\n\n    /**\n     * @member ArrayList\n     * ArrayList.get() Returns the element at the specified position in this list.\n     *\n     * @param {int} i index of element to return\n     *\n     * @returns {Object} the element at the specified position in this list.\n     */\n    this.get = function(i) {\n      return array[i];\n    };\n    /**\n     * @member ArrayList\n     * ArrayList.contains() Returns true if this list contains the specified element.\n     *\n     * @param {Object} item element whose presence in this List is to be tested.\n     *\n     * @returns {boolean} true if the specified element is present; false otherwise.\n     */\n    this.contains = function(item) {\n      return this.indexOf(item)>-1;\n    };\n    /**\n     * @member ArrayList\n     * ArrayList.indexOf() Returns the position this element takes in the list, or -1 if the element is not found.\n     *\n     * @param {Object} item element whose position in this List is to be tested.\n     *\n     * @returns {int} the list position that the first match for this element holds in the list, or -1 if it is not in the list.\n     */\n    this.indexOf = function(item) {\n      for (var i = 0, len = array.length; i < len; ++i) {\n        if (virtEquals(item, array[i])) {\n          return i;\n        }\n      }\n      return -1;\n    };\n    /**\n     * @member ArrayList\n     * ArrayList.lastIndexOf() Returns the index of the last occurrence of the specified element in this list,\n     * or -1 if this list does not contain the element. More formally, returns the highest index i such that\n     * (o==null ? get(i)==null : o.equals(get(i))), or -1 if there is no such index.\n     *\n     * @param {Object} item element to search for.\n     *\n     * @returns {int} the index of the last occurrence of the specified element in this list, or -1 if this list does not contain the element.\n     */\n    this.lastIndexOf = function(item) {\n      for (var i = array.length-1; i >= 0; --i) {\n        if (virtEquals(item, array[i])) {\n          return i;\n        }\n      }\n      return -1;\n    };\n    /**\n     * @member ArrayList\n     * ArrayList.add() Adds the specified element to this list.\n     *\n     * @param {int}    index  optional index at which the specified element is to be inserted\n     * @param {Object} object element to be added to the list\n     */\n    this.add = function() {\n      if (arguments.length === 1) {\n        array.push(arguments[0]); // for add(Object)\n      } else if (arguments.length === 2) {\n        var arg0 = arguments[0];\n        if (typeof arg0 === 'number') {\n          if (arg0 >= 0 && arg0 <= array.length) {\n            array.splice(arg0, 0, arguments[1]); // for add(i, Object)\n          } else {\n            throw(arg0 + \" is not a valid index\");\n          }\n        } else {\n          throw(typeof arg0 + \" is not a number\");\n        }\n      } else {\n        throw(\"Please use the proper number of parameters.\");\n      }\n    };\n    /**\n     * @member ArrayList\n     * ArrayList.addAll(collection) appends all of the elements in the specified\n     * Collection to the end of this list, in the order that they are returned by\n     * the specified Collection's Iterator.\n     *\n     * When called as addAll(index, collection) the elements are inserted into\n     * this list at the position indicated by index.\n     *\n     * @param {index} Optional; specifies the position the colletion should be inserted at\n     * @param {collection} Any iterable object (ArrayList, HashMap.keySet(), etc.)\n     * @throws out of bounds error for negative index, or index greater than list size.\n     */\n    this.addAll = function(arg1, arg2) {\n      // addAll(int, Collection)\n      var it;\n      if (typeof arg1 === \"number\") {\n        if (arg1 < 0 || arg1 > array.length) {\n          throw(\"Index out of bounds for addAll: \" + arg1 + \" greater or equal than \" + array.length);\n        }\n        it = new ObjectIterator(arg2);\n        while (it.hasNext()) {\n          array.splice(arg1++, 0, it.next());\n        }\n      }\n      // addAll(Collection)\n      else {\n        it = new ObjectIterator(arg1);\n        while (it.hasNext()) {\n          array.push(it.next());\n        }\n      }\n    };\n    /**\n     * @member ArrayList\n     * ArrayList.set() Replaces the element at the specified position in this list with the specified element.\n     *\n     * @param {int}    index  index of element to replace\n     * @param {Object} object element to be stored at the specified position\n     */\n    this.set = function() {\n      if (arguments.length === 2) {\n        var arg0 = arguments[0];\n        if (typeof arg0 === 'number') {\n          if (arg0 >= 0 && arg0 < array.length) {\n            array.splice(arg0, 1, arguments[1]);\n          } else {\n            throw(arg0 + \" is not a valid index.\");\n          }\n        } else {\n          throw(typeof arg0 + \" is not a number\");\n        }\n      } else {\n        throw(\"Please use the proper number of parameters.\");\n      }\n    };\n\n    /**\n     * @member ArrayList\n     * ArrayList.size() Returns the number of elements in this list.\n     *\n     * @returns {int} the number of elements in this list\n     */\n    this.size = function() {\n      return array.length;\n    };\n\n    /**\n     * @member ArrayList\n     * ArrayList.clear() Removes all of the elements from this list. The list will be empty after this call returns.\n     */\n    this.clear = function() {\n      array.length = 0;\n    };\n\n    /**\n     * @member ArrayList\n     * ArrayList.remove() Removes an element either based on index, if the argument is a number, or\n     * by equality check, if the argument is an object.\n     *\n     * @param {int|Object} item either the index of the element to be removed, or the element itself.\n     *\n     * @returns {Object|boolean} If removal is by index, the element that was removed, or null if nothing was removed. If removal is by object, true if removal occurred, otherwise false.\n     */\n    this.remove = function(item) {\n      if (typeof item === 'number') {\n        return array.splice(item, 1)[0];\n      }\n      item = this.indexOf(item);\n      if (item > -1) {\n        array.splice(item, 1);\n        return true;\n      }\n      return false;\n    };\n\n     /**\n     * @member ArrayList\n     * ArrayList.removeAll Removes from this List all of the elements from\n     * the current ArrayList which are present in the passed in paramater ArrayList 'c'.\n     * Shifts any succeeding elements to the left (reduces their index).\n     *\n     * @param {ArrayList} the ArrayList to compare to the current ArrayList\n     *\n     * @returns {boolean} true if the ArrayList had an element removed; false otherwise\n     */\n    this.removeAll = function(c) {\n      var i, x, item,\n          newList = new ArrayList();\n      newList.addAll(this);\n      this.clear();\n      // For every item that exists in the original ArrayList and not in the c ArrayList\n      // copy it into the empty 'this' ArrayList to create the new 'this' Array.\n      for (i = 0, x = 0; i < newList.size(); i++) {\n        item = newList.get(i);\n        if (!c.contains(item)) {\n          this.add(x++, item);\n        }\n      }\n      if (this.size() < newList.size()) {\n        return true;\n      }\n      return false;\n    };\n\n    /**\n     * @member ArrayList\n     * ArrayList.isEmpty() Tests if this list has no elements.\n     *\n     * @returns {boolean} true if this list has no elements; false otherwise\n     */\n    this.isEmpty = function() {\n       return !array.length;\n    };\n\n    /**\n     * @member ArrayList\n     * ArrayList.clone() Returns a shallow copy of this ArrayList instance. (The elements themselves are not copied.)\n     *\n     * @returns {ArrayList} a clone of this ArrayList instance\n     */\n    this.clone = function() {\n      return new ArrayList(this);\n    };\n\n    /**\n     * @member ArrayList\n     * ArrayList.toArray() Returns an array containing all of the elements in this list in the correct order.\n     *\n     * @returns {Object[]} Returns an array containing all of the elements in this list in the correct order\n     */\n    this.toArray = function() {\n      return array.slice(0);\n    };\n\n    this.iterator = function() {\n      return new Iterator(array);\n    };\n  }\n\n  return ArrayList;\n};\n\n},{}],10:[function(require,module,exports){\nmodule.exports = (function(charMap, undef) {\n\n  var Char = function(chr) {\n    if (typeof chr === 'string' && chr.length === 1) {\n      this.code = chr.charCodeAt(0);\n    } else if (typeof chr === 'number') {\n      this.code = chr;\n    } else if (chr instanceof Char) {\n      this.code = chr;\n    } else {\n      this.code = NaN;\n    }\n    return (charMap[this.code] === undef) ? charMap[this.code] = this : charMap[this.code];\n  };\n\n  Char.prototype.toString = function() {\n    return String.fromCharCode(this.code);\n  };\n\n  Char.prototype.valueOf = function() {\n    return this.code;\n  };\n\n  return Char;\n}({}));\n\n},{}],11:[function(require,module,exports){\n/**\n* A HashMap stores a collection of objects, each referenced by a key. This is similar to an Array, only\n* instead of accessing elements with a numeric index, a String  is used. (If you are familiar with\n* associative arrays from other languages, this is the same idea.)\n*\n* @param {int} initialCapacity          defines the initial capacity of the map, it's 16 by default\n* @param {float} loadFactor             the load factor for the map, the default is 0.75\n* @param {Map} m                        gives the new HashMap the same mappings as this Map\n*/\nmodule.exports = function(options) {\n  var virtHashCode = options.virtHashCode,\n      virtEquals = options.virtEquals;\n\n  /**\n  * @member HashMap\n  * A HashMap stores a collection of objects, each referenced by a key. This is similar to an Array, only\n  * instead of accessing elements with a numeric index, a String  is used. (If you are familiar with\n  * associative arrays from other languages, this is the same idea.)\n  *\n  * @param {int} initialCapacity          defines the initial capacity of the map, it's 16 by default\n  * @param {float} loadFactor             the load factor for the map, the default is 0.75\n  * @param {Map} m                        gives the new HashMap the same mappings as this Map\n  */\n  function HashMap() {\n    if (arguments.length === 1 && arguments[0] instanceof HashMap) {\n      return arguments[0].clone();\n    }\n\n    var initialCapacity = arguments.length > 0 ? arguments[0] : 16;\n    var loadFactor = arguments.length > 1 ? arguments[1] : 0.75;\n    var buckets = [];\n    buckets.length = initialCapacity;\n    var count = 0;\n    var hashMap = this;\n\n    function getBucketIndex(key) {\n      var index = virtHashCode(key) % buckets.length;\n      return index < 0 ? buckets.length + index : index;\n    }\n    function ensureLoad() {\n      if (count <= loadFactor * buckets.length) {\n        return;\n      }\n      var allEntries = [];\n      for (var i = 0; i < buckets.length; ++i) {\n        if (buckets[i] !== undefined) {\n          allEntries = allEntries.concat(buckets[i]);\n        }\n      }\n      var newBucketsLength = buckets.length * 2;\n      buckets = [];\n      buckets.length = newBucketsLength;\n      for (var j = 0; j < allEntries.length; ++j) {\n        var index = getBucketIndex(allEntries[j].key);\n        var bucket = buckets[index];\n        if (bucket === undefined) {\n          buckets[index] = bucket = [];\n        }\n        bucket.push(allEntries[j]);\n      }\n    }\n\n    function Iterator(conversion, removeItem) {\n      var bucketIndex = 0;\n      var itemIndex = -1;\n      var endOfBuckets = false;\n      var currentItem;\n\n      function findNext() {\n        while (!endOfBuckets) {\n          ++itemIndex;\n          if (bucketIndex >= buckets.length) {\n            endOfBuckets = true;\n          } else if (buckets[bucketIndex] === undefined || itemIndex >= buckets[bucketIndex].length) {\n            itemIndex = -1;\n            ++bucketIndex;\n          } else {\n            return;\n          }\n        }\n      }\n\n      /*\n      * @member Iterator\n      * Checks if the Iterator has more items\n      */\n      this.hasNext = function() {\n        return !endOfBuckets;\n      };\n\n      /*\n      * @member Iterator\n      * Return the next Item\n      */\n      this.next = function() {\n        currentItem = conversion(buckets[bucketIndex][itemIndex]);\n        findNext();\n        return currentItem;\n      };\n\n      /*\n      * @member Iterator\n      * Remove the current item\n      */\n      this.remove = function() {\n        if (currentItem !== undefined) {\n          removeItem(currentItem);\n          --itemIndex;\n          findNext();\n        }\n      };\n\n      findNext();\n    }\n\n    function Set(conversion, isIn, removeItem) {\n      this.clear = function() {\n        hashMap.clear();\n      };\n\n      this.contains = function(o) {\n        return isIn(o);\n      };\n\n      this.containsAll = function(o) {\n        var it = o.iterator();\n        while (it.hasNext()) {\n          if (!this.contains(it.next())) {\n            return false;\n          }\n        }\n        return true;\n      };\n\n      this.isEmpty = function() {\n        return hashMap.isEmpty();\n      };\n\n      this.iterator = function() {\n        return new Iterator(conversion, removeItem);\n      };\n\n      this.remove = function(o) {\n        if (this.contains(o)) {\n          removeItem(o);\n          return true;\n        }\n        return false;\n      };\n\n      this.removeAll = function(c) {\n        var it = c.iterator();\n        var changed = false;\n        while (it.hasNext()) {\n          var item = it.next();\n          if (this.contains(item)) {\n            removeItem(item);\n            changed = true;\n          }\n        }\n        return true;\n      };\n\n      this.retainAll = function(c) {\n        var it = this.iterator();\n        var toRemove = [];\n        while (it.hasNext()) {\n          var entry = it.next();\n          if (!c.contains(entry)) {\n            toRemove.push(entry);\n          }\n        }\n        for (var i = 0; i < toRemove.length; ++i) {\n          removeItem(toRemove[i]);\n        }\n        return toRemove.length > 0;\n      };\n\n      this.size = function() {\n        return hashMap.size();\n      };\n\n      this.toArray = function() {\n        var result = [];\n        var it = this.iterator();\n        while (it.hasNext()) {\n          result.push(it.next());\n        }\n        return result;\n      };\n    }\n\n    function Entry(pair) {\n      this._isIn = function(map) {\n        return map === hashMap && (pair.removed === undefined);\n      };\n\n      this.equals = function(o) {\n        return virtEquals(pair.key, o.getKey());\n      };\n\n      this.getKey = function() {\n        return pair.key;\n      };\n\n      this.getValue = function() {\n        return pair.value;\n      };\n\n      this.hashCode = function(o) {\n        return virtHashCode(pair.key);\n      };\n\n      this.setValue = function(value) {\n        var old = pair.value;\n        pair.value = value;\n        return old;\n      };\n    }\n\n    this.clear = function() {\n      count = 0;\n      buckets = [];\n      buckets.length = initialCapacity;\n    };\n\n    this.clone = function() {\n      var map = new HashMap();\n      map.putAll(this);\n      return map;\n    };\n\n    this.containsKey = function(key) {\n      var index = getBucketIndex(key);\n      var bucket = buckets[index];\n      if (bucket === undefined) {\n        return false;\n      }\n      for (var i = 0; i < bucket.length; ++i) {\n        if (virtEquals(bucket[i].key, key)) {\n          return true;\n        }\n      }\n      return false;\n    };\n\n    this.containsValue = function(value) {\n      for (var i = 0; i < buckets.length; ++i) {\n        var bucket = buckets[i];\n        if (bucket === undefined) {\n          continue;\n        }\n        for (var j = 0; j < bucket.length; ++j) {\n          if (virtEquals(bucket[j].value, value)) {\n            return true;\n          }\n        }\n      }\n      return false;\n    };\n\n    this.entrySet = function() {\n      return new Set(\n\n      function(pair) {\n        return new Entry(pair);\n      },\n\n      function(pair) {\n        return (pair instanceof Entry) && pair._isIn(hashMap);\n      },\n\n      function(pair) {\n        return hashMap.remove(pair.getKey());\n      });\n    };\n\n    this.get = function(key) {\n      var index = getBucketIndex(key);\n      var bucket = buckets[index];\n      if (bucket === undefined) {\n        return null;\n      }\n      for (var i = 0; i < bucket.length; ++i) {\n        if (virtEquals(bucket[i].key, key)) {\n          return bucket[i].value;\n        }\n      }\n      return null;\n    };\n\n    this.isEmpty = function() {\n      return count === 0;\n    };\n\n    this.keySet = function() {\n      return new Set(\n        // get key from pair\n        function(pair) {\n          return pair.key;\n        },\n        // is-in test\n        function(key) {\n          return hashMap.containsKey(key);\n        },\n        // remove from hashmap by key\n        function(key) {\n          return hashMap.remove(key);\n        }\n      );\n    };\n\n    this.values = function() {\n      return new Set(\n        // get value from pair\n        function(pair) {\n          return pair.value;\n        },\n        // is-in test\n        function(value) {\n          return hashMap.containsValue(value);\n        },\n        // remove from hashmap by value\n        function(value) {\n          return hashMap.removeByValue(value);\n        }\n      );\n    };\n\n    this.put = function(key, value) {\n      var index = getBucketIndex(key);\n      var bucket = buckets[index];\n      if (bucket === undefined) {\n        ++count;\n        buckets[index] = [{\n          key: key,\n          value: value\n        }];\n        ensureLoad();\n        return null;\n      }\n      for (var i = 0; i < bucket.length; ++i) {\n        if (virtEquals(bucket[i].key, key)) {\n          var previous = bucket[i].value;\n          bucket[i].value = value;\n          return previous;\n        }\n      }\n      ++count;\n      bucket.push({\n        key: key,\n        value: value\n      });\n      ensureLoad();\n      return null;\n    };\n\n    this.putAll = function(m) {\n      var it = m.entrySet().iterator();\n      while (it.hasNext()) {\n        var entry = it.next();\n        this.put(entry.getKey(), entry.getValue());\n      }\n    };\n\n    this.remove = function(key) {\n      var index = getBucketIndex(key);\n      var bucket = buckets[index];\n      if (bucket === undefined) {\n        return null;\n      }\n      for (var i = 0; i < bucket.length; ++i) {\n        if (virtEquals(bucket[i].key, key)) {\n          --count;\n          var previous = bucket[i].value;\n          bucket[i].removed = true;\n          if (bucket.length > 1) {\n            bucket.splice(i, 1);\n          } else {\n            buckets[index] = undefined;\n          }\n          return previous;\n        }\n      }\n      return null;\n    };\n\n    this.removeByValue = function(value) {\n      var bucket, i, ilen, pair;\n      for (bucket in buckets) {\n        if (buckets.hasOwnProperty(bucket)) {\n          for (i = 0, ilen = buckets[bucket].length; i < ilen; i++) {\n            pair = buckets[bucket][i];\n            // removal on values is based on identity, not equality\n            if (pair.value === value) {\n              buckets[bucket].splice(i, 1);\n              return true;\n            }\n          }\n        }\n      }\n      return false;\n    };\n\n    this.size = function() {\n      return count;\n    };\n  }\n\n  return HashMap;\n};\n\n},{}],12:[function(require,module,exports){\n// module export\nmodule.exports = function(options,undef) {\n  var window = options.Browser.window,\n      document = options.Browser.document,\n      noop = options.noop;\n\n  /**\n   * [internal function] computeFontMetrics() calculates various metrics for text\n   * placement. Currently this function computes the ascent, descent and leading\n   * (from \"lead\", used for vertical space) values for the currently active font.\n   */\n  function computeFontMetrics(pfont) {\n    var emQuad = 250,\n        correctionFactor = pfont.size / emQuad,\n        canvas = document.createElement(\"canvas\");\n    canvas.width = 2*emQuad;\n    canvas.height = 2*emQuad;\n    canvas.style.opacity = 0;\n    var cfmFont = pfont.getCSSDefinition(emQuad+\"px\", \"normal\"),\n        ctx = canvas.getContext(\"2d\");\n    ctx.font = cfmFont;\n\n    // Size the canvas using a string with common max-ascent and max-descent letters.\n    // Changing the canvas dimensions resets the context, so we must reset the font.\n    var protrusions = \"dbflkhyjqpg\";\n    canvas.width = ctx.measureText(protrusions).width;\n    ctx.font = cfmFont;\n\n    // for text lead values, we meaure a multiline text container.\n    var leadDiv = document.createElement(\"div\");\n    leadDiv.style.position = \"absolute\";\n    leadDiv.style.opacity = 0;\n    leadDiv.style.fontFamily = '\"' + pfont.name + '\"';\n    leadDiv.style.fontSize = emQuad + \"px\";\n    leadDiv.innerHTML = protrusions + \"<br/>\" + protrusions;\n    document.body.appendChild(leadDiv);\n\n    var w = canvas.width,\n        h = canvas.height,\n        baseline = h/2;\n\n    // Set all canvas pixeldata values to 255, with all the content\n    // data being 0. This lets us scan for data[i] != 255.\n    ctx.fillStyle = \"white\";\n    ctx.fillRect(0, 0, w, h);\n    ctx.fillStyle = \"black\";\n    ctx.fillText(protrusions, 0, baseline);\n    var pixelData = ctx.getImageData(0, 0, w, h).data;\n\n    // canvas pixel data is w*4 by h*4, because R, G, B and A are separate,\n    // consecutive values in the array, rather than stored as 32 bit ints.\n    var i = 0,\n        w4 = w * 4,\n        len = pixelData.length;\n\n    // Finding the ascent uses a normal, forward scanline\n    while (++i < len && pixelData[i] === 255) {\n      noop();\n    }\n    var ascent = Math.round(i / w4);\n\n    // Finding the descent uses a reverse scanline\n    i = len - 1;\n    while (--i > 0 && pixelData[i] === 255) {\n      noop();\n    }\n    var descent = Math.round(i / w4);\n\n    // set font metrics\n    pfont.ascent = correctionFactor * (baseline - ascent);\n    pfont.descent = correctionFactor * (descent - baseline);\n\n    // Then we try to get the real value from the browser\n    if (document.defaultView.getComputedStyle) {\n      var leadDivHeight = document.defaultView.getComputedStyle(leadDiv,null).getPropertyValue(\"height\");\n      leadDivHeight = correctionFactor * leadDivHeight.replace(\"px\",\"\");\n      if (leadDivHeight >= pfont.size * 2) {\n        pfont.leading = Math.round(leadDivHeight/2);\n      }\n    }\n    document.body.removeChild(leadDiv);\n\n    // if we're caching, cache the context used for this pfont\n    if (pfont.caching) {\n      return ctx;\n    }\n  }\n\n  /**\n   * Constructor for a system or from-file (non-SVG) font.\n   */\n  function PFont(name, size) {\n    // according to the P5 API, new PFont() is legal (albeit completely useless)\n    if (name === undef) {\n      name = \"\";\n    }\n    this.name = name;\n    if (size === undef) {\n      size = 0;\n    }\n    this.size = size;\n    this.glyph = false;\n    this.ascent = 0;\n    this.descent = 0;\n    // For leading, the \"safe\" value uses the standard TEX ratio\n    this.leading = 1.2 * size;\n\n    // Note that an italic, bold font must used \"... Bold Italic\"\n    // in P5. \"... Italic Bold\" is treated as normal/normal.\n    var illegalIndicator = name.indexOf(\" Italic Bold\");\n    if (illegalIndicator !== -1) {\n      name = name.substring(0, illegalIndicator);\n    }\n\n    // determine font style\n    this.style = \"normal\";\n    var italicsIndicator = name.indexOf(\" Italic\");\n    if (italicsIndicator !== -1) {\n      name = name.substring(0, italicsIndicator);\n      this.style = \"italic\";\n    }\n\n    // determine font weight\n    this.weight = \"normal\";\n    var boldIndicator = name.indexOf(\" Bold\");\n    if (boldIndicator !== -1) {\n      name = name.substring(0, boldIndicator);\n      this.weight = \"bold\";\n    }\n\n    // determine font-family name\n    this.family = \"sans-serif\";\n    if (name !== undef) {\n      switch(name) {\n        case \"sans-serif\":\n        case \"serif\":\n        case \"monospace\":\n        case \"fantasy\":\n        case \"cursive\":\n          this.family = name;\n          break;\n        default:\n          this.family = '\"' + name + '\", sans-serif';\n          break;\n      }\n    }\n    // Calculate the ascent/descent/leading value based on\n    // how the browser renders this font.\n    this.context2d = computeFontMetrics(this);\n    this.css = this.getCSSDefinition();\n    if (this.context2d) {\n      this.context2d.font = this.css;\n    }\n  }\n\n  /**\n   * regulates whether or not we're caching the canvas\n   * 2d context for quick text width computation.\n   */\n  PFont.prototype.caching = true;\n\n  /**\n   * This function generates the CSS \"font\" string for this PFont\n   */\n  PFont.prototype.getCSSDefinition = function(fontSize, lineHeight) {\n    if(fontSize===undef) {\n      fontSize = this.size + \"px\";\n    }\n    if(lineHeight===undef) {\n      lineHeight = this.leading + \"px\";\n    }\n    // CSS \"font\" definition: font-style font-variant font-weight font-size/line-height font-family\n    var components = [this.style, \"normal\", this.weight, fontSize + \"/\" + lineHeight, this.family];\n    return components.join(\" \");\n  };\n\n  /**\n   * Rely on the cached context2d measureText function.\n   */\n  PFont.prototype.measureTextWidth = function(string) {\n    return this.context2d.measureText(string).width;\n  };\n\n  /**\n   * FALLBACK FUNCTION -- replaces Pfont.prototype.measureTextWidth\n   * when the font cache becomes too large. This contructs a new\n   * canvas 2d context object for calling measureText on.\n   */\n  PFont.prototype.measureTextWidthFallback = function(string) {\n    var canvas = document.createElement(\"canvas\"),\n        ctx = canvas.getContext(\"2d\");\n    ctx.font = this.css;\n    return ctx.measureText(string).width;\n  };\n\n  /**\n   * Global \"loaded fonts\" list, internal to PFont\n   */\n  PFont.PFontCache = { length: 0 };\n\n  /**\n   * This function acts as single access point for getting and caching\n   * fonts across all sketches handled by an instance of Processing.js\n   */\n  PFont.get = function(fontName, fontSize) {\n    // round fontSize to one decimal point\n    fontSize = ((fontSize*10)+0.5|0)/10;\n    var cache = PFont.PFontCache,\n        idx = fontName+\"/\"+fontSize;\n    if (!cache[idx]) {\n      cache[idx] = new PFont(fontName, fontSize);\n      cache.length++;\n\n      // FALLBACK FUNCTIONALITY 1:\n      // If the cache has become large, switch over from full caching\n      // to caching only the static metrics for each new font request.\n      if (cache.length === 50) {\n        PFont.prototype.measureTextWidth = PFont.prototype.measureTextWidthFallback;\n        PFont.prototype.caching = false;\n        // clear contexts stored for each cached font\n        var entry;\n        for (entry in cache) {\n          if (entry !== \"length\") {\n            cache[entry].context2d = null;\n          }\n        }\n        return new PFont(fontName, fontSize);\n      }\n\n      // FALLBACK FUNCTIONALITY 2:\n      // If the cache has become too large, switch off font caching entirely.\n      if (cache.length === 400) {\n        PFont.PFontCache = {};\n        PFont.get = PFont.getFallback;\n        return new PFont(fontName, fontSize);\n      }\n    }\n    return cache[idx];\n  };\n\n  /**\n   * FALLBACK FUNCTION -- replaces PFont.get when the font cache\n   * becomes too large. This function bypasses font caching entirely.\n   */\n  PFont.getFallback = function(fontName, fontSize) {\n    return new PFont(fontName, fontSize);\n  };\n\n  /**\n   * Lists all standard fonts. Due to browser limitations, this list is\n   * not the system font list, like in P5, but the CSS \"genre\" list.\n   */\n  PFont.list = function() {\n    return [\"sans-serif\", \"serif\", \"monospace\", \"fantasy\", \"cursive\"];\n  };\n\n  /**\n   * Loading external fonts through @font-face rules is handled by PFont,\n   * to ensure fonts loaded in this way are globally available.\n   */\n  PFont.preloading = {\n    // template element used to compare font sizes\n    template: {},\n    // indicates whether or not the reference tiny font has been loaded\n    initialized: false,\n    // load the reference tiny font via a css @font-face rule\n    initialize: function() {\n      var generateTinyFont = function() {\n        var encoded = \"#E3KAI2wAgT1MvMg7Eo3VmNtYX7ABi3CxnbHlm\" +\n                      \"7Abw3kaGVhZ7ACs3OGhoZWE7A53CRobXR47AY3\" +\n                      \"AGbG9jYQ7G03Bm1heH7ABC3CBuYW1l7Ae3AgcG\" +\n                      \"9zd7AI3AE#B3AQ2kgTY18PPPUACwAg3ALSRoo3\" +\n                      \"#yld0xg32QAB77#E777773B#E3C#I#Q77773E#\" +\n                      \"Q7777777772CMAIw7AB77732B#M#Q3wAB#g3B#\" +\n                      \"E#E2BB//82BB////w#B7#gAEg3E77x2B32B#E#\" +\n                      \"Q#MTcBAQ32gAe#M#QQJ#E32M#QQJ#I#g32Q77#\";\n        var expand = function(input) {\n                       return \"AAAAAAAA\".substr(~~input ? 7-input : 6);\n                     };\n        return encoded.replace(/[#237]/g, expand);\n      };\n      var fontface = document.createElement(\"style\");\n      fontface.setAttribute(\"type\",\"text/css\");\n      fontface.innerHTML =  \"@font-face {\\n\" +\n                            '  font-family: \"PjsEmptyFont\";' + \"\\n\" +\n                            \"  src: url('data:application/x-font-ttf;base64,\"+generateTinyFont()+\"')\\n\" +\n                            \"       format('truetype');\\n\" +\n                            \"}\";\n      document.head.appendChild(fontface);\n\n      // set up the template element\n      var element = document.createElement(\"span\");\n      element.style.cssText = 'position: absolute; top: -1000; left: 0; opacity: 0; font-family: \"PjsEmptyFont\", fantasy;';\n      element.innerHTML = \"AAAAAAAA\";\n      document.body.appendChild(element);\n      this.template = element;\n\n      this.initialized = true;\n    },\n    // Shorthand function to get the computed width for an element.\n    getElementWidth: function(element) {\n      return document.defaultView.getComputedStyle(element,\"\").getPropertyValue(\"width\");\n    },\n    // time taken so far in attempting to load a font\n    timeAttempted: 0,\n    // returns false if no fonts are pending load, or true otherwise.\n    pending: function(intervallength) {\n      if (!this.initialized) {\n        this.initialize();\n      }\n      var element,\n          computedWidthFont,\n          computedWidthRef = this.getElementWidth(this.template);\n      for (var i = 0; i < this.fontList.length; i++) {\n        // compares size of text in pixels. if equal, custom font is not yet loaded\n        element = this.fontList[i];\n        computedWidthFont = this.getElementWidth(element);\n        if (this.timeAttempted < 4000 && computedWidthFont === computedWidthRef) {\n          this.timeAttempted += intervallength;\n          return true;\n        } else {\n          document.body.removeChild(element);\n          this.fontList.splice(i--, 1);\n          this.timeAttempted = 0;\n        }\n      }\n      // if there are no more fonts to load, pending is false\n      if (this.fontList.length === 0) {\n        return false;\n      }\n      // We should have already returned before getting here.\n      // But, if we do get here, length!=0 so fonts are pending.\n      return true;\n    },\n    // fontList contains elements to compare font sizes against a template\n    fontList: [],\n    // addedList contains the fontnames of all the fonts loaded via @font-face\n    addedList: {},\n    // adds a font to the font cache\n    // creates an element using the font, to start loading the font,\n    // and compare against a default font to see if the custom font is loaded\n    add: function(fontSrc) {\n      if (!this.initialized) {\n       this.initialize();\n      }\n      // fontSrc can be a string or a javascript object\n      // acceptable fonts are .ttf, .otf, and data uri\n      var fontName = (typeof fontSrc === 'object' ? fontSrc.fontFace : fontSrc),\n          fontUrl = (typeof fontSrc === 'object' ? fontSrc.url : fontSrc);\n\n      // check whether we already created the @font-face rule for this font\n      if (this.addedList[fontName]) {\n        return;\n      }\n\n      // if we didn't, create the @font-face rule\n      var style = document.createElement(\"style\");\n      style.setAttribute(\"type\",\"text/css\");\n      style.innerHTML = \"@font-face{\\n  font-family: '\" + fontName + \"';\\n  src:  url('\" + fontUrl + \"');\\n}\\n\";\n      document.head.appendChild(style);\n      this.addedList[fontName] = true;\n\n      // also create the element to load and compare the new font\n      var element = document.createElement(\"span\");\n      element.style.cssText = \"position: absolute; top: 0; left: 0; opacity: 0;\";\n      element.style.fontFamily = '\"' + fontName + '\", \"PjsEmptyFont\", fantasy';\n      element.innerHTML = \"AAAAAAAA\";\n      document.body.appendChild(element);\n      this.fontList.push(element);\n    }\n  };\n\n  return PFont;\n};\n},{}],13:[function(require,module,exports){\nmodule.exports = function(options, undef) {\n\n  // FIXME: hack\n  var p = options.p;\n\n  /**\n   * PMatrix2D is a 3x2 affine matrix implementation. The constructor accepts another PMatrix2D or a list of six float elements.\n   * If no parameters are provided the matrix is set to the identity matrix.\n   *\n   * @param {PMatrix2D} matrix  the initial matrix to set to\n   * @param {float} m00         the first element of the matrix\n   * @param {float} m01         the second element of the matrix\n   * @param {float} m02         the third element of the matrix\n   * @param {float} m10         the fourth element of the matrix\n   * @param {float} m11         the fifth element of the matrix\n   * @param {float} m12         the sixth element of the matrix\n   */\n  var PMatrix2D = function() {\n    if (arguments.length === 0) {\n      this.reset();\n    } else if (arguments.length === 1 && arguments[0] instanceof PMatrix2D) {\n      this.set(arguments[0].array());\n    } else if (arguments.length === 6) {\n      this.set(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);\n    }\n  };\n\n  /**\n   * PMatrix2D methods\n   */\n  PMatrix2D.prototype = {\n    /**\n     * @member PMatrix2D\n     * The set() function sets the matrix elements. The function accepts either another PMatrix2D, an array of elements, or a list of six floats.\n     *\n     * @param {PMatrix2D} matrix    the matrix to set this matrix to\n     * @param {float[]} elements    an array of elements to set this matrix to\n     * @param {float} m00           the first element of the matrix\n     * @param {float} m01           the third element of the matrix\n     * @param {float} m10           the fourth element of the matrix\n     * @param {float} m11           the fith element of the matrix\n     * @param {float} m12           the sixth element of the matrix\n     */\n    set: function() {\n      if (arguments.length === 6) {\n        var a = arguments;\n        this.set([a[0], a[1], a[2],\n                  a[3], a[4], a[5]]);\n      } else if (arguments.length === 1 && arguments[0] instanceof PMatrix2D) {\n        this.elements = arguments[0].array();\n      } else if (arguments.length === 1 && arguments[0] instanceof Array) {\n        this.elements = arguments[0].slice();\n      }\n    },\n    /**\n     * @member PMatrix2D\n     * The get() function returns a copy of this PMatrix2D.\n     *\n     * @return {PMatrix2D} a copy of this PMatrix2D\n     */\n    get: function() {\n      var outgoing = new PMatrix2D();\n      outgoing.set(this.elements);\n      return outgoing;\n    },\n    /**\n     * @member PMatrix2D\n     * The reset() function sets this PMatrix2D to the identity matrix.\n     */\n    reset: function() {\n      this.set([1, 0, 0, 0, 1, 0]);\n    },\n    /**\n     * @member PMatrix2D\n     * The array() function returns a copy of the element values.\n     * @addon\n     *\n     * @return {float[]} returns a copy of the element values\n     */\n    array: function array() {\n      return this.elements.slice();\n    },\n    /**\n     * @member PMatrix2D\n     * The translate() function translates this matrix by moving the current coordinates to the location specified by tx and ty.\n     *\n     * @param {float} tx  the x-axis coordinate to move to\n     * @param {float} ty  the y-axis coordinate to move to\n     */\n    translate: function(tx, ty) {\n      this.elements[2] = tx * this.elements[0] + ty * this.elements[1] + this.elements[2];\n      this.elements[5] = tx * this.elements[3] + ty * this.elements[4] + this.elements[5];\n    },\n    /**\n     * @member PMatrix2D\n     * The invTranslate() function translates this matrix by moving the current coordinates to the negative location specified by tx and ty.\n     *\n     * @param {float} tx  the x-axis coordinate to move to\n     * @param {float} ty  the y-axis coordinate to move to\n     */\n    invTranslate: function(tx, ty) {\n      this.translate(-tx, -ty);\n    },\n     /**\n     * @member PMatrix2D\n     * The transpose() function is not used in processingjs.\n     */\n    transpose: function() {\n      // Does nothing in Processing.\n    },\n    /**\n     * @member PMatrix2D\n     * The mult() function multiplied this matrix.\n     * If two array elements are passed in the function will multiply a two element vector against this matrix.\n     * If target is null or not length four, a new float array will be returned.\n     * The values for vec and target can be the same (though that's less efficient).\n     * If two PVectors are passed in the function multiply the x and y coordinates of a PVector against this matrix.\n     *\n     * @param {PVector} source, target  the PVectors used to multiply this matrix\n     * @param {float[]} source, target  the arrays used to multiply this matrix\n     *\n     * @return {PVector|float[]} returns a PVector or an array representing the new matrix\n     */\n    mult: function(source, target) {\n      var x, y;\n      if (source instanceof PVector) {\n        x = source.x;\n        y = source.y;\n        if (!target) {\n          target = new PVector();\n        }\n      } else if (source instanceof Array) {\n        x = source[0];\n        y = source[1];\n        if (!target) {\n          target = [];\n        }\n      }\n      if (target instanceof Array) {\n        target[0] = this.elements[0] * x + this.elements[1] * y + this.elements[2];\n        target[1] = this.elements[3] * x + this.elements[4] * y + this.elements[5];\n      } else if (target instanceof PVector) {\n        target.x = this.elements[0] * x + this.elements[1] * y + this.elements[2];\n        target.y = this.elements[3] * x + this.elements[4] * y + this.elements[5];\n        target.z = 0;\n      }\n      return target;\n    },\n    /**\n     * @member PMatrix2D\n     * The multX() function calculates the x component of a vector from a transformation.\n     *\n     * @param {float} x the x component of the vector being transformed\n     * @param {float} y the y component of the vector being transformed\n     *\n     * @return {float} returnes the result of the calculation\n     */\n    multX: function(x, y) {\n      return (x * this.elements[0] + y * this.elements[1] + this.elements[2]);\n    },\n    /**\n     * @member PMatrix2D\n     * The multY() function calculates the y component of a vector from a transformation.\n     *\n     * @param {float} x the x component of the vector being transformed\n     * @param {float} y the y component of the vector being transformed\n     *\n     * @return {float} returnes the result of the calculation\n     */\n    multY: function(x, y) {\n      return (x * this.elements[3] + y * this.elements[4] + this.elements[5]);\n    },\n    /**\n     * @member PMatrix2D\n     * The skewX() function skews the matrix along the x-axis the amount specified by the angle parameter.\n     * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.\n     *\n     * @param {float} angle  angle of skew specified in radians\n     */\n    skewX: function(angle) {\n      this.apply(1, 0, 1, angle, 0, 0);\n    },\n    /**\n     * @member PMatrix2D\n     * The skewY() function skews the matrix along the y-axis the amount specified by the angle parameter.\n     * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.\n     *\n     * @param {float} angle  angle of skew specified in radians\n     */\n    skewY: function(angle) {\n      this.apply(1, 0, 1,  0, angle, 0);\n    },\n    /**\n     * @member PMatrix2D\n     * The shearX() function shears the matrix along the x-axis the amount specified by the angle parameter.\n     * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.\n     *\n     * @param {float} angle  angle of skew specified in radians\n     */\n    shearX: function(angle) {\n      this.apply(1, 0, 1, Math.tan(angle) , 0, 0);\n    },\n    /**\n     * @member PMatrix2D\n     * The shearY() function shears the matrix along the y-axis the amount specified by the angle parameter.\n     * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.\n     *\n     * @param {float} angle  angle of skew specified in radians\n     */\n    shearY: function(angle) {\n      this.apply(1, 0, 1,  0, Math.tan(angle), 0);\n    },\n    /**\n     * @member PMatrix2D\n     * The determinant() function calvculates the determinant of this matrix.\n     *\n     * @return {float} the determinant of the matrix\n     */\n    determinant: function() {\n      return (this.elements[0] * this.elements[4] - this.elements[1] * this.elements[3]);\n    },\n    /**\n     * @member PMatrix2D\n     * The invert() function inverts this matrix\n     *\n     * @return {boolean} true if successful\n     */\n    invert: function() {\n      var d = this.determinant();\n      if (Math.abs( d ) > PConstants.MIN_INT) {\n        var old00 = this.elements[0];\n        var old01 = this.elements[1];\n        var old02 = this.elements[2];\n        var old10 = this.elements[3];\n        var old11 = this.elements[4];\n        var old12 = this.elements[5];\n        this.elements[0] =  old11 / d;\n        this.elements[3] = -old10 / d;\n        this.elements[1] = -old01 / d;\n        this.elements[4] =  old00 / d;\n        this.elements[2] = (old01 * old12 - old11 * old02) / d;\n        this.elements[5] = (old10 * old02 - old00 * old12) / d;\n        return true;\n      }\n      return false;\n    },\n    /**\n     * @member PMatrix2D\n     * The scale() function increases or decreases the size of a shape by expanding and contracting vertices. When only one parameter is specified scale will occur in all dimensions.\n     * This is equivalent to a two parameter call.\n     *\n     * @param {float} sx  the amount to scale on the x-axis\n     * @param {float} sy  the amount to scale on the y-axis\n     */\n    scale: function(sx, sy) {\n      if (sx && sy === undef) {\n        sy = sx;\n      }\n      if (sx && sy) {\n        this.elements[0] *= sx;\n        this.elements[1] *= sy;\n        this.elements[3] *= sx;\n        this.elements[4] *= sy;\n      }\n    },\n     /**\n      * @member PMatrix2D\n      * The invScale() function decreases or increases the size of a shape by contracting and expanding vertices. When only one parameter is specified scale will occur in all dimensions.\n      * This is equivalent to a two parameter call.\n      *\n      * @param {float} sx  the amount to scale on the x-axis\n      * @param {float} sy  the amount to scale on the y-axis\n      */\n    invScale: function(sx, sy) {\n      if (sx && !sy) {\n        sy = sx;\n      }\n      this.scale(1 / sx, 1 / sy);\n    },\n    /**\n     * @member PMatrix2D\n     * The apply() function multiplies the current matrix by the one specified through the parameters. Note that either a PMatrix2D or a list of floats can be passed in.\n     *\n     * @param {PMatrix2D} matrix    the matrix to apply this matrix to\n     * @param {float} m00           the first element of the matrix\n     * @param {float} m01           the third element of the matrix\n     * @param {float} m10           the fourth element of the matrix\n     * @param {float} m11           the fith element of the matrix\n     * @param {float} m12           the sixth element of the matrix\n     */\n    apply: function() {\n      var source;\n      if (arguments.length === 1 && arguments[0] instanceof PMatrix2D) {\n        source = arguments[0].array();\n      } else if (arguments.length === 6) {\n        source = Array.prototype.slice.call(arguments);\n      } else if (arguments.length === 1 && arguments[0] instanceof Array) {\n        source = arguments[0];\n      }\n\n      var result = [0, 0, this.elements[2],\n                    0, 0, this.elements[5]];\n      var e = 0;\n      for (var row = 0; row < 2; row++) {\n        for (var col = 0; col < 3; col++, e++) {\n          result[e] += this.elements[row * 3 + 0] * source[col + 0] +\n                       this.elements[row * 3 + 1] * source[col + 3];\n        }\n      }\n      this.elements = result.slice();\n    },\n    /**\n     * @member PMatrix2D\n     * The preApply() function applies another matrix to the left of this one. Note that either a PMatrix2D or elements of a matrix can be passed in.\n     *\n     * @param {PMatrix2D} matrix    the matrix to apply this matrix to\n     * @param {float} m00           the first element of the matrix\n     * @param {float} m01           the third element of the matrix\n     * @param {float} m10           the fourth element of the matrix\n     * @param {float} m11           the fith element of the matrix\n     * @param {float} m12           the sixth element of the matrix\n     */\n    preApply: function() {\n      var source;\n      if (arguments.length === 1 && arguments[0] instanceof PMatrix2D) {\n        source = arguments[0].array();\n      } else if (arguments.length === 6) {\n        source = Array.prototype.slice.call(arguments);\n      } else if (arguments.length === 1 && arguments[0] instanceof Array) {\n        source = arguments[0];\n      }\n      var result = [0, 0, source[2],\n                    0, 0, source[5]];\n      result[2] = source[2] + this.elements[2] * source[0] + this.elements[5] * source[1];\n      result[5] = source[5] + this.elements[2] * source[3] + this.elements[5] * source[4];\n      result[0] = this.elements[0] * source[0] + this.elements[3] * source[1];\n      result[3] = this.elements[0] * source[3] + this.elements[3] * source[4];\n      result[1] = this.elements[1] * source[0] + this.elements[4] * source[1];\n      result[4] = this.elements[1] * source[3] + this.elements[4] * source[4];\n      this.elements = result.slice();\n    },\n    /**\n     * @member PMatrix2D\n     * The rotate() function rotates the matrix.\n     *\n     * @param {float} angle         the angle of rotation in radiants\n     */\n    rotate: function(angle) {\n      var c = Math.cos(angle);\n      var s = Math.sin(angle);\n      var temp1 = this.elements[0];\n      var temp2 = this.elements[1];\n      this.elements[0] =  c * temp1 + s * temp2;\n      this.elements[1] = -s * temp1 + c * temp2;\n      temp1 = this.elements[3];\n      temp2 = this.elements[4];\n      this.elements[3] =  c * temp1 + s * temp2;\n      this.elements[4] = -s * temp1 + c * temp2;\n    },\n    /**\n     * @member PMatrix2D\n     * The rotateZ() function rotates the matrix.\n     *\n     * @param {float} angle         the angle of rotation in radiants\n     */\n    rotateZ: function(angle) {\n      this.rotate(angle);\n    },\n    /**\n     * @member PMatrix2D\n     * The invRotateZ() function rotates the matrix in opposite direction.\n     *\n     * @param {float} angle         the angle of rotation in radiants\n     */\n    invRotateZ: function(angle) {\n      this.rotateZ(angle - Math.PI);\n    },\n    /**\n     * @member PMatrix2D\n     * The print() function prints out the elements of this matrix\n     */\n    print: function() {\n      var digits = printMatrixHelper(this.elements);\n      var output = \"\" + p.nfs(this.elements[0], digits, 4) + \" \" +\n                        p.nfs(this.elements[1], digits, 4) + \" \" +\n                        p.nfs(this.elements[2], digits, 4) + \"\\n\" +\n                        p.nfs(this.elements[3], digits, 4) + \" \" +\n                        p.nfs(this.elements[4], digits, 4) + \" \" +\n                        p.nfs(this.elements[5], digits, 4) + \"\\n\\n\";\n      p.println(output);\n    }\n  };\n\n  return PMatrix2D;\n};\n\n},{}],14:[function(require,module,exports){\nmodule.exports = function(options, undef) {\n\n  // FIXME: hack\n  var p = options.p;\n\n  /**\n   * PMatrix3D is a 4x4  matrix implementation. The constructor accepts another PMatrix3D or a list of six or sixteen float elements.\n   * If no parameters are provided the matrix is set to the identity matrix.\n   */\n  var PMatrix3D = function() {\n    // When a matrix is created, it is set to an identity matrix\n    this.reset();\n  };\n\n  /**\n   * PMatrix3D methods\n   */\n  PMatrix3D.prototype = {\n    /**\n     * @member PMatrix2D\n     * The set() function sets the matrix elements. The function accepts either another PMatrix3D, an array of elements, or a list of six or sixteen floats.\n     *\n     * @param {PMatrix3D} matrix    the initial matrix to set to\n     * @param {float[]} elements    an array of elements to set this matrix to\n     * @param {float} m00           the first element of the matrix\n     * @param {float} m01           the second element of the matrix\n     * @param {float} m02           the third element of the matrix\n     * @param {float} m03           the fourth element of the matrix\n     * @param {float} m10           the fifth element of the matrix\n     * @param {float} m11           the sixth element of the matrix\n     * @param {float} m12           the seventh element of the matrix\n     * @param {float} m13           the eight element of the matrix\n     * @param {float} m20           the nineth element of the matrix\n     * @param {float} m21           the tenth element of the matrix\n     * @param {float} m22           the eleventh element of the matrix\n     * @param {float} m23           the twelveth element of the matrix\n     * @param {float} m30           the thirteenth element of the matrix\n     * @param {float} m31           the fourtheenth element of the matrix\n     * @param {float} m32           the fivetheenth element of the matrix\n     * @param {float} m33           the sixteenth element of the matrix\n     */\n    set: function() {\n      if (arguments.length === 16) {\n        this.elements = Array.prototype.slice.call(arguments);\n      } else if (arguments.length === 1 && arguments[0] instanceof PMatrix3D) {\n        this.elements = arguments[0].array();\n      } else if (arguments.length === 1 && arguments[0] instanceof Array) {\n        this.elements = arguments[0].slice();\n      }\n    },\n    /**\n     * @member PMatrix3D\n     * The get() function returns a copy of this PMatrix3D.\n     *\n     * @return {PMatrix3D} a copy of this PMatrix3D\n     */\n    get: function() {\n      var outgoing = new PMatrix3D();\n      outgoing.set(this.elements);\n      return outgoing;\n    },\n    /**\n     * @member PMatrix3D\n     * The reset() function sets this PMatrix3D to the identity matrix.\n     */\n    reset: function() {\n      this.elements = [1,0,0,0,\n                       0,1,0,0,\n                       0,0,1,0,\n                       0,0,0,1];\n    },\n    /**\n     * @member PMatrix3D\n     * The array() function returns a copy of the element values.\n     * @addon\n     *\n     * @return {float[]} returns a copy of the element values\n     */\n    array: function array() {\n      return this.elements.slice();\n    },\n    /**\n     * @member PMatrix3D\n     * The translate() function translates this matrix by moving the current coordinates to the location specified by tx, ty, and tz.\n     *\n     * @param {float} tx  the x-axis coordinate to move to\n     * @param {float} ty  the y-axis coordinate to move to\n     * @param {float} tz  the z-axis coordinate to move to\n     */\n    translate: function(tx, ty, tz) {\n      if (tz === undef) {\n        tz = 0;\n      }\n\n      this.elements[3]  += tx * this.elements[0]  + ty * this.elements[1]  + tz * this.elements[2];\n      this.elements[7]  += tx * this.elements[4]  + ty * this.elements[5]  + tz * this.elements[6];\n      this.elements[11] += tx * this.elements[8]  + ty * this.elements[9]  + tz * this.elements[10];\n      this.elements[15] += tx * this.elements[12] + ty * this.elements[13] + tz * this.elements[14];\n    },\n    /**\n     * @member PMatrix3D\n     * The transpose() function transpose this matrix.\n     */\n    transpose: function() {\n      var temp = this.elements[4];\n      this.elements[4] = this.elements[1];\n      this.elements[1] = temp;\n\n      temp = this.elements[8];\n      this.elements[8] = this.elements[2];\n      this.elements[2] = temp;\n\n      temp = this.elements[6];\n      this.elements[6] = this.elements[9];\n      this.elements[9] = temp;\n\n      temp = this.elements[3];\n      this.elements[3] = this.elements[12];\n      this.elements[12] = temp;\n\n      temp = this.elements[7];\n      this.elements[7] = this.elements[13];\n      this.elements[13] = temp;\n\n      temp = this.elements[11];\n      this.elements[11] = this.elements[14];\n      this.elements[14] = temp;\n    },\n    /**\n     * @member PMatrix3D\n     * The mult() function multiplied this matrix.\n     * If two array elements are passed in the function will multiply a two element vector against this matrix.\n     * If target is null or not length four, a new float array will be returned.\n     * The values for vec and target can be the same (though that's less efficient).\n     * If two PVectors are passed in the function multiply the x and y coordinates of a PVector against this matrix.\n     *\n     * @param {PVector} source, target  the PVectors used to multiply this matrix\n     * @param {float[]} source, target  the arrays used to multiply this matrix\n     *\n     * @return {PVector|float[]} returns a PVector or an array representing the new matrix\n     */\n    mult: function(source, target) {\n      var x, y, z, w;\n      if (source instanceof PVector) {\n        x = source.x;\n        y = source.y;\n        z = source.z;\n        w = 1;\n        if (!target) {\n          target = new PVector();\n        }\n      } else if (source instanceof Array) {\n        x = source[0];\n        y = source[1];\n        z = source[2];\n        w = source[3] || 1;\n\n        if ( !target || (target.length !== 3 && target.length !== 4) ) {\n          target = [0, 0, 0];\n        }\n      }\n\n      if (target instanceof Array) {\n        if (target.length === 3) {\n          target[0] = this.elements[0] * x + this.elements[1] * y + this.elements[2] * z + this.elements[3];\n          target[1] = this.elements[4] * x + this.elements[5] * y + this.elements[6] * z + this.elements[7];\n          target[2] = this.elements[8] * x + this.elements[9] * y + this.elements[10] * z + this.elements[11];\n        } else if (target.length === 4) {\n          target[0] = this.elements[0] * x + this.elements[1] * y + this.elements[2] * z + this.elements[3] * w;\n          target[1] = this.elements[4] * x + this.elements[5] * y + this.elements[6] * z + this.elements[7] * w;\n          target[2] = this.elements[8] * x + this.elements[9] * y + this.elements[10] * z + this.elements[11] * w;\n          target[3] = this.elements[12] * x + this.elements[13] * y + this.elements[14] * z + this.elements[15] * w;\n        }\n      }\n      if (target instanceof PVector) {\n        target.x = this.elements[0] * x + this.elements[1] * y + this.elements[2] * z + this.elements[3];\n        target.y = this.elements[4] * x + this.elements[5] * y + this.elements[6] * z + this.elements[7];\n        target.z = this.elements[8] * x + this.elements[9] * y + this.elements[10] * z + this.elements[11];\n      }\n      return target;\n    },\n    /**\n     * @member PMatrix3D\n     * The preApply() function applies another matrix to the left of this one. Note that either a PMatrix3D or elements of a matrix can be passed in.\n     *\n     * @param {PMatrix3D} matrix    the matrix to apply this matrix to\n     * @param {float} m00           the first element of the matrix\n     * @param {float} m01           the second element of the matrix\n     * @param {float} m02           the third element of the matrix\n     * @param {float} m03           the fourth element of the matrix\n     * @param {float} m10           the fifth element of the matrix\n     * @param {float} m11           the sixth element of the matrix\n     * @param {float} m12           the seventh element of the matrix\n     * @param {float} m13           the eight element of the matrix\n     * @param {float} m20           the nineth element of the matrix\n     * @param {float} m21           the tenth element of the matrix\n     * @param {float} m22           the eleventh element of the matrix\n     * @param {float} m23           the twelveth element of the matrix\n     * @param {float} m30           the thirteenth element of the matrix\n     * @param {float} m31           the fourtheenth element of the matrix\n     * @param {float} m32           the fivetheenth element of the matrix\n     * @param {float} m33           the sixteenth element of the matrix\n     */\n    preApply: function() {\n      var source;\n      if (arguments.length === 1 && arguments[0] instanceof PMatrix3D) {\n        source = arguments[0].array();\n      } else if (arguments.length === 16) {\n        source = Array.prototype.slice.call(arguments);\n      } else if (arguments.length === 1 && arguments[0] instanceof Array) {\n        source = arguments[0];\n      }\n\n      var result = [0, 0, 0, 0,\n                    0, 0, 0, 0,\n                    0, 0, 0, 0,\n                    0, 0, 0, 0];\n      var e = 0;\n      for (var row = 0; row < 4; row++) {\n        for (var col = 0; col < 4; col++, e++) {\n          result[e] += this.elements[col + 0] * source[row * 4 + 0] + this.elements[col + 4] *\n                       source[row * 4 + 1] + this.elements[col + 8] * source[row * 4 + 2] +\n                       this.elements[col + 12] * source[row * 4 + 3];\n        }\n      }\n      this.elements = result.slice();\n    },\n    /**\n     * @member PMatrix3D\n     * The apply() function multiplies the current matrix by the one specified through the parameters. Note that either a PMatrix3D or a list of floats can be passed in.\n     *\n     * @param {PMatrix3D} matrix    the matrix to apply this matrix to\n     * @param {float} m00           the first element of the matrix\n     * @param {float} m01           the second element of the matrix\n     * @param {float} m02           the third element of the matrix\n     * @param {float} m03           the fourth element of the matrix\n     * @param {float} m10           the fifth element of the matrix\n     * @param {float} m11           the sixth element of the matrix\n     * @param {float} m12           the seventh element of the matrix\n     * @param {float} m13           the eight element of the matrix\n     * @param {float} m20           the nineth element of the matrix\n     * @param {float} m21           the tenth element of the matrix\n     * @param {float} m22           the eleventh element of the matrix\n     * @param {float} m23           the twelveth element of the matrix\n     * @param {float} m30           the thirteenth element of the matrix\n     * @param {float} m31           the fourtheenth element of the matrix\n     * @param {float} m32           the fivetheenth element of the matrix\n     * @param {float} m33           the sixteenth element of the matrix\n     */\n    apply: function() {\n      var source;\n      if (arguments.length === 1 && arguments[0] instanceof PMatrix3D) {\n        source = arguments[0].array();\n      } else if (arguments.length === 16) {\n        source = Array.prototype.slice.call(arguments);\n      } else if (arguments.length === 1 && arguments[0] instanceof Array) {\n        source = arguments[0];\n      }\n\n      var result = [0, 0, 0, 0,\n                    0, 0, 0, 0,\n                    0, 0, 0, 0,\n                    0, 0, 0, 0];\n      var e = 0;\n      for (var row = 0; row < 4; row++) {\n        for (var col = 0; col < 4; col++, e++) {\n          result[e] += this.elements[row * 4 + 0] * source[col + 0] + this.elements[row * 4 + 1] *\n                       source[col + 4] + this.elements[row * 4 + 2] * source[col + 8] +\n                       this.elements[row * 4 + 3] * source[col + 12];\n        }\n      }\n      this.elements = result.slice();\n    },\n    /**\n     * @member PMatrix3D\n     * The rotate() function rotates the matrix.\n     *\n     * @param {float} angle         the angle of rotation in radiants\n     */\n    rotate: function(angle, v0, v1, v2) {\n      if (!v1) {\n        this.rotateZ(angle);\n      } else {\n        // TODO should make sure this vector is normalized\n        var c = Math.cos(angle);\n        var s = Math.sin(angle);\n        var t = 1.0 - c;\n\n        this.apply((t * v0 * v0) + c,\n                   (t * v0 * v1) - (s * v2),\n                   (t * v0 * v2) + (s * v1),\n                   0,\n                   (t * v0 * v1) + (s * v2),\n                   (t * v1 * v1) + c,\n                   (t * v1 * v2) - (s * v0),\n                   0,\n                   (t * v0 * v2) - (s * v1),\n                   (t * v1 * v2) + (s * v0),\n                   (t * v2 * v2) + c,\n                   0,\n                   0, 0, 0, 1);\n      }\n    },\n    /**\n     * @member PMatrix3D\n     * The invApply() function applies the inverted matrix to this matrix.\n     *\n     * @param {float} m00           the first element of the matrix\n     * @param {float} m01           the second element of the matrix\n     * @param {float} m02           the third element of the matrix\n     * @param {float} m03           the fourth element of the matrix\n     * @param {float} m10           the fifth element of the matrix\n     * @param {float} m11           the sixth element of the matrix\n     * @param {float} m12           the seventh element of the matrix\n     * @param {float} m13           the eight element of the matrix\n     * @param {float} m20           the nineth element of the matrix\n     * @param {float} m21           the tenth element of the matrix\n     * @param {float} m22           the eleventh element of the matrix\n     * @param {float} m23           the twelveth element of the matrix\n     * @param {float} m30           the thirteenth element of the matrix\n     * @param {float} m31           the fourtheenth element of the matrix\n     * @param {float} m32           the fivetheenth element of the matrix\n     * @param {float} m33           the sixteenth element of the matrix\n     *\n     * @return {boolean} returns true if the operation was successful.\n     */\n    invApply: function() {\n      if (inverseCopy === undef) {\n        inverseCopy = new PMatrix3D();\n      }\n      var a = arguments;\n      inverseCopy.set(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8],\n                      a[9], a[10], a[11], a[12], a[13], a[14], a[15]);\n\n      if (!inverseCopy.invert()) {\n        return false;\n      }\n      this.preApply(inverseCopy);\n      return true;\n    },\n    /**\n     * @member PMatrix3D\n     * The rotateZ() function rotates the matrix.\n     *\n     * @param {float} angle         the angle of rotation in radiants\n     */\n    rotateX: function(angle) {\n      var c = Math.cos(angle);\n      var s = Math.sin(angle);\n      this.apply([1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1]);\n    },\n    /**\n     * @member PMatrix3D\n     * The rotateY() function rotates the matrix.\n     *\n     * @param {float} angle         the angle of rotation in radiants\n     */\n    rotateY: function(angle) {\n      var c = Math.cos(angle);\n      var s = Math.sin(angle);\n      this.apply([c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1]);\n    },\n    /**\n     * @member PMatrix3D\n     * The rotateZ() function rotates the matrix.\n     *\n     * @param {float} angle         the angle of rotation in radiants\n     */\n    rotateZ: function(angle) {\n      var c = Math.cos(angle);\n      var s = Math.sin(angle);\n      this.apply([c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\n    },\n    /**\n     * @member PMatrix3D\n     * The scale() function increases or decreases the size of a matrix by expanding and contracting vertices. When only one parameter is specified scale will occur in all dimensions.\n     * This is equivalent to a three parameter call.\n     *\n     * @param {float} sx  the amount to scale on the x-axis\n     * @param {float} sy  the amount to scale on the y-axis\n     * @param {float} sz  the amount to scale on the z-axis\n     */\n    scale: function(sx, sy, sz) {\n      if (sx && sy === undef && sz === undef) {\n        sy = sz = sx;\n      } else if (sx && sy && sz === undef) {\n        sz = 1;\n      }\n\n      if (sx && sy && sz) {\n        this.elements[0]  *= sx;\n        this.elements[1]  *= sy;\n        this.elements[2]  *= sz;\n        this.elements[4]  *= sx;\n        this.elements[5]  *= sy;\n        this.elements[6]  *= sz;\n        this.elements[8]  *= sx;\n        this.elements[9]  *= sy;\n        this.elements[10] *= sz;\n        this.elements[12] *= sx;\n        this.elements[13] *= sy;\n        this.elements[14] *= sz;\n      }\n    },\n    /**\n     * @member PMatrix3D\n     * The skewX() function skews the matrix along the x-axis the amount specified by the angle parameter.\n     * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.\n     *\n     * @param {float} angle  angle of skew specified in radians\n     */\n    skewX: function(angle) {\n      var t = Math.tan(angle);\n      this.apply(1, t, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n    },\n    /**\n     * @member PMatrix3D\n     * The skewY() function skews the matrix along the y-axis the amount specified by the angle parameter.\n     * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.\n     *\n     * @param {float} angle  angle of skew specified in radians\n     */\n    skewY: function(angle) {\n      var t = Math.tan(angle);\n      this.apply(1, 0, 0, 0, t, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n    },\n    /**\n     * @member PMatrix3D\n     * The shearX() function shears the matrix along the x-axis the amount specified by the angle parameter.\n     * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.\n     *\n     * @param {float} angle  angle of shear specified in radians\n     */\n    shearX: function(angle) {\n      var t = Math.tan(angle);\n      this.apply(1, t, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n    },\n    /**\n     * @member PMatrix3D\n     * The shearY() function shears the matrix along the y-axis the amount specified by the angle parameter.\n     * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.\n     *\n     * @param {float} angle  angle of shear specified in radians\n     */\n    shearY: function(angle) {\n      var t = Math.tan(angle);\n      this.apply(1, 0, 0, 0, t, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n    },\n    multX: function(x, y, z, w) {\n      if (!z) {\n        return this.elements[0] * x + this.elements[1] * y + this.elements[3];\n      }\n      if (!w) {\n        return this.elements[0] * x + this.elements[1] * y + this.elements[2] * z + this.elements[3];\n      }\n      return this.elements[0] * x + this.elements[1] * y + this.elements[2] * z + this.elements[3] * w;\n    },\n    multY: function(x, y, z, w) {\n      if (!z) {\n        return this.elements[4] * x + this.elements[5] * y + this.elements[7];\n      }\n      if (!w) {\n        return this.elements[4] * x + this.elements[5] * y + this.elements[6] * z + this.elements[7];\n      }\n      return this.elements[4] * x + this.elements[5] * y + this.elements[6] * z + this.elements[7] * w;\n    },\n    multZ: function(x, y, z, w) {\n      if (!w) {\n        return this.elements[8] * x + this.elements[9] * y + this.elements[10] * z + this.elements[11];\n      }\n      return this.elements[8] * x + this.elements[9] * y + this.elements[10] * z + this.elements[11] * w;\n    },\n    multW: function(x, y, z, w) {\n      if (!w) {\n        return this.elements[12] * x + this.elements[13] * y + this.elements[14] * z + this.elements[15];\n      }\n      return this.elements[12] * x + this.elements[13] * y + this.elements[14] * z + this.elements[15] * w;\n    },\n    /**\n     * @member PMatrix3D\n     * The invert() function inverts this matrix\n     *\n     * @return {boolean} true if successful\n     */\n    invert: function() {\n      var fA0 = this.elements[0] * this.elements[5] - this.elements[1] * this.elements[4];\n      var fA1 = this.elements[0] * this.elements[6] - this.elements[2] * this.elements[4];\n      var fA2 = this.elements[0] * this.elements[7] - this.elements[3] * this.elements[4];\n      var fA3 = this.elements[1] * this.elements[6] - this.elements[2] * this.elements[5];\n      var fA4 = this.elements[1] * this.elements[7] - this.elements[3] * this.elements[5];\n      var fA5 = this.elements[2] * this.elements[7] - this.elements[3] * this.elements[6];\n      var fB0 = this.elements[8] * this.elements[13] - this.elements[9] * this.elements[12];\n      var fB1 = this.elements[8] * this.elements[14] - this.elements[10] * this.elements[12];\n      var fB2 = this.elements[8] * this.elements[15] - this.elements[11] * this.elements[12];\n      var fB3 = this.elements[9] * this.elements[14] - this.elements[10] * this.elements[13];\n      var fB4 = this.elements[9] * this.elements[15] - this.elements[11] * this.elements[13];\n      var fB5 = this.elements[10] * this.elements[15] - this.elements[11] * this.elements[14];\n\n      // Determinant\n      var fDet = fA0 * fB5 - fA1 * fB4 + fA2 * fB3 + fA3 * fB2 - fA4 * fB1 + fA5 * fB0;\n\n      // Account for a very small value\n      // return false if not successful.\n      if (Math.abs(fDet) <= 1e-9) {\n        return false;\n      }\n\n      var kInv = [];\n      kInv[0]  = +this.elements[5] * fB5 - this.elements[6] * fB4 + this.elements[7] * fB3;\n      kInv[4]  = -this.elements[4] * fB5 + this.elements[6] * fB2 - this.elements[7] * fB1;\n      kInv[8]  = +this.elements[4] * fB4 - this.elements[5] * fB2 + this.elements[7] * fB0;\n      kInv[12] = -this.elements[4] * fB3 + this.elements[5] * fB1 - this.elements[6] * fB0;\n      kInv[1]  = -this.elements[1] * fB5 + this.elements[2] * fB4 - this.elements[3] * fB3;\n      kInv[5]  = +this.elements[0] * fB5 - this.elements[2] * fB2 + this.elements[3] * fB1;\n      kInv[9]  = -this.elements[0] * fB4 + this.elements[1] * fB2 - this.elements[3] * fB0;\n      kInv[13] = +this.elements[0] * fB3 - this.elements[1] * fB1 + this.elements[2] * fB0;\n      kInv[2]  = +this.elements[13] * fA5 - this.elements[14] * fA4 + this.elements[15] * fA3;\n      kInv[6]  = -this.elements[12] * fA5 + this.elements[14] * fA2 - this.elements[15] * fA1;\n      kInv[10] = +this.elements[12] * fA4 - this.elements[13] * fA2 + this.elements[15] * fA0;\n      kInv[14] = -this.elements[12] * fA3 + this.elements[13] * fA1 - this.elements[14] * fA0;\n      kInv[3]  = -this.elements[9] * fA5 + this.elements[10] * fA4 - this.elements[11] * fA3;\n      kInv[7]  = +this.elements[8] * fA5 - this.elements[10] * fA2 + this.elements[11] * fA1;\n      kInv[11] = -this.elements[8] * fA4 + this.elements[9] * fA2 - this.elements[11] * fA0;\n      kInv[15] = +this.elements[8] * fA3 - this.elements[9] * fA1 + this.elements[10] * fA0;\n\n      // Inverse using Determinant\n      var fInvDet = 1.0 / fDet;\n      kInv[0]  *= fInvDet;\n      kInv[1]  *= fInvDet;\n      kInv[2]  *= fInvDet;\n      kInv[3]  *= fInvDet;\n      kInv[4]  *= fInvDet;\n      kInv[5]  *= fInvDet;\n      kInv[6]  *= fInvDet;\n      kInv[7]  *= fInvDet;\n      kInv[8]  *= fInvDet;\n      kInv[9]  *= fInvDet;\n      kInv[10] *= fInvDet;\n      kInv[11] *= fInvDet;\n      kInv[12] *= fInvDet;\n      kInv[13] *= fInvDet;\n      kInv[14] *= fInvDet;\n      kInv[15] *= fInvDet;\n\n      this.elements = kInv.slice();\n      return true;\n    },\n    toString: function() {\n      var str = \"\";\n      for (var i = 0; i < 15; i++) {\n        str += this.elements[i] + \", \";\n      }\n      str += this.elements[15];\n      return str;\n    },\n    /**\n     * @member PMatrix3D\n     * The print() function prints out the elements of this matrix\n     */\n    print: function() {\n      var digits = printMatrixHelper(this.elements);\n\n      var output = \"\"   + p.nfs(this.elements[0], digits, 4)  + \" \" + p.nfs(this.elements[1], digits, 4)  +\n                   \" \"  + p.nfs(this.elements[2], digits, 4)  + \" \" + p.nfs(this.elements[3], digits, 4)  +\n                   \"\\n\" + p.nfs(this.elements[4], digits, 4)  + \" \" + p.nfs(this.elements[5], digits, 4)  +\n                   \" \"  + p.nfs(this.elements[6], digits, 4)  + \" \" + p.nfs(this.elements[7], digits, 4)  +\n                   \"\\n\" + p.nfs(this.elements[8], digits, 4)  + \" \" + p.nfs(this.elements[9], digits, 4)  +\n                   \" \"  + p.nfs(this.elements[10], digits, 4) + \" \" + p.nfs(this.elements[11], digits, 4) +\n                   \"\\n\" + p.nfs(this.elements[12], digits, 4) + \" \" + p.nfs(this.elements[13], digits, 4) +\n                   \" \"  + p.nfs(this.elements[14], digits, 4) + \" \" + p.nfs(this.elements[15], digits, 4) + \"\\n\\n\";\n      p.println(output);\n    },\n    invTranslate: function(tx, ty, tz) {\n      this.preApply(1, 0, 0, -tx, 0, 1, 0, -ty, 0, 0, 1, -tz, 0, 0, 0, 1);\n    },\n    invRotateX: function(angle) {\n      var c = Math.cos(-angle);\n      var s = Math.sin(-angle);\n      this.preApply([1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1]);\n    },\n    invRotateY: function(angle) {\n      var c = Math.cos(-angle);\n      var s = Math.sin(-angle);\n      this.preApply([c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1]);\n    },\n    invRotateZ: function(angle) {\n      var c = Math.cos(-angle);\n      var s = Math.sin(-angle);\n      this.preApply([c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\n    },\n    invScale: function(x, y, z) {\n      this.preApply([1 / x, 0, 0, 0, 0, 1 / y, 0, 0, 0, 0, 1 / z, 0, 0, 0, 0, 1]);\n    }\n  };\n\n  return PMatrix3D;\n};\n},{}],15:[function(require,module,exports){\nmodule.exports = function(options) {\n  var PConstants = options.PConstants,\n      PMatrix2D = options.PMatrix2D,\n      PMatrix3D = options.PMatrix3D;\n\n  /**\n   * Datatype for storing shapes. Processing can currently load and display SVG (Scalable Vector Graphics) shapes.\n   * Before a shape is used, it must be loaded with the <b>loadShape()</b> function. The <b>shape()</b> function is used to draw the shape to the display window.\n   * The <b>PShape</b> object contain a group of methods, linked below, that can operate on the shape data.\n   * <br><br>The <b>loadShape()</b> method supports SVG files created with Inkscape and Adobe Illustrator.\n   * It is not a full SVG implementation, but offers some straightforward support for handling vector data.\n   *\n   * @param {int} family the shape type, one of GROUP, PRIMITIVE, PATH, or GEOMETRY\n   *\n   * @see #shape()\n   * @see #loadShape()\n   * @see #shapeMode()\n   */\n  var PShape = function(family) {\n    this.family    = family || PConstants.GROUP;\n    this.visible   = true;\n    this.style     = true;\n    this.children  = [];\n    this.nameTable = [];\n    this.params    = [];\n    this.name      = \"\";\n    this.image     = null;  //type PImage\n    this.matrix    = null;\n    this.kind      = null;\n    this.close     = null;\n    this.width     = null;\n    this.height    = null;\n    this.parent    = null;\n  };\n  /**\n    * PShape methods\n    * missing: findChild(), apply(), contains(), findChild(), getPrimitive(), getParams(), getVertex() , getVertexCount(),\n    * getVertexCode() , getVertexCodes() , getVertexCodeCount(), getVertexX(), getVertexY(), getVertexZ()\n    */\n  PShape.prototype = {\n    /**\n     * @member PShape\n     * The isVisible() function returns a boolean value \"true\" if the image is set to be visible, \"false\" if not. This is modified with the <b>setVisible()</b> parameter.\n     * <br><br>The visibility of a shape is usually controlled by whatever program created the SVG file.\n     * For instance, this parameter is controlled by showing or hiding the shape in the layers palette in Adobe Illustrator.\n     *\n     * @return {boolean}  returns \"true\" if the image is set to be visible, \"false\" if not\n     */\n    isVisible: function(){\n      return this.visible;\n    },\n    /**\n     * @member PShape\n     * The setVisible() function sets the shape to be visible or invisible. This is determined by the value of the <b>visible</b> parameter.\n     * <br><br>The visibility of a shape is usually controlled by whatever program created the SVG file.\n     * For instance, this parameter is controlled by showing or hiding the shape in the layers palette in Adobe Illustrator.\n     *\n     * @param {boolean} visible \"false\" makes the shape invisible and \"true\" makes it visible\n     */\n    setVisible: function (visible){\n      this.visible = visible;\n    },\n    /**\n     * @member PShape\n     * The disableStyle() function disables the shape's style data and uses Processing's current styles. Styles include attributes such as colors, stroke weight, and stroke joints.\n     * Overrides this shape's style information and uses PGraphics styles and colors. Identical to ignoreStyles(true). Also disables styles for all child shapes.\n     */\n    disableStyle: function(){\n      this.style = false;\n      for(var i = 0, j=this.children.length; i<j; i++) {\n        this.children[i].disableStyle();\n      }\n    },\n    /**\n     * @member PShape\n     * The enableStyle() function enables the shape's style data and ignores Processing's current styles. Styles include attributes such as colors, stroke weight, and stroke joints.\n     */\n    enableStyle: function(){\n      this.style = true;\n      for(var i = 0, j=this.children.length; i<j; i++) {\n        this.children[i].enableStyle();\n      }\n    },\n    /**\n     * @member PShape\n     * The getFamily function returns the shape type\n     *\n     * @return {int} the shape type, one of GROUP, PRIMITIVE, PATH, or GEOMETRY\n     */\n    getFamily: function(){\n      return this.family;\n    },\n    /**\n     * @member PShape\n     * The getWidth() function gets the width of the drawing area (not necessarily the shape boundary).\n     */\n    getWidth: function(){\n      return this.width;\n    },\n    /**\n     * @member PShape\n     * The getHeight() function gets the height of the drawing area (not necessarily the shape boundary).\n     */\n    getHeight: function(){\n      return this.height;\n    },\n    /**\n     * @member PShape\n     * The setName() function sets the name of the shape\n     *\n     * @param {String} name the name of the shape\n     */\n    setName: function(name){\n      this.name = name;\n    },\n    /**\n     * @member PShape\n     * The getName() function returns the name of the shape\n     *\n     * @return {String} the name of the shape\n     */\n    getName: function(){\n      return this.name;\n    },\n    /**\n     * @member PShape\n     * Called by the following (the shape() command adds the g)\n     * PShape s = loadShapes(\"blah.svg\");\n     * shape(s);\n     */\n    draw: function(renderContext) {\n      if(!renderContext) {\n        throw \"render context missing for draw() in PShape\";\n      }\n      if (this.visible) {\n        this.pre(renderContext);\n        this.drawImpl(renderContext);\n        this.post(renderContext);\n      }\n    },\n    /**\n     * @member PShape\n     * the drawImpl() function draws the SVG document.\n     */\n    drawImpl: function(renderContext) {\n      if (this.family === PConstants.GROUP) {\n        this.drawGroup(renderContext);\n      } else if (this.family === PConstants.PRIMITIVE) {\n        this.drawPrimitive(renderContext);\n      } else if (this.family === PConstants.GEOMETRY) {\n        this.drawGeometry(renderContext);\n      } else if (this.family === PConstants.PATH) {\n        this.drawPath(renderContext);\n      }\n    },\n    /**\n     * @member PShape\n     * The drawPath() function draws the <path> part of the SVG document.\n     */\n    drawPath: function(renderContext) {\n      var i, j;\n      if (this.vertices.length === 0) { return; }\n      renderContext.beginShape();\n      if (this.vertexCodes.length === 0) {  // each point is a simple vertex\n        if (this.vertices[0].length === 2) {  // drawing 2D vertices\n          for (i = 0, j = this.vertices.length; i < j; i++) {\n            renderContext.vertex(this.vertices[i][0], this.vertices[i][1]);\n          }\n        } else {  // drawing 3D vertices\n          for (i = 0, j = this.vertices.length; i < j; i++) {\n            renderContext.vertex(this.vertices[i][0],\n                                 this.vertices[i][1],\n                                 this.vertices[i][2]);\n          }\n        }\n      } else {  // coded set of vertices\n        var index = 0;\n        if (this.vertices[0].length === 2) {  // drawing a 2D path\n          for (i = 0, j = this.vertexCodes.length; i < j; i++) {\n            if (this.vertexCodes[i] === PConstants.VERTEX) {\n              renderContext.vertex(this.vertices[index][0], this.vertices[index][1], this.vertices[index].moveTo);\n              renderContext.breakShape = false;\n              index++;\n            } else if (this.vertexCodes[i] === PConstants.BEZIER_VERTEX) {\n              renderContext.bezierVertex(this.vertices[index+0][0],\n                                         this.vertices[index+0][1],\n                                         this.vertices[index+1][0],\n                                         this.vertices[index+1][1],\n                                         this.vertices[index+2][0],\n                                         this.vertices[index+2][1]);\n              index += 3;\n            } else if (this.vertexCodes[i] === PConstants.CURVE_VERTEX) {\n              renderContext.curveVertex(this.vertices[index][0],\n                                        this.vertices[index][1]);\n              index++;\n            } else if (this.vertexCodes[i] ===  PConstants.BREAK) {\n              renderContext.breakShape = true;\n            }\n          }\n        } else {  // drawing a 3D path\n          for (i = 0, j = this.vertexCodes.length; i < j; i++) {\n            if (this.vertexCodes[i] === PConstants.VERTEX) {\n              renderContext.vertex(this.vertices[index][0],\n                                   this.vertices[index][1],\n                                   this.vertices[index][2]);\n              if (this.vertices[index].moveTo === true) {\n                vertArray[vertArray.length-1].moveTo = true;\n              } else if (this.vertices[index].moveTo === false) {\n                vertArray[vertArray.length-1].moveTo = false;\n              }\n              renderContext.breakShape = false;\n            } else if (this.vertexCodes[i] ===  PConstants.BEZIER_VERTEX) {\n              renderContext.bezierVertex(this.vertices[index+0][0],\n                                         this.vertices[index+0][1],\n                                         this.vertices[index+0][2],\n                                         this.vertices[index+1][0],\n                                         this.vertices[index+1][1],\n                                         this.vertices[index+1][2],\n                                         this.vertices[index+2][0],\n                                         this.vertices[index+2][1],\n                                         this.vertices[index+2][2]);\n              index += 3;\n            } else if (this.vertexCodes[i] === PConstants.CURVE_VERTEX) {\n              renderContext.curveVertex(this.vertices[index][0],\n                                        this.vertices[index][1],\n                                        this.vertices[index][2]);\n              index++;\n            } else if (this.vertexCodes[i] === PConstants.BREAK) {\n              renderContext.breakShape = true;\n            }\n          }\n        }\n      }\n      renderContext.endShape(this.close ? PConstants.CLOSE : PConstants.OPEN);\n    },\n    /**\n     * @member PShape\n     * The drawGeometry() function draws the geometry part of the SVG document.\n     */\n    drawGeometry: function(renderContext) {\n      var i, j;\n      renderContext.beginShape(this.kind);\n      if (this.style) {\n        for (i = 0, j = this.vertices.length; i < j; i++) {\n          renderContext.vertex(this.vertices[i]);\n        }\n      } else {\n        for (i = 0, j = this.vertices.length; i < j; i++) {\n          var vert = this.vertices[i];\n          if (vert[2] === 0) {\n            renderContext.vertex(vert[0], vert[1]);\n          } else {\n            renderContext.vertex(vert[0], vert[1], vert[2]);\n          }\n        }\n      }\n      renderContext.endShape();\n    },\n    /**\n     * @member PShape\n     * The drawGroup() function draws the <g> part of the SVG document.\n     */\n    drawGroup: function(renderContext) {\n      for (var i = 0, j = this.children.length; i < j; i++) {\n        this.children[i].draw(renderContext);\n      }\n    },\n    /**\n     * @member PShape\n     * The drawPrimitive() function draws SVG document shape elements. These can be point, line, triangle, quad, rect, ellipse, arc, box, or sphere.\n     */\n    drawPrimitive: function(renderContext) {\n      if (this.kind === PConstants.POINT) {\n        renderContext.point(this.params[0], this.params[1]);\n      } else if (this.kind === PConstants.LINE) {\n        if (this.params.length === 4) {  // 2D\n          renderContext.line(this.params[0], this.params[1],\n                            this.params[2], this.params[3]);\n        } else {  // 3D\n          renderContext.line(this.params[0], this.params[1], this.params[2],\n                             this.params[3], this.params[4], this.params[5]);\n        }\n      } else if (this.kind === PConstants.TRIANGLE) {\n        renderContext.triangle(this.params[0], this.params[1],\n                               this.params[2], this.params[3],\n                               this.params[4], this.params[5]);\n      } else if (this.kind === PConstants.QUAD) {\n        renderContext.quad(this.params[0], this.params[1],\n                           this.params[2], this.params[3],\n                           this.params[4], this.params[5],\n                           this.params[6], this.params[7]);\n      } else if (this.kind === PConstants.RECT) {\n        if (this.image !== null) {\n          var imMode = imageModeConvert;\n          renderContext.imageMode(PConstants.CORNER);\n          renderContext.image(this.image,\n                              this.params[0],\n                              this.params[1],\n                              this.params[2],\n                              this.params[3]);\n          imageModeConvert = imMode;\n        } else {\n          var rcMode = renderContext.curRectMode;\n          renderContext.rectMode(PConstants.CORNER);\n          renderContext.rect(this.params[0],\n                             this.params[1],\n                             this.params[2],\n                             this.params[3]);\n          renderContext.curRectMode = rcMode;\n        }\n      } else if (this.kind === PConstants.ELLIPSE) {\n        var elMode = renderContext.curEllipseMode;\n        renderContext.ellipseMode(PConstants.CORNER);\n        renderContext.ellipse(this.params[0],\n                              this.params[1],\n                              this.params[2],\n                              this.params[3]);\n        renderContext.curEllipseMode = elMode;\n      } else if (this.kind === PConstants.ARC) {\n        var eMode = curEllipseMode;\n        renderContext.ellipseMode(PConstants.CORNER);\n        renderContext.arc(this.params[0],\n                          this.params[1],\n                          this.params[2],\n                          this.params[3],\n                          this.params[4],\n                          this.params[5]);\n        curEllipseMode = eMode;\n      } else if (this.kind === PConstants.BOX) {\n        if (this.params.length === 1) {\n          renderContext.box(this.params[0]);\n        } else {\n          renderContext.box(this.params[0], this.params[1], this.params[2]);\n        }\n      } else if (this.kind === PConstants.SPHERE) {\n        renderContext.sphere(this.params[0]);\n      }\n    },\n    /**\n     * @member PShape\n     * The pre() function performs the preparations before the SVG is drawn. This includes doing transformations and storing previous styles.\n     */\n    pre: function(renderContext) {\n      if (this.matrix) {\n        renderContext.pushMatrix();\n        renderContext.transform(this.matrix);\n      }\n      if (this.style) {\n        renderContext.pushStyle();\n        this.styles(renderContext);\n      }\n    },\n    /**\n     * @member PShape\n     * The post() function performs the necessary actions after the SVG is drawn. This includes removing transformations and removing added styles.\n     */\n    post: function(renderContext) {\n      if (this.matrix) {\n        renderContext.popMatrix();\n      }\n      if (this.style) {\n        renderContext.popStyle();\n      }\n    },\n    /**\n     * @member PShape\n     * The styles() function changes the Processing's current styles\n     */\n    styles: function(renderContext) {\n      if (this.stroke) {\n        renderContext.stroke(this.strokeColor);\n        renderContext.strokeWeight(this.strokeWeight);\n        renderContext.strokeCap(this.strokeCap);\n        renderContext.strokeJoin(this.strokeJoin);\n      } else {\n        renderContext.noStroke();\n      }\n\n      if (this.fill) {\n        renderContext.fill(this.fillColor);\n\n      } else {\n        renderContext.noFill();\n      }\n    },\n    /**\n     * @member PShape\n     * The getChild() function extracts a child shape from a parent shape. Specify the name of the shape with the <b>target</b> parameter or the\n     * layer position of the shape to get with the <b>index</b> parameter.\n     * The shape is returned as a <b>PShape</b> object, or <b>null</b> is returned if there is an error.\n     *\n     * @param {String} target   the name of the shape to get\n     * @param {int} index   the layer position of the shape to get\n     *\n     * @return {PShape} returns a child element of a shape as a PShape object or null if there is an error\n     */\n    getChild: function(child) {\n      var i, j;\n      if (typeof child === 'number') {\n        return this.children[child];\n      }\n      var found;\n      if(child === \"\" || this.name === child){\n        return this;\n      }\n      if(this.nameTable.length > 0) {\n        for(i = 0, j = this.nameTable.length; i < j || found; i++) {\n          if(this.nameTable[i].getName === child) {\n            found = this.nameTable[i];\n            break;\n          }\n        }\n        if (found) { return found; }\n      }\n      for(i = 0, j = this.children.length; i < j; i++) {\n        found = this.children[i].getChild(child);\n        if(found) { return found; }\n      }\n      return null;\n    },\n    /**\n     * @member PShape\n     * The getChildCount() returns the number of children\n     *\n     * @return {int} returns a count of children\n     */\n    getChildCount: function () {\n      return this.children.length;\n    },\n    /**\n     * @member PShape\n     * The addChild() adds a child to the PShape.\n     *\n     * @param {PShape} child the child to add\n     */\n    addChild: function( child ) {\n      this.children.push(child);\n      child.parent = this;\n      if (child.getName() !== null) {\n        this.addName(child.getName(), child);\n      }\n    },\n    /**\n     * @member PShape\n     * The addName() functions adds a shape to the name lookup table.\n     *\n     * @param {String} name   the name to be added\n     * @param {PShape} shape  the shape\n     */\n    addName: function(name,  shape) {\n      if (this.parent !== null) {\n        this.parent.addName( name, shape );\n      } else {\n        this.nameTable.push( [name, shape] );\n      }\n    },\n    /**\n     * @member PShape\n     * The translate() function specifies an amount to displace the shape. The <b>x</b> parameter specifies left/right translation, the <b>y</b> parameter specifies up/down translation, and the <b>z</b> parameter specifies translations toward/away from the screen.\n     * Subsequent calls to the method accumulates the effect. For example, calling <b>translate(50, 0)</b> and then <b>translate(20, 0)</b> is the same as <b>translate(70, 0)</b>.\n     * This transformation is applied directly to the shape, it's not refreshed each time <b>draw()</b> is run.\n     * <br><br>Using this method with the <b>z</b> parameter requires using the P3D or OPENGL parameter in combination with size.\n     *\n     * @param {int|float} x left/right translation\n     * @param {int|float} y up/down translation\n     * @param {int|float} z forward/back translation\n     *\n     * @see PMatrix2D#translate\n     * @see PMatrix3D#translate\n     */\n    translate: function() {\n      if(arguments.length === 2)\n      {\n        this.checkMatrix(2);\n        this.matrix.translate(arguments[0], arguments[1]);\n      } else {\n        this.checkMatrix(3);\n        this.matrix.translate(arguments[0], arguments[1], 0);\n      }\n    },\n    /**\n     * @member PShape\n     * The checkMatrix() function makes sure that the shape's matrix is 1) not null, and 2) has a matrix\n     * that can handle <em>at least</em> the specified number of dimensions.\n     *\n     * @param {int} dimensions the specified number of dimensions\n     */\n    checkMatrix: function(dimensions) {\n      if(this.matrix === null) {\n        if(dimensions === 2) {\n          this.matrix = new PMatrix2D();\n        } else {\n          this.matrix = new PMatrix3D();\n        }\n      }else if(dimensions === 3 && this.matrix instanceof PMatrix2D) {\n        this.matrix = new PMatrix3D();\n      }\n    },\n    /**\n     * @member PShape\n     * The rotateX() function rotates a shape around the x-axis the amount specified by the <b>angle</b> parameter. Angles should be specified in radians (values from 0 to TWO_PI) or converted to radians with the <b>radians()</b> method.\n     * <br><br>Shapes are always rotated around the upper-left corner of their bounding box. Positive numbers rotate objects in a clockwise direction.\n     * Subsequent calls to the method accumulates the effect. For example, calling <b>rotateX(HALF_PI)</b> and then <b>rotateX(HALF_PI)</b> is the same as <b>rotateX(PI)</b>.\n     * This transformation is applied directly to the shape, it's not refreshed each time <b>draw()</b> is run.\n     * <br><br>This method requires a 3D renderer. You need to pass P3D or OPENGL as a third parameter into the <b>size()</b> method as shown in the example above.\n     *\n     * @param {float}angle angle of rotation specified in radians\n     *\n     * @see PMatrix3D#rotateX\n     */\n    rotateX: function(angle) {\n      this.rotate(angle, 1, 0, 0);\n    },\n    /**\n     * @member PShape\n     * The rotateY() function rotates a shape around the y-axis the amount specified by the <b>angle</b> parameter. Angles should be specified in radians (values from 0 to TWO_PI) or converted to radians with the <b>radians()</b> method.\n     * <br><br>Shapes are always rotated around the upper-left corner of their bounding box. Positive numbers rotate objects in a clockwise direction.\n     * Subsequent calls to the method accumulates the effect. For example, calling <b>rotateY(HALF_PI)</b> and then <b>rotateY(HALF_PI)</b> is the same as <b>rotateY(PI)</b>.\n     * This transformation is applied directly to the shape, it's not refreshed each time <b>draw()</b> is run.\n     * <br><br>This method requires a 3D renderer. You need to pass P3D or OPENGL as a third parameter into the <b>size()</b> method as shown in the example above.\n     *\n     * @param {float}angle angle of rotation specified in radians\n     *\n     * @see PMatrix3D#rotateY\n     */\n    rotateY: function(angle) {\n      this.rotate(angle, 0, 1, 0);\n    },\n    /**\n     * @member PShape\n     * The rotateZ() function rotates a shape around the z-axis the amount specified by the <b>angle</b> parameter. Angles should be specified in radians (values from 0 to TWO_PI) or converted to radians with the <b>radians()</b> method.\n     * <br><br>Shapes are always rotated around the upper-left corner of their bounding box. Positive numbers rotate objects in a clockwise direction.\n     * Subsequent calls to the method accumulates the effect. For example, calling <b>rotateZ(HALF_PI)</b> and then <b>rotateZ(HALF_PI)</b> is the same as <b>rotateZ(PI)</b>.\n     * This transformation is applied directly to the shape, it's not refreshed each time <b>draw()</b> is run.\n     * <br><br>This method requires a 3D renderer. You need to pass P3D or OPENGL as a third parameter into the <b>size()</b> method as shown in the example above.\n     *\n     * @param {float}angle angle of rotation specified in radians\n     *\n     * @see PMatrix3D#rotateZ\n     */\n    rotateZ: function(angle) {\n      this.rotate(angle, 0, 0, 1);\n    },\n    /**\n     * @member PShape\n     * The rotate() function rotates a shape the amount specified by the <b>angle</b> parameter. Angles should be specified in radians (values from 0 to TWO_PI) or converted to radians with the <b>radians()</b> method.\n     * <br><br>Shapes are always rotated around the upper-left corner of their bounding box. Positive numbers rotate objects in a clockwise direction.\n     * Transformations apply to everything that happens after and subsequent calls to the method accumulates the effect.\n     * For example, calling <b>rotate(HALF_PI)</b> and then <b>rotate(HALF_PI)</b> is the same as <b>rotate(PI)</b>.\n     * This transformation is applied directly to the shape, it's not refreshed each time <b>draw()</b> is run.\n     * If optional parameters x,y,z are supplied, the rotate is about the point (x, y, z).\n     *\n     * @param {float}angle  angle of rotation specified in radians\n     * @param {float}x      x-coordinate of the point\n     * @param {float}y      y-coordinate of the point\n     * @param {float}z      z-coordinate of the point\n     * @see PMatrix2D#rotate\n     * @see PMatrix3D#rotate\n     */\n    rotate: function() {\n      if(arguments.length === 1){\n        this.checkMatrix(2);\n        this.matrix.rotate(arguments[0]);\n      } else {\n        this.checkMatrix(3);\n        this.matrix.rotate(arguments[0],\n                           arguments[1],\n                           arguments[2],\n                           arguments[3]);\n      }\n    },\n    /**\n     * @member PShape\n     * The scale() function increases or decreases the size of a shape by expanding and contracting vertices. Shapes always scale from the relative origin of their bounding box.\n     * Scale values are specified as decimal percentages. For example, the method call <b>scale(2.0)</b> increases the dimension of a shape by 200%.\n     * Subsequent calls to the method multiply the effect. For example, calling <b>scale(2.0)</b> and then <b>scale(1.5)</b> is the same as <b>scale(3.0)</b>.\n     * This transformation is applied directly to the shape, it's not refreshed each time <b>draw()</b> is run.\n     * <br><br>Using this fuction with the <b>z</b> parameter requires passing P3D or OPENGL into the size() parameter.\n     *\n     * @param {float}s      percentage to scale the object\n     * @param {float}x      percentage to scale the object in the x-axis\n     * @param {float}y      percentage to scale the object in the y-axis\n     * @param {float}z      percentage to scale the object in the z-axis\n     *\n     * @see PMatrix2D#scale\n     * @see PMatrix3D#scale\n     */\n    scale: function() {\n      if(arguments.length === 2) {\n        this.checkMatrix(2);\n        this.matrix.scale(arguments[0], arguments[1]);\n      } else if (arguments.length === 3) {\n        this.checkMatrix(2);\n        this.matrix.scale(arguments[0], arguments[1], arguments[2]);\n      } else {\n        this.checkMatrix(2);\n        this.matrix.scale(arguments[0]);\n      }\n    },\n    /**\n     * @member PShape\n     * The resetMatrix() function resets the matrix\n     *\n     * @see PMatrix2D#reset\n     * @see PMatrix3D#reset\n     */\n    resetMatrix: function() {\n      this.checkMatrix(2);\n      this.matrix.reset();\n    },\n    /**\n     * @member PShape\n     * The applyMatrix() function multiplies this matrix by another matrix of type PMatrix3D or PMatrix2D.\n     * Individual elements can also be provided\n     *\n     * @param {PMatrix3D|PMatrix2D} matrix   the matrix to multiply by\n     *\n     * @see PMatrix2D#apply\n     * @see PMatrix3D#apply\n     */\n    applyMatrix: function(matrix) {\n      if (arguments.length === 1) {\n        this.applyMatrix(matrix.elements[0],\n                         matrix.elements[1], 0,\n                         matrix.elements[2],\n                         matrix.elements[3],\n                         matrix.elements[4], 0,\n                         matrix.elements[5],\n                         0, 0, 1, 0,\n                         0, 0, 0, 1);\n      } else if (arguments.length === 6) {\n        this.checkMatrix(2);\n        this.matrix.apply(arguments[0], arguments[1], arguments[2], 0,\n                          arguments[3], arguments[4], arguments[5], 0,\n                          0,   0,   1,   0,\n                          0,   0,   0,   1);\n\n      } else if (arguments.length === 16) {\n        this.checkMatrix(3);\n        this.matrix.apply(arguments[0],\n                          arguments[1],\n                          arguments[2],\n                          arguments[3],\n                          arguments[4],\n                          arguments[5],\n                          arguments[6],\n                          arguments[7],\n                          arguments[8],\n                          arguments[9],\n                          arguments[10],\n                          arguments[11],\n                          arguments[12],\n                          arguments[13],\n                          arguments[14],\n                          arguments[15]);\n      }\n    }\n  };\n\n  return PShape;\n};\n},{}],16:[function(require,module,exports){\n/**\n * SVG stands for Scalable Vector Graphics, a portable graphics format. It is\n * a vector format so it allows for infinite resolution and relatively small\n * file sizes. Most modern media software can view SVG files, including Adobe\n * products, Firefox, etc. Illustrator and Inkscape can edit SVG files.\n *\n * @param {PApplet} parent     typically use \"this\"\n * @param {String} filename    name of the SVG file to load\n * @param {XMLElement} xml     an XMLElement element\n * @param {PShapeSVG} parent   the parent PShapeSVG\n *\n * @see PShape\n */\nmodule.exports = function(options) {\n  var CommonFunctions = options.CommonFunctions,\n      PConstants = options.PConstants,\n      PShape = options.PShape,\n      XMLElement = options.XMLElement,\n      colors = options.colors;\n\n  var PShapeSVG = function() {\n    PShape.call(this);                // PShape is the base class.\n    if (arguments.length === 1) {     // xml element coming in\n      this.element  = arguments[0];\n\n      // set values to their defaults according to the SVG spec\n      this.vertexCodes         = [];\n      this.vertices            = [];\n      this.opacity             = 1;\n\n      this.stroke              = false;\n      this.strokeColor         = PConstants.ALPHA_MASK;\n      this.strokeWeight        = 1;\n      this.strokeCap           = PConstants.SQUARE;  // BUTT in svg spec\n      this.strokeJoin          = PConstants.MITER;\n      this.strokeGradient      = null;\n      this.strokeGradientPaint = null;\n      this.strokeName          = null;\n      this.strokeOpacity       = 1;\n\n      this.fill                = true;\n      this.fillColor           = PConstants.ALPHA_MASK;\n      this.fillGradient        = null;\n      this.fillGradientPaint   = null;\n      this.fillName            = null;\n      this.fillOpacity         = 1;\n\n      if (this.element.getName() !== \"svg\") {\n        throw(\"root is not <svg>, it's <\" + this.element.getName() + \">\");\n      }\n    }\n    else if (arguments.length === 2) {\n      if (typeof arguments[1] === 'string') {\n        if (arguments[1].indexOf(\".svg\") > -1) { //its a filename\n          this.element = new XMLElement(true, arguments[1]);\n          // set values to their defaults according to the SVG spec\n          this.vertexCodes         = [];\n          this.vertices            = [];\n          this.opacity             = 1;\n\n          this.stroke              = false;\n          this.strokeColor         = PConstants.ALPHA_MASK;\n          this.strokeWeight        = 1;\n          this.strokeCap           = PConstants.SQUARE;  // BUTT in svg spec\n          this.strokeJoin          = PConstants.MITER;\n          this.strokeGradient      = \"\";\n          this.strokeGradientPaint = \"\";\n          this.strokeName          = \"\";\n          this.strokeOpacity       = 1;\n\n          this.fill                = true;\n          this.fillColor           = PConstants.ALPHA_MASK;\n          this.fillGradient        = null;\n          this.fillGradientPaint   = null;\n          this.fillOpacity         = 1;\n\n        }\n      } else { // XMLElement\n        if (arguments[0]) { // PShapeSVG\n          this.element             = arguments[1];\n          this.vertexCodes         = arguments[0].vertexCodes.slice();\n          this.vertices            = arguments[0].vertices.slice();\n\n          this.stroke              = arguments[0].stroke;\n          this.strokeColor         = arguments[0].strokeColor;\n          this.strokeWeight        = arguments[0].strokeWeight;\n          this.strokeCap           = arguments[0].strokeCap;\n          this.strokeJoin          = arguments[0].strokeJoin;\n          this.strokeGradient      = arguments[0].strokeGradient;\n          this.strokeGradientPaint = arguments[0].strokeGradientPaint;\n          this.strokeName          = arguments[0].strokeName;\n\n          this.fill                = arguments[0].fill;\n          this.fillColor           = arguments[0].fillColor;\n          this.fillGradient        = arguments[0].fillGradient;\n          this.fillGradientPaint   = arguments[0].fillGradientPaint;\n          this.fillName            = arguments[0].fillName;\n          this.strokeOpacity       = arguments[0].strokeOpacity;\n          this.fillOpacity         = arguments[0].fillOpacity;\n          this.opacity             = arguments[0].opacity;\n        }\n      }\n    }\n\n    this.name      = this.element.getStringAttribute(\"id\");\n    var displayStr = this.element.getStringAttribute(\"display\", \"inline\");\n    this.visible   = displayStr !== \"none\";\n    var str = this.element.getAttribute(\"transform\");\n    if (str) {\n      this.matrix = this.parseMatrix(str);\n    }\n    // not proper parsing of the viewBox, but will cover us for cases where\n    // the width and height of the object is not specified\n    var viewBoxStr = this.element.getStringAttribute(\"viewBox\");\n    if ( viewBoxStr !== null ) {\n      var viewBox = viewBoxStr.split(\" \");\n      this.width  = viewBox[2];\n      this.height = viewBox[3];\n    }\n\n    // TODO if viewbox is not same as width/height, then use it to scale\n    // the original objects. for now, viewbox only used when width/height\n    // are empty values (which by the spec means w/h of \"100%\"\n    var unitWidth  = this.element.getStringAttribute(\"width\");\n    var unitHeight = this.element.getStringAttribute(\"height\");\n    if (unitWidth !== null) {\n      this.width  = this.parseUnitSize(unitWidth);\n      this.height = this.parseUnitSize(unitHeight);\n    } else {\n      if ((this.width === 0) || (this.height === 0)) {\n        // For the spec, the default is 100% and 100%. For purposes\n        // here, insert a dummy value because this is prolly just a\n        // font or something for which the w/h doesn't matter.\n        this.width  = 1;\n        this.height = 1;\n\n        //show warning\n        throw(\"The width and/or height is not \" +\n              \"readable in the <svg> tag of this file.\");\n      }\n    }\n    this.parseColors(this.element);\n    this.parseChildren(this.element);\n\n  };\n  /**\n   * PShapeSVG methods are inherited from the PShape prototype\n   */\n  PShapeSVG.prototype = new PShape();\n  /**\n   * @member PShapeSVG\n   * The parseMatrix() function parses the specified SVG matrix into a PMatrix2D. Note that PMatrix2D\n   * is rotated relative to the SVG definition, so parameters are rearranged\n   * here. More about the transformation matrices in\n   * <a href=\"http://www.w3.org/TR/SVG/coords.html#TransformAttribute\">this section</a>\n   * of the SVG documentation.\n   *\n   * @param {String} str text of the matrix param.\n   *\n   * @return {PMatrix2D} a PMatrix2D\n   */\n  PShapeSVG.prototype.parseMatrix = (function() {\n    function getCoords(s) {\n      var m = [];\n      s.replace(/\\((.*?)\\)/, (function() {\n        return function(all, params) {\n          // get the coordinates that can be separated by spaces or a comma\n          m = params.replace(/,+/g, \" \").split(/\\s+/);\n        };\n      }()));\n      return m;\n    }\n\n    return function(str) {\n      this.checkMatrix(2);\n      var pieces = [];\n      str.replace(/\\s*(\\w+)\\((.*?)\\)/g, function(all) {\n        // get a list of transform definitions\n        pieces.push(CommonFunctions.trim(all));\n      });\n      if (pieces.length === 0) {\n        return null;\n      }\n\n      for (var i = 0, j = pieces.length; i < j; i++) {\n        var m = getCoords(pieces[i]);\n\n        if (pieces[i].indexOf(\"matrix\") !== -1) {\n          this.matrix.set(m[0], m[2], m[4], m[1], m[3], m[5]);\n        } else if (pieces[i].indexOf(\"translate\") !== -1) {\n          var tx = m[0];\n          var ty = (m.length === 2) ? m[1] : 0;\n          this.matrix.translate(tx,ty);\n        } else if (pieces[i].indexOf(\"scale\") !== -1) {\n          var sx = m[0];\n          var sy = (m.length === 2) ? m[1] : m[0];\n          this.matrix.scale(sx,sy);\n        } else if (pieces[i].indexOf(\"rotate\") !== -1) {\n          var angle = m[0];\n          if (m.length === 1) {\n            this.matrix.rotate(CommonFunctions.radians(angle));\n          } else if (m.length === 3) {\n            this.matrix.translate(m[1], m[2]);\n            this.matrix.rotate(CommonFunctions.radians(m[0]));\n            this.matrix.translate(-m[1], -m[2]);\n          }\n        } else if (pieces[i].indexOf(\"skewX\") !== -1) {\n          this.matrix.skewX(parseFloat(m[0]));\n        } else if (pieces[i].indexOf(\"skewY\") !== -1) {\n          this.matrix.skewY(m[0]);\n        } else if (pieces[i].indexOf(\"shearX\") !== -1) {\n          this.matrix.shearX(m[0]);\n        } else if (pieces[i].indexOf(\"shearY\") !== -1) {\n          this.matrix.shearY(m[0]);\n        }\n      }\n      return this.matrix;\n    };\n  }());\n\n  /**\n   * @member PShapeSVG\n   * The parseChildren() function parses the specified XMLElement\n   *\n   * @param {XMLElement}element the XMLElement to parse\n   */\n  PShapeSVG.prototype.parseChildren = function(element) {\n    var newelement = element.getChildren();\n    var base = new PShape();\n    var i, j;\n    for (i = 0, j = newelement.length; i < j; i++) {\n      var kid = this.parseChild(newelement[i]);\n      if (kid) {\n        base.addChild(kid);\n      }\n    }\n    for (i = 0, j = base.children.length; i < j; i++) {\n      this.children.push(base.children[i]);\n    }\n  };\n  /**\n   * @member PShapeSVG\n   * The getName() function returns the name\n   *\n   * @return {String} the name\n   */\n  PShapeSVG.prototype.getName = function() {\n    return this.name;\n  };\n  /**\n   * @member PShapeSVG\n   * The parseChild() function parses a child XML element.\n   *\n   * @param {XMLElement} elem the element to parse\n   *\n   * @return {PShape} the newly created PShape\n   */\n  PShapeSVG.prototype.parseChild = function( elem ) {\n    var name = elem.getName();\n    var shape;\n    if (name === \"g\") {\n      shape = new PShapeSVG(this, elem);\n    } else if (name === \"defs\") {\n      // generally this will contain gradient info, so may\n      // as well just throw it into a group element for parsing\n      shape = new PShapeSVG(this, elem);\n    } else if (name === \"line\") {\n      shape = new PShapeSVG(this, elem);\n      shape.parseLine();\n    } else if (name === \"circle\") {\n      shape = new PShapeSVG(this, elem);\n      shape.parseEllipse(true);\n    } else if (name === \"ellipse\") {\n      shape = new PShapeSVG(this, elem);\n      shape.parseEllipse(false);\n    } else if (name === \"rect\") {\n      shape = new PShapeSVG(this, elem);\n      shape.parseRect();\n    } else if (name === \"polygon\") {\n      shape = new PShapeSVG(this, elem);\n      shape.parsePoly(true);\n    } else if (name === \"polyline\") {\n      shape = new PShapeSVG(this, elem);\n      shape.parsePoly(false);\n    } else if (name === \"path\") {\n      shape = new PShapeSVG(this, elem);\n      shape.parsePath();\n    } else if (name === \"radialGradient\") {\n      //return new RadialGradient(this, elem);\n      unimplemented('PShapeSVG.prototype.parseChild, name = radialGradient');\n    } else if (name === \"linearGradient\") {\n      //return new LinearGradient(this, elem);\n      unimplemented('PShapeSVG.prototype.parseChild, name = linearGradient');\n    } else if (name === \"text\") {\n      unimplemented('PShapeSVG.prototype.parseChild, name = text');\n    } else if (name === \"filter\") {\n      unimplemented('PShapeSVG.prototype.parseChild, name = filter');\n    } else if (name === \"mask\") {\n      unimplemented('PShapeSVG.prototype.parseChild, name = mask');\n    } else {\n      // ignoring\n    }\n    return shape;\n  };\n  /**\n   * @member PShapeSVG\n   * The parsePath() function parses the <path> element of the svg file\n   * A path is defined by including a path element which contains a d=\"(path data)\" attribute, where the d attribute contains\n   * the moveto, line, curve (both cubic and quadratic Beziers), arc and closepath instructions.\n   **/\n  PShapeSVG.prototype.parsePath = function() {\n    this.family = PConstants.PATH;\n    this.kind = 0;\n    var pathDataChars = [];\n    var c;\n    //change multiple spaces and commas to single space\n    var pathData = CommonFunctions.trim(this.element.getStringAttribute(\"d\").replace(/[\\s,]+/g,' '));\n    if (pathData === null) {\n      return;\n    }\n    pathData = pathData.split('');\n    var cx     = 0,\n        cy     = 0,\n        ctrlX  = 0,\n        ctrlY  = 0,\n        ctrlX1 = 0,\n        ctrlX2 = 0,\n        ctrlY1 = 0,\n        ctrlY2 = 0,\n        endX   = 0,\n        endY   = 0,\n        ppx    = 0,\n        ppy    = 0,\n        px     = 0,\n        py     = 0,\n        i      = 0,\n        valOf  = 0;\n    var str = \"\";\n    var tmpArray = [];\n    var flag = false;\n    var lastInstruction;\n    var command;\n    var j, k;\n    while (i< pathData.length) {\n      valOf = pathData[i].charCodeAt(0);\n      if ((valOf >= 65 && valOf <= 90) || (valOf >= 97 && valOf <= 122)) {\n        // if it's a letter\n        // populate the tmpArray with coordinates\n        j = i;\n        i++;\n        if (i < pathData.length) { // don't go over boundary of array\n          tmpArray = [];\n          valOf = pathData[i].charCodeAt(0);\n          while (!((valOf >= 65 && valOf <= 90) ||\n                   (valOf >= 97 && valOf <= 100) ||\n                   (valOf >= 102 && valOf <= 122)) && flag === false) { // if its NOT a letter\n            if (valOf === 32) { //if its a space and the str isn't empty\n              // sometimes you get a space after the letter\n              if (str !== \"\") {\n                tmpArray.push(parseFloat(str));\n                str = \"\";\n              }\n              i++;\n            } else if (valOf === 45) { //if it's a -\n              // allow for 'e' notation in numbers, e.g. 2.10e-9\n              if (pathData[i-1].charCodeAt(0) === 101) {\n                str += pathData[i].toString();\n                i++;\n              } else {\n                // sometimes no space separator after (ex: 104.535-16.322)\n                if (str !== \"\") {\n                  tmpArray.push(parseFloat(str));\n                }\n                str = pathData[i].toString();\n                i++;\n              }\n            } else {\n              str += pathData[i].toString();\n              i++;\n            }\n            if (i === pathData.length) { // don't go over boundary of array\n              flag = true;\n            } else {\n              valOf = pathData[i].charCodeAt(0);\n            }\n          }\n        }\n        if (str !== \"\") {\n          tmpArray.push(parseFloat(str));\n          str = \"\";\n        }\n        command = pathData[j];\n        valOf = command.charCodeAt(0);\n        if (valOf === 77) {  // M - move to (absolute)\n          if (tmpArray.length >= 2 && tmpArray.length % 2 === 0) {\n            // need one+ pairs of co-ordinates\n            cx = tmpArray[0];\n            cy = tmpArray[1];\n            this.parsePathMoveto(cx, cy);\n            if (tmpArray.length > 2) {\n              for (j = 2, k = tmpArray.length; j < k; j+=2) {\n                // absolute line to\n                cx = tmpArray[j];\n                cy = tmpArray[j+1];\n                this.parsePathLineto(cx,cy);\n              }\n            }\n          }\n        } else if (valOf === 109) {  // m - move to (relative)\n          if (tmpArray.length >= 2 && tmpArray.length % 2 === 0) {\n            // need one+ pairs of co-ordinates\n            cx += tmpArray[0];\n            cy += tmpArray[1];\n            this.parsePathMoveto(cx,cy);\n            if (tmpArray.length > 2) {\n              for (j = 2, k = tmpArray.length; j < k; j+=2) {\n                // relative line to\n                cx += tmpArray[j];\n                cy += tmpArray[j + 1];\n                this.parsePathLineto(cx,cy);\n              }\n            }\n          }\n        } else if (valOf === 76) { // L - lineto (absolute)\n          if (tmpArray.length >= 2 && tmpArray.length % 2 === 0) {\n            // need one+ pairs of co-ordinates\n            for (j = 0, k = tmpArray.length; j < k; j+=2) {\n              cx = tmpArray[j];\n              cy = tmpArray[j + 1];\n              this.parsePathLineto(cx,cy);\n            }\n          }\n        } else if (valOf === 108) { // l - lineto (relative)\n          if (tmpArray.length >= 2 && tmpArray.length % 2 === 0) {\n            // need one+ pairs of co-ordinates\n            for (j = 0, k = tmpArray.length; j < k; j+=2) {\n              cx += tmpArray[j];\n              cy += tmpArray[j+1];\n              this.parsePathLineto(cx,cy);\n            }\n          }\n        } else if (valOf === 72) { // H - horizontal lineto (absolute)\n          for (j = 0, k = tmpArray.length; j < k; j++) {\n            // multiple x co-ordinates can be provided\n            cx = tmpArray[j];\n            this.parsePathLineto(cx, cy);\n          }\n        } else if (valOf === 104) { // h - horizontal lineto (relative)\n          for (j = 0, k = tmpArray.length; j < k; j++) {\n            // multiple x co-ordinates can be provided\n            cx += tmpArray[j];\n            this.parsePathLineto(cx, cy);\n          }\n        } else if (valOf === 86) { // V - vertical lineto (absolute)\n          for (j = 0, k = tmpArray.length; j < k; j++) {\n            // multiple y co-ordinates can be provided\n            cy = tmpArray[j];\n            this.parsePathLineto(cx, cy);\n          }\n        } else if (valOf === 118) { // v - vertical lineto (relative)\n          for (j = 0, k = tmpArray.length; j < k; j++) {\n            // multiple y co-ordinates can be provided\n            cy += tmpArray[j];\n            this.parsePathLineto(cx, cy);\n          }\n        } else if (valOf === 67) { // C - curve to (absolute)\n          if (tmpArray.length >= 6 && tmpArray.length % 6 === 0) {\n            // need one+ multiples of 6 co-ordinates\n            for (j = 0, k = tmpArray.length; j < k; j+=6) {\n              ctrlX1 = tmpArray[j];\n              ctrlY1 = tmpArray[j + 1];\n              ctrlX2 = tmpArray[j + 2];\n              ctrlY2 = tmpArray[j + 3];\n              endX   = tmpArray[j + 4];\n              endY   = tmpArray[j + 5];\n              this.parsePathCurveto(ctrlX1,\n                                    ctrlY1,\n                                    ctrlX2,\n                                    ctrlY2,\n                                    endX,\n                                    endY);\n              cx = endX;\n              cy = endY;\n            }\n          }\n        } else if (valOf === 99) { // c - curve to (relative)\n          if (tmpArray.length >= 6 && tmpArray.length % 6 === 0) {\n            // need one+ multiples of 6 co-ordinates\n            for (j = 0, k = tmpArray.length; j < k; j+=6) {\n              ctrlX1 = cx + tmpArray[j];\n              ctrlY1 = cy + tmpArray[j + 1];\n              ctrlX2 = cx + tmpArray[j + 2];\n              ctrlY2 = cy + tmpArray[j + 3];\n              endX   = cx + tmpArray[j + 4];\n              endY   = cy + tmpArray[j + 5];\n              this.parsePathCurveto(ctrlX1,\n                                    ctrlY1,\n                                    ctrlX2,\n                                    ctrlY2,\n                                    endX,\n                                    endY);\n              cx = endX;\n              cy = endY;\n            }\n          }\n        } else if (valOf === 83) { // S - curve to shorthand (absolute)\n          if (tmpArray.length >= 4 && tmpArray.length % 4 === 0) {\n            // need one+ multiples of 4 co-ordinates\n            for (j = 0, k = tmpArray.length; j < k; j+=4) {\n              if (lastInstruction.toLowerCase() ===  \"c\" ||\n                  lastInstruction.toLowerCase() ===  \"s\") {\n                ppx    = this.vertices[ this.vertices.length-2 ][0];\n                ppy    = this.vertices[ this.vertices.length-2 ][1];\n                px     = this.vertices[ this.vertices.length-1 ][0];\n                py     = this.vertices[ this.vertices.length-1 ][1];\n                ctrlX1 = px + (px - ppx);\n                ctrlY1 = py + (py - ppy);\n              } else {\n                //If there is no previous curve,\n                //the current point will be used as the first control point.\n                ctrlX1 = this.vertices[this.vertices.length-1][0];\n                ctrlY1 = this.vertices[this.vertices.length-1][1];\n              }\n              ctrlX2 = tmpArray[j];\n              ctrlY2 = tmpArray[j + 1];\n              endX   = tmpArray[j + 2];\n              endY   = tmpArray[j + 3];\n              this.parsePathCurveto(ctrlX1,\n                                    ctrlY1,\n                                    ctrlX2,\n                                    ctrlY2,\n                                    endX,\n                                    endY);\n              cx = endX;\n              cy = endY;\n            }\n          }\n        } else if (valOf === 115) { // s - curve to shorthand (relative)\n          if (tmpArray.length >= 4 && tmpArray.length % 4 === 0) {\n            // need one+ multiples of 4 co-ordinates\n            for (j = 0, k = tmpArray.length; j < k; j+=4) {\n              if (lastInstruction.toLowerCase() ===  \"c\" ||\n                  lastInstruction.toLowerCase() ===  \"s\") {\n                ppx    = this.vertices[this.vertices.length-2][0];\n                ppy    = this.vertices[this.vertices.length-2][1];\n                px     = this.vertices[this.vertices.length-1][0];\n                py     = this.vertices[this.vertices.length-1][1];\n                ctrlX1 = px + (px - ppx);\n                ctrlY1 = py + (py - ppy);\n              } else {\n                //If there is no previous curve,\n                //the current point will be used as the first control point.\n                ctrlX1 = this.vertices[this.vertices.length-1][0];\n                ctrlY1 = this.vertices[this.vertices.length-1][1];\n              }\n              ctrlX2 = cx + tmpArray[j];\n              ctrlY2 = cy + tmpArray[j + 1];\n              endX   = cx + tmpArray[j + 2];\n              endY   = cy + tmpArray[j + 3];\n              this.parsePathCurveto(ctrlX1,\n                                    ctrlY1,\n                                    ctrlX2,\n                                    ctrlY2,\n                                    endX,\n                                    endY);\n              cx = endX;\n              cy = endY;\n            }\n          }\n        } else if (valOf === 81) { // Q - quadratic curve to (absolute)\n          if (tmpArray.length >= 4 && tmpArray.length % 4 === 0) {\n            // need one+ multiples of 4 co-ordinates\n            for (j = 0, k = tmpArray.length; j < k; j+=4) {\n              ctrlX = tmpArray[j];\n              ctrlY = tmpArray[j + 1];\n              endX  = tmpArray[j + 2];\n              endY  = tmpArray[j + 3];\n              this.parsePathQuadto(cx, cy, ctrlX, ctrlY, endX, endY);\n              cx = endX;\n              cy = endY;\n            }\n          }\n        } else if (valOf === 113) { // q - quadratic curve to (relative)\n          if (tmpArray.length >= 4 && tmpArray.length % 4 === 0) {\n            // need one+ multiples of 4 co-ordinates\n            for (j = 0, k = tmpArray.length; j < k; j+=4) {\n              ctrlX = cx + tmpArray[j];\n              ctrlY = cy + tmpArray[j + 1];\n              endX  = cx + tmpArray[j + 2];\n              endY  = cy + tmpArray[j + 3];\n              this.parsePathQuadto(cx, cy, ctrlX, ctrlY, endX, endY);\n              cx = endX;\n              cy = endY;\n            }\n          }\n        } else if (valOf === 84) {\n          // T - quadratic curve to shorthand (absolute)\n          if (tmpArray.length >= 2 && tmpArray.length % 2 === 0) {\n            // need one+ pairs of co-ordinates\n            for (j = 0, k = tmpArray.length; j < k; j+=2) {\n              if (lastInstruction.toLowerCase() ===  \"q\" ||\n                  lastInstruction.toLowerCase() ===  \"t\") {\n                ppx   = this.vertices[this.vertices.length-2][0];\n                ppy   = this.vertices[this.vertices.length-2][1];\n                px    = this.vertices[this.vertices.length-1][0];\n                py    = this.vertices[this.vertices.length-1][1];\n                ctrlX = px + (px - ppx);\n                ctrlY = py + (py - ppy);\n              } else {\n                // If there is no previous command or if the previous command\n                // was not a Q, q, T or t, assume the control point is\n                // coincident with the current point.\n                ctrlX = cx;\n                ctrlY = cy;\n              }\n              endX  = tmpArray[j];\n              endY  = tmpArray[j + 1];\n              this.parsePathQuadto(cx, cy, ctrlX, ctrlY, endX, endY);\n              cx = endX;\n              cy = endY;\n            }\n          }\n        } else if (valOf === 116) {\n          // t - quadratic curve to shorthand (relative)\n          if (tmpArray.length >= 2 && tmpArray.length % 2 === 0) {\n            // need one+ pairs of co-ordinates\n            for (j = 0, k = tmpArray.length; j < k; j+=2) {\n              if (lastInstruction.toLowerCase() ===  \"q\" ||\n                  lastInstruction.toLowerCase() ===  \"t\") {\n                ppx   = this.vertices[this.vertices.length-2][0];\n                ppy   = this.vertices[this.vertices.length-2][1];\n                px    = this.vertices[this.vertices.length-1][0];\n                py    = this.vertices[this.vertices.length-1][1];\n                ctrlX = px + (px - ppx);\n                ctrlY = py + (py - ppy);\n              } else {\n                // If there is no previous command or if the previous command\n                // was not a Q, q, T or t, assume the control point is\n                // coincident with the current point.\n                ctrlX = cx;\n                ctrlY = cy;\n              }\n              endX  = cx + tmpArray[j];\n              endY  = cy + tmpArray[j + 1];\n              this.parsePathQuadto(cx, cy, ctrlX, ctrlY, endX, endY);\n              cx = endX;\n              cy = endY;\n            }\n          }\n        } else if (valOf === 90 || valOf === 122) { // Z or z (these do the same thing)\n          this.close = true;\n        }\n        lastInstruction = command.toString();\n      } else { i++;}\n    }\n  };\n  /**\n   * @member PShapeSVG\n   * PShapeSVG.parsePath() helper function\n   *\n   * @see PShapeSVG#parsePath\n   */\n  PShapeSVG.prototype.parsePathQuadto = function(x1, y1, cx, cy, x2, y2) {\n    if (this.vertices.length > 0) {\n      this.parsePathCode(PConstants.BEZIER_VERTEX);\n      // x1/y1 already covered by last moveto, lineto, or curveto\n      this.parsePathVertex(x1 + ((cx-x1)*2/3), y1 + ((cy-y1)*2/3));\n      this.parsePathVertex(x2 + ((cx-x2)*2/3), y2 + ((cy-y2)*2/3));\n      this.parsePathVertex(x2, y2);\n    } else {\n      throw (\"Path must start with M/m\");\n    }\n  };\n  /**\n   * @member PShapeSVG\n   * PShapeSVG.parsePath() helper function\n   *\n   * @see PShapeSVG#parsePath\n   */\n  PShapeSVG.prototype.parsePathCurveto = function(x1,  y1, x2, y2, x3, y3) {\n    if (this.vertices.length > 0) {\n      this.parsePathCode(PConstants.BEZIER_VERTEX );\n      this.parsePathVertex(x1, y1);\n      this.parsePathVertex(x2, y2);\n      this.parsePathVertex(x3, y3);\n    } else {\n      throw (\"Path must start with M/m\");\n    }\n  };\n  /**\n   * @member PShapeSVG\n   * PShapeSVG.parsePath() helper function\n   *\n   * @see PShapeSVG#parsePath\n   */\n  PShapeSVG.prototype.parsePathLineto = function(px, py) {\n    if (this.vertices.length > 0) {\n      this.parsePathCode(PConstants.VERTEX);\n      this.parsePathVertex(px, py);\n      // add property to distinguish between curContext.moveTo\n      // or curContext.lineTo\n      this.vertices[this.vertices.length-1].moveTo = false;\n    } else {\n      throw (\"Path must start with M/m\");\n    }\n  };\n\n  PShapeSVG.prototype.parsePathMoveto = function(px, py) {\n    if (this.vertices.length > 0) {\n      this.parsePathCode(PConstants.BREAK);\n    }\n    this.parsePathCode(PConstants.VERTEX);\n    this.parsePathVertex(px, py);\n    // add property to distinguish between curContext.moveTo\n    // or curContext.lineTo\n    this.vertices[this.vertices.length-1].moveTo = true;\n  };\n  /**\n   * @member PShapeSVG\n   * PShapeSVG.parsePath() helper function\n   *\n   * @see PShapeSVG#parsePath\n   */\n  PShapeSVG.prototype.parsePathVertex = function(x,  y) {\n    var verts = [];\n    verts[0]  = x;\n    verts[1]  = y;\n    this.vertices.push(verts);\n  };\n  /**\n   * @member PShapeSVG\n   * PShapeSVG.parsePath() helper function\n   *\n   * @see PShapeSVG#parsePath\n   */\n  PShapeSVG.prototype.parsePathCode = function(what) {\n    this.vertexCodes.push(what);\n  };\n  /**\n   * @member PShapeSVG\n   * The parsePoly() function parses a polyline or polygon from an SVG file.\n   *\n   * @param {boolean}val true if shape is closed (polygon), false if not (polyline)\n   */\n  PShapeSVG.prototype.parsePoly = function(val) {\n    this.family    = PConstants.PATH;\n    this.close     = val;\n    var pointsAttr = CommonFunctions.trim(this.element.getStringAttribute(\"points\").replace(/[,\\s]+/g,' '));\n    if (pointsAttr !== null) {\n      //split into array\n      var pointsBuffer = pointsAttr.split(\" \");\n      if (pointsBuffer.length % 2 === 0) {\n        for (var i = 0, j = pointsBuffer.length; i < j; i++) {\n          var verts = [];\n          verts[0]  = pointsBuffer[i];\n          verts[1]  = pointsBuffer[++i];\n          this.vertices.push(verts);\n        }\n      } else {\n        throw(\"Error parsing polygon points: odd number of coordinates provided\");\n      }\n    }\n  };\n  /**\n   * @member PShapeSVG\n   * The parseRect() function parses a rect from an SVG file.\n   */\n  PShapeSVG.prototype.parseRect = function() {\n    this.kind      = PConstants.RECT;\n    this.family    = PConstants.PRIMITIVE;\n    this.params    = [];\n    this.params[0] = this.element.getFloatAttribute(\"x\");\n    this.params[1] = this.element.getFloatAttribute(\"y\");\n    this.params[2] = this.element.getFloatAttribute(\"width\");\n    this.params[3] = this.element.getFloatAttribute(\"height\");\n    if (this.params[2] < 0 || this.params[3] < 0) {\n      throw(\"svg error: negative width or height found while parsing <rect>\");\n    }\n  };\n  /**\n   * @member PShapeSVG\n   * The parseEllipse() function handles parsing ellipse and circle tags.\n   *\n   * @param {boolean}val true if this is a circle and not an ellipse\n   */\n  PShapeSVG.prototype.parseEllipse = function(val) {\n    this.kind   = PConstants.ELLIPSE;\n    this.family = PConstants.PRIMITIVE;\n    this.params = [];\n\n    this.params[0] = this.element.getFloatAttribute(\"cx\") | 0 ;\n    this.params[1] = this.element.getFloatAttribute(\"cy\") | 0;\n\n    var rx, ry;\n    if (val) {\n      rx = ry = this.element.getFloatAttribute(\"r\");\n      if (rx < 0) {\n        throw(\"svg error: negative radius found while parsing <circle>\");\n      }\n    } else {\n      rx = this.element.getFloatAttribute(\"rx\");\n      ry = this.element.getFloatAttribute(\"ry\");\n      if (rx < 0 || ry < 0) {\n        throw(\"svg error: negative x-axis radius or y-axis radius found while parsing <ellipse>\");\n      }\n    }\n    this.params[0] -= rx;\n    this.params[1] -= ry;\n\n    this.params[2] = rx*2;\n    this.params[3] = ry*2;\n  };\n  /**\n   * @member PShapeSVG\n   * The parseLine() function handles parsing line tags.\n   *\n   * @param {boolean}val true if this is a circle and not an ellipse\n   */\n  PShapeSVG.prototype.parseLine = function() {\n    this.kind = PConstants.LINE;\n    this.family = PConstants.PRIMITIVE;\n    this.params = [];\n    this.params[0] = this.element.getFloatAttribute(\"x1\");\n    this.params[1] = this.element.getFloatAttribute(\"y1\");\n    this.params[2] = this.element.getFloatAttribute(\"x2\");\n    this.params[3] = this.element.getFloatAttribute(\"y2\");\n  };\n  /**\n   * @member PShapeSVG\n   * The parseColors() function handles parsing the opacity, strijem stroke-width, stroke-linejoin,stroke-linecap, fill, and style attributes\n   *\n   * @param {XMLElement}element the element of which attributes to parse\n   */\n  PShapeSVG.prototype.parseColors = function(element) {\n    if (element.hasAttribute(\"opacity\")) {\n      this.setOpacity(element.getAttribute(\"opacity\"));\n    }\n    if (element.hasAttribute(\"stroke\")) {\n      this.setStroke(element.getAttribute(\"stroke\"));\n    }\n    if (element.hasAttribute(\"stroke-width\")) {\n      // if NaN (i.e. if it's 'inherit') then default\n      // back to the inherit setting\n      this.setStrokeWeight(element.getAttribute(\"stroke-width\"));\n    }\n    if (element.hasAttribute(\"stroke-linejoin\") ) {\n      this.setStrokeJoin(element.getAttribute(\"stroke-linejoin\"));\n    }\n    if (element.hasAttribute(\"stroke-linecap\")) {\n      this.setStrokeCap(element.getStringAttribute(\"stroke-linecap\"));\n    }\n    // fill defaults to black (though stroke defaults to \"none\")\n    // http://www.w3.org/TR/SVG/painting.html#FillProperties\n    if (element.hasAttribute(\"fill\")) {\n      this.setFill(element.getStringAttribute(\"fill\"));\n    }\n    if (element.hasAttribute(\"style\")) {\n      var styleText   = element.getStringAttribute(\"style\");\n      var styleTokens = styleText.toString().split( \";\" );\n\n      for (var i = 0, j = styleTokens.length; i < j; i++) {\n        var tokens = CommonFunctions.trim(styleTokens[i].split( \":\" ));\n        if (tokens[0] === \"fill\") {\n            this.setFill(tokens[1]);\n        } else if (tokens[0] === \"fill-opacity\") {\n            this.setFillOpacity(tokens[1]);\n        } else if (tokens[0] === \"stroke\") {\n            this.setStroke(tokens[1]);\n        } else if (tokens[0] === \"stroke-width\") {\n            this.setStrokeWeight(tokens[1]);\n        } else if (tokens[0] === \"stroke-linecap\") {\n            this.setStrokeCap(tokens[1]);\n        } else if (tokens[0] === \"stroke-linejoin\") {\n            this.setStrokeJoin(tokens[1]);\n        } else if (tokens[0] === \"stroke-opacity\") {\n            this.setStrokeOpacity(tokens[1]);\n        } else if (tokens[0] === \"opacity\") {\n            this.setOpacity(tokens[1]);\n        } // Other attributes are not yet implemented\n      }\n    }\n  };\n  /**\n   * @member PShapeSVG\n   * PShapeSVG.parseColors() helper function\n   *\n   * @param {String} opacityText the value of fillOpacity\n   *\n   * @see PShapeSVG#parseColors\n   */\n  PShapeSVG.prototype.setFillOpacity = function(opacityText) {\n    this.fillOpacity = parseFloat(opacityText);\n    this.fillColor   = this.fillOpacity * 255  << 24 |\n                       this.fillColor & 0xFFFFFF;\n  };\n  /**\n   * @member PShapeSVG\n   * PShapeSVG.parseColors() helper function\n   *\n   * @param {String} fillText the value of fill\n   *\n   * @see PShapeSVG#parseColors\n   */\n  PShapeSVG.prototype.setFill = function (fillText) {\n    var opacityMask = this.fillColor & 0xFF000000;\n    if (fillText === \"none\") {\n      this.fill = false;\n    } else if (fillText.indexOf(\"#\") === 0) {\n      this.fill      = true;\n      if (fillText.length === 4) {\n        // convert #00F to #0000FF\n        fillText = fillText.replace(/#(.)(.)(.)/,\"#$1$1$2$2$3$3\");\n      }\n      this.fillColor = opacityMask |\n                       (parseInt(fillText.substring(1), 16 )) &\n                       0xFFFFFF;\n    } else if (fillText.indexOf(\"rgb\") === 0) {\n      this.fill      = true;\n      this.fillColor = opacityMask | this.parseRGB(fillText);\n    } else if (fillText.indexOf(\"url(#\") === 0) {\n      this.fillName = fillText.substring(5, fillText.length - 1 );\n    } else if (colors[fillText]) {\n      this.fill      = true;\n      this.fillColor = opacityMask |\n                       (parseInt(colors[fillText].substring(1), 16)) &\n                       0xFFFFFF;\n    }\n  };\n  /**\n   * @member PShapeSVG\n   * PShapeSVG.parseColors() helper function\n   *\n   * @param {String} opacity the value of opacity\n   *\n   * @see PShapeSVG#parseColors\n   */\n  PShapeSVG.prototype.setOpacity = function(opacity) {\n    this.strokeColor = parseFloat(opacity) * 255 << 24 |\n                       this.strokeColor & 0xFFFFFF;\n    this.fillColor   = parseFloat(opacity) * 255 << 24 |\n                       this.fillColor & 0xFFFFFF;\n  };\n  /**\n   * @member PShapeSVG\n   * PShapeSVG.parseColors() helper function\n   *\n   * @param {String} strokeText the value to set stroke to\n   *\n   * @see PShapeSVG#parseColors\n   */\n  PShapeSVG.prototype.setStroke = function(strokeText) {\n    var opacityMask = this.strokeColor & 0xFF000000;\n    if (strokeText === \"none\") {\n      this.stroke = false;\n    } else if (strokeText.charAt( 0 ) === \"#\") {\n      this.stroke      = true;\n      if (strokeText.length === 4) {\n        // convert #00F to #0000FF\n        strokeText = strokeText.replace(/#(.)(.)(.)/,\"#$1$1$2$2$3$3\");\n      }\n      this.strokeColor = opacityMask |\n                         (parseInt( strokeText.substring( 1 ), 16 )) &\n                         0xFFFFFF;\n    } else if (strokeText.indexOf( \"rgb\" ) === 0 ) {\n      this.stroke = true;\n      this.strokeColor = opacityMask | this.parseRGB(strokeText);\n    } else if (strokeText.indexOf( \"url(#\" ) === 0) {\n      this.strokeName = strokeText.substring(5, strokeText.length - 1);\n    } else if (colors[strokeText]) {\n      this.stroke      = true;\n      this.strokeColor = opacityMask |\n                         (parseInt(colors[strokeText].substring(1), 16)) &\n                         0xFFFFFF;\n    }\n  };\n  /**\n   * @member PShapeSVG\n   * PShapeSVG.parseColors() helper function\n   *\n   * @param {String} weight the value to set strokeWeight to\n   *\n   * @see PShapeSVG#parseColors\n   */\n  PShapeSVG.prototype.setStrokeWeight = function(weight) {\n    this.strokeWeight = this.parseUnitSize(weight);\n  };\n  /**\n   * @member PShapeSVG\n   * PShapeSVG.parseColors() helper function\n   *\n   * @param {String} linejoin the value to set strokeJoin to\n   *\n   * @see PShapeSVG#parseColors\n   */\n  PShapeSVG.prototype.setStrokeJoin = function(linejoin) {\n    if (linejoin === \"miter\") {\n      this.strokeJoin = PConstants.MITER;\n\n    } else if (linejoin === \"round\") {\n      this.strokeJoin = PConstants.ROUND;\n\n    } else if (linejoin === \"bevel\") {\n      this.strokeJoin = PConstants.BEVEL;\n    }\n  };\n  /**\n   * @member PShapeSVG\n   * PShapeSVG.parseColors() helper function\n   *\n   * @param {String} linecap the value to set strokeCap to\n   *\n   * @see PShapeSVG#parseColors\n   */\n  PShapeSVG.prototype.setStrokeCap = function (linecap) {\n    if (linecap === \"butt\") {\n      this.strokeCap = PConstants.SQUARE;\n\n    } else if (linecap === \"round\") {\n      this.strokeCap = PConstants.ROUND;\n\n    } else if (linecap === \"square\") {\n      this.strokeCap = PConstants.PROJECT;\n    }\n  };\n  /**\n   * @member PShapeSVG\n   * PShapeSVG.parseColors() helper function\n   *\n   * @param {String} opacityText the value to set stroke opacity to\n   *\n   * @see PShapeSVG#parseColors\n   */\n  PShapeSVG.prototype.setStrokeOpacity =  function (opacityText) {\n    this.strokeOpacity = parseFloat(opacityText);\n    this.strokeColor   = this.strokeOpacity * 255 << 24 |\n                         this.strokeColor &\n                         0xFFFFFF;\n  };\n  /**\n   * @member PShapeSVG\n   * The parseRGB() function parses an rbg() color string and returns a color int\n   *\n   * @param {String} color the color to parse in rbg() format\n   *\n   * @return {int} the equivalent color int\n   */\n  PShapeSVG.prototype.parseRGB = function(color) {\n    var sub    = color.substring(color.indexOf('(') + 1, color.indexOf(')'));\n    var values = sub.split(\", \");\n    return (values[0] << 16) | (values[1] << 8) | (values[2]);\n  };\n  /**\n   * @member PShapeSVG\n   * The parseUnitSize() function parse a size that may have a suffix for its units.\n   * Ignoring cases where this could also be a percentage.\n   * The <A HREF=\"http://www.w3.org/TR/SVG/coords.html#Units\">units</A> spec:\n   * <UL>\n   * <LI>\"1pt\" equals \"1.25px\" (and therefore 1.25 user units)\n   * <LI>\"1pc\" equals \"15px\" (and therefore 15 user units)\n   * <LI>\"1mm\" would be \"3.543307px\" (3.543307 user units)\n   * <LI>\"1cm\" equals \"35.43307px\" (and therefore 35.43307 user units)\n   * <LI>\"1in\" equals \"90px\" (and therefore 90 user units)\n   * </UL>\n   */\n  PShapeSVG.prototype.parseUnitSize = function (text) {\n    var len = text.length - 2;\n    if (len < 0) { return text; }\n    if (text.indexOf(\"pt\") === len) {\n      return parseFloat(text.substring(0, len)) * 1.25;\n    }\n    if (text.indexOf(\"pc\") === len) {\n      return parseFloat( text.substring( 0, len)) * 15;\n    }\n    if (text.indexOf(\"mm\") === len) {\n      return parseFloat( text.substring(0, len)) * 3.543307;\n    }\n    if (text.indexOf(\"cm\") === len) {\n      return parseFloat(text.substring(0, len)) * 35.43307;\n    }\n    if (text.indexOf(\"in\") === len) {\n      return parseFloat(text.substring(0, len)) * 90;\n    }\n    if (text.indexOf(\"px\") === len) {\n      return parseFloat(text.substring(0, len));\n    }\n    return parseFloat(text);\n  };\n\n  return PShapeSVG;\n};\n\n},{}],17:[function(require,module,exports){\nmodule.exports = function(options, undef) {\n  var PConstants = options.PConstants;\n\n  function PVector(x, y, z) {\n    this.x = x || 0;\n    this.y = y || 0;\n    this.z = z || 0;\n  }\n\n  PVector.fromAngle = function(angle, v) {\n    if (v === undef || v === null) {\n      v = new PVector();\n    }\n    v.x = Math.cos(angle);\n    v.y = Math.sin(angle);\n    return v;\n  };\n\n  PVector.random2D = function(v) {\n    return PVector.fromAngle(Math.random() * PConstants.TWO_PI, v);\n  };\n\n  PVector.random3D = function(v) {\n    var angle = Math.random() * PConstants.TWO_PI;\n    var vz = Math.random() * 2 - 1;\n    var mult = Math.sqrt(1 - vz * vz);\n    var vx = mult * Math.cos(angle);\n    var vy = mult * Math.sin(angle);\n    if (v === undef || v === null) {\n      v = new PVector(vx, vy, vz);\n    } else {\n      v.set(vx, vy, vz);\n    }\n    return v;\n  };\n\n  PVector.dist = function(v1, v2) {\n    return v1.dist(v2);\n  };\n\n  PVector.dot = function(v1, v2) {\n    return v1.dot(v2);\n  };\n\n  PVector.cross = function(v1, v2) {\n    return v1.cross(v2);\n  };\n\n  PVector.sub = function(v1, v2) {\n    return new PVector(v1.x - v2.x, v1.y - v2.y, v1.z - v2.z);\n  };\n\n  PVector.angleBetween = function(v1, v2) {\n    return Math.acos(v1.dot(v2) / Math.sqrt(v1.magSq() * v2.magSq()));\n  };\n\n  PVector.lerp = function(v1, v2, amt) {\n    // non-static lerp mutates object, but this version returns a new vector\n    var retval = new PVector(v1.x, v1.y, v1.z);\n    retval.lerp(v2, amt);\n    return retval;\n  };\n\n  // Common vector operations for PVector\n  PVector.prototype = {\n    set: function(v, y, z) {\n      if (arguments.length === 1) {\n        this.set(v.x || v[0] || 0,\n                 v.y || v[1] || 0,\n                 v.z || v[2] || 0);\n      } else {\n        this.x = v;\n        this.y = y;\n        this.z = z;\n      }\n    },\n    get: function() {\n      return new PVector(this.x, this.y, this.z);\n    },\n    mag: function() {\n      var x = this.x,\n          y = this.y,\n          z = this.z;\n      return Math.sqrt(x * x + y * y + z * z);\n    },\n    magSq: function() {\n      var x = this.x,\n          y = this.y,\n          z = this.z;\n      return (x * x + y * y + z * z);\n    },\n    setMag: function(v_or_len, len) {\n      if (len === undef) {\n        len = v_or_len;\n        this.normalize();\n        this.mult(len);\n      } else {\n        var v = v_or_len;\n        v.normalize();\n        v.mult(len);\n        return v;\n      }\n    },\n    add: function(v, y, z) {\n      if (arguments.length === 1) {\n        this.x += v.x;\n        this.y += v.y;\n        this.z += v.z;\n      } else if (arguments.length === 2) {\n        // 2D Vector\n        this.x += v;\n        this.y += y;\n      } else {\n        this.x += v;\n        this.y += y;\n        this.z += z;\n      }\n    },\n    sub: function(v, y, z) {\n      if (arguments.length === 1) {\n        this.x -= v.x;\n        this.y -= v.y;\n        this.z -= v.z;\n      } else if (arguments.length === 2) {\n        // 2D Vector\n        this.x -= v;\n        this.y -= y;\n      } else {\n        this.x -= v;\n        this.y -= y;\n        this.z -= z;\n      }\n    },\n    mult: function(v) {\n      if (typeof v === 'number') {\n        this.x *= v;\n        this.y *= v;\n        this.z *= v;\n      } else {\n        this.x *= v.x;\n        this.y *= v.y;\n        this.z *= v.z;\n      }\n    },\n    div: function(v) {\n      if (typeof v === 'number') {\n        this.x /= v;\n        this.y /= v;\n        this.z /= v;\n      } else {\n        this.x /= v.x;\n        this.y /= v.y;\n        this.z /= v.z;\n      }\n    },\n    rotate: function(angle) {\n      var prev_x = this.x;\n      var c = Math.cos(angle);\n      var s = Math.sin(angle);\n      this.x = c * this.x - s * this.y;\n      this.y = s * prev_x + c * this.y;\n    },\n    dist: function(v) {\n      var dx = this.x - v.x,\n          dy = this.y - v.y,\n          dz = this.z - v.z;\n      return Math.sqrt(dx * dx + dy * dy + dz * dz);\n    },\n    dot: function(v, y, z) {\n      if (arguments.length === 1) {\n        return (this.x * v.x + this.y * v.y + this.z * v.z);\n      }\n      return (this.x * v + this.y * y + this.z * z);\n    },\n    cross: function(v) {\n      var x = this.x,\n          y = this.y,\n          z = this.z;\n      return new PVector(y * v.z - v.y * z,\n                         z * v.x - v.z * x,\n                         x * v.y - v.x * y);\n    },\n    lerp: function(v_or_x, amt_or_y, z, amt) {\n      var lerp_val = function(start, stop, amt) {\n        return start + (stop - start) * amt;\n      };\n      var x, y;\n      if (arguments.length === 2) {\n        // given vector and amt\n        amt = amt_or_y;\n        x = v_or_x.x;\n        y = v_or_x.y;\n        z = v_or_x.z;\n      } else {\n        // given x, y, z and amt\n        x = v_or_x;\n        y = amt_or_y;\n      }\n      this.x = lerp_val(this.x, x, amt);\n      this.y = lerp_val(this.y, y, amt);\n      this.z = lerp_val(this.z, z, amt);\n    },\n    normalize: function() {\n      var m = this.mag();\n      if (m > 0) {\n        this.div(m);\n      }\n    },\n    limit: function(high) {\n      if (this.mag() > high) {\n        this.normalize();\n        this.mult(high);\n      }\n    },\n    heading: function() {\n      return (-Math.atan2(-this.y, this.x));\n    },\n    heading2D: function() {\n      return this.heading();\n    },\n    toString: function() {\n      return \"[\" + this.x + \", \" + this.y + \", \" + this.z + \"]\";\n    },\n    array: function() {\n      return [this.x, this.y, this.z];\n    }\n  };\n\n  function createPVectorMethod(method) {\n    return function(v1, v2) {\n      var v = v1.get();\n      v[method](v2);\n      return v;\n    };\n  }\n\n  for (var method in PVector.prototype) {\n    if (PVector.prototype.hasOwnProperty(method) && !PVector.hasOwnProperty(method)) {\n      PVector[method] = createPVectorMethod(method);\n    }\n  }\n\n  return PVector;\n};\n\n},{}],18:[function(require,module,exports){\n/**\n * XMLAttribute is an attribute of a XML element.\n *\n * @param {String} fname     the full name of the attribute\n * @param {String} n         the short name of the attribute\n * @param {String} namespace the namespace URI of the attribute\n * @param {String} v         the value of the attribute\n * @param {String }t         the type of the attribute\n *\n * @see XMLElement\n */\nmodule.exports = function() {\n\n  var XMLAttribute = function (fname, n, nameSpace, v, t){\n    this.fullName = fname || \"\";\n    this.name = n || \"\";\n    this.namespace = nameSpace || \"\";\n    this.value = v;\n    this.type = t;\n  };\n\n  XMLAttribute.prototype = {\n    /**\n     * @member XMLAttribute\n     * The getName() function returns the short name of the attribute\n     *\n     * @return {String} the short name of the attribute\n     */\n    getName: function() {\n      return this.name;\n    },\n    /**\n     * @member XMLAttribute\n     * The getFullName() function returns the full name of the attribute\n     *\n     * @return {String} the full name of the attribute\n     */\n    getFullName: function() {\n      return this.fullName;\n    },\n    /**\n     * @member XMLAttribute\n     * The getNamespace() function returns the namespace of the attribute\n     *\n     * @return {String} the namespace of the attribute\n     */\n    getNamespace: function() {\n      return this.namespace;\n    },\n    /**\n     * @member XMLAttribute\n     * The getValue() function returns the value of the attribute\n     *\n     * @return {String} the value of the attribute\n     */\n    getValue: function() {\n      return this.value;\n    },\n    /**\n     * @member XMLAttribute\n     * The getValue() function returns the type of the attribute\n     *\n     * @return {String} the type of the attribute\n     */\n    getType: function() {\n      return this.type;\n    },\n    /**\n     * @member XMLAttribute\n     * The setValue() function sets the value of the attribute\n     *\n     * @param {String} newval the new value\n     */\n    setValue: function(newval) {\n      this.value = newval;\n    }\n  };\n\n  return XMLAttribute;\n};\n\n},{}],19:[function(require,module,exports){\n/**\n * XMLElement is a representation of an XML object. The object is able to parse XML code\n *\n * @param {PApplet} parent   typically use \"this\"\n * @param {String} filename  name of the XML/SVG file to load\n * @param {String} xml       the xml/svg string\n * @param {String} fullname  the full name of the element\n * @param {String} namespace the namespace  of the URI\n * @param {String} systemID  the system ID of the XML data where the element starts\n * @param {Integer }lineNr   the line in the XML data where the element starts\n */\nmodule.exports = function(options, undef) {\n\n  var Browser = options.Browser,\n      ajax = Browser.ajax,\n      window = Browser.window,\n      XMLHttpRequest = window.XMLHttpRequest,\n      DOMParser = window.DOMParser,\n      XMLAttribute = options. XMLAttribute;\n\n  var XMLElement = function(selector, uri, sysid, line) {\n    this.attributes = [];\n    this.children   = [];\n    this.fullName   = null;\n    this.name       = null;\n    this.namespace  = \"\";\n    this.content = null;\n    this.parent    = null;\n    this.lineNr     = \"\";\n    this.systemID   = \"\";\n    this.type = \"ELEMENT\";\n\n    if (selector) {\n      if (typeof selector === \"string\") {\n        if (uri === undef && selector.indexOf(\"<\") > -1) {\n          // load XML from text string\n          this.parse(selector);\n        } else {\n          // XMLElement(fullname, namespace, sysid, line) format\n          this.fullName = selector;\n          this.namespace = uri;\n          this.systemId = sysid;\n          this.lineNr = line;\n        }\n      } else {\n        // XMLElement(this, file uri) format\n        this.parse(uri, true);\n      }\n    }\n  };\n  /**\n   * XMLElement methods\n   * missing: enumerateAttributeNames(), enumerateChildren(),\n   * NOTE: parse does not work when a url is passed in\n   */\n  XMLElement.prototype = {\n    /**\n     * @member XMLElement\n     * The parse() function retrieves the file via ajax() and uses DOMParser()\n     * parseFromString method to make an XML document\n     * @addon\n     *\n     * @param {String} filename name of the XML/SVG file to load\n     *\n     * @throws ExceptionType Error loading document\n     *\n     * @see XMLElement#parseChildrenRecursive\n     */\n    parse: function(textstring, stringIsURI) {\n      var xmlDoc;\n      try {\n        if (stringIsURI) {\n          textstring = ajax(textstring);\n        }\n        xmlDoc = new DOMParser().parseFromString(textstring, \"text/xml\");\n        var elements = xmlDoc.documentElement;\n        if (elements) {\n          this.parseChildrenRecursive(null, elements);\n        } else {\n          throw (\"Error loading document\");\n        }\n        return this;\n      } catch(e) {\n        throw(e);\n      }\n    },\n    /**\n     * @member XMLElement\n     * Internal helper function for parse().\n     * Loops through the\n     * @addon\n     *\n     * @param {XMLElement} parent                      the parent node\n     * @param {XML document childNodes} elementpath    the remaining nodes that need parsing\n     *\n     * @return {XMLElement} the new element and its children elements\n     */\n    parseChildrenRecursive: function (parent, elementpath){\n      var xmlelement,\n        xmlattribute,\n        tmpattrib,\n        l, m,\n        child;\n      if (!parent) { // this element is the root element\n        this.fullName = elementpath.localName;\n        this.name     = elementpath.nodeName;\n        xmlelement    = this;\n      } else { // this element has a parent\n        xmlelement         = new XMLElement(elementpath.nodeName);\n        xmlelement.parent  = parent;\n      }\n\n      // if this is a text node, return a PCData element (parsed character data)\n      if (elementpath.nodeType === 3 && elementpath.textContent !== \"\") {\n        return this.createPCDataElement(elementpath.textContent);\n      }\n\n      // if this is a CDATA node, return a CData element (unparsed character data)\n      if (elementpath.nodeType === 4) {\n       return this.createCDataElement(elementpath.textContent);\n      }\n\n      // bind all attributes, if there are any\n      if (elementpath.attributes) {\n        for (l = 0, m = elementpath.attributes.length; l < m; l++) {\n          tmpattrib    = elementpath.attributes[l];\n          xmlattribute = new XMLAttribute(tmpattrib.getname,\n                                          tmpattrib.nodeName,\n                                          tmpattrib.namespaceURI,\n                                          tmpattrib.nodeValue,\n                                          tmpattrib.nodeType);\n          xmlelement.attributes.push(xmlattribute);\n        }\n      }\n\n      // bind all children, if there are any\n      if (elementpath.childNodes) {\n        for (l = 0, m = elementpath.childNodes.length; l < m; l++) {\n          var node = elementpath.childNodes[l];\n          child = xmlelement.parseChildrenRecursive(xmlelement, node);\n          if (child !== null) {\n            xmlelement.children.push(child);\n          }\n        }\n      }\n\n      return xmlelement;\n    },\n    /**\n     * @member XMLElement\n     * The createElement() function Creates an empty element\n     *\n     * @param {String} fullName   the full name of the element\n     * @param {String} namespace  the namespace URI\n     * @param {String} systemID   the system ID of the XML data where the element starts\n     * @param {int} lineNr    the line in the XML data where the element starts\n     */\n    createElement: function (fullname, namespaceuri, sysid, line) {\n      if (sysid === undef) {\n        return new XMLElement(fullname, namespaceuri);\n      }\n      return new XMLElement(fullname, namespaceuri, sysid, line);\n    },\n    /**\n     * @member XMLElement\n     * The createPCDataElement() function creates an element to be used for #PCDATA content.\n     * Because Processing discards whitespace TEXT nodes, this method will not build an element\n     * if the passed content is empty after trimming for whitespace.\n     *\n     * @return {XMLElement} new \"pcdata\" XMLElement, or null if content consists only of whitespace\n     */\n    createPCDataElement: function (content, isCDATA) {\n      if (content.replace(/^\\s+$/g,\"\") === \"\") {\n        return null;\n      }\n      var pcdata = new XMLElement();\n      pcdata.type = \"TEXT\";\n      pcdata.content = content;\n      return pcdata;\n    },\n    /**\n     * @member XMLElement\n     * The createCDataElement() function creates an element to be used for CDATA content.\n     *\n     * @return {XMLElement} new \"cdata\" XMLElement, or null if content consists only of whitespace\n     */\n    createCDataElement: function (content) {\n      var cdata = this.createPCDataElement(content);\n      if (cdata === null) {\n        return null;\n      }\n\n      cdata.type = \"CDATA\";\n      var htmlentities = {\"<\": \"&lt;\", \">\": \"&gt;\", \"'\": \"&apos;\", '\"': \"&quot;\"},\n          entity;\n      for (entity in htmlentities) {\n        if (!Object.hasOwnProperty(htmlentities,entity)) {\n          content = content.replace(new RegExp(entity, \"g\"), htmlentities[entity]);\n        }\n      }\n      cdata.cdata = content;\n      return cdata;\n    },\n    /**\n     * @member XMLElement\n     * The hasAttribute() function returns whether an attribute exists\n     *\n     * @param {String} name      name of the attribute\n     * @param {String} namespace the namespace URI of the attribute\n     *\n     * @return {boolean} true if the attribute exists\n     */\n    hasAttribute: function () {\n      if (arguments.length === 1) {\n        return this.getAttribute(arguments[0]) !== null;\n      }\n      if (arguments.length === 2) {\n        return this.getAttribute(arguments[0],arguments[1]) !== null;\n      }\n    },\n    /**\n     * @member XMLElement\n     * The equals() function checks to see if the XMLElement being passed in equals another XMLElement\n     *\n     * @param {XMLElement} rawElement the element to compare to\n     *\n     * @return {boolean} true if the element equals another element\n     */\n    equals: function(other) {\n      if (!(other instanceof XMLElement)) {\n        return false;\n      }\n      var i, j;\n      if (this.fullName !== other.fullName) { return false; }\n      if (this.attributes.length !== other.getAttributeCount()) { return false; }\n      // attributes may be ordered differently\n      if (this.attributes.length !== other.attributes.length) { return false; }\n      var attr_name, attr_ns, attr_value, attr_type, attr_other;\n      for (i = 0, j = this.attributes.length; i < j; i++) {\n        attr_name = this.attributes[i].getName();\n        attr_ns = this.attributes[i].getNamespace();\n        attr_other = other.findAttribute(attr_name, attr_ns);\n        if (attr_other === null) { return false; }\n        if (this.attributes[i].getValue() !== attr_other.getValue()) { return false; }\n        if (this.attributes[i].getType() !== attr_other.getType()) { return false; }\n      }\n      // children must be ordered identically\n      if (this.children.length !== other.getChildCount()) { return false; }\n      if (this.children.length>0) {\n        var child1, child2;\n        for (i = 0, j = this.children.length; i < j; i++) {\n          child1 = this.getChild(i);\n          child2 = other.getChild(i);\n          if (!child1.equals(child2)) { return false; }\n        }\n        return true;\n      }\n      return (this.content === other.content);\n    },\n    /**\n     * @member XMLElement\n     * The getContent() function returns the content of an element. If there is no such content, null is returned\n     *\n     * @return {String} the (possibly null) content\n     */\n    getContent: function(){\n      if (this.type === \"TEXT\" || this.type === \"CDATA\") {\n        return this.content;\n      }\n      var children = this.children;\n      if (children.length === 1 && (children[0].type === \"TEXT\" || children[0].type === \"CDATA\")) {\n        return children[0].content;\n      }\n      return null;\n    },\n    /**\n     * @member XMLElement\n     * The getAttribute() function returns the value of an attribute\n     *\n     * @param {String} name         the non-null full name of the attribute\n     * @param {String} namespace    the namespace URI, which may be null\n     * @param {String} defaultValue the default value of the attribute\n     *\n     * @return {String} the value, or defaultValue if the attribute does not exist\n     */\n    getAttribute: function (){\n      var attribute;\n      if (arguments.length === 2) {\n        attribute = this.findAttribute(arguments[0]);\n        if (attribute) {\n          return attribute.getValue();\n        }\n        return arguments[1];\n      } else if (arguments.length === 1) {\n        attribute = this.findAttribute(arguments[0]);\n        if (attribute) {\n          return attribute.getValue();\n        }\n        return null;\n      } else if (arguments.length === 3) {\n        attribute = this.findAttribute(arguments[0],arguments[1]);\n        if (attribute) {\n          return attribute.getValue();\n        }\n        return arguments[2];\n      }\n    },\n    /**\n     * @member XMLElement\n     * The getStringAttribute() function returns the string attribute of the element\n     * If the <b>defaultValue</b> parameter is used and the attribute doesn't exist, the <b>defaultValue</b> value is returned.\n     * When calling the function without the <b>defaultValue</b> parameter, if the attribute doesn't exist, the value 0 is returned.\n     *\n     * @param name         the name of the attribute\n     * @param defaultValue value returned if the attribute is not found\n     *\n     * @return {String} the value, or defaultValue if the attribute does not exist\n     */\n    getStringAttribute: function() {\n      if (arguments.length === 1) {\n        return this.getAttribute(arguments[0]);\n      }\n      if (arguments.length === 2) {\n        return this.getAttribute(arguments[0], arguments[1]);\n      }\n      return this.getAttribute(arguments[0], arguments[1],arguments[2]);\n    },\n    /**\n     * Processing 1.5 XML API wrapper for the generic String\n     * attribute getter. This may only take one argument.\n     */\n    getString: function(attributeName) {\n      return this.getStringAttribute(attributeName);\n    },\n    /**\n     * @member XMLElement\n     * The getFloatAttribute() function returns the float attribute of the element.\n     * If the <b>defaultValue</b> parameter is used and the attribute doesn't exist, the <b>defaultValue</b> value is returned.\n     * When calling the function without the <b>defaultValue</b> parameter, if the attribute doesn't exist, the value 0 is returned.\n     *\n     * @param name         the name of the attribute\n     * @param defaultValue value returned if the attribute is not found\n     *\n     * @return {float} the value, or defaultValue if the attribute does not exist\n     */\n    getFloatAttribute: function() {\n      if (arguments.length === 1 ) {\n        return parseFloat(this.getAttribute(arguments[0], 0));\n      }\n      if (arguments.length === 2 ) {\n        return this.getAttribute(arguments[0], arguments[1]);\n      }\n      return this.getAttribute(arguments[0], arguments[1],arguments[2]);\n    },\n    /**\n     * Processing 1.5 XML API wrapper for the generic float\n     * attribute getter. This may only take one argument.\n     */\n    getFloat: function(attributeName) {\n      return this.getFloatAttribute(attributeName);\n    },\n    /**\n     * @member XMLElement\n     * The getIntAttribute() function returns the integer attribute of the element.\n     * If the <b>defaultValue</b> parameter is used and the attribute doesn't exist, the <b>defaultValue</b> value is returned.\n     * When calling the function without the <b>defaultValue</b> parameter, if the attribute doesn't exist, the value 0 is returned.\n     *\n     * @param name         the name of the attribute\n     * @param defaultValue value returned if the attribute is not found\n     *\n     * @return {int} the value, or defaultValue if the attribute does not exist\n     */\n    getIntAttribute: function () {\n      if (arguments.length === 1) {\n        return this.getAttribute( arguments[0], 0 );\n      }\n      if (arguments.length === 2) {\n        return this.getAttribute(arguments[0], arguments[1]);\n      }\n      return this.getAttribute(arguments[0], arguments[1],arguments[2]);\n    },\n    /**\n     * Processing 1.5 XML API wrapper for the generic int\n     * attribute getter. This may only take one argument.\n     */\n    getInt: function(attributeName) {\n      return this.getIntAttribute(attributeName);\n    },\n    /**\n     * @member XMLElement\n     * The hasChildren() function returns whether the element has children.\n     *\n     * @return {boolean} true if the element has children.\n     */\n    hasChildren: function () {\n      return this.children.length > 0 ;\n    },\n    /**\n     * @member XMLElement\n     * The addChild() function adds a child element\n     *\n     * @param {XMLElement} child the non-null child to add.\n     */\n    addChild: function (child) {\n      if (child !== null) {\n        child.parent = this;\n        this.children.push(child);\n      }\n    },\n    /**\n     * @member XMLElement\n     * The insertChild() function inserts a child element at the index provided\n     *\n     * @param {XMLElement} child  the non-null child to add.\n     * @param {int} index     where to put the child.\n     */\n    insertChild: function (child, index) {\n      if (child) {\n        if ((child.getLocalName() === null) && (! this.hasChildren())) {\n          var lastChild = this.children[this.children.length -1];\n          if (lastChild.getLocalName() === null) {\n              lastChild.setContent(lastChild.getContent() + child.getContent());\n              return;\n          }\n        }\n        child.parent = this;\n        this.children.splice(index,0,child);\n      }\n    },\n    /**\n     * @member XMLElement\n     * The getChild() returns the child XMLElement as specified by the <b>index</b> parameter.\n     * The value of the <b>index</b> parameter must be less than the total number of children to avoid going out of the array storing the child elements.\n     * When the <b>path</b> parameter is specified, then it will return all children that match that path. The path is a series of elements and sub-elements, separated by slashes.\n     *\n     * @param {int} index     where to put the child.\n     * @param {String} path       path to a particular element\n     *\n     * @return {XMLElement} the element\n     */\n    getChild: function (selector) {\n      if (typeof selector === \"number\") {\n        return this.children[selector];\n      }\n      if (selector.indexOf('/') !== -1) {\n        // path traversal is required\n        return this.getChildRecursive(selector.split(\"/\"), 0);\n      }\n      var kid, kidName;\n      for (var i = 0, j = this.getChildCount(); i < j; i++) {\n        kid = this.getChild(i);\n        kidName = kid.getName();\n        if (kidName !== null && kidName === selector) {\n            return kid;\n        }\n      }\n      return null;\n    },\n    /**\n     * @member XMLElement\n     * The getChildren() returns all of the children as an XMLElement array.\n     * When the <b>path</b> parameter is specified, then it will return all children that match that path.\n     * The path is a series of elements and sub-elements, separated by slashes.\n     *\n     * @param {String} path       element name or path/to/element\n     *\n     * @return {XMLElement} array of child elements that match\n     *\n     * @see XMLElement#getChildCount()\n     * @see XMLElement#getChild()\n     */\n    getChildren: function(){\n      if (arguments.length === 1) {\n        if (typeof arguments[0] === \"number\") {\n          return this.getChild( arguments[0]);\n        }\n        if (arguments[0].indexOf('/') !== -1) { // path was given\n          return this.getChildrenRecursive( arguments[0].split(\"/\"), 0);\n        }\n        var matches = [];\n        var kid, kidName;\n        for (var i = 0, j = this.getChildCount(); i < j; i++) {\n          kid = this.getChild(i);\n          kidName = kid.getName();\n          if (kidName !== null && kidName === arguments[0]) {\n            matches.push(kid);\n          }\n        }\n        return matches;\n      }\n      return this.children;\n    },\n    /**\n     * @member XMLElement\n     * The getChildCount() returns the number of children for the element.\n     *\n     * @return {int} the count\n     *\n     * @see XMLElement#getChild()\n     * @see XMLElement#getChildren()\n     */\n    getChildCount: function() {\n      return this.children.length;\n    },\n    /**\n     * @member XMLElement\n     * Internal helper function for getChild().\n     *\n     * @param {String[]} items   result of splitting the query on slashes\n     * @param {int} offset   where in the items[] array we're currently looking\n     *\n     * @return {XMLElement} matching element or null if no match\n     */\n    getChildRecursive: function (items, offset) {\n      // terminating clause: we are the requested candidate\n      if (offset === items.length) {\n        return this;\n      }\n      // continuation clause\n      var kid, kidName, matchName = items[offset];\n      for(var i = 0, j = this.getChildCount(); i < j; i++) {\n          kid = this.getChild(i);\n          kidName = kid.getName();\n          if (kidName !== null && kidName === matchName) {\n            return kid.getChildRecursive(items, offset+1);\n          }\n      }\n      return null;\n    },\n    /**\n     * @member XMLElement\n     * Internal helper function for getChildren().\n     *\n     * @param {String[]} items   result of splitting the query on slashes\n     * @param {int} offset   where in the items[] array we're currently looking\n     *\n     * @return {XMLElement[]} matching elements or empty array if no match\n     */\n    getChildrenRecursive: function (items, offset) {\n      if (offset === items.length-1) {\n        return this.getChildren(items[offset]);\n      }\n      var matches = this.getChildren(items[offset]);\n      var kidMatches = [];\n      for (var i = 0; i < matches.length; i++) {\n        kidMatches = kidMatches.concat(matches[i].getChildrenRecursive(items, offset+1));\n      }\n      return kidMatches;\n    },\n    /**\n     * @member XMLElement\n     * The isLeaf() function returns whether the element is a leaf element.\n     *\n     * @return {boolean} true if the element has no children.\n     */\n    isLeaf: function() {\n      return !this.hasChildren();\n    },\n    /**\n     * @member XMLElement\n     * The listChildren() function put the names of all children into an array. Same as looping through\n     * each child and calling getName() on each XMLElement.\n     *\n     * @return {String[]} a list of element names.\n     */\n    listChildren: function() {\n      var arr = [];\n      for (var i = 0, j = this.children.length; i < j; i++) {\n        arr.push( this.getChild(i).getName());\n      }\n      return arr;\n    },\n    /**\n     * @member XMLElement\n     * The removeAttribute() function removes an attribute\n     *\n     * @param {String} name        the non-null name of the attribute.\n     * @param {String} namespace   the namespace URI of the attribute, which may be null.\n     */\n    removeAttribute: function (name , namespace) {\n      this.namespace = namespace || \"\";\n      for (var i = 0, j = this.attributes.length; i < j; i++) {\n        if (this.attributes[i].getName() === name && this.attributes[i].getNamespace() === this.namespace) {\n          this.attributes.splice(i, 1);\n          break;\n        }\n      }\n    },\n    /**\n     * @member XMLElement\n     * The removeChild() removes a child element.\n     *\n     * @param {XMLElement} child      the the non-null child to be renoved\n     */\n    removeChild: function(child) {\n      if (child) {\n        for (var i = 0, j = this.children.length; i < j; i++) {\n          if (this.children[i].equals(child)) {\n            this.children.splice(i, 1);\n            break;\n          }\n        }\n      }\n    },\n    /**\n     * @member XMLElement\n     * The removeChildAtIndex() removes the child located at a certain index\n     *\n     * @param {int} index      the index of the child, where the first child has index 0\n     */\n    removeChildAtIndex: function(index) {\n      if (this.children.length > index) { //make sure its not outofbounds\n        this.children.splice(index, 1);\n      }\n    },\n    /**\n     * @member XMLElement\n     * The findAttribute() function searches an attribute\n     *\n     * @param {String} name        fullName the non-null full name of the attribute\n     * @param {String} namespace   the name space, which may be null\n     *\n     * @return {XMLAttribute} the attribute, or null if the attribute does not exist.\n     */\n    findAttribute: function (name, namespace) {\n      this.namespace = namespace || \"\";\n      for (var i = 0, j = this.attributes.length; i < j; i++) {\n        if (this.attributes[i].getName() === name && this.attributes[i].getNamespace() === this.namespace) {\n           return this.attributes[i];\n        }\n      }\n      return null;\n    },\n    /**\n     * @member XMLElement\n     * The setAttribute() function sets an attribute.\n     *\n     * @param {String} name        the non-null full name of the attribute\n     * @param {String} namespace   the non-null value of the attribute\n     */\n    setAttribute: function() {\n      var attr;\n      if (arguments.length === 3) {\n        var index = arguments[0].indexOf(':');\n        var name  = arguments[0].substring(index + 1);\n        attr      = this.findAttribute(name, arguments[1]);\n        if (attr) {\n          attr.setValue(arguments[2]);\n        } else {\n          attr = new XMLAttribute(arguments[0], name, arguments[1], arguments[2], \"CDATA\");\n          this.attributes.push(attr);\n        }\n      } else {\n        attr = this.findAttribute(arguments[0]);\n        if (attr) {\n          attr.setValue(arguments[1]);\n        } else {\n          attr = new XMLAttribute(arguments[0], arguments[0], null, arguments[1], \"CDATA\");\n          this.attributes.push(attr);\n        }\n      }\n    },\n    /**\n     * Processing 1.5 XML API wrapper for the generic String\n     * attribute setter. This must take two arguments.\n     */\n    setString: function(attribute, value) {\n      this.setAttribute(attribute, value);\n    },\n    /**\n     * Processing 1.5 XML API wrapper for the generic int\n     * attribute setter. This must take two arguments.\n     */\n    setInt: function(attribute, value) {\n      this.setAttribute(attribute, value);\n    },\n    /**\n     * Processing 1.5 XML API wrapper for the generic float\n     * attribute setter. This must take two arguments.\n     */\n    setFloat: function(attribute, value) {\n      this.setAttribute(attribute, value);\n    },\n    /**\n     * @member XMLElement\n     * The setContent() function sets the #PCDATA content. It is an error to call this method with a\n     * non-null value if there are child objects.\n     *\n     * @param {String} content     the (possibly null) content\n     */\n    setContent: function(content) {\n      if (this.children.length > 0) {\n        Processing.debug(\"Tried to set content for XMLElement with children\"); }\n      this.content = content;\n    },\n    /**\n     * @member XMLElement\n     * The setName() function sets the full name. This method also sets the short name and clears the\n     * namespace URI.\n     *\n     * @param {String} name        the non-null name\n     * @param {String} namespace   the namespace URI, which may be null.\n     */\n    setName: function() {\n      if (arguments.length === 1) {\n        this.name      = arguments[0];\n        this.fullName  = arguments[0];\n        this.namespace = null;\n      } else {\n        var index = arguments[0].indexOf(':');\n        if ((arguments[1] === null) || (index < 0)) {\n            this.name = arguments[0];\n        } else {\n            this.name = arguments[0].substring(index + 1);\n        }\n        this.fullName  = arguments[0];\n        this.namespace = arguments[1];\n      }\n    },\n    /**\n     * @member XMLElement\n     * The getName() function returns the full name (i.e. the name including an eventual namespace\n     * prefix) of the element.\n     *\n     * @return {String} the name, or null if the element only contains #PCDATA.\n     */\n    getName: function() {\n      return this.fullName;\n    },\n    /**\n     * @member XMLElement\n     * The getLocalName() function returns the local name (i.e. the name excluding an eventual namespace\n     * prefix) of the element.\n     *\n     * @return {String} the name, or null if the element only contains #PCDATA.\n     */\n    getLocalName: function() {\n      return this.name;\n    },\n    /**\n     * @member XMLElement\n     * The getAttributeCount() function returns the number of attributes for the node\n     * that this XMLElement represents.\n     *\n     * @return {int} the number of attributes in this XMLElement\n     */\n    getAttributeCount: function() {\n      return this.attributes.length;\n    },\n    /**\n     * @member XMLElement\n     * The toString() function returns the XML definition of an XMLElement.\n     *\n     * @return {String} the XML definition of this XMLElement\n     */\n    toString: function() {\n      // shortcut for text and cdata nodes\n      if (this.type === \"TEXT\") {\n        return this.content || \"\";\n      }\n\n      if (this.type === \"CDATA\") {\n        return this.cdata || \"\";\n      }\n\n      // real XMLElements\n      var tagstring = this.fullName;\n      var xmlstring =  \"<\" + tagstring;\n      var a,c;\n\n      // serialize the attributes to XML string\n      for (a = 0; a<this.attributes.length; a++) {\n        var attr = this.attributes[a];\n        xmlstring += \" \"  + attr.getName() + \"=\" + '\"' + attr.getValue() + '\"';\n      }\n\n      // serialize all children to XML string\n      if (this.children.length === 0) {\n        if (this.content === \"\" || this.content === null || this.content === undefined) {\n          xmlstring += \"/>\";\n        } else {\n          xmlstring += \">\" + this.content + \"</\"+tagstring+\">\";\n        }\n      } else {\n        xmlstring += \">\";\n        for (c = 0; c<this.children.length; c++) {\n          xmlstring += this.children[c].toString();\n        }\n        xmlstring += \"</\" + tagstring + \">\";\n      }\n      return xmlstring;\n     }\n  };\n\n  /**\n   * static Processing 1.5 XML API wrapper for the\n   * parse method. This may only take one argument.\n   */\n  XMLElement.parse = function(xmlstring) {\n    var element = new XMLElement();\n    element.parse(xmlstring);\n    return element;\n  };\n\n  return XMLElement;\n};\n\n},{}],20:[function(require,module,exports){\n/**\n * web colors, by name\n */\nmodule.exports = {\n    aliceblue:            \"#f0f8ff\",\n    antiquewhite:         \"#faebd7\",\n    aqua:                 \"#00ffff\",\n    aquamarine:           \"#7fffd4\",\n    azure:                \"#f0ffff\",\n    beige:                \"#f5f5dc\",\n    bisque:               \"#ffe4c4\",\n    black:                \"#000000\",\n    blanchedalmond:       \"#ffebcd\",\n    blue:                 \"#0000ff\",\n    blueviolet:           \"#8a2be2\",\n    brown:                \"#a52a2a\",\n    burlywood:            \"#deb887\",\n    cadetblue:            \"#5f9ea0\",\n    chartreuse:           \"#7fff00\",\n    chocolate:            \"#d2691e\",\n    coral:                \"#ff7f50\",\n    cornflowerblue:       \"#6495ed\",\n    cornsilk:             \"#fff8dc\",\n    crimson:              \"#dc143c\",\n    cyan:                 \"#00ffff\",\n    darkblue:             \"#00008b\",\n    darkcyan:             \"#008b8b\",\n    darkgoldenrod:        \"#b8860b\",\n    darkgray:             \"#a9a9a9\",\n    darkgreen:            \"#006400\",\n    darkkhaki:            \"#bdb76b\",\n    darkmagenta:          \"#8b008b\",\n    darkolivegreen:       \"#556b2f\",\n    darkorange:           \"#ff8c00\",\n    darkorchid:           \"#9932cc\",\n    darkred:              \"#8b0000\",\n    darksalmon:           \"#e9967a\",\n    darkseagreen:         \"#8fbc8f\",\n    darkslateblue:        \"#483d8b\",\n    darkslategray:        \"#2f4f4f\",\n    darkturquoise:        \"#00ced1\",\n    darkviolet:           \"#9400d3\",\n    deeppink:             \"#ff1493\",\n    deepskyblue:          \"#00bfff\",\n    dimgray:              \"#696969\",\n    dodgerblue:           \"#1e90ff\",\n    firebrick:            \"#b22222\",\n    floralwhite:          \"#fffaf0\",\n    forestgreen:          \"#228b22\",\n    fuchsia:              \"#ff00ff\",\n    gainsboro:            \"#dcdcdc\",\n    ghostwhite:           \"#f8f8ff\",\n    gold:                 \"#ffd700\",\n    goldenrod:            \"#daa520\",\n    gray:                 \"#808080\",\n    green:                \"#008000\",\n    greenyellow:          \"#adff2f\",\n    honeydew:             \"#f0fff0\",\n    hotpink:              \"#ff69b4\",\n    indianred:            \"#cd5c5c\",\n    indigo:               \"#4b0082\",\n    ivory:                \"#fffff0\",\n    khaki:                \"#f0e68c\",\n    lavender:             \"#e6e6fa\",\n    lavenderblush:        \"#fff0f5\",\n    lawngreen:            \"#7cfc00\",\n    lemonchiffon:         \"#fffacd\",\n    lightblue:            \"#add8e6\",\n    lightcoral:           \"#f08080\",\n    lightcyan:            \"#e0ffff\",\n    lightgoldenrodyellow: \"#fafad2\",\n    lightgrey:            \"#d3d3d3\",\n    lightgreen:           \"#90ee90\",\n    lightpink:            \"#ffb6c1\",\n    lightsalmon:          \"#ffa07a\",\n    lightseagreen:        \"#20b2aa\",\n    lightskyblue:         \"#87cefa\",\n    lightslategray:       \"#778899\",\n    lightsteelblue:       \"#b0c4de\",\n    lightyellow:          \"#ffffe0\",\n    lime:                 \"#00ff00\",\n    limegreen:            \"#32cd32\",\n    linen:                \"#faf0e6\",\n    magenta:              \"#ff00ff\",\n    maroon:               \"#800000\",\n    mediumaquamarine:     \"#66cdaa\",\n    mediumblue:           \"#0000cd\",\n    mediumorchid:         \"#ba55d3\",\n    mediumpurple:         \"#9370d8\",\n    mediumseagreen:       \"#3cb371\",\n    mediumslateblue:      \"#7b68ee\",\n    mediumspringgreen:    \"#00fa9a\",\n    mediumturquoise:      \"#48d1cc\",\n    mediumvioletred:      \"#c71585\",\n    midnightblue:         \"#191970\",\n    mintcream:            \"#f5fffa\",\n    mistyrose:            \"#ffe4e1\",\n    moccasin:             \"#ffe4b5\",\n    navajowhite:          \"#ffdead\",\n    navy:                 \"#000080\",\n    oldlace:              \"#fdf5e6\",\n    olive:                \"#808000\",\n    olivedrab:            \"#6b8e23\",\n    orange:               \"#ffa500\",\n    orangered:            \"#ff4500\",\n    orchid:               \"#da70d6\",\n    palegoldenrod:        \"#eee8aa\",\n    palegreen:            \"#98fb98\",\n    paleturquoise:        \"#afeeee\",\n    palevioletred:        \"#d87093\",\n    papayawhip:           \"#ffefd5\",\n    peachpuff:            \"#ffdab9\",\n    peru:                 \"#cd853f\",\n    pink:                 \"#ffc0cb\",\n    plum:                 \"#dda0dd\",\n    powderblue:           \"#b0e0e6\",\n    purple:               \"#800080\",\n    red:                  \"#ff0000\",\n    rosybrown:            \"#bc8f8f\",\n    royalblue:            \"#4169e1\",\n    saddlebrown:          \"#8b4513\",\n    salmon:               \"#fa8072\",\n    sandybrown:           \"#f4a460\",\n    seagreen:             \"#2e8b57\",\n    seashell:             \"#fff5ee\",\n    sienna:               \"#a0522d\",\n    silver:               \"#c0c0c0\",\n    skyblue:              \"#87ceeb\",\n    slateblue:            \"#6a5acd\",\n    slategray:            \"#708090\",\n    snow:                 \"#fffafa\",\n    springgreen:          \"#00ff7f\",\n    steelblue:            \"#4682b4\",\n    tan:                  \"#d2b48c\",\n    teal:                 \"#008080\",\n    thistle:              \"#d8bfd8\",\n    tomato:               \"#ff6347\",\n    turquoise:            \"#40e0d0\",\n    violet:               \"#ee82ee\",\n    wheat:                \"#f5deb3\",\n    white:                \"#ffffff\",\n    whitesmoke:           \"#f5f5f5\",\n    yellow:               \"#ffff00\",\n    yellowgreen:          \"#9acd32\"\n  };\n\n},{}],21:[function(require,module,exports){\nmodule.exports = function(virtHashCode, virtEquals, undef) {\n\n  return function withProxyFunctions(p, removeFirstArgument) {\n    /**\n     * The contains(string) function returns true if the string passed in the parameter\n     * is a substring of this string. It returns false if the string passed\n     * in the parameter is not a substring of this string.\n     *\n     * @param {String} The string to look for in the current string\n     *\n     * @return {boolean} returns true if this string contains\n     * the string passed as parameter. returns false, otherwise.\n     *\n     */\n    p.__contains = function (subject, subStr) {\n      if (typeof subject !== \"string\") {\n        return subject.contains.apply(subject, removeFirstArgument(arguments));\n      }\n      //Parameter is not null AND\n      //The type of the parameter is the same as this object (string)\n      //The javascript function that finds a substring returns 0 or higher\n      return (\n        (subject !== null) &&\n        (subStr !== null) &&\n        (typeof subStr === \"string\") &&\n        (subject.indexOf(subStr) > -1)\n      );\n    };\n\n    /**\n     * The __replaceAll() function searches all matches between a substring (or regular expression) and a string,\n     * and replaces the matched substring with a new substring\n     *\n     * @param {String} subject    a substring\n     * @param {String} regex      a substring or a regular expression\n     * @param {String} replace    the string to replace the found value\n     *\n     * @return {String} returns result\n     *\n     * @see #match\n     */\n    p.__replaceAll = function(subject, regex, replacement) {\n      if (typeof subject !== \"string\") {\n        return subject.replaceAll.apply(subject, removeFirstArgument(arguments));\n      }\n\n      return subject.replace(new RegExp(regex, \"g\"), replacement);\n    };\n\n    /**\n     * The __replaceFirst() function searches first matche between a substring (or regular expression) and a string,\n     * and replaces the matched substring with a new substring\n     *\n     * @param {String} subject    a substring\n     * @param {String} regex      a substring or a regular expression\n     * @param {String} replace    the string to replace the found value\n     *\n     * @return {String} returns result\n     *\n     * @see #match\n     */\n    p.__replaceFirst = function(subject, regex, replacement) {\n      if (typeof subject !== \"string\") {\n        return subject.replaceFirst.apply(subject, removeFirstArgument(arguments));\n      }\n\n      return subject.replace(new RegExp(regex, \"\"), replacement);\n    };\n\n    /**\n     * The __replace() function searches all matches between a substring and a string,\n     * and replaces the matched substring with a new substring\n     *\n     * @param {String} subject         a substring\n     * @param {String} what         a substring to find\n     * @param {String} replacement    the string to replace the found value\n     *\n     * @return {String} returns result\n     */\n    p.__replace = function(subject, what, replacement) {\n      if (typeof subject !== \"string\") {\n        return subject.replace.apply(subject, removeFirstArgument(arguments));\n      }\n      if (what instanceof RegExp) {\n        return subject.replace(what, replacement);\n      }\n\n      if (typeof what !== \"string\") {\n        what = what.toString();\n      }\n      if (what === \"\") {\n        return subject;\n      }\n\n      var i = subject.indexOf(what);\n      if (i < 0) {\n        return subject;\n      }\n\n      var j = 0, result = \"\";\n      do {\n        result += subject.substring(j, i) + replacement;\n        j = i + what.length;\n      } while ( (i = subject.indexOf(what, j)) >= 0);\n      return result + subject.substring(j);\n    };\n\n    /**\n     * The __equals() function compares two strings (or objects) to see if they are the same.\n     * This method is necessary because it's not possible to compare strings using the equality operator (==).\n     * Returns true if the strings are the same and false if they are not.\n     *\n     * @param {String} subject  a string used for comparison\n     * @param {String} other  a string used for comparison with\n     *\n     * @return {boolean} true is the strings are the same false otherwise\n     */\n    p.__equals = function(subject, other) {\n      if (subject.equals instanceof Function) {\n        return subject.equals.apply(subject, removeFirstArgument(arguments));\n      }\n\n      return virtEquals(subject, other);\n    };\n\n    /**\n     * The __equalsIgnoreCase() function compares two strings to see if they are the same.\n     * Returns true if the strings are the same, either when forced to all lower case or\n     * all upper case.\n     *\n     * @param {String} subject  a string used for comparison\n     * @param {String} other  a string used for comparison with\n     *\n     * @return {boolean} true is the strings are the same, ignoring case. false otherwise\n     */\n    p.__equalsIgnoreCase = function(subject, other) {\n      if (typeof subject !== \"string\") {\n        return subject.equalsIgnoreCase.apply(subject, removeFirstArgument(arguments));\n      }\n\n      return subject.toLowerCase() === other.toLowerCase();\n    };\n\n    /**\n     * The __toCharArray() function splits the string into a char array.\n     *\n     * @param {String} subject The string\n     *\n     * @return {Char[]} a char array\n     */\n    p.__toCharArray = function(subject) {\n      if (typeof subject !== \"string\") {\n        return subject.toCharArray.apply(subject, removeFirstArgument(arguments));\n      }\n\n      var chars = [];\n      for (var i = 0, len = subject.length; i < len; ++i) {\n        chars[i] = new Char(subject.charAt(i));\n      }\n      return chars;\n    };\n\n    /**\n     * The __split() function splits a string using the regex delimiter\n     * specified. If limit is specified, the resultant array will have number\n     * of elements equal to or less than the limit.\n     *\n     * @param {String} subject string to be split\n     * @param {String} regexp  regex string used to split the subject\n     * @param {int}    limit   max number of tokens to be returned\n     *\n     * @return {String[]} an array of tokens from the split string\n     */\n    p.__split = function(subject, regex, limit) {\n      if (typeof subject !== \"string\") {\n        return subject.split.apply(subject, removeFirstArgument(arguments));\n      }\n\n      var pattern = new RegExp(regex);\n\n      // If limit is not specified, use JavaScript's built-in String.split.\n      if ((limit === undef) || (limit < 1)) {\n        return subject.split(pattern);\n      }\n\n      // If limit is specified, JavaScript's built-in String.split has a\n      // different behaviour than Java's. A Java-compatible implementation is\n      // provided here.\n      var result = [], currSubject = subject, pos;\n      while (((pos = currSubject.search(pattern)) !== -1) && (result.length < (limit - 1))) {\n        var match = pattern.exec(currSubject).toString();\n        result.push(currSubject.substring(0, pos));\n        currSubject = currSubject.substring(pos + match.length);\n      }\n      if ((pos !== -1) || (currSubject !== \"\")) {\n        result.push(currSubject);\n      }\n      return result;\n    };\n\n    /**\n     * The codePointAt() function returns the unicode value of the character at a given index of a string.\n     *\n     * @param  {int} idx         the index of the character\n     *\n     * @return {String} code     the String containing the unicode value of the character\n     */\n    p.__codePointAt = function(subject, idx) {\n      var code = subject.charCodeAt(idx),\n          hi,\n          low;\n      if (0xD800 <= code && code <= 0xDBFF) {\n        hi = code;\n        low = subject.charCodeAt(idx + 1);\n        return ((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000;\n      }\n      return code;\n    };\n\n    /**\n     * The matches() function checks whether or not a string matches a given regular expression.\n     *\n     * @param {String} str      the String on which the match is tested\n     * @param {String} regexp   the regexp for which a match is tested\n     *\n     * @return {boolean} true if the string fits the regexp, false otherwise\n     */\n    p.__matches = function(str, regexp) {\n      return (new RegExp(regexp)).test(str);\n    };\n\n    /**\n     * The startsWith() function tests if a string starts with the specified prefix.  If the prefix\n     * is the empty String or equal to the subject String, startsWith() will also return true.\n     *\n     * @param {String} prefix   the String used to compare against the start of the subject String.\n     * @param {int}    toffset  (optional) an offset into the subject String where searching should begin.\n     *\n     * @return {boolean} true if the subject String starts with the prefix.\n     */\n    p.__startsWith = function(subject, prefix, toffset) {\n      if (typeof subject !== \"string\") {\n        return subject.startsWith.apply(subject, removeFirstArgument(arguments));\n      }\n\n      toffset = toffset || 0;\n      if (toffset < 0 || toffset > subject.length) {\n        return false;\n      }\n      return (prefix === '' || prefix === subject) ? true : (subject.indexOf(prefix) === toffset);\n    };\n\n    /**\n     * The endsWith() function tests if a string ends with the specified suffix.  If the suffix\n     * is the empty String, endsWith() will also return true.\n     *\n     * @param {String} suffix   the String used to compare against the end of the subject String.\n     *\n     * @return {boolean} true if the subject String starts with the prefix.\n     */\n    p.__endsWith = function(subject, suffix) {\n      if (typeof subject !== \"string\") {\n        return subject.endsWith.apply(subject, removeFirstArgument(arguments));\n      }\n\n      var suffixLen = suffix ? suffix.length : 0;\n      return (suffix === '' || suffix === subject) ? true :\n        (subject.indexOf(suffix) === subject.length - suffixLen);\n    };\n\n    /**\n     * The returns hash code of the.\n     *\n     * @param {Object} subject The string\n     *\n     * @return {int} a hash code\n     */\n    p.__hashCode = function(subject) {\n      if (subject.hashCode instanceof Function) {\n        return subject.hashCode.apply(subject, removeFirstArgument(arguments));\n      }\n      return virtHashCode(subject);\n    };\n\n    /**\n     * The __printStackTrace() prints stack trace to the console.\n     *\n     * @param {Exception} subject The error\n     */\n    p.__printStackTrace = function(subject) {\n      p.println(\"Exception: \" + subject.toString() );\n    };\n  };\n\n};\n\n},{}],22:[function(require,module,exports){\n/**\n * For many \"math\" functions, we can delegate\n * to the Math object. For others, we can't.\n */\nmodule.exports = function withMath(p, undef) {\n  var internalRandomGenerator = function() { return Math.random(); };\n\n  /**\n  * Calculates the absolute value (magnitude) of a number. The absolute value of a number is always positive.\n  *\n  * @param {int|float} value   int or float\n  *\n  * @returns {int|float}\n  */\n  p.abs = Math.abs;\n\n  /**\n  * Calculates the closest int value that is greater than or equal to the value of the parameter.\n  * For example, ceil(9.03) returns the value 10.\n  *\n  * @param {float} value   float\n  *\n  * @returns {int}\n  *\n  * @see floor\n  * @see round\n  */\n  p.ceil = Math.ceil;\n\n  /**\n  * Returns Euler's number e (2.71828...) raised to the power of the value parameter.\n  *\n  * @param {int|float} value   int or float: the exponent to raise e to\n  *\n  * @returns {float}\n  */\n  p.exp = Math.exp;\n\n  /**\n  * Calculates the closest int value that is less than or equal to the value of the parameter.\n  *\n  * @param {int|float} value        the value to floor\n  *\n  * @returns {int|float}\n  *\n  * @see ceil\n  * @see round\n  */\n  p.floor = Math.floor;\n\n  /**\n  * Calculates the natural logarithm (the base-e logarithm) of a number. This function\n  * expects the values greater than 0.0.\n  *\n  * @param {int|float} value        int or float: number must be greater then 0.0\n  *\n  * @returns {float}\n  */\n  p.log = Math.log;\n\n  /**\n  * Facilitates exponential expressions. The pow() function is an efficient way of\n  * multiplying numbers by themselves (or their reciprocal) in large quantities.\n  * For example, pow(3, 5) is equivalent to the expression 3*3*3*3*3 and pow(3, -5)\n  * is equivalent to 1 / 3*3*3*3*3.\n  *\n  * @param {int|float} num        base of the exponential expression\n  * @param {int|float} exponent   power of which to raise the base\n  *\n  * @returns {float}\n  *\n  * @see sqrt\n  */\n  p.pow = Math.pow;\n\n  /**\n  * Calculates the integer closest to the value parameter. For example, round(9.2) returns the value 9.\n  *\n  * @param {float} value        number to round\n  *\n  * @returns {int}\n  *\n  * @see floor\n  * @see ceil\n  */\n  p.round = Math.round;\n  /**\n  * Calculates the square root of a number. The square root of a number is always positive,\n  * even though there may be a valid negative root. The square root s of number a is such\n  * that s*s = a. It is the opposite of squaring.\n  *\n  * @param {float} value        int or float, non negative\n  *\n  * @returns {float}\n  *\n  * @see pow\n  * @see sq\n  */\n\n  p.sqrt = Math.sqrt;\n\n  // Trigonometry\n  /**\n  * The inverse of cos(), returns the arc cosine of a value. This function expects the\n  * values in the range of -1 to 1 and values are returned in the range 0 to PI (3.1415927).\n  *\n  * @param {float} value        the value whose arc cosine is to be returned\n  *\n  * @returns {float}\n  *\n  * @see cos\n  * @see asin\n  * @see atan\n  */\n  p.acos = Math.acos;\n\n  /**\n  * The inverse of sin(), returns the arc sine of a value. This function expects the values\n  * in the range of -1 to 1 and values are returned in the range -PI/2 to PI/2.\n  *\n  * @param {float} value        the value whose arc sine is to be returned\n  *\n  * @returns {float}\n  *\n  * @see sin\n  * @see acos\n  * @see atan\n  */\n  p.asin = Math.asin;\n\n  /**\n  * The inverse of tan(), returns the arc tangent of a value. This function expects the values\n  * in the range of -Infinity to Infinity (exclusive) and values are returned in the range -PI/2 to PI/2 .\n  *\n  * @param {float} value        -Infinity to Infinity (exclusive)\n  *\n  * @returns {float}\n  *\n  * @see tan\n  * @see asin\n  * @see acos\n  */\n  p.atan = Math.atan;\n\n  /**\n  * Calculates the angle (in radians) from a specified point to the coordinate origin as measured from\n  * the positive x-axis. Values are returned as a float in the range from PI to -PI. The atan2() function\n  * is most often used for orienting geometry to the position of the cursor. Note: The y-coordinate of the\n  * point is the first parameter and the x-coordinate is the second due the the structure of calculating the tangent.\n  *\n  * @param {float} y        y-coordinate of the point\n  * @param {float} x        x-coordinate of the point\n  *\n  * @returns {float}\n  *\n  * @see tan\n  */\n  p.atan2 = Math.atan2;\n\n  /**\n  * Calculates the cosine of an angle. This function expects the values of the angle parameter to be provided\n  * in radians (values from 0 to PI*2). Values are returned in the range -1 to 1.\n  *\n  * @param {float} value        an angle in radians\n  *\n  * @returns {float}\n  *\n  * @see tan\n  * @see sin\n  */\n  p.cos = Math.cos;\n\n  /**\n  * Calculates the sine of an angle. This function expects the values of the angle parameter to be provided in\n  * radians (values from 0 to 6.28). Values are returned in the range -1 to 1.\n  *\n  * @param {float} value        an angle in radians\n  *\n  * @returns {float}\n  *\n  * @see cos\n  * @see radians\n  */\n  p.sin = Math.sin;\n\n  /**\n  * Calculates the ratio of the sine and cosine of an angle. This function expects the values of the angle\n  * parameter to be provided in radians (values from 0 to PI*2). Values are returned in the range infinity to -infinity.\n  *\n  * @param {float} value        an angle in radians\n  *\n  * @returns {float}\n  *\n  * @see cos\n  * @see sin\n  * @see radians\n  */\n  p.tan = Math.tan;\n\n  /**\n  * Constrains a value to not exceed a maximum and minimum value.\n  *\n  * @param {int|float} value   the value to constrain\n  * @param {int|float} value   minimum limit\n  * @param {int|float} value   maximum limit\n  *\n  * @returns {int|float}\n  *\n  * @see max\n  * @see min\n  */\n  p.constrain = function(aNumber, aMin, aMax) {\n    return aNumber > aMax ? aMax : aNumber < aMin ? aMin : aNumber;\n  };\n\n  /**\n  * Calculates the distance between two points.\n  *\n  * @param {int|float} x1     int or float: x-coordinate of the first point\n  * @param {int|float} y1     int or float: y-coordinate of the first point\n  * @param {int|float} z1     int or float: z-coordinate of the first point\n  * @param {int|float} x2     int or float: x-coordinate of the second point\n  * @param {int|float} y2     int or float: y-coordinate of the second point\n  * @param {int|float} z2     int or float: z-coordinate of the second point\n  *\n  * @returns {float}\n  */\n  p.dist = function() {\n    var dx, dy, dz;\n    if (arguments.length === 4) {\n      dx = arguments[0] - arguments[2];\n      dy = arguments[1] - arguments[3];\n      return Math.sqrt(dx * dx + dy * dy);\n    }\n    if (arguments.length === 6) {\n      dx = arguments[0] - arguments[3];\n      dy = arguments[1] - arguments[4];\n      dz = arguments[2] - arguments[5];\n      return Math.sqrt(dx * dx + dy * dy + dz * dz);\n    }\n  };\n\n  /**\n  * Calculates a number between two numbers at a specific increment. The amt  parameter is the\n  * amount to interpolate between the two values where 0.0 equal to the first point, 0.1 is very\n  * near the first point, 0.5 is half-way in between, etc. The lerp function is convenient for\n  * creating motion along a straight path and for drawing dotted lines.\n  *\n  * @param {int|float} value1       float or int: first value\n  * @param {int|float} value2       float or int: second value\n  * @param {int|float} amt          float: between 0.0 and 1.0\n  *\n  * @returns {float}\n  *\n  * @see curvePoint\n  * @see bezierPoint\n  */\n  p.lerp = function(value1, value2, amt) {\n    return ((value2 - value1) * amt) + value1;\n  };\n\n  /**\n  * Calculates the magnitude (or length) of a vector. A vector is a direction in space commonly\n  * used in computer graphics and linear algebra. Because it has no \"start\" position, the magnitude\n  * of a vector can be thought of as the distance from coordinate (0,0) to its (x,y) value.\n  * Therefore, mag() is a shortcut for writing \"dist(0, 0, x, y)\".\n  *\n  * @param {int|float} a       float or int: first value\n  * @param {int|float} b       float or int: second value\n  * @param {int|float} c       float or int: third value\n  *\n  * @returns {float}\n  *\n  * @see dist\n  */\n  p.mag = function(a, b, c) {\n    if (c) {\n      return Math.sqrt(a * a + b * b + c * c);\n    }\n\n    return Math.sqrt(a * a + b * b);\n  };\n\n  /**\n  * Re-maps a number from one range to another. In the example above, the number '25' is converted from\n  * a value in the range 0..100 into a value that ranges from the left edge (0) to the right edge (width) of the screen.\n  * Numbers outside the range are not clamped to 0 and 1, because out-of-range values are often intentional and useful.\n  *\n  * @param {float} value        The incoming value to be converted\n  * @param {float} istart       Lower bound of the value's current range\n  * @param {float} istop        Upper bound of the value's current range\n  * @param {float} ostart       Lower bound of the value's target range\n  * @param {float} ostop        Upper bound of the value's target range\n  *\n  * @returns {float}\n  *\n  * @see norm\n  * @see lerp\n  */\n  p.map = function(value, istart, istop, ostart, ostop) {\n    return ostart + (ostop - ostart) * ((value - istart) / (istop - istart));\n  };\n\n  /**\n  * Determines the largest value in a sequence of numbers.\n  *\n  * @param {int|float} value1         int or float\n  * @param {int|float} value2         int or float\n  * @param {int|float} value3         int or float\n  * @param {int|float} array          int or float array\n  *\n  * @returns {int|float}\n  *\n  * @see min\n  */\n  p.max = function() {\n    if (arguments.length === 2) {\n      return arguments[0] < arguments[1] ? arguments[1] : arguments[0];\n    }\n    var numbers = arguments.length === 1 ? arguments[0] : arguments; // if single argument, array is used\n    if (! (\"length\" in numbers && numbers.length > 0)) {\n      throw \"Non-empty array is expected\";\n    }\n    var max = numbers[0],\n      count = numbers.length;\n    for (var i = 1; i < count; ++i) {\n      if (max < numbers[i]) {\n        max = numbers[i];\n      }\n    }\n    return max;\n  };\n\n  /**\n  * Determines the smallest value in a sequence of numbers.\n  *\n  * @param {int|float} value1         int or float\n  * @param {int|float} value2         int or float\n  * @param {int|float} value3         int or float\n  * @param {int|float} array          int or float array\n  *\n  * @returns {int|float}\n  *\n  * @see max\n  */\n  p.min = function() {\n    if (arguments.length === 2) {\n      return arguments[0] < arguments[1] ? arguments[0] : arguments[1];\n    }\n    var numbers = arguments.length === 1 ? arguments[0] : arguments; // if single argument, array is used\n    if (! (\"length\" in numbers && numbers.length > 0)) {\n      throw \"Non-empty array is expected\";\n    }\n    var min = numbers[0],\n      count = numbers.length;\n    for (var i = 1; i < count; ++i) {\n      if (min > numbers[i]) {\n        min = numbers[i];\n      }\n    }\n    return min;\n  };\n\n  /**\n  * Normalizes a number from another range into a value between 0 and 1.\n  * Identical to map(value, low, high, 0, 1);\n  * Numbers outside the range are not clamped to 0 and 1, because out-of-range\n  * values are often intentional and useful.\n  *\n  * @param {float} aNumber    The incoming value to be converted\n  * @param {float} low        Lower bound of the value's current range\n  * @param {float} high       Upper bound of the value's current range\n  *\n  * @returns {float}\n  *\n  * @see map\n  * @see lerp\n  */\n  p.norm = function(aNumber, low, high) {\n    return (aNumber - low) / (high - low);\n  };\n\n  /**\n  * Squares a number (multiplies a number by itself). The result is always a positive number,\n  * as multiplying two negative numbers always yields a positive result. For example, -1 * -1 = 1.\n  *\n  * @param {float} value        int or float\n  *\n  * @returns {float}\n  *\n  * @see sqrt\n  */\n  p.sq = function(aNumber) {\n    return aNumber * aNumber;\n  };\n\n  /**\n  * Converts a radian measurement to its corresponding value in degrees. Radians and degrees are two ways of\n  * measuring the same thing. There are 360 degrees in a circle and 2*PI radians in a circle. For example,\n  * 90 degrees = PI/2 = 1.5707964. All trigonometric methods in Processing require their parameters to be specified in radians.\n  *\n  * @param {int|float} value        an angle in radians\n  *\n  * @returns {float}\n  *\n  * @see radians\n  */\n  p.degrees = function(aAngle) {\n    return (aAngle * 180) / Math.PI;\n  };\n\n  /**\n  * Generates random numbers. Each time the random() function is called, it returns an unexpected value within\n  * the specified range. If one parameter is passed to the function it will return a float between zero and the\n  * value of the high parameter. The function call random(5) returns values between 0 and 5 (starting at zero,\n  * up to but not including 5). If two parameters are passed, it will return a float with a value between the\n  * parameters. The function call random(-5, 10.2) returns values starting at -5 up to (but not including) 10.2.\n  * To convert a floating-point random number to an integer, use the int() function.\n  *\n  * @param {int|float} value1         if one parameter is used, the top end to random from, if two params the low end\n  * @param {int|float} value2         the top end of the random range\n  *\n  * @returns {float}\n  *\n  * @see randomSeed\n  * @see noise\n  */\n  p.random = function(aMin, aMax) {\n    if (arguments.length === 0) {\n      aMax = 1;\n      aMin = 0;\n    } else if (arguments.length === 1) {\n      aMax = aMin;\n      aMin = 0;\n    }\n    if (aMin === aMax) {\n      return aMin;\n    }\n    for (var i = 0; i < 100; i++) {\n      var ir = internalRandomGenerator();\n      var result = ir * (aMax - aMin) + aMin;\n      if (result !== aMax) {\n        return result;\n      }\n      // assertion: ir is never less than 0.5\n    }\n    return aMin;\n  };\n\n  // Pseudo-random generator\n  function Marsaglia(i1, i2) {\n    // from http://www.math.uni-bielefeld.de/~sillke/ALGORITHMS/random/marsaglia-c\n    var z=i1 || 362436069, w= i2 || 521288629;\n    var intGenerator = function() {\n      z=(36969*(z&65535)+(z>>>16)) & 0xFFFFFFFF;\n      w=(18000*(w&65535)+(w>>>16)) & 0xFFFFFFFF;\n      return (((z&0xFFFF)<<16) | (w&0xFFFF)) & 0xFFFFFFFF;\n    };\n\n    this.doubleGenerator = function() {\n      var i = intGenerator() / 4294967296;\n      return i < 0 ? 1 + i : i;\n    };\n    this.intGenerator = intGenerator;\n  }\n\n  Marsaglia.createRandomized = function() {\n    var now = new Date();\n    return new Marsaglia((now / 60000) & 0xFFFFFFFF, now & 0xFFFFFFFF);\n  };\n\n  /**\n  * Sets the seed value for random(). By default, random() produces different results each time the\n  * program is run. Set the value parameter to a constant to return the same pseudo-random numbers\n  * each time the software is run.\n  *\n  * @param {int|float} seed         int\n  *\n  * @see random\n  * @see noise\n  * @see noiseSeed\n  */\n  p.randomSeed = function(seed) {\n    internalRandomGenerator = (new Marsaglia(seed, (seed<<16)+(seed>>16))).doubleGenerator;\n    this.haveNextNextGaussian = false;\n  };\n\n  /**\n  * Returns a float from a random series of numbers having a mean of 0 and standard deviation of 1. Each time\n  * the randomGaussian() function is called, it returns a number fitting a Gaussian, or normal, distribution.\n  * There is theoretically no minimum or maximum value that randomGaussian() might return. Rather, there is just a\n  * very low probability that values far from the mean will be returned; and a higher probability that numbers\n  * near the mean will be returned.\n  *\n  * @returns {float}\n  *\n  * @see random\n  * @see noise\n  */\n  p.randomGaussian = function() {\n    if (this.haveNextNextGaussian) {\n      this.haveNextNextGaussian = false;\n      return this.nextNextGaussian;\n    }\n    var v1, v2, s;\n    do {\n      v1 = 2 * internalRandomGenerator() - 1; // between -1.0 and 1.0\n      v2 = 2 * internalRandomGenerator() - 1; // between -1.0 and 1.0\n      s = v1 * v1 + v2 * v2;\n    }\n    while (s >= 1 || s === 0);\n\n    var multiplier = Math.sqrt(-2 * Math.log(s) / s);\n    this.nextNextGaussian = v2 * multiplier;\n    this.haveNextNextGaussian = true;\n\n    return v1 * multiplier;\n  };\n\n  // Noise functions and helpers\n  function PerlinNoise(seed) {\n    var rnd = seed !== undef ? new Marsaglia(seed, (seed<<16)+(seed>>16)) : Marsaglia.createRandomized();\n    var i, j;\n    // http://www.noisemachine.com/talk1/17b.html\n    // http://mrl.nyu.edu/~perlin/noise/\n    // generate permutation\n    var perm = new Uint8Array(512);\n    for(i=0;i<256;++i) { perm[i] = i; }\n    for(i=0;i<256;++i) {\n      // NOTE: we can only do this because we've made sure the Marsaglia generator\n      //       gives us numbers where the last byte in a pseudo-random number is\n      //       still pseudo-random. If no 2nd argument is passed in the constructor,\n      //       that is no longer the case and this pair swap will always run identically.\n      var t = perm[j = rnd.intGenerator() & 0xFF];\n      perm[j] = perm[i];\n      perm[i] = t;\n    }\n    // copy to avoid taking mod in perm[0];\n    for(i=0;i<256;++i) { perm[i + 256] = perm[i]; }\n\n    function grad3d(i,x,y,z) {\n      var h = i & 15; // convert into 12 gradient directions\n      var u = h<8 ? x : y,\n          v = h<4 ? y : h===12||h===14 ? x : z;\n      return ((h&1) === 0 ? u : -u) + ((h&2) === 0 ? v : -v);\n    }\n\n    function grad2d(i,x,y) {\n      var v = (i & 1) === 0 ? x : y;\n      return (i&2) === 0 ? -v : v;\n    }\n\n    function grad1d(i,x) {\n      return (i&1) === 0 ? -x : x;\n    }\n\n    function lerp(t,a,b) { return a + t * (b - a); }\n\n    this.noise3d = function(x, y, z) {\n      var X = Math.floor(x)&255, Y = Math.floor(y)&255, Z = Math.floor(z)&255;\n      x -= Math.floor(x); y -= Math.floor(y); z -= Math.floor(z);\n      var fx = (3-2*x)*x*x, fy = (3-2*y)*y*y, fz = (3-2*z)*z*z;\n      var p0 = perm[X]+Y, p00 = perm[p0] + Z, p01 = perm[p0 + 1] + Z,\n          p1 = perm[X + 1] + Y, p10 = perm[p1] + Z, p11 = perm[p1 + 1] + Z;\n      return lerp(fz,\n        lerp(fy, lerp(fx, grad3d(perm[p00], x, y, z), grad3d(perm[p10], x-1, y, z)),\n                 lerp(fx, grad3d(perm[p01], x, y-1, z), grad3d(perm[p11], x-1, y-1,z))),\n        lerp(fy, lerp(fx, grad3d(perm[p00 + 1], x, y, z-1), grad3d(perm[p10 + 1], x-1, y, z-1)),\n                 lerp(fx, grad3d(perm[p01 + 1], x, y-1, z-1), grad3d(perm[p11 + 1], x-1, y-1,z-1))));\n    };\n\n    this.noise2d = function(x, y) {\n      var X = Math.floor(x)&255, Y = Math.floor(y)&255;\n      x -= Math.floor(x); y -= Math.floor(y);\n      var fx = (3-2*x)*x*x, fy = (3-2*y)*y*y;\n      var p0 = perm[X]+Y, p1 = perm[X + 1] + Y;\n      return lerp(fy,\n        lerp(fx, grad2d(perm[p0], x, y), grad2d(perm[p1], x-1, y)),\n        lerp(fx, grad2d(perm[p0 + 1], x, y-1), grad2d(perm[p1 + 1], x-1, y-1)));\n    };\n\n    this.noise1d = function(x) {\n      var X = Math.floor(x)&255;\n      x -= Math.floor(x);\n      var fx = (3-2*x)*x*x;\n      return lerp(fx, grad1d(perm[X], x), grad1d(perm[X+1], x-1));\n    };\n  }\n\n  // processing defaults\n  var noiseProfile = { generator: undef, octaves: 4, fallout: 0.5, seed: undef};\n\n  /**\n  * Returns the Perlin noise value at specified coordinates. Perlin noise is a random sequence\n  * generator producing a more natural ordered, harmonic succession of numbers compared to the\n  * standard random() function. It was invented by Ken Perlin in the 1980s and been used since\n  * in graphical applications to produce procedural textures, natural motion, shapes, terrains etc.\n  * The main difference to the random() function is that Perlin noise is defined in an infinite\n  * n-dimensional space where each pair of coordinates corresponds to a fixed semi-random value\n  * (fixed only for the lifespan of the program). The resulting value will always be between 0.0\n  * and 1.0. Processing can compute 1D, 2D and 3D noise, depending on the number of coordinates\n  * given. The noise value can be animated by moving through the noise space as demonstrated in\n  * the example above. The 2nd and 3rd dimension can also be interpreted as time.\n  * The actual noise is structured similar to an audio signal, in respect to the function's use\n  * of frequencies. Similar to the concept of harmonics in physics, perlin noise is computed over\n  * several octaves which are added together for the final result.\n  * Another way to adjust the character of the resulting sequence is the scale of the input\n  * coordinates. As the function works within an infinite space the value of the coordinates\n  * doesn't matter as such, only the distance between successive coordinates does (eg. when using\n  * noise() within a loop). As a general rule the smaller the difference between coordinates, the\n  * smoother the resulting noise sequence will be. Steps of 0.005-0.03 work best for most applications,\n  * but this will differ depending on use.\n  *\n  * @param {float} x          x coordinate in noise space\n  * @param {float} y          y coordinate in noise space\n  * @param {float} z          z coordinate in noise space\n  *\n  * @returns {float}\n  *\n  * @see random\n  * @see noiseDetail\n  */\n  p.noise = function(x, y, z) {\n    if(noiseProfile.generator === undef) {\n      // caching\n      noiseProfile.generator = new PerlinNoise(noiseProfile.seed);\n    }\n    var generator = noiseProfile.generator;\n    var effect = 1, k = 1, sum = 0;\n    for(var i=0; i<noiseProfile.octaves; ++i) {\n      effect *= noiseProfile.fallout;\n      switch (arguments.length) {\n      case 1:\n        sum += effect * (1 + generator.noise1d(k*x))/2; break;\n      case 2:\n        sum += effect * (1 + generator.noise2d(k*x, k*y))/2; break;\n      case 3:\n        sum += effect * (1 + generator.noise3d(k*x, k*y, k*z))/2; break;\n      }\n      k *= 2;\n    }\n    return sum;\n  };\n\n  /**\n  * Adjusts the character and level of detail produced by the Perlin noise function.\n  * Similar to harmonics in physics, noise is computed over several octaves. Lower octaves\n  * contribute more to the output signal and as such define the overal intensity of the noise,\n  * whereas higher octaves create finer grained details in the noise sequence. By default,\n  * noise is computed over 4 octaves with each octave contributing exactly half than its\n  * predecessor, starting at 50% strength for the 1st octave. This falloff amount can be\n  * changed by adding an additional function parameter. Eg. a falloff factor of 0.75 means\n  * each octave will now have 75% impact (25% less) of the previous lower octave. Any value\n  * between 0.0 and 1.0 is valid, however note that values greater than 0.5 might result in\n  * greater than 1.0 values returned by noise(). By changing these parameters, the signal\n  * created by the noise() function can be adapted to fit very specific needs and characteristics.\n  *\n  * @param {int} octaves          number of octaves to be used by the noise() function\n  * @param {float} falloff        falloff factor for each octave\n  *\n  * @see noise\n  */\n  p.noiseDetail = function(octaves, fallout) {\n    noiseProfile.octaves = octaves;\n    if(fallout !== undef) {\n      noiseProfile.fallout = fallout;\n    }\n  };\n\n  /**\n  * Sets the seed value for noise(). By default, noise() produces different results each\n  * time the program is run. Set the value parameter to a constant to return the same\n  * pseudo-random numbers each time the software is run.\n  *\n  * @param {int} seed         int\n  *\n  * @returns {float}\n  *\n  * @see random\n  * @see radomSeed\n  * @see noise\n  * @see noiseDetail\n  */\n  p.noiseSeed = function(seed) {\n    noiseProfile.seed = seed;\n    noiseProfile.generator = undef;\n  };\n};\n\n},{}],23:[function(require,module,exports){\n/**\n * Common functions traditionally on \"p\" that should be class functions\n * that get bound to \"p\" when an instance is actually built, instead.\n */\nmodule.exports = (function commonFunctions(undef) {\n\n  var CommonFunctions = {\n    /**\n     * Remove whitespace characters from the beginning and ending\n     * of a String or a String array. Works like String.trim() but includes the\n     * unicode nbsp character as well. If an array is passed in the function will return a new array not effecting the array passed in.\n     *\n     * @param {String} str    the string to trim\n     * @param {String[]} str  the string array to trim\n     *\n     * @return {String|String[]} retrurns a string or an array will removed whitespaces\n     */\n    trim: function(str) {\n      if (str instanceof Array) {\n        var arr = [];\n        for (var i = 0; i < str.length; i++) {\n          arr.push(str[i].replace(/^\\s*/, '').replace(/\\s*$/, '').replace(/\\r*$/, ''));\n        }\n        return arr;\n      }\n      return str.replace(/^\\s*/, '').replace(/\\s*$/, '').replace(/\\r*$/, '');\n    },\n\n    /**\n     * Converts a degree measurement to its corresponding value in radians. Radians and degrees are two ways of\n     * measuring the same thing. There are 360 degrees in a circle and 2*PI radians in a circle. For example,\n     * 90 degrees = PI/2 = 1.5707964. All trigonometric methods in Processing require their parameters to be specified in radians.\n     *\n     * @param {int|float} value        an angle in radians\n     *\n     * @returns {float}\n     *\n     * @see degrees\n     */\n    radians: function(aAngle) {\n      return (aAngle / 180) * Math.PI;\n    },\n\n    /**\n     * Number-to-String formatting function. Prepends \"plus\" or \"minus\" depending\n     * on whether the value is positive or negative, respectively, after padding\n     * the value with zeroes on the left and right, the number of zeroes used dictated\n     * by the values 'leftDigits' and 'rightDigits'. 'value' cannot be an array.\n     *\n     * @param {int|float} value                 the number to format\n     * @param {String} plus                     the prefix for positive numbers\n     * @param {String} minus                    the prefix for negative numbers\n     * @param {int} left                        number of digits to the left of the decimal point\n     * @param {int} right                       number of digits to the right of the decimal point\n     * @param {String} group                    string delimited for groups, such as the comma in \"1,000\"\n     *\n     * @returns {String or String[]}\n     *\n     * @see nfCore\n     */\n    nfCoreScalar: function (value, plus, minus, leftDigits, rightDigits, group) {\n      var sign = (value < 0) ? minus : plus;\n      var autoDetectDecimals = rightDigits === 0;\n      var rightDigitsOfDefault = (rightDigits === undef || rightDigits < 0) ? 0 : rightDigits;\n\n      var absValue = Math.abs(value);\n      if (autoDetectDecimals) {\n        rightDigitsOfDefault = 1;\n        absValue *= 10;\n        while (Math.abs(Math.round(absValue) - absValue) > 1e-6 && rightDigitsOfDefault < 7) {\n          ++rightDigitsOfDefault;\n          absValue *= 10;\n        }\n      } else if (rightDigitsOfDefault !== 0) {\n        absValue *= Math.pow(10, rightDigitsOfDefault);\n      }\n\n      // Using Java's default rounding policy HALF_EVEN. This policy is based\n      // on the idea that 0.5 values round to the nearest even number, and\n      // everything else is rounded normally.\n      var number, doubled = absValue * 2;\n      if (Math.floor(absValue) === absValue) {\n        number = absValue;\n      } else if (Math.floor(doubled) === doubled) {\n        var floored = Math.floor(absValue);\n        number = floored + (floored % 2);\n      } else {\n        number = Math.round(absValue);\n      }\n\n      var buffer = \"\";\n      var totalDigits = leftDigits + rightDigitsOfDefault;\n      while (totalDigits > 0 || number > 0) {\n        totalDigits--;\n        buffer = \"\" + (number % 10) + buffer;\n        number = Math.floor(number / 10);\n      }\n      if (group !== undef) {\n        var i = buffer.length - 3 - rightDigitsOfDefault;\n        while(i > 0) {\n          buffer = buffer.substring(0,i) + group + buffer.substring(i);\n          i-=3;\n        }\n      }\n      if (rightDigitsOfDefault > 0) {\n        return sign + buffer.substring(0, buffer.length - rightDigitsOfDefault) +\n               \".\" + buffer.substring(buffer.length - rightDigitsOfDefault, buffer.length);\n      }\n      return sign + buffer;\n    },\n\n    /**\n    * Number-to-String formatting function. Prepends \"plus\" or \"minus\" depending\n    * on whether the value is positive or negative, respectively, after padding\n    * the value with zeroes on the left and right, the number of zeroes used dictated\n    * by the values 'leftDigits' and 'rightDigits'. 'value' can be an array;\n    * if the input is an array, each value in it is formatted separately, and\n    * an array with formatted values is returned.\n    *\n    * @param {int|int[]|float|float[]} value   the number(s) to format\n    * @param {String} plus                     the prefix for positive numbers\n    * @param {String} minus                    the prefix for negative numbers\n    * @param {int} left                        number of digits to the left of the decimal point\n    * @param {int} right                       number of digits to the right of the decimal point\n    * @param {String} group                    string delimited for groups, such as the comma in \"1,000\"\n    *\n    * @returns {String or String[]}\n    *\n    * @see nfCoreScalar\n    */\n    nfCore: function(value, plus, minus, leftDigits, rightDigits, group) {\n      if (value instanceof Array) {\n        var arr = [];\n        for (var i = 0, len = value.length; i < len; i++) {\n          arr.push(CommonFunctions.nfCoreScalar(value[i], plus, minus, leftDigits, rightDigits, group));\n        }\n        return arr;\n      }\n      return CommonFunctions.nfCoreScalar(value, plus, minus, leftDigits, rightDigits, group);\n    },\n\n    /**\n    * Utility function for formatting numbers into strings. There are two versions, one for\n    * formatting floats and one for formatting ints. The values for the digits, left, and\n    * right parameters should always be positive integers.\n    * As shown in the above example, nf() is used to add zeros to the left and/or right\n    * of a number. This is typically for aligning a list of numbers. To remove digits from\n    * a floating-point number, use the int(), ceil(), floor(), or round() functions.\n    *\n    * @param {int|int[]|float|float[]} value   the number(s) to format\n    * @param {int} left                        number of digits to the left of the decimal point\n    * @param {int} right                       number of digits to the right of the decimal point\n    *\n    * @returns {String or String[]}\n    *\n    * @see nfs\n    * @see nfp\n    * @see nfc\n    */\n    nf: function(value, leftDigits, rightDigits) {\n      return CommonFunctions.nfCore(value, \"\", \"-\", leftDigits, rightDigits);\n    },\n\n    /**\n    * Utility function for formatting numbers into strings. Similar to nf()  but leaves a blank space in front\n    * of positive numbers so they align with negative numbers in spite of the minus symbol. There are two\n    * versions, one for formatting floats and one for formatting ints. The values for the digits, left,\n    * and right parameters should always be positive integers.\n    *\n    * @param {int|int[]|float|float[]} value   the number(s) to format\n    * @param {int} left                        number of digits to the left of the decimal point\n    * @param {int} right                       number of digits to the right of the decimal point\n    *\n    * @returns {String or String[]}\n    *\n    * @see nf\n    * @see nfp\n    * @see nfc\n    */\n    nfs: function(value, leftDigits, rightDigits) {\n      return CommonFunctions.nfCore(value, \" \", \"-\", leftDigits, rightDigits);\n    },\n\n    /**\n    * Utility function for formatting numbers into strings. Similar to nf()  but puts a \"+\" in front of\n    * positive numbers and a \"-\" in front of negative numbers. There are two versions, one for formatting\n    * floats and one for formatting ints. The values for the digits, left, and right parameters should\n    * always be positive integers.\n    *\n    * @param {int|int[]|float|float[]} value   the number(s) to format\n    * @param {int} left                        number of digits to the left of the decimal point\n    * @param {int} right                       number of digits to the right of the decimal point\n    *\n    * @returns {String or String[]}\n    *\n    * @see nfs\n    * @see nf\n    * @see nfc\n    */\n    nfp: function(value, leftDigits, rightDigits) {\n      return CommonFunctions.nfCore(value, \"+\", \"-\", leftDigits, rightDigits);\n    },\n\n    /**\n    * Utility function for formatting numbers into strings and placing appropriate commas to mark\n    * units of 1000. There are two versions, one for formatting ints and one for formatting an array\n    * of ints. The value for the digits parameter should always be a positive integer.\n    *\n    * @param {int|int[]|float|float[]} value   the number(s) to format\n    * @param {int} left                        number of digits to the left of the decimal point\n    * @param {int} right                       number of digits to the right of the decimal point\n    *\n    * @returns {String or String[]}\n    *\n    * @see nf\n    * @see nfs\n    * @see nfp\n    */\n    nfc: function(value, rightDigits) {\n      return CommonFunctions.nfCore(value, \"\", \"-\", 0, rightDigits, \",\");\n    },\n\n    // used to bind all common functions to \"p\"\n    withCommonFunctions: function withCommonFunctions(p) {\n      [\"trim\", \"radians\", \"nf\", \"nfs\", \"nfp\", \"nfc\"].forEach(function(f){\n        p[f] = CommonFunctions[f];\n      });\n    }\n  };\n\n  return CommonFunctions;\n}());\n\n},{}],24:[function(require,module,exports){\n/**\n * Touch and Mouse event handling\n */\nmodule.exports = function withTouch(p, curElement, attachEventHandler, document, PConstants, undef) {\n\n  /**\n   * Determine the location of the (mouse) pointer.\n   */\n  function calculateOffset(curElement, event) {\n    var element = curElement,\n      offsetX = 0,\n      offsetY = 0;\n\n    p.pmouseX = p.mouseX;\n    p.pmouseY = p.mouseY;\n\n    // Find element offset\n    if (element.offsetParent) {\n      do {\n        offsetX += element.offsetLeft;\n        offsetY += element.offsetTop;\n      } while (!!(element = element.offsetParent));\n    }\n\n    // Find Scroll offset\n    element = curElement;\n    do {\n      offsetX -= element.scrollLeft || 0;\n      offsetY -= element.scrollTop || 0;\n    } while (!!(element = element.parentNode));\n\n    // Get padding and border style widths for mouse offsets\n    var stylePaddingLeft, stylePaddingTop, styleBorderLeft, styleBorderTop;\n    if (document.defaultView && document.defaultView.getComputedStyle) {\n      stylePaddingLeft = parseInt(document.defaultView.getComputedStyle(curElement, null).paddingLeft, 10)      || 0;\n      stylePaddingTop  = parseInt(document.defaultView.getComputedStyle(curElement, null).paddingTop, 10)       || 0;\n      styleBorderLeft  = parseInt(document.defaultView.getComputedStyle(curElement, null).borderLeftWidth, 10)  || 0;\n      styleBorderTop   = parseInt(document.defaultView.getComputedStyle(curElement, null).borderTopWidth, 10)   || 0;\n    }\n\n    // Add padding and border style widths to offset\n    offsetX += stylePaddingLeft;\n    offsetY += stylePaddingTop;\n\n    offsetX += styleBorderLeft;\n    offsetY += styleBorderTop;\n\n    // Take into account any scrolling done\n    offsetX += window.pageXOffset;\n    offsetY += window.pageYOffset;\n\n    return {'X':offsetX,'Y':offsetY};\n  }\n\n  // simple relative position\n  function updateMousePosition(curElement, event) {\n    var offset = calculateOffset(curElement, event);\n    // Dropping support for IE clientX and clientY, switching to pageX and pageY\n    // so we don't have to calculate scroll offset.\n    // Removed in ticket #184. See rev: 2f106d1c7017fed92d045ba918db47d28e5c16f4\n    p.mouseX = event.pageX - offset.X;\n    p.mouseY = event.pageY - offset.Y;\n  }\n\n  /**\n   * Return a TouchEvent with canvas-specific x/y co-ordinates\n   */\n  function addTouchEventOffset(t) {\n    var offset = calculateOffset(t.changedTouches[0].target, t.changedTouches[0]),\n        i;\n\n    for (i = 0; i < t.touches.length; i++) {\n      var touch = t.touches[i];\n      touch.offsetX = touch.pageX - offset.X;\n      touch.offsetY = touch.pageY - offset.Y;\n    }\n    for (i = 0; i < t.targetTouches.length; i++) {\n      var targetTouch = t.targetTouches[i];\n      targetTouch.offsetX = targetTouch.pageX - offset.X;\n      targetTouch.offsetY = targetTouch.pageY - offset.Y;\n    }\n    for (i = 0; i < t.changedTouches.length; i++) {\n      var changedTouch = t.changedTouches[i];\n      changedTouch.offsetX = changedTouch.pageX - offset.X;\n      changedTouch.offsetY = changedTouch.pageY - offset.Y;\n    }\n\n    return t;\n  }\n\n  /**\n   * Touch event support.\n   */\n  attachEventHandler(curElement, \"touchstart\", function (t) {\n    // Removes unwanted behaviour of the canvas when touching canvas\n    curElement.setAttribute(\"style\",\"-webkit-user-select: none\");\n    curElement.setAttribute(\"onclick\",\"void(0)\");\n    curElement.setAttribute(\"style\",\"-webkit-tap-highlight-color:rgba(0,0,0,0)\");\n    // Loop though eventHandlers and remove mouse listeners\n    for (var i=0, ehl=eventHandlers.length; i<ehl; i++) {\n      var type = eventHandlers[i].type;\n      // Have this function remove itself from the eventHandlers list too\n      if (type === \"mouseout\" ||  type === \"mousemove\" ||\n          type === \"mousedown\" || type === \"mouseup\" ||\n          type === \"DOMMouseScroll\" || type === \"mousewheel\" || type === \"touchstart\") {\n        detachEventHandler(eventHandlers[i]);\n      }\n    }\n\n    // If there are any native touch events defined in the sketch, connect all of them\n    // Otherwise, connect all of the emulated mouse events\n    if (p.touchStart !== undef || p.touchMove !== undef ||\n        p.touchEnd !== undef || p.touchCancel !== undef) {\n      attachEventHandler(curElement, \"touchstart\", function(t) {\n        if (p.touchStart !== undef) {\n          t = addTouchEventOffset(t);\n          p.touchStart(t);\n        }\n      });\n\n      attachEventHandler(curElement, \"touchmove\", function(t) {\n        if (p.touchMove !== undef) {\n          t.preventDefault(); // Stop the viewport from scrolling\n          t = addTouchEventOffset(t);\n          p.touchMove(t);\n        }\n      });\n\n      attachEventHandler(curElement, \"touchend\", function(t) {\n        if (p.touchEnd !== undef) {\n          t = addTouchEventOffset(t);\n          p.touchEnd(t);\n        }\n      });\n\n      attachEventHandler(curElement, \"touchcancel\", function(t) {\n        if (p.touchCancel !== undef) {\n          t = addTouchEventOffset(t);\n          p.touchCancel(t);\n        }\n      });\n\n    } else {\n      // Emulated touch start/mouse down event\n      attachEventHandler(curElement, \"touchstart\", function(e) {\n        updateMousePosition(curElement, e.touches[0]);\n\n        p.__mousePressed = true;\n        p.mouseDragging = false;\n        p.mouseButton = PConstants.LEFT;\n\n        if (typeof p.mousePressed === \"function\") {\n          p.mousePressed();\n        }\n      });\n\n      // Emulated touch move/mouse move event\n      attachEventHandler(curElement, \"touchmove\", function(e) {\n        e.preventDefault();\n        updateMousePosition(curElement, e.touches[0]);\n\n        if (typeof p.mouseMoved === \"function\" && !p.__mousePressed) {\n          p.mouseMoved();\n        }\n        if (typeof p.mouseDragged === \"function\" && p.__mousePressed) {\n          p.mouseDragged();\n          p.mouseDragging = true;\n        }\n      });\n\n      // Emulated touch up/mouse up event\n      attachEventHandler(curElement, \"touchend\", function(e) {\n        p.__mousePressed = false;\n\n        if (typeof p.mouseClicked === \"function\" && !p.mouseDragging) {\n          p.mouseClicked();\n        }\n\n        if (typeof p.mouseReleased === \"function\") {\n          p.mouseReleased();\n        }\n      });\n    }\n\n    // Refire the touch start event we consumed in this function\n    curElement.dispatchEvent(t);\n  });\n\n  /**\n   * Context menu toggles. Most often you will not want the\n   * browser's context menu to show on a right click, but\n   * sometimes, you do, so we add two unofficial functions\n   * that can be used to trigger context menu behaviour.\n   */\n  (function() {\n    var enabled = true,\n        contextMenu = function(e) {\n          e.preventDefault();\n          e.stopPropagation();\n        };\n\n    p.disableContextMenu = function() {\n      if (!enabled) {\n        return;\n      }\n      attachEventHandler(curElement, 'contextmenu', contextMenu);\n      enabled = false;\n    };\n\n    p.enableContextMenu = function() {\n      if (enabled) {\n        return;\n      }\n      detachEventHandler({elem: curElement, type: 'contextmenu', fn: contextMenu});\n      enabled = true;\n    };\n  }());\n\n  /**\n   * Mouse moved or dragged\n   */\n  attachEventHandler(curElement, \"mousemove\", function(e) {\n    updateMousePosition(curElement, e);\n    if (typeof p.mouseMoved === \"function\" && !p.__mousePressed) {\n      p.mouseMoved();\n    }\n    if (typeof p.mouseDragged === \"function\" && p.__mousePressed) {\n      p.mouseDragged();\n      p.mouseDragging = true;\n    }\n  });\n\n  /**\n   * Unofficial mouse-out handling\n   */\n  attachEventHandler(curElement, \"mouseout\", function(e) {\n    if (typeof p.mouseOut === \"function\") {\n      p.mouseOut();\n    }\n  });\n\n  /**\n   * Mouse over\n   */\n  attachEventHandler(curElement, \"mouseover\", function(e) {\n    updateMousePosition(curElement, e);\n    if (typeof p.mouseOver === \"function\") {\n      p.mouseOver();\n    }\n  });\n\n  /**\n   * Disable browser's default handling for click-drag of a canvas.\n   */\n  curElement.onmousedown = function () {\n    // make sure focus happens, but nothing else\n    curElement.focus();\n    return false;\n  };\n\n  /**\n   * Mouse pressed or drag\n   */\n  attachEventHandler(curElement, \"mousedown\", function(e) {\n    p.__mousePressed = true;\n    p.mouseDragging = false;\n    switch (e.which) {\n    case 1:\n      p.mouseButton = PConstants.LEFT;\n      break;\n    case 2:\n      p.mouseButton = PConstants.CENTER;\n      break;\n    case 3:\n      p.mouseButton = PConstants.RIGHT;\n      break;\n    }\n\n    if (typeof p.mousePressed === \"function\") {\n      p.mousePressed();\n    }\n  });\n\n  /**\n   * Mouse clicked or released\n   */\n  attachEventHandler(curElement, \"mouseup\", function(e) {\n    p.__mousePressed = false;\n\n    if (typeof p.mouseClicked === \"function\" && !p.mouseDragging) {\n      p.mouseClicked();\n    }\n\n    if (typeof p.mouseReleased === \"function\") {\n      p.mouseReleased();\n    }\n  });\n\n  /**\n   * Unofficial scroll wheel handling.\n   */\n  var mouseWheelHandler = function(e) {\n    // do not handle scroll wheel if initiated outside of the sketch\n    if (e.target !== curElement) return;\n\n    var delta = 0;\n\n    if (e.wheelDelta) {\n      delta = e.wheelDelta / 120;\n      if (window.opera) {\n        delta = -delta;\n      }\n    } else if (e.detail) {\n      delta = -e.detail / 3;\n    }\n\n    p.mouseScroll = delta;\n\n    if (delta && typeof p.mouseScrolled === 'function') {\n      // If this sketch has explicit scroll handling,\n      // prevent scroll from kicking in globally before\n      // calling the scroll handler.\n      e.stopPropagation();\n      e.preventDefault();   \n      p.mouseScrolled();\n    }\n  };\n\n  // Support Gecko and non-Gecko scroll events\n  attachEventHandler(document, 'DOMMouseScroll', mouseWheelHandler);\n  attachEventHandler(document, 'mousewheel', mouseWheelHandler);\n\n};\n\n\n},{}],25:[function(require,module,exports){\n/**\n * The parser for turning Processing syntax into Pjs JavaScript.\n * This code is not trivial; unless you know what you're doing,\n * you shouldn't be changing things in here =)\n */\nmodule.exports = function setupParser(Processing, options) {\n\n  var defaultScope = options.defaultScope,\n      PConstants = defaultScope.PConstants,\n      aFunctions = options.aFunctions,\n      Browser = options.Browser,\n      document = Browser.document,\n      undef;\n\n  // Processing global methods and constants for the parser\n  function getGlobalMembers() {\n    // The names array contains the names of everything that is inside \"p.\"\n    // When something new is added to \"p.\" it must also be added to this list.\n    var names = [ /* this code is generated by jsglobals.js */\n      \"abs\", \"acos\", \"alpha\", \"ambient\", \"ambientLight\", \"append\", \"applyMatrix\",\n      \"arc\", \"arrayCopy\", \"asin\", \"atan\", \"atan2\", \"background\", \"beginCamera\",\n      \"beginDraw\", \"beginShape\", \"bezier\", \"bezierDetail\", \"bezierPoint\",\n      \"bezierTangent\", \"bezierVertex\", \"binary\", \"blend\", \"blendColor\",\n      \"blit_resize\", \"blue\", \"box\", \"breakShape\", \"brightness\",\n      \"camera\", \"ceil\", \"Character\", \"color\", \"colorMode\",\n      \"concat\", \"constrain\", \"copy\", \"cos\", \"createFont\",\n      \"createGraphics\", \"createImage\", \"cursor\", \"curve\", \"curveDetail\",\n      \"curvePoint\", \"curveTangent\", \"curveTightness\", \"curveVertex\", \"day\",\n      \"degrees\", \"directionalLight\", \"disableContextMenu\",\n      \"dist\", \"draw\", \"ellipse\", \"ellipseMode\", \"emissive\", \"enableContextMenu\",\n      \"endCamera\", \"endDraw\", \"endShape\", \"exit\", \"exp\", \"expand\", \"externals\",\n      \"fill\", \"filter\", \"floor\", \"focused\", \"frameCount\", \"frameRate\", \"frustum\",\n      \"get\", \"glyphLook\", \"glyphTable\", \"green\", \"height\", \"hex\", \"hint\", \"hour\",\n      \"hue\", \"image\", \"imageMode\", \"intersect\", \"join\", \"key\",\n      \"keyCode\", \"keyPressed\", \"keyReleased\", \"keyTyped\", \"lerp\", \"lerpColor\",\n      \"lightFalloff\", \"lights\", \"lightSpecular\", \"line\", \"link\", \"loadBytes\",\n      \"loadFont\", \"loadGlyphs\", \"loadImage\", \"loadPixels\", \"loadShape\", \"loadXML\",\n      \"loadStrings\", \"log\", \"loop\", \"mag\", \"map\", \"match\", \"matchAll\", \"max\",\n      \"millis\", \"min\", \"minute\", \"mix\", \"modelX\", \"modelY\", \"modelZ\", \"modes\",\n      \"month\", \"mouseButton\", \"mouseClicked\", \"mouseDragged\", \"mouseMoved\",\n      \"mouseOut\", \"mouseOver\", \"mousePressed\", \"mouseReleased\", \"mouseScroll\",\n      \"mouseScrolled\", \"mouseX\", \"mouseY\", \"name\", \"nf\", \"nfc\", \"nfp\", \"nfs\",\n      \"noCursor\", \"noFill\", \"noise\", \"noiseDetail\", \"noiseSeed\", \"noLights\",\n      \"noLoop\", \"norm\", \"normal\", \"noSmooth\", \"noStroke\", \"noTint\", \"ortho\",\n      \"param\", \"parseBoolean\", \"parseByte\", \"parseChar\", \"parseFloat\",\n      \"parseInt\", \"parseXML\", \"peg\", \"perspective\", \"PImage\", \"pixels\",\n      \"PMatrix2D\", \"PMatrix3D\", \"PMatrixStack\", \"pmouseX\", \"pmouseY\", \"point\",\n      \"pointLight\", \"popMatrix\", \"popStyle\", \"pow\", \"print\", \"printCamera\",\n      \"println\", \"printMatrix\", \"printProjection\", \"PShape\", \"PShapeSVG\",\n      \"pushMatrix\", \"pushStyle\", \"quad\", \"radians\", \"random\", \"randomGaussian\",\n      \"randomSeed\", \"rect\", \"rectMode\", \"red\", \"redraw\", \"requestImage\",\n      \"resetMatrix\", \"reverse\", \"rotate\", \"rotateX\", \"rotateY\", \"rotateZ\",\n      \"round\", \"saturation\", \"save\", \"saveFrame\", \"saveStrings\", \"scale\",\n      \"screenX\", \"screenY\", \"screenZ\", \"second\", \"set\", \"setup\", \"shape\",\n      \"shapeMode\", \"shared\", \"shearX\", \"shearY\", \"shininess\", \"shorten\", \"sin\", \"size\", \"smooth\",\n      \"sort\", \"specular\", \"sphere\", \"sphereDetail\", \"splice\", \"split\",\n      \"splitTokens\", \"spotLight\", \"sq\", \"sqrt\", \"status\", \"str\", \"stroke\",\n      \"strokeCap\", \"strokeJoin\", \"strokeWeight\", \"subset\", \"tan\", \"text\",\n      \"textAlign\", \"textAscent\", \"textDescent\", \"textFont\", \"textLeading\",\n      \"textMode\", \"textSize\", \"texture\", \"textureMode\", \"textWidth\", \"tint\", \"toImageData\",\n      \"touchCancel\", \"touchEnd\", \"touchMove\", \"touchStart\", \"translate\", \"transform\",\n      \"triangle\", \"trim\", \"unbinary\", \"unhex\", \"updatePixels\", \"use3DContext\",\n      \"vertex\", \"width\", \"XMLElement\", \"XML\", \"year\", \"__contains\", \"__equals\",\n      \"__equalsIgnoreCase\", \"__frameRate\", \"__hashCode\", \"__int_cast\",\n      \"__instanceof\", \"__keyPressed\", \"__mousePressed\", \"__printStackTrace\",\n      \"__replace\", \"__replaceAll\", \"__replaceFirst\", \"__toCharArray\", \"__split\",\n      \"__codePointAt\", \"__startsWith\", \"__endsWith\", \"__matches\"];\n\n    // custom functions and properties are added here\n    if(aFunctions) {\n      Object.keys(aFunctions).forEach(function(name) {\n        names.push(name);\n      });\n    }\n\n    // custom libraries that were attached to Processing\n    var members = {};\n    var i, l;\n    for (i = 0, l = names.length; i < l ; ++i) {\n      members[names[i]] = null;\n    }\n    for (var lib in Processing.lib) {\n      if (Processing.lib.hasOwnProperty(lib)) {\n        if (Processing.lib[lib].exports) {\n          var exportedNames = Processing.lib[lib].exports;\n          for (i = 0, l = exportedNames.length; i < l; ++i) {\n           members[exportedNames[i]] = null;\n          }\n        }\n      }\n    }\n    return members;\n  }\n\n  /*\n\n    Parser converts Java-like syntax into JavaScript.\n    Creates an Abstract Syntax Tree -- \"Light AST\" from the Java-like code.\n\n    It is an object tree. The root object is created from the AstRoot class, which contains statements.\n\n    A statement object can be of type: AstForStatement, AstCatchStatement, AstPrefixStatement, AstMethod, AstClass,\n    AstInterface, AstFunction, AstStatementBlock and AstLabel.\n\n    AstPrefixStatement can be a statement of type: if, switch, while, with, do, else, finally, return, throw, try, break, and continue.\n\n    These object's toString function returns the JavaScript code for the statement.\n\n    Any processing calls need \"processing.\" prepended to them.\n\n    Similarly, calls from inside classes need \"$this_1.\", prepended to them,\n    with 1 being the depth level for inner classes.\n    This includes members passed down from inheritance.\n\n    The resulting code is then eval'd and run.\n\n  */\n\n  function parseProcessing(code) {\n    var globalMembers = getGlobalMembers();\n\n    // masks parentheses, brackets and braces with '\"A5\"'\n    // where A is the bracket type, and 5 is the index in an array containing all brackets split into atoms\n    // 'while(true){}' -> 'while\"B1\"\"A2\"'\n    // parentheses() = B, brackets[] = C and braces{} = A\n    function splitToAtoms(code) {\n      var atoms = [];\n      var items = code.split(/([\\{\\[\\(\\)\\]\\}])/);\n      var result = items[0];\n\n      var stack = [];\n      for(var i=1; i < items.length; i += 2) {\n        var item = items[i];\n        if(item === '[' || item === '{' || item === '(') {\n          stack.push(result); result = item;\n        } else if(item === ']' || item === '}' || item === ')') {\n          var kind = item === '}' ? 'A' : item === ')' ? 'B' : 'C';\n          var index = atoms.length; atoms.push(result + item);\n          result = stack.pop() + '\"' + kind + (index + 1) + '\"';\n        }\n        result += items[i + 1];\n      }\n      atoms.unshift(result);\n      return atoms;\n    }\n\n    // replaces strings and regexs keyed by index with an array of strings\n    function injectStrings(code, strings) {\n      return code.replace(/'(\\d+)'/g, function(all, index) {\n        var val = strings[index];\n        if(val.charAt(0) === \"/\") {\n          return val;\n        }\n        return (/^'((?:[^'\\\\\\n])|(?:\\\\.[0-9A-Fa-f]*))'$/).test(val) ? \"(new $p.Character(\" + val + \"))\" : val;\n      });\n    }\n\n    // trims off leading and trailing spaces\n    // returns an object. object.left, object.middle, object.right, object.untrim\n    function trimSpaces(string) {\n      var m1 = /^\\s*/.exec(string), result;\n      if(m1[0].length === string.length) {\n        result = {left: m1[0], middle: \"\", right: \"\"};\n      } else {\n        var m2 = /\\s*$/.exec(string);\n        result = {left: m1[0], middle: string.substring(m1[0].length, m2.index), right: m2[0]};\n      }\n      result.untrim = function(t) { return this.left + t + this.right; };\n      return result;\n    }\n\n    // simple trim of leading and trailing spaces\n    function trim(string) {\n      return string.replace(/^\\s+/,'').replace(/\\s+$/,'');\n    }\n\n    function appendToLookupTable(table, array) {\n      for(var i=0,l=array.length;i<l;++i) {\n        table[array[i]] = null;\n      }\n      return table;\n    }\n\n    function isLookupTableEmpty(table) {\n      for(var i in table) {\n        if(table.hasOwnProperty(i)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    function getAtomIndex(templ) { return templ.substring(2, templ.length - 1); }\n\n    // remove carriage returns \"\\r\"\n    var codeWoExtraCr = code.replace(/\\r\\n?|\\n\\r/g, \"\\n\");\n\n    // masks strings and regexs with \"'5'\", where 5 is the index in an array containing all strings and regexs\n    // also removes all comments\n    var strings = [];\n    var codeWoStrings = codeWoExtraCr.replace(/(\"(?:[^\"\\\\\\n]|\\\\.)*\")|('(?:[^'\\\\\\n]|\\\\.)*')|(([\\[\\(=|&!\\^:?]\\s*)(\\/(?![*\\/])(?:[^\\/\\\\\\n]|\\\\.)*\\/[gim]*)\\b)|(\\/\\/[^\\n]*\\n)|(\\/\\*(?:(?!\\*\\/)(?:.|\\n))*\\*\\/)/g,\n    function(all, quoted, aposed, regexCtx, prefix, regex, singleComment, comment) {\n      var index;\n      if(quoted || aposed) { // replace strings\n        index = strings.length; strings.push(all);\n        return \"'\" + index + \"'\";\n      }\n      if(regexCtx) { // replace RegExps\n        index = strings.length; strings.push(regex);\n        return prefix + \"'\" + index + \"'\";\n      }\n      // kill comments\n      return comment !== \"\" ? \" \" : \"\\n\";\n    });\n\n    // protect character codes from namespace collision\n    codeWoStrings = codeWoStrings.replace(/__x([0-9A-F]{4})/g, function(all, hexCode) {\n      // $ = __x0024\n      // _ = __x005F\n      // this protects existing character codes from conversion\n      // __x0024 = __x005F_x0024\n      return \"__x005F_x\" + hexCode;\n    });\n\n    // convert dollar sign to character code\n    codeWoStrings = codeWoStrings.replace(/\\$/g, \"__x0024\");\n\n    // Remove newlines after return statements\n    codeWoStrings = codeWoStrings.replace(/return\\s*[\\n\\r]+/g, \"return \");\n\n    // removes generics\n    var genericsWereRemoved;\n    var codeWoGenerics = codeWoStrings;\n    var replaceFunc = function(all, before, types, after) {\n      if(!!before || !!after) {\n        return all;\n      }\n      genericsWereRemoved = true;\n      return \"\";\n    };\n\n    do {\n      genericsWereRemoved = false;\n      codeWoGenerics = codeWoGenerics.replace(/([<]?)<\\s*((?:\\?|[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*)(?:\\[\\])*(?:\\s+(?:extends|super)\\s+[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*)?(?:\\s*,\\s*(?:\\?|[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*)(?:\\[\\])*(?:\\s+(?:extends|super)\\s+[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*)?)*)\\s*>([=]?)/g, replaceFunc);\n    } while (genericsWereRemoved);\n\n    var atoms = splitToAtoms(codeWoGenerics);\n    var replaceContext;\n    var declaredClasses = {}, currentClassId, classIdSeed = 0;\n\n    function addAtom(text, type) {\n      var lastIndex = atoms.length;\n      atoms.push(text);\n      return '\"' + type + lastIndex + '\"';\n    }\n\n    function generateClassId() {\n      return \"class\" + (++classIdSeed);\n    }\n\n    function appendClass(class_, classId, scopeId) {\n      class_.classId = classId;\n      class_.scopeId = scopeId;\n      declaredClasses[classId] = class_;\n    }\n\n    // functions defined below\n    var transformClassBody, transformInterfaceBody, transformStatementsBlock, transformStatements, transformMain, transformExpression;\n\n    var classesRegex = /\\b((?:(?:public|private|final|protected|static|abstract)\\s+)*)(class|interface)\\s+([A-Za-z_$][\\w$]*\\b)(\\s+extends\\s+[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*(?:\\s*,\\s*[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*\\b)*)?(\\s+implements\\s+[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*(?:\\s*,\\s*[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*\\b)*)?\\s*(\"A\\d+\")/g;\n    var methodsRegex = /\\b((?:(?:public|private|final|protected|static|abstract|synchronized)\\s+)*)((?!(?:else|new|return|throw|function|public|private|protected)\\b)[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*(?:\\s*\"C\\d+\")*)\\s*([A-Za-z_$][\\w$]*\\b)\\s*(\"B\\d+\")(\\s*throws\\s+[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*(?:\\s*,\\s*[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*)*)?\\s*(\"A\\d+\"|;)/g;\n    var fieldTest = /^((?:(?:public|private|final|protected|static)\\s+)*)((?!(?:else|new|return|throw)\\b)[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*(?:\\s*\"C\\d+\")*)\\s*([A-Za-z_$][\\w$]*\\b)\\s*(?:\"C\\d+\"\\s*)*([=,]|$)/;\n    var cstrsRegex = /\\b((?:(?:public|private|final|protected|static|abstract)\\s+)*)((?!(?:new|return|throw)\\b)[A-Za-z_$][\\w$]*\\b)\\s*(\"B\\d+\")(\\s*throws\\s+[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*(?:\\s*,\\s*[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*)*)?\\s*(\"A\\d+\")/g;\n    var attrAndTypeRegex = /^((?:(?:public|private|final|protected|static)\\s+)*)((?!(?:new|return|throw)\\b)[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*(?:\\s*\"C\\d+\")*)\\s*/;\n    var functionsRegex = /\\bfunction(?:\\s+([A-Za-z_$][\\w$]*))?\\s*(\"B\\d+\")\\s*(\"A\\d+\")/g;\n\n    // This converts classes, methods and functions into atoms, and adds them to the atoms array.\n    // classes = E, methods = D and functions = H\n    function extractClassesAndMethods(code) {\n      var s = code;\n      s = s.replace(classesRegex, function(all) {\n        return addAtom(all, 'E');\n      });\n      s = s.replace(methodsRegex, function(all) {\n        return addAtom(all, 'D');\n      });\n      s = s.replace(functionsRegex, function(all) {\n        return addAtom(all, 'H');\n      });\n      return s;\n    }\n\n    // This converts constructors into atoms, and adds them to the atoms array.\n    // constructors = G\n    function extractConstructors(code, className) {\n      var result = code.replace(cstrsRegex, function(all, attr, name, params, throws_, body) {\n        if(name !== className) {\n          return all;\n        }\n        return addAtom(all, 'G');\n      });\n      return result;\n    }\n\n    // AstParam contains the name of a parameter inside a function declaration\n    function AstParam(name) {\n      this.name = name;\n    }\n    AstParam.prototype.toString = function() {\n      return this.name;\n    };\n    // AstParams contains an array of AstParam objects\n    function AstParams(params, methodArgsParam) {\n      this.params = params;\n      this.methodArgsParam = methodArgsParam;\n    }\n    AstParams.prototype.getNames = function() {\n      var names = [];\n      for(var i=0,l=this.params.length;i<l;++i) {\n        names.push(this.params[i].name);\n      }\n      return names;\n    };\n    AstParams.prototype.prependMethodArgs = function(body) {\n      if (!this.methodArgsParam) {\n        return body;\n      }\n      return \"{\\nvar \" + this.methodArgsParam.name +\n        \" = Array.prototype.slice.call(arguments, \" +\n        this.params.length + \");\\n\" + body.substring(1);\n    };\n    AstParams.prototype.toString = function() {\n      if(this.params.length === 0) {\n        return \"()\";\n      }\n      var result = \"(\";\n      for(var i=0,l=this.params.length;i<l;++i) {\n        result += this.params[i] + \", \";\n      }\n      return result.substring(0, result.length - 2) + \")\";\n    };\n\n    function transformParams(params) {\n      var paramsWoPars = trim(params.substring(1, params.length - 1));\n      var result = [], methodArgsParam = null;\n      if(paramsWoPars !== \"\") {\n        var paramList = paramsWoPars.split(\",\");\n        for(var i=0; i < paramList.length; ++i) {\n          var param = /\\b([A-Za-z_$][\\w$]*\\b)(\\s*\"[ABC][\\d]*\")*\\s*$/.exec(paramList[i]);\n          if (i === paramList.length - 1 && paramList[i].indexOf('...') >= 0) {\n            methodArgsParam = new AstParam(param[1]);\n            break;\n          }\n          result.push(new AstParam(param[1]));\n        }\n      }\n      return new AstParams(result, methodArgsParam);\n    }\n\n    function preExpressionTransform(expr) {\n      var s = expr;\n      // new type[] {...} --> {...}\n      s = s.replace(/\\bnew\\s+([A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*)(?:\\s*\"C\\d+\")+\\s*(\"A\\d+\")/g, function(all, type, init) {\n        return init;\n      });\n      // new Runnable() {...} --> \"F???\"\n      s = s.replace(/\\bnew\\s+([A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*)(?:\\s*\"B\\d+\")\\s*(\"A\\d+\")/g, function(all, type, init) {\n        return addAtom(all, 'F');\n      });\n      // function(...) { } --> \"H???\"\n      s = s.replace(functionsRegex, function(all) {\n        return addAtom(all, 'H');\n      });\n      // new type[?] --> createJavaArray('type', [?])\n      s = s.replace(/\\bnew\\s+([A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*)\\s*(\"C\\d+\"(?:\\s*\"C\\d+\")*)/g, function(all, type, index) {\n        var args = index.replace(/\"C(\\d+)\"/g, function(all, j) { return atoms[j]; })\n          .replace(/\\[\\s*\\]/g, \"[null]\").replace(/\\s*\\]\\s*\\[\\s*/g, \", \");\n        var arrayInitializer = \"{\" + args.substring(1, args.length - 1) + \"}\";\n        var createArrayArgs = \"('\" + type + \"', \" + addAtom(arrayInitializer, 'A') + \")\";\n        return '$p.createJavaArray' + addAtom(createArrayArgs, 'B');\n      });\n      // .length() --> .length\n      s = s.replace(/(\\.\\s*length)\\s*\"B\\d+\"/g, \"$1\");\n      // #000000 --> 0x000000\n      s = s.replace(/#([0-9A-Fa-f]{6})\\b/g, function(all, digits) {\n        return \"0xFF\" + digits;\n      });\n      // delete (type)???, except (int)???\n      s = s.replace(/\"B(\\d+)\"(\\s*(?:[\\w$']|\"B))/g, function(all, index, next) {\n        var atom = atoms[index];\n        if(!/^\\(\\s*[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*\\s*(?:\"C\\d+\"\\s*)*\\)$/.test(atom)) {\n          return all;\n        }\n        if(/^\\(\\s*int\\s*\\)$/.test(atom)) {\n          return \"(int)\" + next;\n        }\n        var indexParts = atom.split(/\"C(\\d+)\"/g);\n        if(indexParts.length > 1) {\n          // even items contains atom numbers, can check only first\n          if(! /^\\[\\s*\\]$/.test(atoms[indexParts[1]])) {\n            return all; // fallback - not a cast\n          }\n        }\n        return \"\" + next;\n      });\n      // (int)??? -> __int_cast(???)\n      s = s.replace(/\\(int\\)([^,\\]\\)\\}\\?\\:\\*\\+\\-\\/\\^\\|\\%\\&\\~<\\>\\=]+)/g, function(all, arg) {\n        var trimmed = trimSpaces(arg);\n        return trimmed.untrim(\"__int_cast(\" + trimmed.middle + \")\");\n      });\n      // super() -> $superCstr(), super. -> $super.;\n      s = s.replace(/\\bsuper(\\s*\"B\\d+\")/g, \"$$superCstr$1\").replace(/\\bsuper(\\s*\\.)/g, \"$$super$1\");\n      // 000.43->0.43 and 0010f->10, but not 0010\n      s = s.replace(/\\b0+((\\d*)(?:\\.[\\d*])?(?:[eE][\\-\\+]?\\d+)?[fF]?)\\b/, function(all, numberWo0, intPart) {\n        if( numberWo0 === intPart) {\n          return all;\n        }\n        return intPart === \"\" ? \"0\" + numberWo0 : numberWo0;\n      });\n      // 3.0f -> 3.0\n      s = s.replace(/\\b(\\.?\\d+\\.?)[fF]\\b/g, \"$1\");\n      // Weird (?) parsing errors with %\n      s = s.replace(/([^\\s])%([^=\\s])/g, \"$1 % $2\");\n      // Since frameRate() and frameRate are different things,\n      // we need to differentiate them somehow. So when we parse\n      // the Processing.js source, replace frameRate so it isn't\n      // confused with frameRate(), as well as keyPressed and mousePressed\n      s = s.replace(/\\b(frameRate|keyPressed|mousePressed)\\b(?!\\s*\"B)/g, \"__$1\");\n      // \"boolean\", \"byte\", \"int\", etc. => \"parseBoolean\", \"parseByte\", \"parseInt\", etc.\n      s = s.replace(/\\b(boolean|byte|char|float|int)\\s*\"B/g, function(all, name) {\n        return \"parse\" + name.substring(0, 1).toUpperCase() + name.substring(1) + \"\\\"B\";\n      });\n      // \"pixels\" replacements:\n      //   pixels[i] = c => pixels.setPixel(i,c) | pixels[i] => pixels.getPixel(i)\n      //   pixels.length => pixels.getLength()\n      //   pixels = ar => pixels.set(ar) | pixels => pixels.toArray()\n      s = s.replace(/\\bpixels\\b\\s*((\"C(\\d+)\")|\\.length)?(\\s*=(?!=)([^,\\]\\)\\}]+))?/g,\n        function(all, indexOrLength, index, atomIndex, equalsPart, rightSide) {\n          if(index) {\n            var atom = atoms[atomIndex];\n            if(equalsPart) {\n              return \"pixels.setPixel\" + addAtom(\"(\" +atom.substring(1, atom.length - 1) +\n                \",\" + rightSide + \")\", 'B');\n            }\n            return \"pixels.getPixel\" + addAtom(\"(\" + atom.substring(1, atom.length - 1) +\n              \")\", 'B');\n          }\n          if(indexOrLength) {\n            // length\n            return \"pixels.getLength\" + addAtom(\"()\", 'B');\n          }\n          if(equalsPart) {\n            return \"pixels.set\" + addAtom(\"(\" + rightSide + \")\", 'B');\n          }\n          return \"pixels.toArray\" + addAtom(\"()\", 'B');\n        });\n      // Java method replacements for: replace, replaceAll, replaceFirst, equals, hashCode, etc.\n      //   xxx.replace(yyy) -> __replace(xxx, yyy)\n      //   \"xx\".replace(yyy) -> __replace(\"xx\", yyy)\n      var repeatJavaReplacement;\n      function replacePrototypeMethods(all, subject, method, atomIndex) {\n        var atom = atoms[atomIndex];\n        repeatJavaReplacement = true;\n        var trimmed = trimSpaces(atom.substring(1, atom.length - 1));\n        return \"__\" + method  + ( trimmed.middle === \"\" ? addAtom(\"(\" + subject.replace(/\\.\\s*$/, \"\") + \")\", 'B') :\n          addAtom(\"(\" + subject.replace(/\\.\\s*$/, \"\") + \",\" + trimmed.middle + \")\", 'B') );\n      }\n      do {\n        repeatJavaReplacement = false;\n        s = s.replace(/((?:'\\d+'|\\b[A-Za-z_$][\\w$]*\\s*(?:\"[BC]\\d+\")*)\\s*\\.\\s*(?:[A-Za-z_$][\\w$]*\\s*(?:\"[BC]\\d+\"\\s*)*\\.\\s*)*)(replace|replaceAll|replaceFirst|contains|equals|equalsIgnoreCase|hashCode|toCharArray|printStackTrace|split|startsWith|endsWith|codePointAt|matches)\\s*\"B(\\d+)\"/g,\n          replacePrototypeMethods);\n      } while (repeatJavaReplacement);\n      // xxx instanceof yyy -> __instanceof(xxx, yyy)\n      function replaceInstanceof(all, subject, type) {\n        repeatJavaReplacement = true;\n        return \"__instanceof\" + addAtom(\"(\" + subject + \", \" + type + \")\", 'B');\n      }\n      do {\n        repeatJavaReplacement = false;\n        s = s.replace(/((?:'\\d+'|\\b[A-Za-z_$][\\w$]*\\s*(?:\"[BC]\\d+\")*)\\s*(?:\\.\\s*[A-Za-z_$][\\w$]*\\s*(?:\"[BC]\\d+\"\\s*)*)*)instanceof\\s+([A-Za-z_$][\\w$]*\\s*(?:\\.\\s*[A-Za-z_$][\\w$]*)*)/g,\n          replaceInstanceof);\n      } while (repeatJavaReplacement);\n      // this() -> $constr()\n      s = s.replace(/\\bthis(\\s*\"B\\d+\")/g, \"$$constr$1\");\n\n      return s;\n    }\n\n    function AstInlineClass(baseInterfaceName, body) {\n      this.baseInterfaceName = baseInterfaceName;\n      this.body = body;\n      body.owner = this;\n    }\n    AstInlineClass.prototype.toString = function() {\n      return \"new (\" + this.body + \")\";\n    };\n\n    function transformInlineClass(class_) {\n      var m = new RegExp(/\\bnew\\s*([A-Za-z_$][\\w$]*\\s*(?:\\.\\s*[A-Za-z_$][\\w$]*)*)\\s*\"B\\d+\"\\s*\"A(\\d+)\"/).exec(class_);\n      var oldClassId = currentClassId, newClassId = generateClassId();\n      currentClassId = newClassId;\n      var uniqueClassName = m[1] + \"$\" + newClassId;\n      var inlineClass = new AstInlineClass(uniqueClassName,\n        transformClassBody(atoms[m[2]], uniqueClassName, \"\", \"implements \" + m[1]));\n      appendClass(inlineClass, newClassId, oldClassId);\n      currentClassId = oldClassId;\n      return inlineClass;\n    }\n\n    function AstFunction(name, params, body) {\n      this.name = name;\n      this.params = params;\n      this.body = body;\n    }\n    AstFunction.prototype.toString = function() {\n      var oldContext = replaceContext;\n      // saving \"this.\" and parameters\n      var names = appendToLookupTable({\"this\":null}, this.params.getNames());\n      replaceContext = function (subject) {\n        return names.hasOwnProperty(subject.name) ? subject.name : oldContext(subject);\n      };\n      var result = \"function\";\n      if(this.name) {\n        result += \" \" + this.name;\n      }\n      var body = this.params.prependMethodArgs(this.body.toString());\n      result += this.params + \" \" + body;\n      replaceContext = oldContext;\n      return result;\n    };\n\n    function transformFunction(class_) {\n      var m = new RegExp(/\\b([A-Za-z_$][\\w$]*)\\s*\"B(\\d+)\"\\s*\"A(\\d+)\"/).exec(class_);\n      return new AstFunction( m[1] !== \"function\" ? m[1] : null,\n        transformParams(atoms[m[2]]), transformStatementsBlock(atoms[m[3]]));\n    }\n\n    function AstInlineObject(members) {\n      this.members = members;\n    }\n    AstInlineObject.prototype.toString = function() {\n      var oldContext = replaceContext;\n      replaceContext = function (subject) {\n          return subject.name === \"this\" ? \"this\" : oldContext(subject); // saving \"this.\"\n      };\n      var result = \"\";\n      for(var i=0,l=this.members.length;i<l;++i) {\n        if(this.members[i].label) {\n          result += this.members[i].label + \": \";\n        }\n        result += this.members[i].value.toString() + \", \";\n      }\n      replaceContext = oldContext;\n      return result.substring(0, result.length - 2);\n    };\n\n    function transformInlineObject(obj) {\n      var members = obj.split(',');\n      for(var i=0; i < members.length; ++i) {\n        var label = members[i].indexOf(':');\n        if(label < 0) {\n          members[i] = { value: transformExpression(members[i]) };\n        } else {\n          members[i] = { label: trim(members[i].substring(0, label)),\n            value: transformExpression( trim(members[i].substring(label + 1)) ) };\n        }\n      }\n      return new AstInlineObject(members);\n    }\n\n    function expandExpression(expr) {\n      if(expr.charAt(0) === '(' || expr.charAt(0) === '[') {\n        return expr.charAt(0) + expandExpression(expr.substring(1, expr.length - 1)) + expr.charAt(expr.length - 1);\n      }\n      if(expr.charAt(0) === '{') {\n        if(/^\\{\\s*(?:[A-Za-z_$][\\w$]*|'\\d+')\\s*:/.test(expr)) {\n          return \"{\" + addAtom(expr.substring(1, expr.length - 1), 'I') + \"}\";\n        }\n        return \"[\" + expandExpression(expr.substring(1, expr.length - 1)) + \"]\";\n      }\n      var trimmed = trimSpaces(expr);\n      var result = preExpressionTransform(trimmed.middle);\n      result = result.replace(/\"[ABC](\\d+)\"/g, function(all, index) {\n        return expandExpression(atoms[index]);\n      });\n      return trimmed.untrim(result);\n    }\n\n    function replaceContextInVars(expr) {\n      return expr.replace(/(\\.\\s*)?((?:\\b[A-Za-z_]|\\$)[\\w$]*)(\\s*\\.\\s*([A-Za-z_$][\\w$]*)(\\s*\\()?)?/g,\n        function(all, memberAccessSign, identifier, suffix, subMember, callSign) {\n          if(memberAccessSign) {\n            return all;\n          }\n          var subject = { name: identifier, member: subMember, callSign: !!callSign };\n          return replaceContext(subject) + (suffix === undef ? \"\" : suffix);\n        });\n    }\n\n    function AstExpression(expr, transforms) {\n      this.expr = expr;\n      this.transforms = transforms;\n    }\n    AstExpression.prototype.toString = function() {\n      var transforms = this.transforms;\n      var expr = replaceContextInVars(this.expr);\n      return expr.replace(/\"!(\\d+)\"/g, function(all, index) {\n        return transforms[index].toString();\n      });\n    };\n\n    transformExpression = function(expr) {\n      var transforms = [];\n      var s = expandExpression(expr);\n      s = s.replace(/\"H(\\d+)\"/g, function(all, index) {\n        transforms.push(transformFunction(atoms[index]));\n        return '\"!' + (transforms.length - 1) + '\"';\n      });\n      s = s.replace(/\"F(\\d+)\"/g, function(all, index) {\n        transforms.push(transformInlineClass(atoms[index]));\n        return '\"!' + (transforms.length - 1) + '\"';\n      });\n      s = s.replace(/\"I(\\d+)\"/g, function(all, index) {\n        transforms.push(transformInlineObject(atoms[index]));\n        return '\"!' + (transforms.length - 1) + '\"';\n      });\n\n      return new AstExpression(s, transforms);\n    };\n\n    function AstVarDefinition(name, value, isDefault) {\n      this.name = name;\n      this.value = value;\n      this.isDefault = isDefault;\n    }\n    AstVarDefinition.prototype.toString = function() {\n      return this.name + ' = ' + this.value;\n    };\n\n    function transformVarDefinition(def, defaultTypeValue) {\n      var eqIndex = def.indexOf(\"=\");\n      var name, value, isDefault;\n      if(eqIndex < 0) {\n        name = def;\n        value = defaultTypeValue;\n        isDefault = true;\n      } else {\n        name = def.substring(0, eqIndex);\n        value = transformExpression(def.substring(eqIndex + 1));\n        isDefault = false;\n      }\n      return new AstVarDefinition( trim(name.replace(/(\\s*\"C\\d+\")+/g, \"\")),\n        value, isDefault);\n    }\n\n    function getDefaultValueForType(type) {\n        if(type === \"int\" || type === \"float\") {\n          return \"0\";\n        }\n        if(type === \"boolean\") {\n          return \"false\";\n        }\n        if(type === \"color\") {\n          return \"0x00000000\";\n        }\n        return \"null\";\n    }\n\n    function AstVar(definitions, varType) {\n      this.definitions = definitions;\n      this.varType = varType;\n    }\n    AstVar.prototype.getNames = function() {\n      var names = [];\n      for(var i=0,l=this.definitions.length;i<l;++i) {\n        names.push(this.definitions[i].name);\n      }\n      return names;\n    };\n    AstVar.prototype.toString = function() {\n      return \"var \" + this.definitions.join(\",\");\n    };\n    function AstStatement(expression) {\n      this.expression = expression;\n    }\n    AstStatement.prototype.toString = function() {\n      return this.expression.toString();\n    };\n\n    function transformStatement(statement) {\n      if(fieldTest.test(statement)) {\n        var attrAndType = attrAndTypeRegex.exec(statement);\n        var definitions = statement.substring(attrAndType[0].length).split(\",\");\n        var defaultTypeValue = getDefaultValueForType(attrAndType[2]);\n        for(var i=0; i < definitions.length; ++i) {\n          definitions[i] = transformVarDefinition(definitions[i], defaultTypeValue);\n        }\n        return new AstVar(definitions, attrAndType[2]);\n      }\n      return new AstStatement(transformExpression(statement));\n    }\n\n    function AstForExpression(initStatement, condition, step) {\n      this.initStatement = initStatement;\n      this.condition = condition;\n      this.step = step;\n    }\n    AstForExpression.prototype.toString = function() {\n      return \"(\" + this.initStatement + \"; \" + this.condition + \"; \" + this.step + \")\";\n    };\n\n    function AstForInExpression(initStatement, container) {\n      this.initStatement = initStatement;\n      this.container = container;\n    }\n    AstForInExpression.prototype.toString = function() {\n      var init = this.initStatement.toString();\n      if(init.indexOf(\"=\") >= 0) { // can be without var declaration\n        init = init.substring(0, init.indexOf(\"=\"));\n      }\n      return \"(\" + init + \" in \" + this.container + \")\";\n    };\n\n    function AstForEachExpression(initStatement, container) {\n      this.initStatement = initStatement;\n      this.container = container;\n    }\n    AstForEachExpression.iteratorId = 0;\n    AstForEachExpression.prototype.toString = function() {\n      var init = this.initStatement.toString();\n      var iterator = \"$it\" + (AstForEachExpression.iteratorId++);\n      var variableName = init.replace(/^\\s*var\\s*/, \"\").split(\"=\")[0];\n      var initIteratorAndVariable = \"var \" + iterator + \" = new $p.ObjectIterator(\" + this.container + \"), \" +\n         variableName + \" = void(0)\";\n      var nextIterationCondition = iterator + \".hasNext() && ((\" +\n         variableName + \" = \" + iterator + \".next()) || true)\";\n      return \"(\" + initIteratorAndVariable + \"; \" + nextIterationCondition + \";)\";\n    };\n\n    function transformForExpression(expr) {\n      var content;\n      if (/\\bin\\b/.test(expr)) {\n        content = expr.substring(1, expr.length - 1).split(/\\bin\\b/g);\n        return new AstForInExpression( transformStatement(trim(content[0])),\n          transformExpression(content[1]));\n      }\n      if (expr.indexOf(\":\") >= 0 && expr.indexOf(\";\") < 0) {\n        content = expr.substring(1, expr.length - 1).split(\":\");\n        return new AstForEachExpression( transformStatement(trim(content[0])),\n          transformExpression(content[1]));\n      }\n      content = expr.substring(1, expr.length - 1).split(\";\");\n      return new AstForExpression( transformStatement(trim(content[0])),\n        transformExpression(content[1]), transformExpression(content[2]));\n    }\n\n    function sortByWeight(array) {\n      array.sort(function (a,b) {\n        return b.weight - a.weight;\n      });\n    }\n\n    function AstInnerInterface(name, body, isStatic) {\n      this.name = name;\n      this.body = body;\n      this.isStatic = isStatic;\n      body.owner = this;\n    }\n    AstInnerInterface.prototype.toString = function() {\n      return \"\" + this.body;\n    };\n    function AstInnerClass(name, body, isStatic) {\n      this.name = name;\n      this.body = body;\n      this.isStatic = isStatic;\n      body.owner = this;\n    }\n    AstInnerClass.prototype.toString = function() {\n      return \"\" + this.body;\n    };\n\n    function transformInnerClass(class_) {\n      var m = classesRegex.exec(class_); // 1 - attr, 2 - class|int, 3 - name, 4 - extends, 5 - implements, 6 - body\n      classesRegex.lastIndex = 0;\n      var isStatic = m[1].indexOf(\"static\") >= 0;\n      var body = atoms[getAtomIndex(m[6])], innerClass;\n      var oldClassId = currentClassId, newClassId = generateClassId();\n      currentClassId = newClassId;\n      if(m[2] === \"interface\") {\n        innerClass = new AstInnerInterface(m[3], transformInterfaceBody(body, m[3], m[4]), isStatic);\n      } else {\n        innerClass = new AstInnerClass(m[3], transformClassBody(body, m[3], m[4], m[5]), isStatic);\n      }\n      appendClass(innerClass, newClassId, oldClassId);\n      currentClassId = oldClassId;\n      return innerClass;\n    }\n\n    function AstClassMethod(name, params, body, isStatic) {\n      this.name = name;\n      this.params = params;\n      this.body = body;\n      this.isStatic = isStatic;\n    }\n    AstClassMethod.prototype.toString = function(){\n      var paramNames = appendToLookupTable({}, this.params.getNames());\n      var oldContext = replaceContext;\n      replaceContext = function (subject) {\n        return paramNames.hasOwnProperty(subject.name) ? subject.name : oldContext(subject);\n      };\n      var body = this.params.prependMethodArgs(this.body.toString());\n      var result = \"function \" + this.methodId + this.params + \" \" + body +\"\\n\";\n      replaceContext = oldContext;\n      return result;\n    };\n\n    function transformClassMethod(method) {\n      var m = methodsRegex.exec(method);\n      methodsRegex.lastIndex = 0;\n      var isStatic = m[1].indexOf(\"static\") >= 0;\n      var body = m[6] !== ';' ? atoms[getAtomIndex(m[6])] : \"{}\";\n      return new AstClassMethod(m[3], transformParams(atoms[getAtomIndex(m[4])]),\n        transformStatementsBlock(body), isStatic );\n    }\n\n    function AstClassField(definitions, fieldType, isStatic) {\n      this.definitions = definitions;\n      this.fieldType = fieldType;\n      this.isStatic = isStatic;\n    }\n    AstClassField.prototype.getNames = function() {\n      var names = [];\n      for(var i=0,l=this.definitions.length;i<l;++i) {\n        names.push(this.definitions[i].name);\n      }\n      return names;\n    };\n    AstClassField.prototype.toString = function() {\n      var thisPrefix = replaceContext({ name: \"[this]\" });\n      if(this.isStatic) {\n        var className = this.owner.name;\n        var staticDeclarations = [];\n        for(var i=0,l=this.definitions.length;i<l;++i) {\n          var definition = this.definitions[i];\n          var name = definition.name, staticName = className + \".\" + name;\n          var declaration = \"if(\" + staticName + \" === void(0)) {\\n\" +\n            \" \" + staticName + \" = \" + definition.value + \"; }\\n\" +\n            \"$p.defineProperty(\" + thisPrefix + \", \" +\n            \"'\" + name + \"', { get: function(){return \" + staticName + \";}, \" +\n            \"set: function(val){\" + staticName + \" = val;} });\\n\";\n          staticDeclarations.push(declaration);\n        }\n        return staticDeclarations.join(\"\");\n      }\n      return thisPrefix + \".\" + this.definitions.join(\"; \" + thisPrefix + \".\");\n    };\n\n    function transformClassField(statement) {\n      var attrAndType = attrAndTypeRegex.exec(statement);\n      var isStatic = attrAndType[1].indexOf(\"static\") >= 0;\n      var definitions = statement.substring(attrAndType[0].length).split(/,\\s*/g);\n      var defaultTypeValue = getDefaultValueForType(attrAndType[2]);\n      for(var i=0; i < definitions.length; ++i) {\n        definitions[i] = transformVarDefinition(definitions[i], defaultTypeValue);\n      }\n      return new AstClassField(definitions, attrAndType[2], isStatic);\n    }\n\n    function AstConstructor(params, body) {\n      this.params = params;\n      this.body = body;\n    }\n    AstConstructor.prototype.toString = function() {\n      var paramNames = appendToLookupTable({}, this.params.getNames());\n      var oldContext = replaceContext;\n      replaceContext = function (subject) {\n        return paramNames.hasOwnProperty(subject.name) ? subject.name : oldContext(subject);\n      };\n      var prefix = \"function $constr_\" + this.params.params.length + this.params.toString();\n      var body = this.params.prependMethodArgs(this.body.toString());\n      if(!/\\$(superCstr|constr)\\b/.test(body)) {\n        body = \"{\\n$superCstr();\\n\" + body.substring(1);\n      }\n      replaceContext = oldContext;\n      return prefix + body + \"\\n\";\n    };\n\n    function transformConstructor(cstr) {\n      var m = new RegExp(/\"B(\\d+)\"\\s*\"A(\\d+)\"/).exec(cstr);\n      var params = transformParams(atoms[m[1]]);\n\n      return new AstConstructor(params, transformStatementsBlock(atoms[m[2]]));\n    }\n\n    function AstInterfaceBody(name, interfacesNames, methodsNames, fields, innerClasses, misc) {\n      var i,l;\n      this.name = name;\n      this.interfacesNames = interfacesNames;\n      this.methodsNames = methodsNames;\n      this.fields = fields;\n      this.innerClasses = innerClasses;\n      this.misc = misc;\n      for(i=0,l=fields.length; i<l; ++i) {\n        fields[i].owner = this;\n      }\n    }\n    AstInterfaceBody.prototype.getMembers = function(classFields, classMethods, classInners) {\n      if(this.owner.base) {\n        this.owner.base.body.getMembers(classFields, classMethods, classInners);\n      }\n      var i, j, l, m;\n      for(i=0,l=this.fields.length;i<l;++i) {\n        var fieldNames = this.fields[i].getNames();\n        for(j=0,m=fieldNames.length;j<m;++j) {\n          classFields[fieldNames[j]] = this.fields[i];\n        }\n      }\n      for(i=0,l=this.methodsNames.length;i<l;++i) {\n        var methodName = this.methodsNames[i];\n        classMethods[methodName] = true;\n      }\n      for(i=0,l=this.innerClasses.length;i<l;++i) {\n        var innerClass = this.innerClasses[i];\n        classInners[innerClass.name] = innerClass;\n      }\n    };\n    AstInterfaceBody.prototype.toString = function() {\n      function getScopeLevel(p) {\n        var i = 0;\n        while(p) {\n          ++i;\n          p=p.scope;\n        }\n        return i;\n      }\n\n      var scopeLevel = getScopeLevel(this.owner);\n\n      var className = this.name;\n      var staticDefinitions = \"\";\n      var metadata = \"\";\n\n      var thisClassFields = {}, thisClassMethods = {}, thisClassInners = {};\n      this.getMembers(thisClassFields, thisClassMethods, thisClassInners);\n\n      var i, l, j, m;\n\n      if (this.owner.interfaces) {\n        // interface name can be present, but interface is not\n        var resolvedInterfaces = [], resolvedInterface;\n        for (i = 0, l = this.interfacesNames.length; i < l; ++i) {\n          if (!this.owner.interfaces[i]) {\n            continue;\n          }\n          resolvedInterface = replaceContext({name: this.interfacesNames[i]});\n          resolvedInterfaces.push(resolvedInterface);\n          staticDefinitions += \"$p.extendInterfaceMembers(\" + className + \", \" + resolvedInterface + \");\\n\";\n        }\n        metadata += className + \".$interfaces = [\" + resolvedInterfaces.join(\", \") + \"];\\n\";\n      }\n      metadata += className + \".$isInterface = true;\\n\";\n      metadata += className + \".$methods = [\\'\" + this.methodsNames.join(\"\\', \\'\") + \"\\'];\\n\";\n\n      sortByWeight(this.innerClasses);\n      for (i = 0, l = this.innerClasses.length; i < l; ++i) {\n        var innerClass = this.innerClasses[i];\n        if (innerClass.isStatic) {\n          staticDefinitions += className + \".\" + innerClass.name + \" = \" + innerClass + \";\\n\";\n        }\n      }\n\n      for (i = 0, l = this.fields.length; i < l; ++i) {\n        var field = this.fields[i];\n        if (field.isStatic) {\n          staticDefinitions += className + \".\" + field.definitions.join(\";\\n\" + className + \".\") + \";\\n\";\n        }\n      }\n\n      return \"(function() {\\n\" +\n        \"function \" + className + \"() { throw \\'Unable to create the interface\\'; }\\n\" +\n        staticDefinitions +\n        metadata +\n        \"return \" + className + \";\\n\" +\n        \"})()\";\n    };\n\n    transformInterfaceBody = function(body, name, baseInterfaces) {\n      var declarations = body.substring(1, body.length - 1);\n      declarations = extractClassesAndMethods(declarations);\n      declarations = extractConstructors(declarations, name);\n      var methodsNames = [], classes = [];\n      declarations = declarations.replace(/\"([DE])(\\d+)\"/g, function(all, type, index) {\n        if(type === 'D') { methodsNames.push(index); }\n        else if(type === 'E') { classes.push(index); }\n        return \"\";\n      });\n      var fields = declarations.split(/;(?:\\s*;)*/g);\n      var baseInterfaceNames;\n      var i, l;\n\n      if(baseInterfaces !== undef) {\n        baseInterfaceNames = baseInterfaces.replace(/^\\s*extends\\s+(.+?)\\s*$/g, \"$1\").split(/\\s*,\\s*/g);\n      }\n\n      for(i = 0, l = methodsNames.length; i < l; ++i) {\n        var method = transformClassMethod(atoms[methodsNames[i]]);\n        methodsNames[i] = method.name;\n      }\n      for(i = 0, l = fields.length - 1; i < l; ++i) {\n        var field = trimSpaces(fields[i]);\n        fields[i] = transformClassField(field.middle);\n      }\n      var tail = fields.pop();\n      for(i = 0, l = classes.length; i < l; ++i) {\n        classes[i] = transformInnerClass(atoms[classes[i]]);\n      }\n\n      return new AstInterfaceBody(name, baseInterfaceNames, methodsNames, fields, classes, { tail: tail });\n    };\n\n    function AstClassBody(name, baseClassName, interfacesNames, functions, methods, fields, cstrs, innerClasses, misc) {\n      var i,l;\n      this.name = name;\n      this.baseClassName = baseClassName;\n      this.interfacesNames = interfacesNames;\n      this.functions = functions;\n      this.methods = methods;\n      this.fields = fields;\n      this.cstrs = cstrs;\n      this.innerClasses = innerClasses;\n      this.misc = misc;\n      for(i=0,l=fields.length; i<l; ++i) {\n        fields[i].owner = this;\n      }\n    }\n    AstClassBody.prototype.getMembers = function(classFields, classMethods, classInners) {\n      if(this.owner.base) {\n        this.owner.base.body.getMembers(classFields, classMethods, classInners);\n      }\n      var i, j, l, m;\n      for(i=0,l=this.fields.length;i<l;++i) {\n        var fieldNames = this.fields[i].getNames();\n        for(j=0,m=fieldNames.length;j<m;++j) {\n          classFields[fieldNames[j]] = this.fields[i];\n        }\n      }\n      for(i=0,l=this.methods.length;i<l;++i) {\n        var method = this.methods[i];\n        classMethods[method.name] = method;\n      }\n      for(i=0,l=this.innerClasses.length;i<l;++i) {\n        var innerClass = this.innerClasses[i];\n        classInners[innerClass.name] = innerClass;\n      }\n    };\n    AstClassBody.prototype.toString = function() {\n      function getScopeLevel(p) {\n        var i = 0;\n        while(p) {\n          ++i;\n          p=p.scope;\n        }\n        return i;\n      }\n\n      var scopeLevel = getScopeLevel(this.owner);\n\n      var selfId = \"$this_\" + scopeLevel;\n      var className = this.name;\n      var result = \"var \" + selfId + \" = this;\\n\";\n      var staticDefinitions = \"\";\n      var metadata = \"\";\n\n      var thisClassFields = {}, thisClassMethods = {}, thisClassInners = {};\n      this.getMembers(thisClassFields, thisClassMethods, thisClassInners);\n\n      var oldContext = replaceContext;\n      replaceContext = function (subject) {\n        var name = subject.name;\n        if(name === \"this\") {\n          // returns \"$this_N.$self\" pointer instead of \"this\" in cases:\n          // \"this()\", \"this.XXX()\", \"this\", but not for \"this.XXX\"\n          return subject.callSign || !subject.member ? selfId + \".$self\" : selfId;\n        }\n        if(thisClassFields.hasOwnProperty(name)) {\n          return thisClassFields[name].isStatic ? className + \".\" + name : selfId + \".\" + name;\n        }\n        if(thisClassInners.hasOwnProperty(name)) {\n          return selfId + \".\" + name;\n        }\n        if(thisClassMethods.hasOwnProperty(name)) {\n          return thisClassMethods[name].isStatic ? className + \".\" + name : selfId + \".$self.\" + name;\n        }\n        return oldContext(subject);\n      };\n\n      var resolvedBaseClassName;\n      if (this.baseClassName) {\n        resolvedBaseClassName = oldContext({name: this.baseClassName});\n        result += \"var $super = { $upcast: \" + selfId + \" };\\n\";\n        result += \"function $superCstr(){\" + resolvedBaseClassName +\n          \".apply($super,arguments);if(!('$self' in $super)) $p.extendClassChain($super)}\\n\";\n        metadata += className + \".$base = \" + resolvedBaseClassName + \";\\n\";\n      } else {\n        result += \"function $superCstr(){$p.extendClassChain(\"+ selfId +\")}\\n\";\n      }\n\n      if (this.owner.base) {\n        // base class name can be present, but class is not\n        staticDefinitions += \"$p.extendStaticMembers(\" + className + \", \" + resolvedBaseClassName + \");\\n\";\n      }\n\n      var i, l, j, m;\n\n      if (this.owner.interfaces) {\n        // interface name can be present, but interface is not\n        var resolvedInterfaces = [], resolvedInterface;\n        for (i = 0, l = this.interfacesNames.length; i < l; ++i) {\n          if (!this.owner.interfaces[i]) {\n            continue;\n          }\n          resolvedInterface = oldContext({name: this.interfacesNames[i]});\n          resolvedInterfaces.push(resolvedInterface);\n          staticDefinitions += \"$p.extendInterfaceMembers(\" + className + \", \" + resolvedInterface + \");\\n\";\n        }\n        metadata += className + \".$interfaces = [\" + resolvedInterfaces.join(\", \") + \"];\\n\";\n      }\n\n      if (this.functions.length > 0) {\n        result += this.functions.join('\\n') + '\\n';\n      }\n\n      sortByWeight(this.innerClasses);\n      for (i = 0, l = this.innerClasses.length; i < l; ++i) {\n        var innerClass = this.innerClasses[i];\n        if (innerClass.isStatic) {\n          staticDefinitions += className + \".\" + innerClass.name + \" = \" + innerClass + \";\\n\";\n          result += selfId + \".\" + innerClass.name + \" = \" + className + \".\" + innerClass.name + \";\\n\";\n        } else {\n          result += selfId + \".\" + innerClass.name + \" = \" + innerClass + \";\\n\";\n        }\n      }\n\n      for (i = 0, l = this.fields.length; i < l; ++i) {\n        var field = this.fields[i];\n        if (field.isStatic) {\n          staticDefinitions += className + \".\" + field.definitions.join(\";\\n\" + className + \".\") + \";\\n\";\n          for (j = 0, m = field.definitions.length; j < m; ++j) {\n            var fieldName = field.definitions[j].name, staticName = className + \".\" + fieldName;\n            result += \"$p.defineProperty(\" + selfId + \", '\" + fieldName + \"', {\" +\n              \"get: function(){return \" + staticName + \"}, \" +\n              \"set: function(val){\" + staticName + \" = val}});\\n\";\n          }\n        } else {\n          result += selfId + \".\" + field.definitions.join(\";\\n\" + selfId + \".\") + \";\\n\";\n        }\n      }\n      var methodOverloads = {};\n      for (i = 0, l = this.methods.length; i < l; ++i) {\n        var method = this.methods[i];\n        var overload = methodOverloads[method.name];\n        var methodId = method.name + \"$\" + method.params.params.length;\n        var hasMethodArgs = !!method.params.methodArgsParam;\n        if (overload) {\n          ++overload;\n          methodId += \"_\" + overload;\n        } else {\n          overload = 1;\n        }\n        method.methodId = methodId;\n        methodOverloads[method.name] = overload;\n        if (method.isStatic) {\n          staticDefinitions += method;\n          staticDefinitions += \"$p.addMethod(\" + className + \", '\" + method.name + \"', \" + methodId + \", \" + hasMethodArgs + \");\\n\";\n          result += \"$p.addMethod(\" + selfId + \", '\" + method.name + \"', \" + methodId + \", \" + hasMethodArgs + \");\\n\";\n        } else {\n          result += method;\n          result += \"$p.addMethod(\" + selfId + \", '\" + method.name + \"', \" + methodId + \", \" + hasMethodArgs + \");\\n\";\n        }\n      }\n      result += trim(this.misc.tail);\n\n      if (this.cstrs.length > 0) {\n        result += this.cstrs.join('\\n') + '\\n';\n      }\n\n      result += \"function $constr() {\\n\";\n      var cstrsIfs = [];\n      for (i = 0, l = this.cstrs.length; i < l; ++i) {\n        var paramsLength = this.cstrs[i].params.params.length;\n        var methodArgsPresent = !!this.cstrs[i].params.methodArgsParam;\n        cstrsIfs.push(\"if(arguments.length \" + (methodArgsPresent ? \">=\" : \"===\") +\n          \" \" + paramsLength + \") { \" +\n          \"$constr_\" + paramsLength + \".apply(\" + selfId + \", arguments); }\");\n      }\n      if(cstrsIfs.length > 0) {\n        result += cstrsIfs.join(\" else \") + \" else \";\n      }\n      // ??? add check if length is 0, otherwise fail\n      result += \"$superCstr();\\n}\\n\";\n      result += \"$constr.apply(null, arguments);\\n\";\n\n      replaceContext = oldContext;\n      return \"(function() {\\n\" +\n        \"function \" + className + \"() {\\n\" + result + \"}\\n\" +\n        staticDefinitions +\n        metadata +\n        \"return \" + className + \";\\n\" +\n        \"})()\";\n    };\n\n    transformClassBody = function(body, name, baseName, interfaces) {\n      var declarations = body.substring(1, body.length - 1);\n      declarations = extractClassesAndMethods(declarations);\n      declarations = extractConstructors(declarations, name);\n      var methods = [], classes = [], cstrs = [], functions = [];\n      declarations = declarations.replace(/\"([DEGH])(\\d+)\"/g, function(all, type, index) {\n        if(type === 'D') { methods.push(index); }\n        else if(type === 'E') { classes.push(index); }\n        else if(type === 'H') { functions.push(index); }\n        else { cstrs.push(index); }\n        return \"\";\n      });\n      var fields = declarations.replace(/^(?:\\s*;)+/, \"\").split(/;(?:\\s*;)*/g);\n      var baseClassName, interfacesNames;\n      var i;\n\n      if(baseName !== undef) {\n        baseClassName = baseName.replace(/^\\s*extends\\s+([A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*)\\s*$/g, \"$1\");\n      }\n\n      if(interfaces !== undef) {\n        interfacesNames = interfaces.replace(/^\\s*implements\\s+(.+?)\\s*$/g, \"$1\").split(/\\s*,\\s*/g);\n      }\n\n      for(i = 0; i < functions.length; ++i) {\n        functions[i] = transformFunction(atoms[functions[i]]);\n      }\n      for(i = 0; i < methods.length; ++i) {\n        methods[i] = transformClassMethod(atoms[methods[i]]);\n      }\n      for(i = 0; i < fields.length - 1; ++i) {\n        var field = trimSpaces(fields[i]);\n        fields[i] = transformClassField(field.middle);\n      }\n      var tail = fields.pop();\n      for(i = 0; i < cstrs.length; ++i) {\n        cstrs[i] = transformConstructor(atoms[cstrs[i]]);\n      }\n      for(i = 0; i < classes.length; ++i) {\n        classes[i] = transformInnerClass(atoms[classes[i]]);\n      }\n\n      return new AstClassBody(name, baseClassName, interfacesNames, functions, methods, fields, cstrs,\n        classes, { tail: tail });\n    };\n\n    function AstInterface(name, body) {\n      this.name = name;\n      this.body = body;\n      body.owner = this;\n    }\n    AstInterface.prototype.toString = function() {\n      return \"var \" + this.name + \" = \" + this.body + \";\\n\" +\n        \"$p.\" + this.name + \" = \" + this.name + \";\\n\";\n    };\n    function AstClass(name, body) {\n      this.name = name;\n      this.body = body;\n      body.owner = this;\n    }\n    AstClass.prototype.toString = function() {\n      return \"var \" + this.name + \" = \" + this.body + \";\\n\" +\n        \"$p.\" + this.name + \" = \" + this.name + \";\\n\";\n    };\n\n    function transformGlobalClass(class_) {\n      var m = classesRegex.exec(class_); // 1 - attr, 2 - class|int, 3 - name, 4 - extends, 5 - implements, 6 - body\n      classesRegex.lastIndex = 0;\n      var body = atoms[getAtomIndex(m[6])];\n      var oldClassId = currentClassId, newClassId = generateClassId();\n      currentClassId = newClassId;\n      var globalClass;\n      if(m[2] === \"interface\") {\n        globalClass = new AstInterface(m[3], transformInterfaceBody(body, m[3], m[4]) );\n      } else {\n        globalClass = new AstClass(m[3], transformClassBody(body, m[3], m[4], m[5]) );\n      }\n      appendClass(globalClass, newClassId, oldClassId);\n      currentClassId = oldClassId;\n      return globalClass;\n    }\n\n    function AstMethod(name, params, body) {\n      this.name = name;\n      this.params = params;\n      this.body = body;\n    }\n    AstMethod.prototype.toString = function(){\n      var paramNames = appendToLookupTable({}, this.params.getNames());\n      var oldContext = replaceContext;\n      replaceContext = function (subject) {\n        return paramNames.hasOwnProperty(subject.name) ? subject.name : oldContext(subject);\n      };\n      var body = this.params.prependMethodArgs(this.body.toString());\n      var result = \"function \" + this.name + this.params + \" \" + body + \"\\n\" +\n                   \"$p.\" + this.name + \" = \" + this.name + \";\\n\" +\n                   this.name + \" = \" + this.name + \".bind($p);\";\n//        \"$p.\" + this.name + \" = \" + this.name + \";\";\n      replaceContext = oldContext;\n      return result;\n    };\n\n    function transformGlobalMethod(method) {\n      var m = methodsRegex.exec(method);\n      var result =\n      methodsRegex.lastIndex = 0;\n      return new AstMethod(m[3], transformParams(atoms[getAtomIndex(m[4])]),\n        transformStatementsBlock(atoms[getAtomIndex(m[6])]));\n    }\n\n    function preStatementsTransform(statements) {\n      var s = statements;\n      // turns multiple catch blocks into one, because we have no way to properly get into them anyway.\n      s = s.replace(/\\b(catch\\s*\"B\\d+\"\\s*\"A\\d+\")(\\s*catch\\s*\"B\\d+\"\\s*\"A\\d+\")+/g, \"$1\");\n      return s;\n    }\n\n    function AstForStatement(argument, misc) {\n      this.argument = argument;\n      this.misc = misc;\n    }\n    AstForStatement.prototype.toString = function() {\n      return this.misc.prefix + this.argument.toString();\n    };\n    function AstCatchStatement(argument, misc) {\n      this.argument = argument;\n      this.misc = misc;\n    }\n    AstCatchStatement.prototype.toString = function() {\n      return this.misc.prefix + this.argument.toString();\n    };\n    function AstPrefixStatement(name, argument, misc) {\n      this.name = name;\n      this.argument = argument;\n      this.misc = misc;\n    }\n    AstPrefixStatement.prototype.toString = function() {\n      var result = this.misc.prefix;\n      if(this.argument !== undef) {\n        result += this.argument.toString();\n      }\n      return result;\n    };\n    function AstSwitchCase(expr) {\n      this.expr = expr;\n    }\n    AstSwitchCase.prototype.toString = function() {\n      return \"case \" + this.expr + \":\";\n    };\n    function AstLabel(label) {\n      this.label = label;\n    }\n    AstLabel.prototype.toString = function() {\n      return this.label;\n    };\n\n    transformStatements = function(statements, transformMethod, transformClass) {\n      var nextStatement = new RegExp(/\\b(catch|for|if|switch|while|with)\\s*\"B(\\d+)\"|\\b(do|else|finally|return|throw|try|break|continue)\\b|(\"[ADEH](\\d+)\")|\\b(case)\\s+([^:]+):|\\b([A-Za-z_$][\\w$]*\\s*:)|(;)/g);\n      var res = [];\n      statements = preStatementsTransform(statements);\n      var lastIndex = 0, m, space;\n      // m contains the matches from the nextStatement regexp, null if there are no matches.\n      // nextStatement.exec starts searching at nextStatement.lastIndex.\n      while((m = nextStatement.exec(statements)) !== null) {\n        if(m[1] !== undef) { // catch, for ...\n          var i = statements.lastIndexOf('\"B', nextStatement.lastIndex);\n          var statementsPrefix = statements.substring(lastIndex, i);\n          if(m[1] === \"for\") {\n            res.push(new AstForStatement(transformForExpression(atoms[m[2]]),\n              { prefix: statementsPrefix }) );\n          } else if(m[1] === \"catch\") {\n            res.push(new AstCatchStatement(transformParams(atoms[m[2]]),\n              { prefix: statementsPrefix }) );\n          } else {\n            res.push(new AstPrefixStatement(m[1], transformExpression(atoms[m[2]]),\n              { prefix: statementsPrefix }) );\n          }\n        } else if(m[3] !== undef) { // do, else, ...\n            res.push(new AstPrefixStatement(m[3], undef,\n              { prefix: statements.substring(lastIndex, nextStatement.lastIndex) }) );\n        } else if(m[4] !== undef) { // block, class and methods\n          space = statements.substring(lastIndex, nextStatement.lastIndex - m[4].length);\n          if(trim(space).length !== 0) { continue; } // avoiding new type[] {} construct\n          res.push(space);\n          var kind = m[4].charAt(1), atomIndex = m[5];\n          if(kind === 'D') {\n            res.push(transformMethod(atoms[atomIndex]));\n          } else if(kind === 'E') {\n            res.push(transformClass(atoms[atomIndex]));\n          } else if(kind === 'H') {\n            res.push(transformFunction(atoms[atomIndex]));\n          } else {\n            res.push(transformStatementsBlock(atoms[atomIndex]));\n          }\n        } else if(m[6] !== undef) { // switch case\n          res.push(new AstSwitchCase(transformExpression(trim(m[7]))));\n        } else if(m[8] !== undef) { // label\n          space = statements.substring(lastIndex, nextStatement.lastIndex - m[8].length);\n          if(trim(space).length !== 0) { continue; } // avoiding ?: construct\n          res.push(new AstLabel(statements.substring(lastIndex, nextStatement.lastIndex)) );\n        } else { // semicolon\n          var statement = trimSpaces(statements.substring(lastIndex, nextStatement.lastIndex - 1));\n          res.push(statement.left);\n          res.push(transformStatement(statement.middle));\n          res.push(statement.right + \";\");\n        }\n        lastIndex = nextStatement.lastIndex;\n      }\n      var statementsTail = trimSpaces(statements.substring(lastIndex));\n      res.push(statementsTail.left);\n      if(statementsTail.middle !== \"\") {\n        res.push(transformStatement(statementsTail.middle));\n        res.push(\";\" + statementsTail.right);\n      }\n      return res;\n    };\n\n    function getLocalNames(statements) {\n      var localNames = [];\n      for(var i=0,l=statements.length;i<l;++i) {\n        var statement = statements[i];\n        if(statement instanceof AstVar) {\n          localNames = localNames.concat(statement.getNames());\n        } else if(statement instanceof AstForStatement &&\n          statement.argument.initStatement instanceof AstVar) {\n          localNames = localNames.concat(statement.argument.initStatement.getNames());\n        } else if(statement instanceof AstInnerInterface || statement instanceof AstInnerClass ||\n          statement instanceof AstInterface || statement instanceof AstClass ||\n          statement instanceof AstMethod || statement instanceof AstFunction) {\n          localNames.push(statement.name);\n        }\n      }\n      return appendToLookupTable({}, localNames);\n    }\n\n    function AstStatementsBlock(statements) {\n      this.statements = statements;\n    }\n    AstStatementsBlock.prototype.toString = function() {\n      var localNames = getLocalNames(this.statements);\n      var oldContext = replaceContext;\n\n      // replacing context only when necessary\n      if(!isLookupTableEmpty(localNames)) {\n        replaceContext = function (subject) {\n          return localNames.hasOwnProperty(subject.name) ? subject.name : oldContext(subject);\n        };\n      }\n\n      var result = \"{\\n\" + this.statements.join('') + \"\\n}\";\n      replaceContext = oldContext;\n      return result;\n    };\n\n    transformStatementsBlock = function(block) {\n      var content = trimSpaces(block.substring(1, block.length - 1));\n      return new AstStatementsBlock(transformStatements(content.middle));\n    };\n\n    function AstRoot(statements) {\n      this.statements = statements;\n    }\n    AstRoot.prototype.toString = function() {\n      var classes = [], otherStatements = [], statement;\n      for (var i = 0, len = this.statements.length; i < len; ++i) {\n        statement = this.statements[i];\n        if (statement instanceof AstClass || statement instanceof AstInterface) {\n          classes.push(statement);\n        } else {\n          otherStatements.push(statement);\n        }\n      }\n      sortByWeight(classes);\n\n      var localNames = getLocalNames(this.statements);\n      replaceContext = function (subject) {\n        var name = subject.name;\n        if(localNames.hasOwnProperty(name)) {\n          return name;\n        }\n        if(globalMembers.hasOwnProperty(name) ||\n           PConstants.hasOwnProperty(name) ||\n           defaultScope.hasOwnProperty(name)) {\n          return \"$p.\" + name;\n        }\n        return name;\n      };\n      var result = \"// this code was autogenerated from PJS\\n\" +\n        \"(function($p) {\\n\" +\n        classes.join('') + \"\\n\" +\n        otherStatements.join('') + \"\\n})\";\n      replaceContext = null;\n      return result;\n    };\n\n    transformMain = function() {\n      var statements = extractClassesAndMethods(atoms[0]);\n      statements = statements.replace(/\\bimport\\s+[^;]+;/g, \"\");\n      return new AstRoot( transformStatements(statements,\n        transformGlobalMethod, transformGlobalClass) );\n    };\n\n    function generateMetadata(ast) {\n      var globalScope = {};\n      var id, class_;\n      for(id in declaredClasses) {\n        if(declaredClasses.hasOwnProperty(id)) {\n          class_ = declaredClasses[id];\n          var scopeId = class_.scopeId, name = class_.name;\n          if(scopeId) {\n            var scope = declaredClasses[scopeId];\n            class_.scope = scope;\n            if(scope.inScope === undef) {\n              scope.inScope = {};\n            }\n            scope.inScope[name] = class_;\n          } else {\n            globalScope[name] = class_;\n          }\n        }\n      }\n\n      function findInScopes(class_, name) {\n        var parts = name.split('.');\n        var currentScope = class_.scope, found;\n        while(currentScope) {\n          if(currentScope.hasOwnProperty(parts[0])) {\n            found = currentScope[parts[0]]; break;\n          }\n          currentScope = currentScope.scope;\n        }\n        if(found === undef) {\n          found = globalScope[parts[0]];\n        }\n        for(var i=1,l=parts.length;i<l && found;++i) {\n          found = found.inScope[parts[i]];\n        }\n        return found;\n      }\n\n      for(id in declaredClasses) {\n        if(declaredClasses.hasOwnProperty(id)) {\n          class_ = declaredClasses[id];\n          var baseClassName = class_.body.baseClassName;\n          if(baseClassName) {\n            var parent = findInScopes(class_, baseClassName);\n            if (parent) {\n              class_.base = parent;\n              if (!parent.derived) {\n                parent.derived = [];\n              }\n              parent.derived.push(class_);\n            }\n          }\n          var interfacesNames = class_.body.interfacesNames,\n            interfaces = [], i, l;\n          if (interfacesNames && interfacesNames.length > 0) {\n            for (i = 0, l = interfacesNames.length; i < l; ++i) {\n              var interface_ = findInScopes(class_, interfacesNames[i]);\n              interfaces.push(interface_);\n              if (!interface_) {\n                continue;\n              }\n              if (!interface_.derived) {\n                interface_.derived = [];\n              }\n              interface_.derived.push(class_);\n            }\n            if (interfaces.length > 0) {\n              class_.interfaces = interfaces;\n            }\n          }\n        }\n      }\n    }\n\n    function setWeight(ast) {\n      var queue = [], tocheck = {};\n      var id, scopeId, class_;\n      // queue most inner and non-inherited\n      for (id in declaredClasses) {\n        if (declaredClasses.hasOwnProperty(id)) {\n          class_ = declaredClasses[id];\n          if (!class_.inScope && !class_.derived) {\n            queue.push(id);\n            class_.weight = 0;\n          } else {\n            var dependsOn = [];\n            if (class_.inScope) {\n              for (scopeId in class_.inScope) {\n                if (class_.inScope.hasOwnProperty(scopeId)) {\n                  dependsOn.push(class_.inScope[scopeId]);\n                }\n              }\n            }\n            if (class_.derived) {\n              dependsOn = dependsOn.concat(class_.derived);\n            }\n            tocheck[id] = dependsOn;\n          }\n        }\n      }\n      function removeDependentAndCheck(targetId, from) {\n        var dependsOn = tocheck[targetId];\n        if (!dependsOn) {\n          return false; // no need to process\n        }\n        var i = dependsOn.indexOf(from);\n        if (i < 0) {\n          return false;\n        }\n        dependsOn.splice(i, 1);\n        if (dependsOn.length > 0) {\n          return false;\n        }\n        delete tocheck[targetId];\n        return true;\n      }\n      while (queue.length > 0) {\n        id = queue.shift();\n        class_ = declaredClasses[id];\n        if (class_.scopeId && removeDependentAndCheck(class_.scopeId, class_)) {\n          queue.push(class_.scopeId);\n          declaredClasses[class_.scopeId].weight = class_.weight + 1;\n        }\n        if (class_.base && removeDependentAndCheck(class_.base.classId, class_)) {\n          queue.push(class_.base.classId);\n          class_.base.weight = class_.weight + 1;\n        }\n        if (class_.interfaces) {\n          var i, l;\n          for (i = 0, l = class_.interfaces.length; i < l; ++i) {\n            if (!class_.interfaces[i] ||\n                !removeDependentAndCheck(class_.interfaces[i].classId, class_)) {\n              continue;\n            }\n            queue.push(class_.interfaces[i].classId);\n            class_.interfaces[i].weight = class_.weight + 1;\n          }\n        }\n      }\n    }\n\n    var transformed = transformMain();\n    generateMetadata(transformed);\n    setWeight(transformed);\n\n    var redendered = transformed.toString();\n\n    // remove empty extra lines with space\n    redendered = redendered.replace(/\\s*\\n(?:[\\t ]*\\n)+/g, \"\\n\\n\");\n\n    // convert character codes to characters\n    redendered = redendered.replace(/__x([0-9A-F]{4})/g, function(all, hexCode) {\n      return String.fromCharCode(parseInt(hexCode,16));\n    });\n\n    return injectStrings(redendered, strings);\n  }// Parser ends\n\n  function preprocessCode(aCode, sketch) {\n    // Parse out @pjs directive, if any.\n    var dm = new RegExp(/\\/\\*\\s*@pjs\\s+((?:[^\\*]|\\*+[^\\*\\/])*)\\*\\//g).exec(aCode);\n    if (dm && dm.length === 2) {\n      // masks contents of a JSON to be replaced later\n      // to protect the contents from further parsing\n      var jsonItems = [],\n          directives = dm.splice(1, 2)[0].replace(/\\{([\\s\\S]*?)\\}/g, (function() {\n            return function(all, item) {\n              jsonItems.push(item);\n              return \"{\" + (jsonItems.length-1) + \"}\";\n            };\n          }())).replace('\\n', '').replace('\\r', '').split(\";\");\n\n      // We'll L/RTrim, and also remove any surrounding double quotes (e.g., just take string contents)\n      var clean = function(s) {\n        return s.replace(/^\\s*[\"']?/, '').replace(/[\"']?\\s*$/, '');\n      };\n\n      for (var i = 0, dl = directives.length; i < dl; i++) {\n        var pair = directives[i].split('=');\n        if (pair && pair.length === 2) {\n          var key = clean(pair[0]),\n              value = clean(pair[1]),\n              list = [];\n          // A few directives require work beyond storying key/value pairings\n          if (key === \"preload\") {\n            list = value.split(',');\n            // All pre-loaded images will get put in imageCache, keyed on filename\n            for (var j = 0, jl = list.length; j < jl; j++) {\n              var imageName = clean(list[j]);\n              sketch.imageCache.add(imageName);\n            }\n          // fonts can be declared as a string containing a url,\n          // or a JSON object, containing a font name, and a url\n          } else if (key === \"font\") {\n            list = value.split(\",\");\n            for (var x = 0, xl = list.length; x < xl; x++) {\n              var fontName = clean(list[x]),\n                  index = /^\\{(\\d*?)\\}$/.exec(fontName);\n              // if index is not null, send JSON, otherwise, send string\n              PFont.preloading.add(index ? JSON.parse(\"{\" + jsonItems[index[1]] + \"}\") : fontName);\n            }\n          } else if (key === \"pauseOnBlur\") {\n            sketch.options.pauseOnBlur = value === \"true\";\n          } else if (key === \"globalKeyEvents\") {\n            sketch.options.globalKeyEvents = value === \"true\";\n          } else if (key.substring(0, 6) === \"param-\") {\n            sketch.params[key.substring(6)] = value;\n          } else {\n            sketch.options[key] = value;\n          }\n        }\n      }\n    }\n    return aCode;\n  }\n\n  // Parse/compiles Processing (Java-like) syntax to JavaScript syntax\n  Processing.compile = function(pdeCode) {\n    var sketch = new Processing.Sketch();\n    var code = preprocessCode(pdeCode, sketch);\n    var compiledPde = parseProcessing(code);\n    sketch.sourceCode = compiledPde;\n    return sketch;\n  };\n\n  var PjsConsole = require(\"../Helpers/PjsConsole\");\n  Processing.logger = new PjsConsole(document);\n\n  // done\n  return Processing;\n};\n\n},{\"../Helpers/PjsConsole\":4}],26:[function(require,module,exports){\n/**\n * Processing.js object\n */\n module.exports = function(options, undef) {\n  var defaultScope = options.defaultScope,\n      extend = options.extend,\n      Browser = options.Browser,\n      ajax = Browser.ajax,\n      navigator = Browser.navigator,\n      window = Browser.window,\n      XMLHttpRequest = window.XMLHttpRequest,\n      document = Browser.document,\n      noop = options.noop,\n\n      PConstants = defaultScope.PConstants;\n      PFont = defaultScope.PFont,\n      PShapeSVG = defaultScope.PShapeSVG,\n      PVector = defaultScope.PVector,\n      Char = Character = defaultScope.Char,\n      ObjectIterator = defaultScope.ObjectIterator,\n      XMLElement = defaultScope.XMLElement,\n      XML = defaultScope.XML;\n\n  // fascinating \"read only\" jshint error if we don't start a new var block here.\n  var HTMLCanvasElement = window.HTMLCanvasElement,\n      HTMLImageElement = window.HTMLImageElement;\n\n  // window.localStorage cannot be accessed if a user is blocking cookies.\n  // In that case, we make it a temporary source cache object.\n  var localStorage;\n  try { localStorage = window.localStorage; } catch (e) { localStorage = {}; }\n\n  var isDOMPresent = (\"document\" in this) && !(\"fake\" in this.document);\n\n  // document.head polyfill for the benefit of Firefox 3.6\n  if (!document.head) {\n    document.head = document.getElementsByTagName('head')[0];\n  }\n\n  var Float32Array = setupTypedArray(\"Float32Array\", \"WebGLFloatArray\"),\n      Int32Array   = setupTypedArray(\"Int32Array\",   \"WebGLIntArray\"),\n      Uint16Array  = setupTypedArray(\"Uint16Array\",  \"WebGLUnsignedShortArray\"),\n      Uint8Array   = setupTypedArray(\"Uint8Array\",   \"WebGLUnsignedByteArray\");\n\n  // Typed Arrays: fallback to WebGL arrays or Native JS arrays if unavailable\n  function setupTypedArray(name, fallback) {\n    // Check if TypedArray exists, and use if so.\n    if (name in window) {\n      return window[name];\n    }\n\n    // Check if WebGLArray exists\n    if (typeof window[fallback] === \"function\") {\n      return window[fallback];\n    }\n\n    // Use Native JS array\n    return function(obj) {\n      if (obj instanceof Array) {\n        return obj;\n      }\n      if (typeof obj === \"number\") {\n        var arr = [];\n        arr.length = obj;\n        return arr;\n      }\n    };\n  }\n\n  /* IE9+ quirks mode check - ticket #1606 */\n  if (document.documentMode >= 9 && !document.doctype) {\n    throw(\"The doctype directive is missing. The recommended doctype in Internet Explorer is the HTML5 doctype: <!DOCTYPE html>\");\n  }\n\n  // Manage multiple Processing instances\n  var processingInstances = [];\n  var processingInstanceIds = {};\n\n  /**\n   * instance tracking - adding new instances\n   */\n  var addInstance = function(processing) {\n    if (processing.externals.canvas.id === undef || !processing.externals.canvas.id.length) {\n      processing.externals.canvas.id = \"__processing\" + processingInstances.length;\n    }\n    processingInstanceIds[processing.externals.canvas.id] = processingInstances.length;\n    processingInstances.push(processing);\n  };\n\n  /**\n   * instance tracking - removal\n   */\n  var removeInstance = function(id) {\n    processingInstances.splice(processingInstanceIds[id], 1);\n    delete processingInstanceIds[id];\n  };\n\n\n  /**\n   * The Processing object\n   */\n  var Processing = this.Processing = function(aCanvas, aCode, aFunctions) {\n\n    if (!(this instanceof Processing)) {\n      throw(\"called Processing constructor as if it were a function: missing 'new'.\");\n    }\n\n    var curElement = {},\n      pgraphicsMode = (aCanvas === undef && aCode === undef);\n\n    if (pgraphicsMode) {\n      curElement = document.createElement(\"canvas\");\n    } else {\n      // We'll take a canvas element or a string for a canvas element's id\n      curElement = typeof aCanvas === \"string\" ? document.getElementById(aCanvas) : aCanvas;\n    }\n\n    if (!('getContext' in curElement)) {\n      throw(\"called Processing constructor without passing canvas element reference or id.\");\n    }\n\n    function unimplemented(s) {\n      Processing.debug('Unimplemented - ' + s);\n    }\n\n    ////////////////////////////////////////////////////////////////////////////\n    // JavaScript event binding and releasing\n    ////////////////////////////////////////////////////////////////////////////\n\n    var eventHandlers = [];\n\n    function attachEventHandler(elem, type, fn) {\n      if (elem.addEventListener) {\n        elem.addEventListener(type, fn, false);\n      } else {\n        elem.attachEvent(\"on\" + type, fn);\n      }\n      eventHandlers.push({elem: elem, type: type, fn: fn});\n    }\n\n    function detachEventHandler(eventHandler) {\n      var elem = eventHandler.elem,\n          type = eventHandler.type,\n          fn   = eventHandler.fn;\n      if (elem.removeEventListener) {\n        elem.removeEventListener(type, fn, false);\n      } else if (elem.detachEvent) {\n        elem.detachEvent(\"on\" + type, fn);\n      }\n    }\n\n    function removeFirstArgument(args) {\n      return Array.prototype.slice.call(args, 1);\n    }\n\n    // When something new is added to \"p.\" it must also be added to the \"names\" array.\n    // The names array contains the names of everything that is inside \"p.\"\n    var p = this;\n\n    p.Char = p.Character = Char;\n\n    // add in the Processing API functions\n    extend.withCommonFunctions(p);\n    extend.withMath(p);\n    extend.withProxyFunctions(p, removeFirstArgument);\n    extend.withTouch(p, curElement, attachEventHandler, document, PConstants);\n\n    // custom functions and properties are added here\n    if(aFunctions) {\n      Object.keys(aFunctions).forEach(function(name) {\n        p[name] = aFunctions[name];\n      });\n    }\n\n    // PJS specific (non-p5) methods and properties to externalize\n    p.externals = {\n      canvas:  curElement,\n      context: undef,\n      sketch:  undef,\n      window: window\n    };\n\n    p.name            = 'Processing.js Instance'; // Set Processing defaults / environment variables\n    p.use3DContext    = false; // default '2d' canvas context\n\n    /**\n     * Confirms if a Processing program is \"focused\", meaning that it is\n     * active and will accept input from mouse or keyboard. This variable\n     * is \"true\" if it is focused and \"false\" if not. This variable is\n     * often used when you want to warn people they need to click on the\n     * browser before it will work.\n    */\n    p.focused         = false;\n    p.breakShape      = false;\n\n    // Glyph path storage for textFonts\n    p.glyphTable      = {};\n\n    // Global vars for tracking mouse position\n    p.pmouseX         = 0;\n    p.pmouseY         = 0;\n    p.mouseX          = 0;\n    p.mouseY          = 0;\n    p.mouseButton     = 0;\n    p.mouseScroll     = 0;\n\n    // Undefined event handlers to be replaced by user when needed\n    p.mouseClicked    = undef;\n    p.mouseDragged    = undef;\n    p.mouseMoved      = undef;\n    p.mousePressed    = undef;\n    p.mouseReleased   = undef;\n    p.mouseScrolled   = undef;\n    p.mouseOver       = undef;\n    p.mouseOut        = undef;\n    p.touchStart      = undef;\n    p.touchEnd        = undef;\n    p.touchMove       = undef;\n    p.touchCancel     = undef;\n    p.key             = undef;\n    p.keyCode         = undef;\n    p.keyPressed      = noop; // needed to remove function checks\n    p.keyReleased     = noop;\n    p.keyTyped        = noop;\n    p.draw            = undef;\n    p.setup           = undef;\n\n    // Remapped vars\n    p.__mousePressed  = false;\n    p.__keyPressed    = false;\n    p.__frameRate     = 60;\n\n    // The current animation frame\n    p.frameCount      = 0;\n\n    // The height/width of the canvas\n    p.width           = 100;\n    p.height          = 100;\n\n    // \"Private\" variables used to maintain state\n    var curContext,\n        curSketch,\n        drawing, // hold a Drawing2D or Drawing3D object\n        doFill = true,\n        fillStyle = [1.0, 1.0, 1.0, 1.0],\n        currentFillColor = 0xFFFFFFFF,\n        isFillDirty = true,\n        doStroke = true,\n        strokeStyle = [0.0, 0.0, 0.0, 1.0],\n        currentStrokeColor = 0xFF000000,\n        isStrokeDirty = true,\n        lineWidth = 1,\n        loopStarted = false,\n        renderSmooth = false,\n        doLoop = true,\n        looping = 0,\n        curRectMode = PConstants.CORNER,\n        curEllipseMode = PConstants.CENTER,\n        normalX = 0,\n        normalY = 0,\n        normalZ = 0,\n        normalMode = PConstants.NORMAL_MODE_AUTO,\n        curFrameRate = 60,\n        curMsPerFrame = 1000/curFrameRate,\n        curCursor = PConstants.ARROW,\n        oldCursor = curElement.style.cursor,\n        curShape = PConstants.POLYGON,\n        curShapeCount = 0,\n        curvePoints = [],\n        curTightness = 0,\n        curveDet = 20,\n        curveInited = false,\n        backgroundObj = -3355444, // rgb(204, 204, 204) is the default gray background colour\n        bezDetail = 20,\n        colorModeA = 255,\n        colorModeX = 255,\n        colorModeY = 255,\n        colorModeZ = 255,\n        pathOpen = false,\n        mouseDragging = false,\n        pmouseXLastFrame = 0,\n        pmouseYLastFrame = 0,\n        curColorMode = PConstants.RGB,\n        curTint = null,\n        curTint3d = null,\n        getLoaded = false,\n        start = Date.now(),\n        timeSinceLastFPS = start,\n        framesSinceLastFPS = 0,\n        textcanvas,\n        curveBasisMatrix,\n        curveToBezierMatrix,\n        curveDrawMatrix,\n        bezierDrawMatrix,\n        bezierBasisInverse,\n        bezierBasisMatrix,\n        curContextCache = { attributes: {}, locations: {} },\n        // Shaders\n        programObject3D,\n        programObject2D,\n        programObjectUnlitShape,\n        boxBuffer,\n        boxNormBuffer,\n        boxOutlineBuffer,\n        rectBuffer,\n        rectNormBuffer,\n        sphereBuffer,\n        lineBuffer,\n        fillBuffer,\n        fillColorBuffer,\n        strokeColorBuffer,\n        pointBuffer,\n        shapeTexVBO,\n        canTex,   // texture for createGraphics\n        textTex,   // texture for 3d tex\n        curTexture = {width:0,height:0},\n        curTextureMode = PConstants.IMAGE,\n        usingTexture = false,\n        textBuffer,\n        textureBuffer,\n        indexBuffer,\n        // Text alignment\n        horizontalTextAlignment = PConstants.LEFT,\n        verticalTextAlignment = PConstants.BASELINE,\n        textMode = PConstants.MODEL,\n        // Font state\n        curFontName = \"Arial\",\n        curTextSize = 12,\n        curTextAscent = 9,\n        curTextDescent = 2,\n        curTextLeading = 14,\n        curTextFont = PFont.get(curFontName, curTextSize),\n        // Pixels cache\n        originalContext,\n        proxyContext = null,\n        isContextReplaced = false,\n        setPixelsCached,\n        maxPixelsCached = 1000,\n        pressedKeysMap = [],\n        lastPressedKeyCode = null,\n        codedKeys = [ PConstants.SHIFT, PConstants.CONTROL, PConstants.ALT, PConstants.CAPSLK, PConstants.PGUP, PConstants.PGDN,\n                      PConstants.END, PConstants.HOME, PConstants.LEFT, PConstants.UP, PConstants.RIGHT, PConstants.DOWN, PConstants.NUMLK,\n                      PConstants.INSERT, PConstants.F1, PConstants.F2, PConstants.F3, PConstants.F4, PConstants.F5, PConstants.F6, PConstants.F7,\n                      PConstants.F8, PConstants.F9, PConstants.F10, PConstants.F11, PConstants.F12, PConstants.META ];\n\n    // User can only have MAX_LIGHTS lights\n    var lightCount = 0;\n\n    //sphere stuff\n    var sphereDetailV = 0,\n        sphereDetailU = 0,\n        sphereX = [],\n        sphereY = [],\n        sphereZ = [],\n        sinLUT = new Float32Array(PConstants.SINCOS_LENGTH),\n        cosLUT = new Float32Array(PConstants.SINCOS_LENGTH),\n        sphereVerts,\n        sphereNorms;\n\n    // Camera defaults and settings\n    var cam,\n        cameraInv,\n        modelView,\n        modelViewInv,\n        userMatrixStack,\n        userReverseMatrixStack,\n        inverseCopy,\n        projection,\n        manipulatingCamera = false,\n        frustumMode = false,\n        cameraFOV = 60 * (Math.PI / 180),\n        cameraX = p.width / 2,\n        cameraY = p.height / 2,\n        cameraZ = cameraY / Math.tan(cameraFOV / 2),\n        cameraNear = cameraZ / 10,\n        cameraFar = cameraZ * 10,\n        cameraAspect = p.width / p.height;\n\n    var vertArray = [],\n        curveVertArray = [],\n        curveVertCount = 0,\n        isCurve = false,\n        isBezier = false,\n        firstVert = true;\n\n    //PShape stuff\n    var curShapeMode = PConstants.CORNER;\n\n    // Stores states for pushStyle() and popStyle().\n    var styleArray = [];\n\n    // The vertices for the box cannot be specified using a triangle strip since each\n    // side of the cube must have its own set of normals.\n    // Vertices are specified in a counter-clockwise order.\n    // Triangles are in this order: back, front, right, bottom, left, top.\n    var boxVerts = new Float32Array([\n       0.5,  0.5, -0.5,  0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5,  0.5, -0.5,  0.5,  0.5, -0.5,\n       0.5,  0.5,  0.5, -0.5,  0.5,  0.5, -0.5, -0.5,  0.5, -0.5, -0.5,  0.5,  0.5, -0.5,  0.5,  0.5,  0.5,  0.5,\n       0.5,  0.5, -0.5,  0.5,  0.5,  0.5,  0.5, -0.5,  0.5,  0.5, -0.5,  0.5,  0.5, -0.5, -0.5,  0.5,  0.5, -0.5,\n       0.5, -0.5, -0.5,  0.5, -0.5,  0.5, -0.5, -0.5,  0.5, -0.5, -0.5,  0.5, -0.5, -0.5, -0.5,  0.5, -0.5, -0.5,\n      -0.5, -0.5, -0.5, -0.5, -0.5,  0.5, -0.5,  0.5,  0.5, -0.5,  0.5,  0.5, -0.5,  0.5, -0.5, -0.5, -0.5, -0.5,\n       0.5,  0.5,  0.5,  0.5,  0.5, -0.5, -0.5,  0.5, -0.5, -0.5,  0.5, -0.5, -0.5,  0.5,  0.5,  0.5,  0.5,  0.5]);\n\n    var boxOutlineVerts = new Float32Array([\n       0.5,  0.5,  0.5,  0.5, -0.5,  0.5,  0.5,  0.5, -0.5,  0.5, -0.5, -0.5,\n      -0.5,  0.5, -0.5, -0.5, -0.5, -0.5, -0.5,  0.5,  0.5, -0.5, -0.5,  0.5,\n       0.5,  0.5,  0.5,  0.5,  0.5, -0.5,  0.5,  0.5, -0.5, -0.5,  0.5, -0.5,\n      -0.5,  0.5, -0.5, -0.5,  0.5,  0.5, -0.5,  0.5,  0.5,  0.5,  0.5,  0.5,\n       0.5, -0.5,  0.5,  0.5, -0.5, -0.5,  0.5, -0.5, -0.5, -0.5, -0.5, -0.5,\n      -0.5, -0.5, -0.5, -0.5, -0.5,  0.5, -0.5, -0.5,  0.5,  0.5, -0.5,  0.5]);\n\n    var boxNorms = new Float32Array([\n       0,  0, -1,  0,  0, -1,  0,  0, -1,  0,  0, -1,  0,  0, -1,  0,  0, -1,\n       0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,\n       1,  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  0,\n       0, -1,  0,  0, -1,  0,  0, -1,  0,  0, -1,  0,  0, -1,  0,  0, -1,  0,\n      -1,  0,  0, -1,  0,  0, -1,  0,  0, -1,  0,  0, -1,  0,  0, -1,  0,  0,\n       0,  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,  0]);\n\n    // These verts are used for the fill and stroke using TRIANGLE_FAN and LINE_LOOP.\n    var rectVerts = new Float32Array([0,0,0, 0,1,0, 1,1,0, 1,0,0]);\n\n    var rectNorms = new Float32Array([0,0,1, 0,0,1, 0,0,1, 0,0,1]);\n\n    // Shader for points and lines in begin/endShape.\n    var vertexShaderSrcUnlitShape =\n      \"varying vec4 vFrontColor;\" +\n\n      \"attribute vec3 aVertex;\" +\n      \"attribute vec4 aColor;\" +\n\n      \"uniform mat4 uView;\" +\n      \"uniform mat4 uProjection;\" +\n      \"uniform float uPointSize;\" +\n\n      \"void main(void) {\" +\n      \"  vFrontColor = aColor;\" +\n      \"  gl_PointSize = uPointSize;\" +\n      \"  gl_Position = uProjection * uView * vec4(aVertex, 1.0);\" +\n      \"}\";\n\n    var fragmentShaderSrcUnlitShape =\n      \"#ifdef GL_ES\\n\" +\n      \"precision highp float;\\n\" +\n      \"#endif\\n\" +\n\n      \"varying vec4 vFrontColor;\" +\n      \"uniform bool uSmooth;\" +\n\n      \"void main(void){\" +\n      \"  if(uSmooth == true){\" +\n      \"    float dist = distance(gl_PointCoord, vec2(0.5));\" +\n      \"    if(dist > 0.5){\" +\n      \"      discard;\" +\n      \"    }\" +\n      \"  }\" +\n      \"  gl_FragColor = vFrontColor;\" +\n      \"}\";\n\n    // Shader for rect, text, box outlines, sphere outlines, point() and line().\n    var vertexShaderSrc2D =\n      \"varying vec4 vFrontColor;\" +\n\n      \"attribute vec3 aVertex;\" +\n      \"attribute vec2 aTextureCoord;\" +\n      \"uniform vec4 uColor;\" +\n\n      \"uniform mat4 uModel;\" +\n      \"uniform mat4 uView;\" +\n      \"uniform mat4 uProjection;\" +\n      \"uniform float uPointSize;\" +\n      \"varying vec2 vTextureCoord;\"+\n\n      \"void main(void) {\" +\n      \"  gl_PointSize = uPointSize;\" +\n      \"  vFrontColor = uColor;\" +\n      \"  gl_Position = uProjection * uView * uModel * vec4(aVertex, 1.0);\" +\n      \"  vTextureCoord = aTextureCoord;\" +\n      \"}\";\n\n    var fragmentShaderSrc2D =\n      \"#ifdef GL_ES\\n\" +\n      \"precision highp float;\\n\" +\n      \"#endif\\n\" +\n\n      \"varying vec4 vFrontColor;\" +\n      \"varying vec2 vTextureCoord;\"+\n\n      \"uniform sampler2D uSampler;\"+\n      \"uniform int uIsDrawingText;\"+\n      \"uniform bool uSmooth;\" +\n\n      \"void main(void){\" +\n      // WebGL does not support POINT_SMOOTH, so we do it ourselves\n      \"  if(uSmooth == true){\" +\n      \"    float dist = distance(gl_PointCoord, vec2(0.5));\" +\n      \"    if(dist > 0.5){\" +\n      \"      discard;\" +\n      \"    }\" +\n      \"  }\" +\n\n      \"  if(uIsDrawingText == 1){\" +\n      \"    float alpha = texture2D(uSampler, vTextureCoord).a;\"+\n      \"    gl_FragColor = vec4(vFrontColor.rgb * alpha, alpha);\"+\n      \"  }\" +\n      \"  else{\" +\n      \"    gl_FragColor = vFrontColor;\" +\n      \"  }\" +\n      \"}\";\n\n    var webglMaxTempsWorkaround = /Windows/.test(navigator.userAgent);\n\n    // Vertex shader for boxes and spheres.\n    var vertexShaderSrc3D =\n      \"varying vec4 vFrontColor;\" +\n\n      \"attribute vec3 aVertex;\" +\n      \"attribute vec3 aNormal;\" +\n      \"attribute vec4 aColor;\" +\n      \"attribute vec2 aTexture;\" +\n      \"varying   vec2 vTexture;\" +\n\n      \"uniform vec4 uColor;\" +\n\n      \"uniform bool uUsingMat;\" +\n      \"uniform vec3 uSpecular;\" +\n      \"uniform vec3 uMaterialEmissive;\" +\n      \"uniform vec3 uMaterialAmbient;\" +\n      \"uniform vec3 uMaterialSpecular;\" +\n      \"uniform float uShininess;\" +\n\n      \"uniform mat4 uModel;\" +\n      \"uniform mat4 uView;\" +\n      \"uniform mat4 uProjection;\" +\n      \"uniform mat4 uNormalTransform;\" +\n\n      \"uniform int uLightCount;\" +\n      \"uniform vec3 uFalloff;\" +\n\n      // Careful changing the order of these fields. Some cards\n      // have issues with memory alignment.\n      \"struct Light {\" +\n      \"  int type;\" +\n      \"  vec3 color;\" +\n      \"  vec3 position;\" +\n      \"  vec3 direction;\" +\n      \"  float angle;\" +\n      \"  vec3 halfVector;\" +\n      \"  float concentration;\" +\n      \"};\" +\n\n      // nVidia cards have issues with arrays of structures\n      // so instead we create 8 instances of Light.\n      \"uniform Light uLights0;\" +\n      \"uniform Light uLights1;\" +\n      \"uniform Light uLights2;\" +\n      \"uniform Light uLights3;\" +\n      \"uniform Light uLights4;\" +\n      \"uniform Light uLights5;\" +\n      \"uniform Light uLights6;\" +\n      \"uniform Light uLights7;\" +\n\n     // GLSL does not support switch.\n      \"Light getLight(int index){\" +\n      \"  if(index == 0) return uLights0;\" +\n      \"  if(index == 1) return uLights1;\" +\n      \"  if(index == 2) return uLights2;\" +\n      \"  if(index == 3) return uLights3;\" +\n      \"  if(index == 4) return uLights4;\" +\n      \"  if(index == 5) return uLights5;\" +\n      \"  if(index == 6) return uLights6;\" +\n      // Do not use a conditional for the last return statement\n      // because some video cards will fail and complain that\n      // \"not all paths return\".\n      \"  return uLights7;\" +\n      \"}\" +\n\n      \"void AmbientLight( inout vec3 totalAmbient, in vec3 ecPos, in Light light ) {\" +\n      // Get the vector from the light to the vertex and\n      // get the distance from the current vector to the light position.\n      \"  float d = length( light.position - ecPos );\" +\n      \"  float attenuation = 1.0 / ( uFalloff[0] + ( uFalloff[1] * d ) + ( uFalloff[2] * d * d ));\" +\n      \"  totalAmbient += light.color * attenuation;\" +\n      \"}\" +\n\n      /*\n        col - accumulated color\n        spec - accumulated specular highlight\n        vertNormal - Normal of the vertex\n        ecPos - eye coordinate position\n        light - light structure\n      */\n      \"void DirectionalLight( inout vec3 col, inout vec3 spec, in vec3 vertNormal, in vec3 ecPos, in Light light ) {\" +\n      \"  float powerFactor = 0.0;\" +\n      \"  float nDotVP = max(0.0, dot( vertNormal, normalize(-light.position) ));\" +\n      \"  float nDotVH = max(0.0, dot( vertNormal, normalize(-light.position-normalize(ecPos) )));\" +\n\n      \"  if( nDotVP != 0.0 ){\" +\n      \"    powerFactor = pow( nDotVH, uShininess );\" +\n      \"  }\" +\n\n      \"  col += light.color * nDotVP;\" +\n      \"  spec += uSpecular * powerFactor;\" +\n      \"}\" +\n\n      /*\n        col - accumulated color\n        spec - accumulated specular highlight\n        vertNormal - Normal of the vertex\n        ecPos - eye coordinate position\n        light - light structure\n      */\n      \"void PointLight( inout vec3 col, inout vec3 spec, in vec3 vertNormal, in vec3 ecPos, in Light light ) {\" +\n      \"  float powerFactor;\" +\n\n      // Get the vector from the light to the vertex.\n      \"   vec3 VP = light.position - ecPos;\" +\n\n      // Get the distance from the current vector to the light position.\n      \"  float d = length( VP ); \" +\n\n      // Normalize the light ray so it can be used in the dot product operation.\n      \"  VP = normalize( VP );\" +\n\n      \"  float attenuation = 1.0 / ( uFalloff[0] + ( uFalloff[1] * d ) + ( uFalloff[2] * d * d ));\" +\n\n      \"  float nDotVP = max( 0.0, dot( vertNormal, VP ));\" +\n      \"  vec3 halfVector = normalize( VP - normalize(ecPos) );\" +\n      \"  float nDotHV = max( 0.0, dot( vertNormal, halfVector ));\" +\n\n      \"  if( nDotVP == 0.0 ) {\" +\n      \"    powerFactor = 0.0;\" +\n      \"  }\" +\n      \"  else {\" +\n      \"    powerFactor = pow( nDotHV, uShininess );\" +\n      \"  }\" +\n\n      \"  spec += uSpecular * powerFactor * attenuation;\" +\n      \"  col += light.color * nDotVP * attenuation;\" +\n      \"}\" +\n\n      /*\n        col - accumulated color\n        spec - accumulated specular highlight\n        vertNormal - Normal of the vertex\n        ecPos - eye coordinate position\n        light - light structure\n      */\n      \"void SpotLight( inout vec3 col, inout vec3 spec, in vec3 vertNormal, in vec3 ecPos, in Light light ) {\" +\n      \"  float spotAttenuation;\" +\n      \"  float powerFactor = 0.0;\" +\n\n      // Calculate the vector from the current vertex to the light.\n      \"  vec3 VP = light.position - ecPos;\" +\n      \"  vec3 ldir = normalize( -light.direction );\" +\n\n      // Get the distance from the spotlight and the vertex\n      \"  float d = length( VP );\" +\n      \"  VP = normalize( VP );\" +\n\n      \"  float attenuation = 1.0 / ( uFalloff[0] + ( uFalloff[1] * d ) + ( uFalloff[2] * d * d ) );\" +\n\n      // Dot product of the vector from vertex to light and light direction.\n      \"  float spotDot = dot( VP, ldir );\" +\n\n      // If the vertex falls inside the cone\n      (webglMaxTempsWorkaround ? // Windows reports max temps error if light.angle is used\n      \"  spotAttenuation = 1.0; \" :\n      \"  if( spotDot > cos( light.angle ) ) {\" +\n      \"    spotAttenuation = pow( spotDot, light.concentration );\" +\n      \"  }\" +\n      \"  else{\" +\n      \"    spotAttenuation = 0.0;\" +\n      \"  }\" +\n      \"  attenuation *= spotAttenuation;\" +\n      \"\") +\n\n      \"  float nDotVP = max( 0.0, dot( vertNormal, VP ) );\" +\n      \"  vec3 halfVector = normalize( VP - normalize(ecPos) );\" +\n      \"  float nDotHV = max( 0.0, dot( vertNormal, halfVector ) );\" +\n\n      \"  if( nDotVP != 0.0 ) {\" +\n      \"    powerFactor = pow( nDotHV, uShininess );\" +\n      \"  }\" +\n\n      \"  spec += uSpecular * powerFactor * attenuation;\" +\n      \"  col += light.color * nDotVP * attenuation;\" +\n      \"}\" +\n\n      \"void main(void) {\" +\n      \"  vec3 finalAmbient = vec3( 0.0 );\" +\n      \"  vec3 finalDiffuse = vec3( 0.0 );\" +\n      \"  vec3 finalSpecular = vec3( 0.0 );\" +\n\n      \"  vec4 col = uColor;\" +\n\n      \"  if ( uColor[0] == -1.0 ){\" +\n      \"    col = aColor;\" +\n      \"  }\" +\n\n      // We use the sphere vertices as the normals when we create the sphere buffer.\n      // But this only works if the sphere vertices are unit length, so we\n      // have to normalize the normals here. Since this is only required for spheres\n      // we could consider placing this in a conditional later on.\n      \"  vec3 norm = normalize(vec3( uNormalTransform * vec4( aNormal, 0.0 ) ));\" +\n\n      \"  vec4 ecPos4 = uView * uModel * vec4(aVertex, 1.0);\" +\n      \"  vec3 ecPos = (vec3(ecPos4))/ecPos4.w;\" +\n\n      // If there were no lights this draw call, just use the\n      // assigned fill color of the shape and the specular value.\n      \"  if( uLightCount == 0 ) {\" +\n      \"    vFrontColor = col + vec4(uMaterialSpecular, 1.0);\" +\n      \"  }\" +\n      \"  else {\" +\n           // WebGL forces us to iterate over a constant value\n           // so we can't iterate using lightCount.\n      \"    for( int i = 0; i < 8; i++ ) {\" +\n      \"      Light l = getLight(i);\" +\n\n      // We can stop iterating if we know we have gone past\n      // the number of lights which are actually on. This gives us a\n      // significant performance increase with high vertex counts.\n      \"      if( i >= uLightCount ){\" +\n      \"        break;\" +\n      \"      }\" +\n\n      \"      if( l.type == 0 ) {\" +\n      \"        AmbientLight( finalAmbient, ecPos, l );\" +\n      \"      }\" +\n      \"      else if( l.type == 1 ) {\" +\n      \"        DirectionalLight( finalDiffuse, finalSpecular, norm, ecPos, l );\" +\n      \"      }\" +\n      \"      else if( l.type == 2 ) {\" +\n      \"        PointLight( finalDiffuse, finalSpecular, norm, ecPos, l );\" +\n      \"      }\" +\n      \"      else {\" +\n      \"        SpotLight( finalDiffuse, finalSpecular, norm, ecPos, l );\" +\n      \"      }\" +\n      \"    }\" +\n\n      \"   if( uUsingMat == false ) {\" +\n      \"     vFrontColor = vec4(\" +\n      \"       vec3( col ) * finalAmbient +\" +\n      \"       vec3( col ) * finalDiffuse +\" +\n      \"       vec3( col ) * finalSpecular,\" +\n      \"       col[3] );\" +\n      \"   }\" +\n      \"   else{\" +\n      \"     vFrontColor = vec4( \" +\n      \"       uMaterialEmissive + \" +\n      \"       (vec3(col) * uMaterialAmbient * finalAmbient ) + \" +\n      \"       (vec3(col) * finalDiffuse) + \" +\n      \"       (uMaterialSpecular * finalSpecular), \" +\n      \"       col[3] );\" +\n      \"    }\" +\n      \"  }\" +\n\n      \"  vTexture.xy = aTexture.xy;\" +\n      \"  gl_Position = uProjection * uView * uModel * vec4( aVertex, 1.0 );\" +\n      \"}\";\n\n    var fragmentShaderSrc3D =\n      \"#ifdef GL_ES\\n\" +\n      \"precision highp float;\\n\" +\n      \"#endif\\n\" +\n\n      \"varying vec4 vFrontColor;\" +\n\n      \"uniform sampler2D uSampler;\" +\n      \"uniform bool uUsingTexture;\" +\n      \"varying vec2 vTexture;\" +\n\n      // In Processing, when a texture is used, the fill color is ignored\n      // vec4(1.0,1.0,1.0,0.5)\n      \"void main(void){\" +\n      \"  if( uUsingTexture ){\" +\n      \"    gl_FragColor = vec4(texture2D(uSampler, vTexture.xy)) * vFrontColor;\" +\n      \"  }\"+\n      \"  else{\" +\n      \"    gl_FragColor = vFrontColor;\" +\n      \"  }\" +\n      \"}\";\n\n    ////////////////////////////////////////////////////////////////////////////\n    // 3D Functions\n    ////////////////////////////////////////////////////////////////////////////\n\n    /*\n     * Sets a uniform variable in a program object to a particular\n     * value. Before calling this function, ensure the correct\n     * program object has been installed as part of the current\n     * rendering state by calling useProgram.\n     *\n     * On some systems, if the variable exists in the shader but isn't used,\n     * the compiler will optimize it out and this function will fail.\n     *\n     * @param {String} cacheId\n     * @param {WebGLProgram} programObj program object returned from\n     * createProgramObject\n     * @param {String} varName the name of the variable in the shader\n     * @param {float | Array} varValue either a scalar value or an Array\n     *\n     * @returns none\n     *\n     * @see uniformi\n     * @see uniformMatrix\n    */\n    function uniformf(cacheId, programObj, varName, varValue) {\n      var varLocation = curContextCache.locations[cacheId];\n      if(varLocation === undef) {\n        varLocation = curContext.getUniformLocation(programObj, varName);\n        curContextCache.locations[cacheId] = varLocation;\n      }\n      // the variable won't be found if it was optimized out.\n      if (varLocation !== null) {\n        if (varValue.length === 4) {\n          curContext.uniform4fv(varLocation, varValue);\n        } else if (varValue.length === 3) {\n          curContext.uniform3fv(varLocation, varValue);\n        } else if (varValue.length === 2) {\n          curContext.uniform2fv(varLocation, varValue);\n        } else {\n          curContext.uniform1f(varLocation, varValue);\n        }\n      }\n    }\n\n    /**\n     * Sets a uniform int or int array in a program object to a particular\n     * value. Before calling this function, ensure the correct\n     * program object has been installed as part of the current\n     * rendering state.\n     *\n     * On some systems, if the variable exists in the shader but isn't used,\n     * the compiler will optimize it out and this function will fail.\n     *\n     * @param {String} cacheId\n     * @param {WebGLProgram} programObj program object returned from\n     * createProgramObject\n     * @param {String} varName the name of the variable in the shader\n     * @param {int | Array} varValue either a scalar value or an Array\n     *\n     * @returns none\n     *\n     * @see uniformf\n     * @see uniformMatrix\n    */\n    function uniformi(cacheId, programObj, varName, varValue) {\n      var varLocation = curContextCache.locations[cacheId];\n      if(varLocation === undef) {\n        varLocation = curContext.getUniformLocation(programObj, varName);\n        curContextCache.locations[cacheId] = varLocation;\n      }\n      // the variable won't be found if it was optimized out.\n      if (varLocation !== null) {\n        if (varValue.length === 4) {\n          curContext.uniform4iv(varLocation, varValue);\n        } else if (varValue.length === 3) {\n          curContext.uniform3iv(varLocation, varValue);\n        } else if (varValue.length === 2) {\n          curContext.uniform2iv(varLocation, varValue);\n        } else {\n          curContext.uniform1i(varLocation, varValue);\n        }\n      }\n    }\n\n    /**\n     * Sets the value of a uniform matrix variable in a program\n     * object. Before calling this function, ensure the correct\n     * program object has been installed as part of the current\n     * rendering state.\n     *\n     * On some systems, if the variable exists in the shader but\n     * isn't used, the compiler will optimize it out and this\n     * function will fail.\n     *\n     * @param {String} cacheId\n     * @param {WebGLProgram} programObj program object returned from\n     * createProgramObject\n     * @param {String} varName the name of the variable in the shader\n     * @param {boolean} transpose must be false\n     * @param {Array} matrix an array of 4, 9 or 16 values\n     *\n     * @returns none\n     *\n     * @see uniformi\n     * @see uniformf\n    */\n    function uniformMatrix(cacheId, programObj, varName, transpose, matrix) {\n      var varLocation = curContextCache.locations[cacheId];\n      if(varLocation === undef) {\n        varLocation = curContext.getUniformLocation(programObj, varName);\n        curContextCache.locations[cacheId] = varLocation;\n      }\n      // The variable won't be found if it was optimized out.\n      if (varLocation !== -1) {\n        if (matrix.length === 16) {\n          curContext.uniformMatrix4fv(varLocation, transpose, matrix);\n        } else if (matrix.length === 9) {\n          curContext.uniformMatrix3fv(varLocation, transpose, matrix);\n        } else {\n          curContext.uniformMatrix2fv(varLocation, transpose, matrix);\n        }\n      }\n    }\n\n    /**\n     * Binds the VBO, sets the vertex attribute data for the program\n     * object and enables the attribute.\n     *\n     * On some systems, if the attribute exists in the shader but\n     * isn't used, the compiler will optimize it out and this\n     * function will fail.\n     *\n     * @param {String} cacheId\n     * @param {WebGLProgram} programObj program object returned from\n     * createProgramObject\n     * @param {String} varName the name of the variable in the shader\n     * @param {int} size the number of components per vertex attribute\n     * @param {WebGLBuffer} VBO Vertex Buffer Object\n     *\n     * @returns none\n     *\n     * @see disableVertexAttribPointer\n    */\n    function vertexAttribPointer(cacheId, programObj, varName, size, VBO) {\n      var varLocation = curContextCache.attributes[cacheId];\n      if(varLocation === undef) {\n        varLocation = curContext.getAttribLocation(programObj, varName);\n        curContextCache.attributes[cacheId] = varLocation;\n      }\n      if (varLocation !== -1) {\n        curContext.bindBuffer(curContext.ARRAY_BUFFER, VBO);\n        curContext.vertexAttribPointer(varLocation, size, curContext.FLOAT, false, 0, 0);\n        curContext.enableVertexAttribArray(varLocation);\n      }\n    }\n\n    /**\n     * Disables a program object attribute from being sent to WebGL.\n     *\n     * @param {String} cacheId\n     * @param {WebGLProgram} programObj program object returned from\n     * createProgramObject\n     * @param {String} varName name of the attribute\n     *\n     * @returns none\n     *\n     * @see vertexAttribPointer\n    */\n    function disableVertexAttribPointer(cacheId, programObj, varName){\n      var varLocation = curContextCache.attributes[cacheId];\n      if(varLocation === undef) {\n        varLocation = curContext.getAttribLocation(programObj, varName);\n        curContextCache.attributes[cacheId] = varLocation;\n      }\n      if (varLocation !== -1) {\n        curContext.disableVertexAttribArray(varLocation);\n      }\n    }\n\n    /**\n     * Creates a WebGL program object.\n     *\n     * @param {String} vetexShaderSource\n     * @param {String} fragmentShaderSource\n     *\n     * @returns {WebGLProgram} A program object\n    */\n    var createProgramObject = function(curContext, vetexShaderSource, fragmentShaderSource) {\n      var vertexShaderObject = curContext.createShader(curContext.VERTEX_SHADER);\n      curContext.shaderSource(vertexShaderObject, vetexShaderSource);\n      curContext.compileShader(vertexShaderObject);\n      if (!curContext.getShaderParameter(vertexShaderObject, curContext.COMPILE_STATUS)) {\n        throw curContext.getShaderInfoLog(vertexShaderObject);\n      }\n\n      var fragmentShaderObject = curContext.createShader(curContext.FRAGMENT_SHADER);\n      curContext.shaderSource(fragmentShaderObject, fragmentShaderSource);\n      curContext.compileShader(fragmentShaderObject);\n      if (!curContext.getShaderParameter(fragmentShaderObject, curContext.COMPILE_STATUS)) {\n        throw curContext.getShaderInfoLog(fragmentShaderObject);\n      }\n\n      var programObject = curContext.createProgram();\n      curContext.attachShader(programObject, vertexShaderObject);\n      curContext.attachShader(programObject, fragmentShaderObject);\n      curContext.linkProgram(programObject);\n      if (!curContext.getProgramParameter(programObject, curContext.LINK_STATUS)) {\n        throw \"Error linking shaders.\";\n      }\n\n      return programObject;\n    };\n\n    ////////////////////////////////////////////////////////////////////////////\n    // 2D/3D drawing handling\n    ////////////////////////////////////////////////////////////////////////////\n    var imageModeCorner = function(x, y, w, h, whAreSizes) {\n      return {\n        x: x,\n        y: y,\n        w: w,\n        h: h\n      };\n    };\n    var imageModeConvert = imageModeCorner;\n\n    var imageModeCorners = function(x, y, w, h, whAreSizes) {\n      return {\n        x: x,\n        y: y,\n        w: whAreSizes ? w : w - x,\n        h: whAreSizes ? h : h - y\n      };\n    };\n\n    var imageModeCenter = function(x, y, w, h, whAreSizes) {\n      return {\n        x: x - w / 2,\n        y: y - h / 2,\n        w: w,\n        h: h\n      };\n    };\n\n    // Objects for shared, 2D and 3D contexts\n    var DrawingShared = function(){};\n    var Drawing2D = function(){};\n    var Drawing3D = function(){};\n    var DrawingPre = function(){};\n\n    // Setup the prototype chain\n    Drawing2D.prototype = new DrawingShared();\n    Drawing2D.prototype.constructor = Drawing2D;\n    Drawing3D.prototype = new DrawingShared();\n    Drawing3D.prototype.constructor = Drawing3D;\n    DrawingPre.prototype = new DrawingShared();\n    DrawingPre.prototype.constructor = DrawingPre;\n\n    // A no-op function for when the user calls 3D functions from a 2D sketch\n    // We can change this to a throw or console.error() later if we want\n    DrawingShared.prototype.a3DOnlyFunction = noop;\n\n    /**\n     * The shape() function displays shapes to the screen.\n     * Processing currently works with SVG shapes only.\n     * The <b>shape</b> parameter specifies the shape to display and the <b>x</b>\n     * and <b>y</b> parameters define the location of the shape from its\n     * upper-left corner.\n     * The shape is displayed at its original size unless the <b>width</b>\n     * and <b>height</b> parameters specify a different size.\n     * The <b>shapeMode()</b> function changes the way the parameters work.\n     * A call to <b>shapeMode(CORNERS)</b>, for example, will change the width\n     * and height parameters to define the x and y values of the opposite corner\n     * of the shape.\n     * <br><br>\n     * Note complex shapes may draw awkwardly with P2D, P3D, and OPENGL. Those\n     * renderers do not yet support shapes that have holes or complicated breaks.\n     *\n     * @param {PShape} shape       the shape to display\n     * @param {int|float} x        x-coordinate of the shape\n     * @param {int|float} y        y-coordinate of the shape\n     * @param {int|float} width    width to display the shape\n     * @param {int|float} height   height to display the shape\n     *\n     * @see PShape\n     * @see loadShape()\n     * @see shapeMode()\n     */\n    p.shape = function(shape, x, y, width, height) {\n      if (arguments.length >= 1 && arguments[0] !== null) {\n        if (shape.isVisible()) {\n          p.pushMatrix();\n          if (curShapeMode === PConstants.CENTER) {\n            if (arguments.length === 5) {\n              p.translate(x - width/2, y - height/2);\n              p.scale(width / shape.getWidth(), height / shape.getHeight());\n            } else if (arguments.length === 3) {\n              p.translate(x - shape.getWidth()/2, - shape.getHeight()/2);\n            } else {\n              p.translate(-shape.getWidth()/2, -shape.getHeight()/2);\n            }\n          } else if (curShapeMode === PConstants.CORNER) {\n            if (arguments.length === 5) {\n              p.translate(x, y);\n              p.scale(width / shape.getWidth(), height / shape.getHeight());\n            } else if (arguments.length === 3) {\n              p.translate(x, y);\n            }\n          } else if (curShapeMode === PConstants.CORNERS) {\n            if (arguments.length === 5) {\n              width  -= x;\n              height -= y;\n              p.translate(x, y);\n              p.scale(width / shape.getWidth(), height / shape.getHeight());\n            } else if (arguments.length === 3) {\n              p.translate(x, y);\n            }\n          }\n          shape.draw(p);\n          if ((arguments.length === 1 && curShapeMode === PConstants.CENTER ) || arguments.length > 1) {\n            p.popMatrix();\n          }\n        }\n      }\n    };\n\n    /**\n     * The shapeMode() function modifies the location from which shapes draw.\n     * The default mode is <b>shapeMode(CORNER)</b>, which specifies the\n     * location to be the upper left corner of the shape and uses the third\n     * and fourth parameters of <b>shape()</b> to specify the width and height.\n     * The syntax <b>shapeMode(CORNERS)</b> uses the first and second parameters\n     * of <b>shape()</b> to set the location of one corner and uses the third\n     * and fourth parameters to set the opposite corner.\n     * The syntax <b>shapeMode(CENTER)</b> draws the shape from its center point\n     * and uses the third and forth parameters of <b>shape()</b> to specify the\n     * width and height.\n     * The parameter must be written in \"ALL CAPS\" because Processing syntax\n     * is case sensitive.\n     *\n     * @param {int} mode One of CORNER, CORNERS, CENTER\n     *\n     * @see shape()\n     * @see rectMode()\n     */\n    p.shapeMode = function (mode) {\n      curShapeMode = mode;\n    };\n\n    /**\n     * The loadShape() function loads vector shapes into a variable of type PShape. Currently, only SVG files may be loaded.\n     * In most cases, <b>loadShape()</b> should be used inside <b>setup()</b> because loading shapes inside <b>draw()</b> will reduce the speed of a sketch.\n     *\n     * @param {String} filename     an SVG file\n     *\n     * @return {PShape} a object of type PShape or null\n     * @see PShape\n     * @see PApplet#shape()\n     * @see PApplet#shapeMode()\n     */\n    p.loadShape = function (filename) {\n      if (arguments.length === 1) {\n        if (filename.indexOf(\".svg\") > -1) {\n          return new PShapeSVG(null, filename);\n        }\n      }\n      return null;\n    };\n\n    /**\n     * Processing 2.0 function for loading XML files.\n     *\n     * @param {String} uri The uri for the xml file to load.\n     *\n     * @return {XML} An XML object representing the xml data.\n     */\n    p.loadXML = function(uri) {\n      return new XML(p, uri);\n    };\n\n    /**\n     * Processing 2.0 function for creating XML elements from string\n     *\n     * @param {String} xml the XML source code\n     *\n     * @return {XML} An XML object representation of the input XML markup.\n     */\n    p.parseXML = function(xmlstring) {\n      var element = new XML();\n      element.parse(xmlstring);\n      return element;\n    };\n\n    ////////////////////////////////////////////////////////////////////////////\n    // 2D Matrix\n    ////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * Helper function for printMatrix(). Finds the largest scalar\n     * in the matrix, then number of digits left of the decimal.\n     * Call from PMatrix2D and PMatrix3D's print() function.\n     */\n    var printMatrixHelper = function(elements) {\n      var big = 0;\n      for (var i = 0; i < elements.length; i++) {\n        if (i !== 0) {\n          big = Math.max(big, Math.abs(elements[i]));\n        } else {\n          big = Math.abs(elements[i]);\n        }\n      }\n\n      var digits = (big + \"\").indexOf(\".\");\n      if (digits === 0) {\n        digits = 1;\n      } else if (digits === -1) {\n        digits = (big + \"\").length;\n      }\n\n      return digits;\n    };\n    /**\n     * PMatrix2D is a 3x2 affine matrix implementation. The constructor accepts another PMatrix2D or a list of six float elements.\n     * If no parameters are provided the matrix is set to the identity matrix.\n     *\n     * @param {PMatrix2D} matrix  the initial matrix to set to\n     * @param {float} m00         the first element of the matrix\n     * @param {float} m01         the second element of the matrix\n     * @param {float} m02         the third element of the matrix\n     * @param {float} m10         the fourth element of the matrix\n     * @param {float} m11         the fifth element of the matrix\n     * @param {float} m12         the sixth element of the matrix\n     */\n    var PMatrix2D = p.PMatrix2D = function() {\n      if (arguments.length === 0) {\n        this.reset();\n      } else if (arguments.length === 1 && arguments[0] instanceof PMatrix2D) {\n        this.set(arguments[0].array());\n      } else if (arguments.length === 6) {\n        this.set(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);\n      }\n    };\n    /**\n     * PMatrix2D methods\n     */\n    PMatrix2D.prototype = {\n      /**\n       * @member PMatrix2D\n       * The set() function sets the matrix elements. The function accepts either another PMatrix2D, an array of elements, or a list of six floats.\n       *\n       * @param {PMatrix2D} matrix    the matrix to set this matrix to\n       * @param {float[]} elements    an array of elements to set this matrix to\n       * @param {float} m00           the first element of the matrix\n       * @param {float} m01           the third element of the matrix\n       * @param {float} m10           the fourth element of the matrix\n       * @param {float} m11           the fith element of the matrix\n       * @param {float} m12           the sixth element of the matrix\n       */\n      set: function() {\n        if (arguments.length === 6) {\n          var a = arguments;\n          this.set([a[0], a[1], a[2],\n                    a[3], a[4], a[5]]);\n        } else if (arguments.length === 1 && arguments[0] instanceof PMatrix2D) {\n          this.elements = arguments[0].array();\n        } else if (arguments.length === 1 && arguments[0] instanceof Array) {\n          this.elements = arguments[0].slice();\n        }\n      },\n      /**\n       * @member PMatrix2D\n       * The get() function returns a copy of this PMatrix2D.\n       *\n       * @return {PMatrix2D} a copy of this PMatrix2D\n       */\n      get: function() {\n        var outgoing = new PMatrix2D();\n        outgoing.set(this.elements);\n        return outgoing;\n      },\n      /**\n       * @member PMatrix2D\n       * The reset() function sets this PMatrix2D to the identity matrix.\n       */\n      reset: function() {\n        this.set([1, 0, 0, 0, 1, 0]);\n      },\n      /**\n       * @member PMatrix2D\n       * The array() function returns a copy of the element values.\n       * @addon\n       *\n       * @return {float[]} returns a copy of the element values\n       */\n      array: function array() {\n        return this.elements.slice();\n      },\n      /**\n       * @member PMatrix2D\n       * The translate() function translates this matrix by moving the current coordinates to the location specified by tx and ty.\n       *\n       * @param {float} tx  the x-axis coordinate to move to\n       * @param {float} ty  the y-axis coordinate to move to\n       */\n      translate: function(tx, ty) {\n        this.elements[2] = tx * this.elements[0] + ty * this.elements[1] + this.elements[2];\n        this.elements[5] = tx * this.elements[3] + ty * this.elements[4] + this.elements[5];\n      },\n      /**\n       * @member PMatrix2D\n       * The invTranslate() function translates this matrix by moving the current coordinates to the negative location specified by tx and ty.\n       *\n       * @param {float} tx  the x-axis coordinate to move to\n       * @param {float} ty  the y-axis coordinate to move to\n       */\n      invTranslate: function(tx, ty) {\n        this.translate(-tx, -ty);\n      },\n       /**\n       * @member PMatrix2D\n       * The transpose() function is not used in processingjs.\n       */\n      transpose: function() {\n        // Does nothing in Processing.\n      },\n      /**\n       * @member PMatrix2D\n       * The mult() function multiplied this matrix.\n       * If two array elements are passed in the function will multiply a two element vector against this matrix.\n       * If target is null or not length four, a new float array will be returned.\n       * The values for vec and target can be the same (though that's less efficient).\n       * If two PVectors are passed in the function multiply the x and y coordinates of a PVector against this matrix.\n       *\n       * @param {PVector} source, target  the PVectors used to multiply this matrix\n       * @param {float[]} source, target  the arrays used to multiply this matrix\n       *\n       * @return {PVector|float[]} returns a PVector or an array representing the new matrix\n       */\n      mult: function(source, target) {\n        var x, y;\n        if (source instanceof PVector) {\n          x = source.x;\n          y = source.y;\n          if (!target) {\n            target = new PVector();\n          }\n        } else if (source instanceof Array) {\n          x = source[0];\n          y = source[1];\n          if (!target) {\n            target = [];\n          }\n        }\n        if (target instanceof Array) {\n          target[0] = this.elements[0] * x + this.elements[1] * y + this.elements[2];\n          target[1] = this.elements[3] * x + this.elements[4] * y + this.elements[5];\n        } else if (target instanceof PVector) {\n          target.x = this.elements[0] * x + this.elements[1] * y + this.elements[2];\n          target.y = this.elements[3] * x + this.elements[4] * y + this.elements[5];\n          target.z = 0;\n        }\n        return target;\n      },\n      /**\n       * @member PMatrix2D\n       * The multX() function calculates the x component of a vector from a transformation.\n       *\n       * @param {float} x the x component of the vector being transformed\n       * @param {float} y the y component of the vector being transformed\n       *\n       * @return {float} returnes the result of the calculation\n       */\n      multX: function(x, y) {\n        return (x * this.elements[0] + y * this.elements[1] + this.elements[2]);\n      },\n      /**\n       * @member PMatrix2D\n       * The multY() function calculates the y component of a vector from a transformation.\n       *\n       * @param {float} x the x component of the vector being transformed\n       * @param {float} y the y component of the vector being transformed\n       *\n       * @return {float} returnes the result of the calculation\n       */\n      multY: function(x, y) {\n        return (x * this.elements[3] + y * this.elements[4] + this.elements[5]);\n      },\n      /**\n       * @member PMatrix2D\n       * The skewX() function skews the matrix along the x-axis the amount specified by the angle parameter.\n       * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.\n       *\n       * @param {float} angle  angle of skew specified in radians\n       */\n      skewX: function(angle) {\n        this.apply(1, 0, 1, angle, 0, 0);\n      },\n      /**\n       * @member PMatrix2D\n       * The skewY() function skews the matrix along the y-axis the amount specified by the angle parameter.\n       * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.\n       *\n       * @param {float} angle  angle of skew specified in radians\n       */\n      skewY: function(angle) {\n        this.apply(1, 0, 1,  0, angle, 0);\n      },\n      /**\n       * @member PMatrix2D\n       * The shearX() function shears the matrix along the x-axis the amount specified by the angle parameter.\n       * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.\n       *\n       * @param {float} angle  angle of skew specified in radians\n       */\n      shearX: function(angle) {\n        this.apply(1, 0, 1, Math.tan(angle) , 0, 0);\n      },\n      /**\n       * @member PMatrix2D\n       * The shearY() function shears the matrix along the y-axis the amount specified by the angle parameter.\n       * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.\n       *\n       * @param {float} angle  angle of skew specified in radians\n       */\n      shearY: function(angle) {\n        this.apply(1, 0, 1,  0, Math.tan(angle), 0);\n      },\n      /**\n       * @member PMatrix2D\n       * The determinant() function calvculates the determinant of this matrix.\n       *\n       * @return {float} the determinant of the matrix\n       */\n      determinant: function() {\n        return (this.elements[0] * this.elements[4] - this.elements[1] * this.elements[3]);\n      },\n      /**\n       * @member PMatrix2D\n       * The invert() function inverts this matrix\n       *\n       * @return {boolean} true if successful\n       */\n      invert: function() {\n        var d = this.determinant();\n        if (Math.abs( d ) > PConstants.MIN_INT) {\n          var old00 = this.elements[0];\n          var old01 = this.elements[1];\n          var old02 = this.elements[2];\n          var old10 = this.elements[3];\n          var old11 = this.elements[4];\n          var old12 = this.elements[5];\n          this.elements[0] =  old11 / d;\n          this.elements[3] = -old10 / d;\n          this.elements[1] = -old01 / d;\n          this.elements[4] =  old00 / d;\n          this.elements[2] = (old01 * old12 - old11 * old02) / d;\n          this.elements[5] = (old10 * old02 - old00 * old12) / d;\n          return true;\n        }\n        return false;\n      },\n      /**\n       * @member PMatrix2D\n       * The scale() function increases or decreases the size of a shape by expanding and contracting vertices. When only one parameter is specified scale will occur in all dimensions.\n       * This is equivalent to a two parameter call.\n       *\n       * @param {float} sx  the amount to scale on the x-axis\n       * @param {float} sy  the amount to scale on the y-axis\n       */\n      scale: function(sx, sy) {\n        if (sx && !sy) {\n          sy = sx;\n        }\n        if (sx && sy) {\n          this.elements[0] *= sx;\n          this.elements[1] *= sy;\n          this.elements[3] *= sx;\n          this.elements[4] *= sy;\n        }\n      },\n       /**\n        * @member PMatrix2D\n        * The invScale() function decreases or increases the size of a shape by contracting and expanding vertices. When only one parameter is specified scale will occur in all dimensions.\n        * This is equivalent to a two parameter call.\n        *\n        * @param {float} sx  the amount to scale on the x-axis\n        * @param {float} sy  the amount to scale on the y-axis\n        */\n      invScale: function(sx, sy) {\n        if (sx && !sy) {\n          sy = sx;\n        }\n        this.scale(1 / sx, 1 / sy);\n      },\n      /**\n       * @member PMatrix2D\n       * The apply() function multiplies the current matrix by the one specified through the parameters. Note that either a PMatrix2D or a list of floats can be passed in.\n       *\n       * @param {PMatrix2D} matrix    the matrix to apply this matrix to\n       * @param {float} m00           the first element of the matrix\n       * @param {float} m01           the third element of the matrix\n       * @param {float} m10           the fourth element of the matrix\n       * @param {float} m11           the fith element of the matrix\n       * @param {float} m12           the sixth element of the matrix\n       */\n      apply: function() {\n        var source;\n        if (arguments.length === 1 && arguments[0] instanceof PMatrix2D) {\n          source = arguments[0].array();\n        } else if (arguments.length === 6) {\n          source = Array.prototype.slice.call(arguments);\n        } else if (arguments.length === 1 && arguments[0] instanceof Array) {\n          source = arguments[0];\n        }\n\n        var result = [0, 0, this.elements[2],\n                      0, 0, this.elements[5]];\n        var e = 0;\n        for (var row = 0; row < 2; row++) {\n          for (var col = 0; col < 3; col++, e++) {\n            result[e] += this.elements[row * 3 + 0] * source[col + 0] +\n                         this.elements[row * 3 + 1] * source[col + 3];\n          }\n        }\n        this.elements = result.slice();\n      },\n      /**\n       * @member PMatrix2D\n       * The preApply() function applies another matrix to the left of this one. Note that either a PMatrix2D or elements of a matrix can be passed in.\n       *\n       * @param {PMatrix2D} matrix    the matrix to apply this matrix to\n       * @param {float} m00           the first element of the matrix\n       * @param {float} m01           the third element of the matrix\n       * @param {float} m10           the fourth element of the matrix\n       * @param {float} m11           the fith element of the matrix\n       * @param {float} m12           the sixth element of the matrix\n       */\n      preApply: function() {\n        var source;\n        if (arguments.length === 1 && arguments[0] instanceof PMatrix2D) {\n          source = arguments[0].array();\n        } else if (arguments.length === 6) {\n          source = Array.prototype.slice.call(arguments);\n        } else if (arguments.length === 1 && arguments[0] instanceof Array) {\n          source = arguments[0];\n        }\n        var result = [0, 0, source[2],\n                      0, 0, source[5]];\n        result[2] = source[2] + this.elements[2] * source[0] + this.elements[5] * source[1];\n        result[5] = source[5] + this.elements[2] * source[3] + this.elements[5] * source[4];\n        result[0] = this.elements[0] * source[0] + this.elements[3] * source[1];\n        result[3] = this.elements[0] * source[3] + this.elements[3] * source[4];\n        result[1] = this.elements[1] * source[0] + this.elements[4] * source[1];\n        result[4] = this.elements[1] * source[3] + this.elements[4] * source[4];\n        this.elements = result.slice();\n      },\n      /**\n       * @member PMatrix2D\n       * The rotate() function rotates the matrix.\n       *\n       * @param {float} angle         the angle of rotation in radiants\n       */\n      rotate: function(angle) {\n        var c = Math.cos(angle);\n        var s = Math.sin(angle);\n        var temp1 = this.elements[0];\n        var temp2 = this.elements[1];\n        this.elements[0] =  c * temp1 + s * temp2;\n        this.elements[1] = -s * temp1 + c * temp2;\n        temp1 = this.elements[3];\n        temp2 = this.elements[4];\n        this.elements[3] =  c * temp1 + s * temp2;\n        this.elements[4] = -s * temp1 + c * temp2;\n      },\n      /**\n       * @member PMatrix2D\n       * The rotateZ() function rotates the matrix.\n       *\n       * @param {float} angle         the angle of rotation in radiants\n       */\n      rotateZ: function(angle) {\n        this.rotate(angle);\n      },\n      /**\n       * @member PMatrix2D\n       * The invRotateZ() function rotates the matrix in opposite direction.\n       *\n       * @param {float} angle         the angle of rotation in radiants\n       */\n      invRotateZ: function(angle) {\n        this.rotateZ(angle - Math.PI);\n      },\n      /**\n       * @member PMatrix2D\n       * The print() function prints out the elements of this matrix\n       */\n      print: function() {\n        var digits = printMatrixHelper(this.elements);\n        var output = \"\" + p.nfs(this.elements[0], digits, 4) + \" \" +\n                     p.nfs(this.elements[1], digits, 4) + \" \" +\n                     p.nfs(this.elements[2], digits, 4) + \"\\n\" +\n                     p.nfs(this.elements[3], digits, 4) + \" \" +\n                     p.nfs(this.elements[4], digits, 4) + \" \" +\n                     p.nfs(this.elements[5], digits, 4) + \"\\n\\n\";\n        p.println(output);\n      }\n    };\n\n    /**\n     * PMatrix3D is a 4x4  matrix implementation. The constructor accepts another PMatrix3D or a list of six or sixteen float elements.\n     * If no parameters are provided the matrix is set to the identity matrix.\n     */\n    var PMatrix3D = p.PMatrix3D = function() {\n      // When a matrix is created, it is set to an identity matrix\n      this.reset();\n    };\n    /**\n     * PMatrix3D methods\n     */\n    PMatrix3D.prototype = {\n      /**\n       * @member PMatrix2D\n       * The set() function sets the matrix elements. The function accepts either another PMatrix3D, an array of elements, or a list of six or sixteen floats.\n       *\n       * @param {PMatrix3D} matrix    the initial matrix to set to\n       * @param {float[]} elements    an array of elements to set this matrix to\n       * @param {float} m00           the first element of the matrix\n       * @param {float} m01           the second element of the matrix\n       * @param {float} m02           the third element of the matrix\n       * @param {float} m03           the fourth element of the matrix\n       * @param {float} m10           the fifth element of the matrix\n       * @param {float} m11           the sixth element of the matrix\n       * @param {float} m12           the seventh element of the matrix\n       * @param {float} m13           the eight element of the matrix\n       * @param {float} m20           the nineth element of the matrix\n       * @param {float} m21           the tenth element of the matrix\n       * @param {float} m22           the eleventh element of the matrix\n       * @param {float} m23           the twelveth element of the matrix\n       * @param {float} m30           the thirteenth element of the matrix\n       * @param {float} m31           the fourtheenth element of the matrix\n       * @param {float} m32           the fivetheenth element of the matrix\n       * @param {float} m33           the sixteenth element of the matrix\n       */\n      set: function() {\n        if (arguments.length === 16) {\n          this.elements = Array.prototype.slice.call(arguments);\n        } else if (arguments.length === 1 && arguments[0] instanceof PMatrix3D) {\n          this.elements = arguments[0].array();\n        } else if (arguments.length === 1 && arguments[0] instanceof Array) {\n          this.elements = arguments[0].slice();\n        }\n      },\n      /**\n       * @member PMatrix3D\n       * The get() function returns a copy of this PMatrix3D.\n       *\n       * @return {PMatrix3D} a copy of this PMatrix3D\n       */\n      get: function() {\n        var outgoing = new PMatrix3D();\n        outgoing.set(this.elements);\n        return outgoing;\n      },\n      /**\n       * @member PMatrix3D\n       * The reset() function sets this PMatrix3D to the identity matrix.\n       */\n      reset: function() {\n        this.elements = [1,0,0,0,\n                         0,1,0,0,\n                         0,0,1,0,\n                         0,0,0,1];\n      },\n      /**\n       * @member PMatrix3D\n       * The array() function returns a copy of the element values.\n       * @addon\n       *\n       * @return {float[]} returns a copy of the element values\n       */\n      array: function array() {\n        return this.elements.slice();\n      },\n      /**\n       * @member PMatrix3D\n       * The translate() function translates this matrix by moving the current coordinates to the location specified by tx, ty, and tz.\n       *\n       * @param {float} tx  the x-axis coordinate to move to\n       * @param {float} ty  the y-axis coordinate to move to\n       * @param {float} tz  the z-axis coordinate to move to\n       */\n      translate: function(tx, ty, tz) {\n        if (tz === undef) {\n          tz = 0;\n        }\n\n        this.elements[3]  += tx * this.elements[0]  + ty * this.elements[1]  + tz * this.elements[2];\n        this.elements[7]  += tx * this.elements[4]  + ty * this.elements[5]  + tz * this.elements[6];\n        this.elements[11] += tx * this.elements[8]  + ty * this.elements[9]  + tz * this.elements[10];\n        this.elements[15] += tx * this.elements[12] + ty * this.elements[13] + tz * this.elements[14];\n      },\n      /**\n       * @member PMatrix3D\n       * The transpose() function transpose this matrix.\n       */\n      transpose: function() {\n        var temp = this.elements[4];\n        this.elements[4] = this.elements[1];\n        this.elements[1] = temp;\n\n        temp = this.elements[8];\n        this.elements[8] = this.elements[2];\n        this.elements[2] = temp;\n\n        temp = this.elements[6];\n        this.elements[6] = this.elements[9];\n        this.elements[9] = temp;\n\n        temp = this.elements[3];\n        this.elements[3] = this.elements[12];\n        this.elements[12] = temp;\n\n        temp = this.elements[7];\n        this.elements[7] = this.elements[13];\n        this.elements[13] = temp;\n\n        temp = this.elements[11];\n        this.elements[11] = this.elements[14];\n        this.elements[14] = temp;\n      },\n      /**\n       * @member PMatrix3D\n       * The mult() function multiplied this matrix.\n       * If two array elements are passed in the function will multiply a two element vector against this matrix.\n       * If target is null or not length four, a new float array will be returned.\n       * The values for vec and target can be the same (though that's less efficient).\n       * If two PVectors are passed in the function multiply the x and y coordinates of a PVector against this matrix.\n       *\n       * @param {PVector} source, target  the PVectors used to multiply this matrix\n       * @param {float[]} source, target  the arrays used to multiply this matrix\n       *\n       * @return {PVector|float[]} returns a PVector or an array representing the new matrix\n       */\n      mult: function(source, target) {\n        var x, y, z, w;\n        if (source instanceof PVector) {\n          x = source.x;\n          y = source.y;\n          z = source.z;\n          w = 1;\n          if (!target) {\n            target = new PVector();\n          }\n        } else if (source instanceof Array) {\n          x = source[0];\n          y = source[1];\n          z = source[2];\n          w = source[3] || 1;\n\n          if ( !target || (target.length !== 3 && target.length !== 4) ) {\n            target = [0, 0, 0];\n          }\n        }\n\n        if (target instanceof Array) {\n          if (target.length === 3) {\n            target[0] = this.elements[0] * x + this.elements[1] * y + this.elements[2] * z + this.elements[3];\n            target[1] = this.elements[4] * x + this.elements[5] * y + this.elements[6] * z + this.elements[7];\n            target[2] = this.elements[8] * x + this.elements[9] * y + this.elements[10] * z + this.elements[11];\n          } else if (target.length === 4) {\n            target[0] = this.elements[0] * x + this.elements[1] * y + this.elements[2] * z + this.elements[3] * w;\n            target[1] = this.elements[4] * x + this.elements[5] * y + this.elements[6] * z + this.elements[7] * w;\n            target[2] = this.elements[8] * x + this.elements[9] * y + this.elements[10] * z + this.elements[11] * w;\n            target[3] = this.elements[12] * x + this.elements[13] * y + this.elements[14] * z + this.elements[15] * w;\n          }\n        }\n        if (target instanceof PVector) {\n          target.x = this.elements[0] * x + this.elements[1] * y + this.elements[2] * z + this.elements[3];\n          target.y = this.elements[4] * x + this.elements[5] * y + this.elements[6] * z + this.elements[7];\n          target.z = this.elements[8] * x + this.elements[9] * y + this.elements[10] * z + this.elements[11];\n        }\n        return target;\n      },\n      /**\n       * @member PMatrix3D\n       * The preApply() function applies another matrix to the left of this one. Note that either a PMatrix3D or elements of a matrix can be passed in.\n       *\n       * @param {PMatrix3D} matrix    the matrix to apply this matrix to\n       * @param {float} m00           the first element of the matrix\n       * @param {float} m01           the second element of the matrix\n       * @param {float} m02           the third element of the matrix\n       * @param {float} m03           the fourth element of the matrix\n       * @param {float} m10           the fifth element of the matrix\n       * @param {float} m11           the sixth element of the matrix\n       * @param {float} m12           the seventh element of the matrix\n       * @param {float} m13           the eight element of the matrix\n       * @param {float} m20           the nineth element of the matrix\n       * @param {float} m21           the tenth element of the matrix\n       * @param {float} m22           the eleventh element of the matrix\n       * @param {float} m23           the twelveth element of the matrix\n       * @param {float} m30           the thirteenth element of the matrix\n       * @param {float} m31           the fourtheenth element of the matrix\n       * @param {float} m32           the fivetheenth element of the matrix\n       * @param {float} m33           the sixteenth element of the matrix\n       */\n      preApply: function() {\n        var source;\n        if (arguments.length === 1 && arguments[0] instanceof PMatrix3D) {\n          source = arguments[0].array();\n        } else if (arguments.length === 16) {\n          source = Array.prototype.slice.call(arguments);\n        } else if (arguments.length === 1 && arguments[0] instanceof Array) {\n          source = arguments[0];\n        }\n\n        var result = [0, 0, 0, 0,\n                      0, 0, 0, 0,\n                      0, 0, 0, 0,\n                      0, 0, 0, 0];\n        var e = 0;\n        for (var row = 0; row < 4; row++) {\n          for (var col = 0; col < 4; col++, e++) {\n            result[e] += this.elements[col + 0] * source[row * 4 + 0] + this.elements[col + 4] *\n                         source[row * 4 + 1] + this.elements[col + 8] * source[row * 4 + 2] +\n                         this.elements[col + 12] * source[row * 4 + 3];\n          }\n        }\n        this.elements = result.slice();\n      },\n      /**\n       * @member PMatrix3D\n       * The apply() function multiplies the current matrix by the one specified through the parameters. Note that either a PMatrix3D or a list of floats can be passed in.\n       *\n       * @param {PMatrix3D} matrix    the matrix to apply this matrix to\n       * @param {float} m00           the first element of the matrix\n       * @param {float} m01           the second element of the matrix\n       * @param {float} m02           the third element of the matrix\n       * @param {float} m03           the fourth element of the matrix\n       * @param {float} m10           the fifth element of the matrix\n       * @param {float} m11           the sixth element of the matrix\n       * @param {float} m12           the seventh element of the matrix\n       * @param {float} m13           the eight element of the matrix\n       * @param {float} m20           the nineth element of the matrix\n       * @param {float} m21           the tenth element of the matrix\n       * @param {float} m22           the eleventh element of the matrix\n       * @param {float} m23           the twelveth element of the matrix\n       * @param {float} m30           the thirteenth element of the matrix\n       * @param {float} m31           the fourtheenth element of the matrix\n       * @param {float} m32           the fivetheenth element of the matrix\n       * @param {float} m33           the sixteenth element of the matrix\n       */\n      apply: function() {\n        var source;\n        if (arguments.length === 1 && arguments[0] instanceof PMatrix3D) {\n          source = arguments[0].array();\n        } else if (arguments.length === 16) {\n          source = Array.prototype.slice.call(arguments);\n        } else if (arguments.length === 1 && arguments[0] instanceof Array) {\n          source = arguments[0];\n        }\n\n        var result = [0, 0, 0, 0,\n                      0, 0, 0, 0,\n                      0, 0, 0, 0,\n                      0, 0, 0, 0];\n        var e = 0;\n        for (var row = 0; row < 4; row++) {\n          for (var col = 0; col < 4; col++, e++) {\n            result[e] += this.elements[row * 4 + 0] * source[col + 0] + this.elements[row * 4 + 1] *\n                         source[col + 4] + this.elements[row * 4 + 2] * source[col + 8] +\n                         this.elements[row * 4 + 3] * source[col + 12];\n          }\n        }\n        this.elements = result.slice();\n      },\n      /**\n       * @member PMatrix3D\n       * The rotate() function rotates the matrix.\n       *\n       * @param {float} angle         the angle of rotation in radiants\n       */\n      rotate: function(angle, v0, v1, v2) {\n        if (arguments.length < 4) {\n          this.rotateZ(angle);\n        } else {\n          var v = new PVector(v0, v1, v2);\n          var m = v.mag();\n          if (m === 0) {\n            return;\n          } else if (m != 1) {\n            v.normalize();\n            v0 = v.x;\n            v1 = v.y;\n            v2 = v.z;\n          }\n          var c = p.cos(angle);\n          var s = p.sin(angle);\n          var t = 1.0 - c;\n\n          this.apply((t * v0 * v0) + c,\n                     (t * v0 * v1) - (s * v2),\n                     (t * v0 * v2) + (s * v1),\n                     0,\n                     (t * v0 * v1) + (s * v2),\n                     (t * v1 * v1) + c,\n                     (t * v1 * v2) - (s * v0),\n                     0,\n                     (t * v0 * v2) - (s * v1),\n                     (t * v1 * v2) + (s * v0),\n                     (t * v2 * v2) + c,\n                     0,\n                     0, 0, 0, 1);\n        }\n      },\n      /**\n       * @member PMatrix3D\n       * The invApply() function applies the inverted matrix to this matrix.\n       *\n       * @param {float} m00           the first element of the matrix\n       * @param {float} m01           the second element of the matrix\n       * @param {float} m02           the third element of the matrix\n       * @param {float} m03           the fourth element of the matrix\n       * @param {float} m10           the fifth element of the matrix\n       * @param {float} m11           the sixth element of the matrix\n       * @param {float} m12           the seventh element of the matrix\n       * @param {float} m13           the eight element of the matrix\n       * @param {float} m20           the nineth element of the matrix\n       * @param {float} m21           the tenth element of the matrix\n       * @param {float} m22           the eleventh element of the matrix\n       * @param {float} m23           the twelveth element of the matrix\n       * @param {float} m30           the thirteenth element of the matrix\n       * @param {float} m31           the fourtheenth element of the matrix\n       * @param {float} m32           the fivetheenth element of the matrix\n       * @param {float} m33           the sixteenth element of the matrix\n       *\n       * @return {boolean} returns true if the operation was successful.\n       */\n      invApply: function() {\n        if (inverseCopy === undef) {\n          inverseCopy = new PMatrix3D();\n        }\n        var a = arguments;\n        inverseCopy.set(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8],\n                        a[9], a[10], a[11], a[12], a[13], a[14], a[15]);\n\n        if (!inverseCopy.invert()) {\n          return false;\n        }\n        this.preApply(inverseCopy);\n        return true;\n      },\n      /**\n       * @member PMatrix3D\n       * The rotateZ() function rotates the matrix.\n       *\n       * @param {float} angle         the angle of rotation in radiants\n       */\n      rotateX: function(angle) {\n        var c = p.cos(angle);\n        var s = p.sin(angle);\n        this.apply([1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1]);\n      },\n      /**\n       * @member PMatrix3D\n       * The rotateY() function rotates the matrix.\n       *\n       * @param {float} angle         the angle of rotation in radiants\n       */\n      rotateY: function(angle) {\n        var c = p.cos(angle);\n        var s = p.sin(angle);\n        this.apply([c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1]);\n      },\n      /**\n       * @member PMatrix3D\n       * The rotateZ() function rotates the matrix.\n       *\n       * @param {float} angle         the angle of rotation in radiants\n       */\n      rotateZ: function(angle) {\n        var c = Math.cos(angle);\n        var s = Math.sin(angle);\n        this.apply([c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\n      },\n      /**\n       * @member PMatrix3D\n       * The scale() function increases or decreases the size of a matrix by expanding and contracting vertices. When only one parameter is specified scale will occur in all dimensions.\n       * This is equivalent to a three parameter call.\n       *\n       * @param {float} sx  the amount to scale on the x-axis\n       * @param {float} sy  the amount to scale on the y-axis\n       * @param {float} sz  the amount to scale on the z-axis\n       */\n      scale: function(sx, sy, sz) {\n        if (sx && !sy && !sz) {\n          sy = sz = sx;\n        } else if (sx && sy && !sz) {\n          sz = 1;\n        }\n\n        if (sx && sy && sz) {\n          this.elements[0]  *= sx;\n          this.elements[1]  *= sy;\n          this.elements[2]  *= sz;\n          this.elements[4]  *= sx;\n          this.elements[5]  *= sy;\n          this.elements[6]  *= sz;\n          this.elements[8]  *= sx;\n          this.elements[9]  *= sy;\n          this.elements[10] *= sz;\n          this.elements[12] *= sx;\n          this.elements[13] *= sy;\n          this.elements[14] *= sz;\n        }\n      },\n      /**\n       * @member PMatrix3D\n       * The skewX() function skews the matrix along the x-axis the amount specified by the angle parameter.\n       * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.\n       *\n       * @param {float} angle  angle of skew specified in radians\n       */\n      skewX: function(angle) {\n        var t = Math.tan(angle);\n        this.apply(1, t, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n      },\n      /**\n       * @member PMatrix3D\n       * The skewY() function skews the matrix along the y-axis the amount specified by the angle parameter.\n       * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.\n       *\n       * @param {float} angle  angle of skew specified in radians\n       */\n      skewY: function(angle) {\n        var t = Math.tan(angle);\n        this.apply(1, 0, 0, 0, t, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n      },\n      /**\n       * @member PMatrix3D\n       * The shearX() function shears the matrix along the x-axis the amount specified by the angle parameter.\n       * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.\n       *\n       * @param {float} angle  angle of shear specified in radians\n       */\n      shearX: function(angle) {\n        var t = Math.tan(angle);\n        this.apply(1, t, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n      },\n      /**\n       * @member PMatrix3D\n       * The shearY() function shears the matrix along the y-axis the amount specified by the angle parameter.\n       * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.\n       *\n       * @param {float} angle  angle of shear specified in radians\n       */\n      shearY: function(angle) {\n        var t = Math.tan(angle);\n        this.apply(1, 0, 0, 0, t, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n      },\n      multX: function(x, y, z, w) {\n        if (!z) {\n          return this.elements[0] * x + this.elements[1] * y + this.elements[3];\n        }\n        if (!w) {\n          return this.elements[0] * x + this.elements[1] * y + this.elements[2] * z + this.elements[3];\n        }\n        return this.elements[0] * x + this.elements[1] * y + this.elements[2] * z + this.elements[3] * w;\n      },\n      multY: function(x, y, z, w) {\n        if (!z) {\n          return this.elements[4] * x + this.elements[5] * y + this.elements[7];\n        }\n        if (!w) {\n          return this.elements[4] * x + this.elements[5] * y + this.elements[6] * z + this.elements[7];\n        }\n        return this.elements[4] * x + this.elements[5] * y + this.elements[6] * z + this.elements[7] * w;\n      },\n      multZ: function(x, y, z, w) {\n        if (!w) {\n          return this.elements[8] * x + this.elements[9] * y + this.elements[10] * z + this.elements[11];\n        }\n        return this.elements[8] * x + this.elements[9] * y + this.elements[10] * z + this.elements[11] * w;\n      },\n      multW: function(x, y, z, w) {\n        if (!w) {\n          return this.elements[12] * x + this.elements[13] * y + this.elements[14] * z + this.elements[15];\n        }\n        return this.elements[12] * x + this.elements[13] * y + this.elements[14] * z + this.elements[15] * w;\n      },\n      /**\n       * @member PMatrix3D\n       * The invert() function inverts this matrix\n       *\n       * @return {boolean} true if successful\n       */\n      invert: function() {\n        var fA0 = this.elements[0] * this.elements[5] - this.elements[1] * this.elements[4];\n        var fA1 = this.elements[0] * this.elements[6] - this.elements[2] * this.elements[4];\n        var fA2 = this.elements[0] * this.elements[7] - this.elements[3] * this.elements[4];\n        var fA3 = this.elements[1] * this.elements[6] - this.elements[2] * this.elements[5];\n        var fA4 = this.elements[1] * this.elements[7] - this.elements[3] * this.elements[5];\n        var fA5 = this.elements[2] * this.elements[7] - this.elements[3] * this.elements[6];\n        var fB0 = this.elements[8] * this.elements[13] - this.elements[9] * this.elements[12];\n        var fB1 = this.elements[8] * this.elements[14] - this.elements[10] * this.elements[12];\n        var fB2 = this.elements[8] * this.elements[15] - this.elements[11] * this.elements[12];\n        var fB3 = this.elements[9] * this.elements[14] - this.elements[10] * this.elements[13];\n        var fB4 = this.elements[9] * this.elements[15] - this.elements[11] * this.elements[13];\n        var fB5 = this.elements[10] * this.elements[15] - this.elements[11] * this.elements[14];\n\n        // Determinant\n        var fDet = fA0 * fB5 - fA1 * fB4 + fA2 * fB3 + fA3 * fB2 - fA4 * fB1 + fA5 * fB0;\n\n        // Account for a very small value\n        // return false if not successful.\n        if (Math.abs(fDet) <= 1e-9) {\n          return false;\n        }\n\n        var kInv = [];\n        kInv[0]  = +this.elements[5] * fB5 - this.elements[6] * fB4 + this.elements[7] * fB3;\n        kInv[4]  = -this.elements[4] * fB5 + this.elements[6] * fB2 - this.elements[7] * fB1;\n        kInv[8]  = +this.elements[4] * fB4 - this.elements[5] * fB2 + this.elements[7] * fB0;\n        kInv[12] = -this.elements[4] * fB3 + this.elements[5] * fB1 - this.elements[6] * fB0;\n        kInv[1]  = -this.elements[1] * fB5 + this.elements[2] * fB4 - this.elements[3] * fB3;\n        kInv[5]  = +this.elements[0] * fB5 - this.elements[2] * fB2 + this.elements[3] * fB1;\n        kInv[9]  = -this.elements[0] * fB4 + this.elements[1] * fB2 - this.elements[3] * fB0;\n        kInv[13] = +this.elements[0] * fB3 - this.elements[1] * fB1 + this.elements[2] * fB0;\n        kInv[2]  = +this.elements[13] * fA5 - this.elements[14] * fA4 + this.elements[15] * fA3;\n        kInv[6]  = -this.elements[12] * fA5 + this.elements[14] * fA2 - this.elements[15] * fA1;\n        kInv[10] = +this.elements[12] * fA4 - this.elements[13] * fA2 + this.elements[15] * fA0;\n        kInv[14] = -this.elements[12] * fA3 + this.elements[13] * fA1 - this.elements[14] * fA0;\n        kInv[3]  = -this.elements[9] * fA5 + this.elements[10] * fA4 - this.elements[11] * fA3;\n        kInv[7]  = +this.elements[8] * fA5 - this.elements[10] * fA2 + this.elements[11] * fA1;\n        kInv[11] = -this.elements[8] * fA4 + this.elements[9] * fA2 - this.elements[11] * fA0;\n        kInv[15] = +this.elements[8] * fA3 - this.elements[9] * fA1 + this.elements[10] * fA0;\n\n        // Inverse using Determinant\n        var fInvDet = 1.0 / fDet;\n        kInv[0]  *= fInvDet;\n        kInv[1]  *= fInvDet;\n        kInv[2]  *= fInvDet;\n        kInv[3]  *= fInvDet;\n        kInv[4]  *= fInvDet;\n        kInv[5]  *= fInvDet;\n        kInv[6]  *= fInvDet;\n        kInv[7]  *= fInvDet;\n        kInv[8]  *= fInvDet;\n        kInv[9]  *= fInvDet;\n        kInv[10] *= fInvDet;\n        kInv[11] *= fInvDet;\n        kInv[12] *= fInvDet;\n        kInv[13] *= fInvDet;\n        kInv[14] *= fInvDet;\n        kInv[15] *= fInvDet;\n\n        this.elements = kInv.slice();\n        return true;\n      },\n      toString: function() {\n        var str = \"\";\n        for (var i = 0; i < 15; i++) {\n          str += this.elements[i] + \", \";\n        }\n        str += this.elements[15];\n        return str;\n      },\n      /**\n       * @member PMatrix3D\n       * The print() function prints out the elements of this matrix\n       */\n      print: function() {\n        var digits = printMatrixHelper(this.elements);\n\n        var output = \"\" + p.nfs(this.elements[0], digits, 4) + \" \" + p.nfs(this.elements[1], digits, 4) +\n                     \" \" + p.nfs(this.elements[2], digits, 4) + \" \" + p.nfs(this.elements[3], digits, 4) +\n                     \"\\n\" + p.nfs(this.elements[4], digits, 4) + \" \" + p.nfs(this.elements[5], digits, 4) +\n                     \" \" + p.nfs(this.elements[6], digits, 4) + \" \" + p.nfs(this.elements[7], digits, 4) +\n                     \"\\n\" + p.nfs(this.elements[8], digits, 4) + \" \" + p.nfs(this.elements[9], digits, 4) +\n                     \" \" + p.nfs(this.elements[10], digits, 4) + \" \" + p.nfs(this.elements[11], digits, 4) +\n                     \"\\n\" + p.nfs(this.elements[12], digits, 4) + \" \" + p.nfs(this.elements[13], digits, 4) +\n                     \" \" + p.nfs(this.elements[14], digits, 4) + \" \" + p.nfs(this.elements[15], digits, 4) + \"\\n\\n\";\n        p.println(output);\n      },\n      invTranslate: function(tx, ty, tz) {\n        this.preApply(1, 0, 0, -tx, 0, 1, 0, -ty, 0, 0, 1, -tz, 0, 0, 0, 1);\n      },\n      invRotateX: function(angle) {\n        var c = Math.cos(-angle);\n        var s = Math.sin(-angle);\n        this.preApply([1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1]);\n      },\n      invRotateY: function(angle) {\n        var c = Math.cos(-angle);\n        var s = Math.sin(-angle);\n        this.preApply([c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1]);\n      },\n      invRotateZ: function(angle) {\n        var c = Math.cos(-angle);\n        var s = Math.sin(-angle);\n        this.preApply([c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\n      },\n      invScale: function(x, y, z) {\n        this.preApply([1 / x, 0, 0, 0, 0, 1 / y, 0, 0, 0, 0, 1 / z, 0, 0, 0, 0, 1]);\n      }\n    };\n\n    /**\n     * @private\n     * The matrix stack stores the transformations and translations that occur within the space.\n     */\n    var PMatrixStack = p.PMatrixStack = function() {\n      this.matrixStack = [];\n    };\n\n    /**\n     * @member PMatrixStack\n     * load pushes the matrix given in the function into the stack\n     *\n     * @param {Object | Array} matrix the matrix to be pushed into the stack\n     */\n    PMatrixStack.prototype.load = function() {\n      var tmpMatrix = drawing.$newPMatrix();\n\n      if (arguments.length === 1) {\n        tmpMatrix.set(arguments[0]);\n      } else {\n        tmpMatrix.set(arguments);\n      }\n      this.matrixStack.push(tmpMatrix);\n    };\n\n    Drawing2D.prototype.$newPMatrix = function() {\n      return new PMatrix2D();\n    };\n\n    Drawing3D.prototype.$newPMatrix = function() {\n      return new PMatrix3D();\n    };\n\n    /**\n     * @member PMatrixStack\n     * push adds a duplicate of the top of the stack onto the stack - uses the peek function\n     */\n    PMatrixStack.prototype.push = function() {\n      this.matrixStack.push(this.peek());\n    };\n\n    /**\n     * @member PMatrixStack\n     * pop removes returns the matrix at the top of the stack\n     *\n     * @returns {Object} the matrix at the top of the stack\n     */\n    PMatrixStack.prototype.pop = function() {\n      return this.matrixStack.pop();\n    };\n\n    /**\n     * @member PMatrixStack\n     * peek returns but doesn't remove the matrix at the top of the stack\n     *\n     * @returns {Object} the matrix at the top of the stack\n     */\n    PMatrixStack.prototype.peek = function() {\n      var tmpMatrix = drawing.$newPMatrix();\n\n      tmpMatrix.set(this.matrixStack[this.matrixStack.length - 1]);\n      return tmpMatrix;\n    };\n\n    /**\n     * @member PMatrixStack\n     * this function multiplies the matrix at the top of the stack with the matrix given as a parameter\n     *\n     * @param {Object | Array} matrix the matrix to be multiplied into the stack\n     */\n    PMatrixStack.prototype.mult = function(matrix) {\n      this.matrixStack[this.matrixStack.length - 1].apply(matrix);\n    };\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Array handling\n    ////////////////////////////////////////////////////////////////////////////\n\n    /**\n    * The split() function breaks a string into pieces using a character or string\n    * as the divider. The delim  parameter specifies the character or characters that\n    * mark the boundaries between each piece. A String[] array is returned that contains\n    * each of the pieces.\n    * If the result is a set of numbers, you can convert the String[] array to to a float[]\n    * or int[] array using the datatype conversion functions int() and float() (see example above).\n    * The splitTokens() function works in a similar fashion, except that it splits using a range\n    * of characters instead of a specific character or sequence.\n    *\n    * @param {String} str       the String to be split\n    * @param {String} delim     the character or String used to separate the data\n    *\n    * @returns {string[]} The new string array\n    *\n    * @see splitTokens\n    * @see join\n    * @see trim\n    */\n    p.split = function(str, delim) {\n      return str.split(delim);\n    };\n\n    /**\n    * The splitTokens() function splits a String at one or many character \"tokens.\" The tokens\n    * parameter specifies the character or characters to be used as a boundary.\n    * If no tokens character is specified, any whitespace character is used to split.\n    * Whitespace characters include tab (\\t), line feed (\\n), carriage return (\\r), form\n    * feed (\\f), and space. To convert a String to an array of integers or floats, use the\n    * datatype conversion functions int() and float() to convert the array of Strings.\n    *\n    * @param {String} str       the String to be split\n    * @param {Char[]} tokens    list of individual characters that will be used as separators\n    *\n    * @returns {string[]} The new string array\n    *\n    * @see split\n    * @see join\n    * @see trim\n    */\n    p.splitTokens = function(str, tokens) {\n      if (tokens === undef) {\n        return str.split(/\\s+/g);\n      }\n\n      var chars = tokens.split(/()/g),\n          buffer = \"\",\n          len = str.length,\n          i, c,\n          tokenized = [];\n\n      for (i = 0; i < len; i++) {\n        c = str[i];\n        if (chars.indexOf(c) > -1) {\n          if (buffer !== \"\") {\n            tokenized.push(buffer);\n          }\n          buffer = \"\";\n        } else {\n          buffer += c;\n        }\n      }\n\n      if (buffer !== \"\") {\n        tokenized.push(buffer);\n      }\n\n      return tokenized;\n    };\n\n    /**\n    * Expands an array by one element and adds data to the new position. The datatype of\n    * the element parameter must be the same as the datatype of the array.\n    * When using an array of objects, the data returned from the function must be cast to\n    * the object array's data type. For example: SomeClass[] items = (SomeClass[])\n    * append(originalArray, element).\n    *\n    * @param {boolean[]|byte[]|char[]|int[]|float[]|String[]|array of objects} array boolean[],\n    * byte[], char[], int[], float[], or String[], or an array of objects\n    * @param {boolean[]|byte[]|char[]|int[]|float[]|String[]|array of objects} element new data for the array\n    *\n    * @returns Array (the same datatype as the input)\n    *\n    * @see shorten\n    * @see expand\n    */\n    p.append = function(array, element) {\n      array[array.length] = element;\n      return array;\n    };\n\n    /**\n    * Concatenates two arrays. For example, concatenating the array { 1, 2, 3 } and the\n    * array { 4, 5, 6 } yields { 1, 2, 3, 4, 5, 6 }. Both parameters must be arrays of the\n    * same datatype.\n    * When using an array of objects, the data returned from the function must be cast to the\n    * object array's data type. For example: SomeClass[] items = (SomeClass[]) concat(array1, array2).\n    *\n    * @param {boolean[]|byte[]|char[]|int[]|float[]|String[]|array of objects} array1 boolean[],\n    * byte[], char[], int[], float[], String[], or an array of objects\n    * @param {boolean[]|byte[]|char[]|int[]|float[]|String[]|array of objects} array2 boolean[],\n    * byte[], char[], int[], float[], String[], or an array of objects\n    *\n    * @returns Array (the same datatype as the input)\n    *\n    * @see splice\n    */\n    p.concat = function(array1, array2) {\n      return array1.concat(array2);\n    };\n\n    /**\n     * Sorts an array of numbers from smallest to largest and puts an array of\n     * words in alphabetical order. The original array is not modified, a\n     * re-ordered array is returned. The count parameter states the number of\n     * elements to sort. For example if there are 12 elements in an array and\n     * if count is the value 5, only the first five elements on the array will\n     * be sorted. Alphabetical ordering is case insensitive.\n     *\n     * @param {String[] | int[] | float[]}  array Array of elements to sort\n     * @param {int}                         numElem Number of elements to sort\n     *\n     * @returns {String[] | int[] | float[]} Array (same datatype as the input)\n     *\n     * @see reverse\n    */\n    p.sort = function(array, numElem) {\n      var ret = [];\n\n      // depending on the type used (int, float) or string\n      // we'll need to use a different compare function\n      if (array.length > 0) {\n        // copy since we need to return another array\n        var elemsToCopy = numElem > 0 ? numElem : array.length;\n        for (var i = 0; i < elemsToCopy; i++) {\n          ret.push(array[i]);\n        }\n        if (typeof array[0] === \"string\") {\n          ret.sort();\n        }\n        // int or float\n        else {\n          ret.sort(function(a, b) {\n            return a - b;\n          });\n        }\n\n        // copy on the rest of the elements that were not sorted in case the user\n        // only wanted a subset of an array to be sorted.\n        if (numElem > 0) {\n          for (var j = ret.length; j < array.length; j++) {\n            ret.push(array[j]);\n          }\n        }\n      }\n      return ret;\n    };\n\n    /**\n    * Inserts a value or array of values into an existing array. The first two parameters must\n    * be of the same datatype. The array parameter defines the array which will be modified\n    * and the second parameter defines the data which will be inserted. When using an array\n    * of objects, the data returned from the function must be cast to the object array's data\n    * type. For example: SomeClass[] items = (SomeClass[]) splice(array1, array2, index).\n    *\n    * @param {boolean[]|byte[]|char[]|int[]|float[]|String[]|array of objects} array boolean[],\n    * byte[], char[], int[], float[], String[], or an array of objects\n    * @param {boolean|byte|char|int|float|String|boolean[]|byte[]|char[]|int[]|float[]|String[]|array of objects}\n    * value boolean, byte, char, int, float, String, boolean[], byte[], char[], int[],\n    * float[], String[], or other Object: value or an array of objects to be spliced in\n    * @param {int} index                position in the array from which to insert data\n    *\n    * @returns Array (the same datatype as the input)\n    *\n    * @see contract\n    * @see subset\n    */\n    p.splice = function(array, value, index) {\n\n      // Trying to splice an empty array into \"array\" in P5 won't do\n      // anything, just return the original.\n      if(value.length === 0)\n      {\n        return array;\n      }\n\n      // If the second argument was an array, we'll need to iterate over all\n      // the \"value\" elements and add one by one because\n      // array.splice(index, 0, value);\n      // would create a multi-dimensional array which isn't what we want.\n      if(value instanceof Array) {\n        for(var i = 0, j = index; i < value.length; j++,i++) {\n          array.splice(j, 0, value[i]);\n        }\n      } else {\n        array.splice(index, 0, value);\n      }\n\n      return array;\n    };\n\n    /**\n    * Extracts an array of elements from an existing array. The array parameter defines the\n    * array from which the elements will be copied and the offset and length parameters determine\n    * which elements to extract. If no length is given, elements will be extracted from the offset\n    * to the end of the array. When specifying the offset remember the first array element is 0.\n    * This function does not change the source array.\n    * When using an array of objects, the data returned from the function must be cast to the\n    * object array's data type.\n    *\n    * @param {boolean[]|byte[]|char[]|int[]|float[]|String[]|array of objects} array boolean[],\n    * byte[], char[], int[], float[], String[], or an array of objects\n    * @param {int} offset         position to begin\n    * @param {int} length         number of values to extract\n    *\n    * @returns Array (the same datatype as the input)\n    *\n    * @see splice\n    */\n    p.subset = function(array, offset, length) {\n      var end = (length !== undef) ? offset + length : array.length;\n      return array.slice(offset, end);\n    };\n\n    /**\n    * Combines an array of Strings into one String, each separated by the character(s) used for\n    * the separator parameter. To join arrays of ints or floats, it's necessary to first convert\n    * them to strings using nf() or nfs().\n    *\n    * @param {Array} array              array of Strings\n    * @param {char|String} separator    char or String to be placed between each item\n    *\n    * @returns {String} The combined string\n    *\n    * @see split\n    * @see trim\n    * @see nf\n    * @see nfs\n    */\n    p.join = function(array, seperator) {\n      return array.join(seperator);\n    };\n\n    /**\n    * Decreases an array by one element and returns the shortened array. When using an\n    * array of objects, the data returned from the function must be cast to the object array's\n    * data type. For example: SomeClass[] items = (SomeClass[]) shorten(originalArray).\n    *\n    * @param {boolean[]|byte[]|char[]|int[]|float[]|String[]|array of objects} array\n    * boolean[], byte[], char[], int[], float[], or String[], or an array of objects\n    *\n    * @returns Array (the same datatype as the input)\n    *\n    * @see append\n    * @see expand\n    */\n    p.shorten = function(ary) {\n      var newary = [];\n\n      // copy array into new array\n      var len = ary.length;\n      for (var i = 0; i < len; i++) {\n        newary[i] = ary[i];\n      }\n      newary.pop();\n\n      return newary;\n    };\n\n    /**\n    * Increases the size of an array. By default, this function doubles the size of the array,\n    * but the optional newSize parameter provides precise control over the increase in size.\n    * When using an array of objects, the data returned from the function must be cast to the\n    * object array's data type. For example: SomeClass[] items = (SomeClass[]) expand(originalArray).\n    *\n    * @param {boolean[]|byte[]|char[]|int[]|float[]|String[]|array of objects} ary\n    * boolean[], byte[], char[], int[], float[], String[], or an array of objects\n    * @param {int} newSize              positive int: new size for the array\n    *\n    * @returns Array (the same datatype as the input)\n    *\n    * @see contract\n    */\n    p.expand = function(ary, targetSize) {\n      var temp = ary.slice(0),\n          newSize = targetSize || ary.length * 2;\n      temp.length = newSize;\n      return temp;\n    };\n\n    /**\n    * Copies an array (or part of an array) to another array. The src array is copied to the\n    * dst array, beginning at the position specified by srcPos and into the position specified\n    * by dstPos. The number of elements to copy is determined by length. The simplified version\n    * with two arguments copies an entire array to another of the same size. It is equivalent\n    * to \"arrayCopy(src, 0, dst, 0, src.length)\". This function is far more efficient for copying\n    * array data than iterating through a for and copying each element.\n    *\n    * @param {Array} src an array of any data type: the source array\n    * @param {Array} dest an array of any data type (as long as it's the same as src): the destination array\n    * @param {int} srcPos     starting position in the source array\n    * @param {int} destPos    starting position in the destination array\n    * @param {int} length     number of array elements to be copied\n    *\n    * @returns none\n    */\n    p.arrayCopy = function() { // src, srcPos, dest, destPos, length) {\n      var src, srcPos = 0, dest, destPos = 0, length;\n\n      if (arguments.length === 2) {\n        // recall itself and copy src to dest from start index 0 to 0 of src.length\n        src = arguments[0];\n        dest = arguments[1];\n        length = src.length;\n      } else if (arguments.length === 3) {\n        // recall itself and copy src to dest from start index 0 to 0 of length\n        src = arguments[0];\n        dest = arguments[1];\n        length = arguments[2];\n      } else if (arguments.length === 5) {\n        src = arguments[0];\n        srcPos = arguments[1];\n        dest = arguments[2];\n        destPos = arguments[3];\n        length = arguments[4];\n      }\n\n      // copy src to dest from index srcPos to index destPos of length recursivly on objects\n      for (var i = srcPos, j = destPos; i < length + srcPos; i++, j++) {\n        if (dest[j] !== undef) {\n          dest[j] = src[i];\n        } else {\n          throw \"array index out of bounds exception\";\n        }\n      }\n    };\n\n    /**\n    * Reverses the order of an array.\n    *\n    * @param {boolean[]|byte[]|char[]|int[]|float[]|String[]} array\n    * boolean[], byte[], char[], int[], float[], or String[]\n    *\n    * @returns Array (the same datatype as the input)\n    *\n    * @see sort\n    */\n    p.reverse = function(array) {\n      return array.reverse();\n    };\n\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Color functions\n    ////////////////////////////////////////////////////////////////////////////\n\n    // helper functions for internal blending modes\n    p.mix = function(a, b, f) {\n      return a + (((b - a) * f) >> 8);\n    };\n\n    p.peg = function(n) {\n      return (n < 0) ? 0 : ((n > 255) ? 255 : n);\n    };\n\n    // blending modes\n    /**\n    * These are internal blending modes used for BlendColor()\n    *\n    * @param {Color} c1       First Color to blend\n    * @param {Color} c2       Second Color to blend\n    *\n    * @returns {Color}        The blended Color\n    *\n    * @see BlendColor\n    * @see Blend\n    */\n    p.modes = (function() {\n      var ALPHA_MASK = PConstants.ALPHA_MASK,\n        RED_MASK = PConstants.RED_MASK,\n        GREEN_MASK = PConstants.GREEN_MASK,\n        BLUE_MASK = PConstants.BLUE_MASK,\n        min = Math.min,\n        max = Math.max;\n\n      function applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb) {\n        var a = min(((c1 & 0xff000000) >>> 24) + f, 0xff) << 24;\n\n        var r = (ar + (((cr - ar) * f) >> 8));\n        r = ((r < 0) ? 0 : ((r > 255) ? 255 : r)) << 16;\n\n        var g = (ag + (((cg - ag) * f) >> 8));\n        g = ((g < 0) ? 0 : ((g > 255) ? 255 : g)) << 8;\n\n        var b = ab + (((cb - ab) * f) >> 8);\n        b = (b < 0) ? 0 : ((b > 255) ? 255 : b);\n\n        return (a | r | g | b);\n      }\n\n      return {\n        replace: function(c1, c2) {\n          return c2;\n        },\n        blend: function(c1, c2) {\n          var f = (c2 & ALPHA_MASK) >>> 24,\n            ar = (c1 & RED_MASK),\n            ag = (c1 & GREEN_MASK),\n            ab = (c1 & BLUE_MASK),\n            br = (c2 & RED_MASK),\n            bg = (c2 & GREEN_MASK),\n            bb = (c2 & BLUE_MASK);\n\n          return (min(((c1 & ALPHA_MASK) >>> 24) + f, 0xff) << 24 |\n                  (ar + (((br - ar) * f) >> 8)) & RED_MASK |\n                  (ag + (((bg - ag) * f) >> 8)) & GREEN_MASK |\n                  (ab + (((bb - ab) * f) >> 8)) & BLUE_MASK);\n        },\n        add: function(c1, c2) {\n          var f = (c2 & ALPHA_MASK) >>> 24;\n          return (min(((c1 & ALPHA_MASK) >>> 24) + f, 0xff) << 24 |\n                  min(((c1 & RED_MASK) + ((c2 & RED_MASK) >> 8) * f), RED_MASK) & RED_MASK |\n                  min(((c1 & GREEN_MASK) + ((c2 & GREEN_MASK) >> 8) * f), GREEN_MASK) & GREEN_MASK |\n                  min((c1 & BLUE_MASK) + (((c2 & BLUE_MASK) * f) >> 8), BLUE_MASK));\n        },\n        subtract: function(c1, c2) {\n          var f = (c2 & ALPHA_MASK) >>> 24;\n          return (min(((c1 & ALPHA_MASK) >>> 24) + f, 0xff) << 24 |\n                  max(((c1 & RED_MASK) - ((c2 & RED_MASK) >> 8) * f), GREEN_MASK) & RED_MASK |\n                  max(((c1 & GREEN_MASK) - ((c2 & GREEN_MASK) >> 8) * f), BLUE_MASK) & GREEN_MASK |\n                  max((c1 & BLUE_MASK) - (((c2 & BLUE_MASK) * f) >> 8), 0));\n        },\n        lightest: function(c1, c2) {\n          var f = (c2 & ALPHA_MASK) >>> 24;\n          return (min(((c1 & ALPHA_MASK) >>> 24) + f, 0xff) << 24 |\n                  max(c1 & RED_MASK, ((c2 & RED_MASK) >> 8) * f) & RED_MASK |\n                  max(c1 & GREEN_MASK, ((c2 & GREEN_MASK) >> 8) * f) & GREEN_MASK |\n                  max(c1 & BLUE_MASK, ((c2 & BLUE_MASK) * f) >> 8));\n        },\n        darkest: function(c1, c2) {\n          var f = (c2 & ALPHA_MASK) >>> 24,\n            ar = (c1 & RED_MASK),\n            ag = (c1 & GREEN_MASK),\n            ab = (c1 & BLUE_MASK),\n            br = min(c1 & RED_MASK, ((c2 & RED_MASK) >> 8) * f),\n            bg = min(c1 & GREEN_MASK, ((c2 & GREEN_MASK) >> 8) * f),\n            bb = min(c1 & BLUE_MASK, ((c2 & BLUE_MASK) * f) >> 8);\n\n          return (min(((c1 & ALPHA_MASK) >>> 24) + f, 0xff) << 24 |\n                  (ar + (((br - ar) * f) >> 8)) & RED_MASK |\n                  (ag + (((bg - ag) * f) >> 8)) & GREEN_MASK |\n                  (ab + (((bb - ab) * f) >> 8)) & BLUE_MASK);\n        },\n        difference: function(c1, c2) {\n          var f  = (c2 & ALPHA_MASK) >>> 24,\n            ar = (c1 & RED_MASK) >> 16,\n            ag = (c1 & GREEN_MASK) >> 8,\n            ab = (c1 & BLUE_MASK),\n            br = (c2 & RED_MASK) >> 16,\n            bg = (c2 & GREEN_MASK) >> 8,\n            bb = (c2 & BLUE_MASK),\n            cr = (ar > br) ? (ar - br) : (br - ar),\n            cg = (ag > bg) ? (ag - bg) : (bg - ag),\n            cb = (ab > bb) ? (ab - bb) : (bb - ab);\n\n          return applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb);\n        },\n        exclusion: function(c1, c2) {\n          var f  = (c2 & ALPHA_MASK) >>> 24,\n            ar = (c1 & RED_MASK) >> 16,\n            ag = (c1 & GREEN_MASK) >> 8,\n            ab = (c1 & BLUE_MASK),\n            br = (c2 & RED_MASK) >> 16,\n            bg = (c2 & GREEN_MASK) >> 8,\n            bb = (c2 & BLUE_MASK),\n            cr = ar + br - ((ar * br) >> 7),\n            cg = ag + bg - ((ag * bg) >> 7),\n            cb = ab + bb - ((ab * bb) >> 7);\n\n          return applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb);\n        },\n        multiply: function(c1, c2) {\n          var f  = (c2 & ALPHA_MASK) >>> 24,\n            ar = (c1 & RED_MASK) >> 16,\n            ag = (c1 & GREEN_MASK) >> 8,\n            ab = (c1 & BLUE_MASK),\n            br = (c2 & RED_MASK) >> 16,\n            bg = (c2 & GREEN_MASK) >> 8,\n            bb = (c2 & BLUE_MASK),\n            cr = (ar * br) >> 8,\n            cg = (ag * bg) >> 8,\n            cb = (ab * bb) >> 8;\n\n          return applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb);\n        },\n        screen: function(c1, c2) {\n          var f  = (c2 & ALPHA_MASK) >>> 24,\n            ar = (c1 & RED_MASK) >> 16,\n            ag = (c1 & GREEN_MASK) >> 8,\n            ab = (c1 & BLUE_MASK),\n            br = (c2 & RED_MASK) >> 16,\n            bg = (c2 & GREEN_MASK) >> 8,\n            bb = (c2 & BLUE_MASK),\n            cr = 255 - (((255 - ar) * (255 - br)) >> 8),\n            cg = 255 - (((255 - ag) * (255 - bg)) >> 8),\n            cb = 255 - (((255 - ab) * (255 - bb)) >> 8);\n\n          return applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb);\n        },\n        hard_light: function(c1, c2) {\n          var f  = (c2 & ALPHA_MASK) >>> 24,\n            ar = (c1 & RED_MASK) >> 16,\n            ag = (c1 & GREEN_MASK) >> 8,\n            ab = (c1 & BLUE_MASK),\n            br = (c2 & RED_MASK) >> 16,\n            bg = (c2 & GREEN_MASK) >> 8,\n            bb = (c2 & BLUE_MASK),\n            cr = (br < 128) ? ((ar * br) >> 7) : (255 - (((255 - ar) * (255 - br)) >> 7)),\n            cg = (bg < 128) ? ((ag * bg) >> 7) : (255 - (((255 - ag) * (255 - bg)) >> 7)),\n            cb = (bb < 128) ? ((ab * bb) >> 7) : (255 - (((255 - ab) * (255 - bb)) >> 7));\n\n          return applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb);\n        },\n        soft_light: function(c1, c2) {\n          var f  = (c2 & ALPHA_MASK) >>> 24,\n            ar = (c1 & RED_MASK) >> 16,\n            ag = (c1 & GREEN_MASK) >> 8,\n            ab = (c1 & BLUE_MASK),\n            br = (c2 & RED_MASK) >> 16,\n            bg = (c2 & GREEN_MASK) >> 8,\n            bb = (c2 & BLUE_MASK),\n            cr = ((ar * br) >> 7) + ((ar * ar) >> 8) - ((ar * ar * br) >> 15),\n            cg = ((ag * bg) >> 7) + ((ag * ag) >> 8) - ((ag * ag * bg) >> 15),\n            cb = ((ab * bb) >> 7) + ((ab * ab) >> 8) - ((ab * ab * bb) >> 15);\n\n          return applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb);\n        },\n        overlay: function(c1, c2) {\n          var f  = (c2 & ALPHA_MASK) >>> 24,\n            ar = (c1 & RED_MASK) >> 16,\n            ag = (c1 & GREEN_MASK) >> 8,\n            ab = (c1 & BLUE_MASK),\n            br = (c2 & RED_MASK) >> 16,\n            bg = (c2 & GREEN_MASK) >> 8,\n            bb = (c2 & BLUE_MASK),\n            cr = (ar < 128) ? ((ar * br) >> 7) : (255 - (((255 - ar) * (255 - br)) >> 7)),\n            cg = (ag < 128) ? ((ag * bg) >> 7) : (255 - (((255 - ag) * (255 - bg)) >> 7)),\n            cb = (ab < 128) ? ((ab * bb) >> 7) : (255 - (((255 - ab) * (255 - bb)) >> 7));\n\n          return applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb);\n        },\n        dodge: function(c1, c2) {\n          var f  = (c2 & ALPHA_MASK) >>> 24,\n            ar = (c1 & RED_MASK) >> 16,\n            ag = (c1 & GREEN_MASK) >> 8,\n            ab = (c1 & BLUE_MASK),\n            br = (c2 & RED_MASK) >> 16,\n            bg = (c2 & GREEN_MASK) >> 8,\n            bb = (c2 & BLUE_MASK);\n\n          var cr = 255;\n          if (br !== 255) {\n            cr = (ar << 8) / (255 - br);\n            cr = (cr < 0) ? 0 : ((cr > 255) ? 255 : cr);\n          }\n\n          var cg = 255;\n          if (bg !== 255) {\n            cg = (ag << 8) / (255 - bg);\n            cg = (cg < 0) ? 0 : ((cg > 255) ? 255 : cg);\n          }\n\n          var cb = 255;\n          if (bb !== 255) {\n            cb = (ab << 8) / (255 - bb);\n            cb = (cb < 0) ? 0 : ((cb > 255) ? 255 : cb);\n          }\n\n          return applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb);\n        },\n        burn: function(c1, c2) {\n          var f  = (c2 & ALPHA_MASK) >>> 24,\n            ar = (c1 & RED_MASK) >> 16,\n            ag = (c1 & GREEN_MASK) >> 8,\n            ab = (c1 & BLUE_MASK),\n            br = (c2 & RED_MASK) >> 16,\n            bg = (c2 & GREEN_MASK) >> 8,\n            bb = (c2 & BLUE_MASK);\n\n          var cr = 0;\n          if (br !== 0) {\n            cr = ((255 - ar) << 8) / br;\n            cr = 255 - ((cr < 0) ? 0 : ((cr > 255) ? 255 : cr));\n          }\n\n          var cg = 0;\n          if (bg !== 0) {\n            cg = ((255 - ag) << 8) / bg;\n            cg = 255 - ((cg < 0) ? 0 : ((cg > 255) ? 255 : cg));\n          }\n\n          var cb = 0;\n          if (bb !== 0) {\n            cb = ((255 - ab) << 8) / bb;\n            cb = 255 - ((cb < 0) ? 0 : ((cb > 255) ? 255 : cb));\n          }\n\n          return applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb);\n        }\n      };\n    }());\n\n    function color$4(aValue1, aValue2, aValue3, aValue4) {\n      var r, g, b, a;\n\n      if (curColorMode === PConstants.HSB) {\n        var rgb = p.color.toRGB(aValue1, aValue2, aValue3);\n        r = rgb[0];\n        g = rgb[1];\n        b = rgb[2];\n      } else {\n        r = Math.round(255 * (aValue1 / colorModeX));\n        g = Math.round(255 * (aValue2 / colorModeY));\n        b = Math.round(255 * (aValue3 / colorModeZ));\n      }\n\n      a = Math.round(255 * (aValue4 / colorModeA));\n\n      // Limit values less than 0 and greater than 255\n      r = (r < 0) ? 0 : r;\n      g = (g < 0) ? 0 : g;\n      b = (b < 0) ? 0 : b;\n      a = (a < 0) ? 0 : a;\n      r = (r > 255) ? 255 : r;\n      g = (g > 255) ? 255 : g;\n      b = (b > 255) ? 255 : b;\n      a = (a > 255) ? 255 : a;\n\n      // Create color int\n      return (a << 24) & PConstants.ALPHA_MASK | (r << 16) & PConstants.RED_MASK | (g << 8) & PConstants.GREEN_MASK | b & PConstants.BLUE_MASK;\n    }\n\n    function color$2(aValue1, aValue2) {\n      var a;\n\n      // Color int and alpha\n      if (aValue1 & PConstants.ALPHA_MASK) {\n        a = Math.round(255 * (aValue2 / colorModeA));\n        // Limit values less than 0 and greater than 255\n        a = (a > 255) ? 255 : a;\n        a = (a < 0) ? 0 : a;\n\n        return aValue1 - (aValue1 & PConstants.ALPHA_MASK) + ((a << 24) & PConstants.ALPHA_MASK);\n      }\n      // Grayscale and alpha\n      if (curColorMode === PConstants.RGB) {\n        return color$4(aValue1, aValue1, aValue1, aValue2);\n      }\n      if (curColorMode === PConstants.HSB) {\n        return color$4(0, 0, (aValue1 / colorModeX) * colorModeZ, aValue2);\n      }\n    }\n\n    function color$1(aValue1) {\n      // Grayscale\n      if (aValue1 <= colorModeX && aValue1 >= 0) {\n          if (curColorMode === PConstants.RGB) {\n            return color$4(aValue1, aValue1, aValue1, colorModeA);\n          }\n          if (curColorMode === PConstants.HSB) {\n            return color$4(0, 0, (aValue1 / colorModeX) * colorModeZ, colorModeA);\n          }\n      }\n      // Color int\n      if (aValue1) {\n        if (aValue1 > 2147483647) {\n          // Java Overflow\n          aValue1 -= 4294967296;\n        }\n        return aValue1;\n      }\n    }\n\n    /**\n    * Creates colors for storing in variables of the color datatype. The parameters are\n    * interpreted as RGB or HSB values depending on the current colorMode(). The default\n    * mode is RGB values from 0 to 255 and therefore, the function call color(255, 204, 0)\n    * will return a bright yellow color. More about how colors are stored can be found in\n    * the reference for the color datatype.\n    *\n    * @param {int|float} aValue1        red or hue or grey values relative to the current color range.\n    * Also can be color value in hexadecimal notation (i.e. #FFCC00 or 0xFFFFCC00)\n    * @param {int|float} aValue2        green or saturation values relative to the current color range\n    * @param {int|float} aValue3        blue or brightness values relative to the current color range\n    * @param {int|float} aValue4        relative to current color range. Represents alpha\n    *\n    * @returns {color} the color\n    *\n    * @see colorMode\n    */\n    p.color = function(aValue1, aValue2, aValue3, aValue4) {\n\n      // 4 arguments: (R, G, B, A) or (H, S, B, A)\n      if (aValue1 !== undef && aValue2 !== undef && aValue3 !== undef && aValue4 !== undef) {\n        return color$4(aValue1, aValue2, aValue3, aValue4);\n      }\n\n      // 3 arguments: (R, G, B) or (H, S, B)\n      if (aValue1 !== undef && aValue2 !== undef && aValue3 !== undef) {\n        return color$4(aValue1, aValue2, aValue3, colorModeA);\n      }\n\n      // 2 arguments: (Color, A) or (Grayscale, A)\n      if (aValue1 !== undef && aValue2 !== undef) {\n        return color$2(aValue1, aValue2);\n      }\n\n      // 1 argument: (Grayscale) or (Color)\n      if (typeof aValue1 === \"number\") {\n        return color$1(aValue1);\n      }\n\n      // Default\n      return color$4(colorModeX, colorModeY, colorModeZ, colorModeA);\n    };\n\n    // Ease of use function to extract the colour bits into a string\n    p.color.toString = function(colorInt) {\n      return \"rgba(\" + ((colorInt & PConstants.RED_MASK) >>> 16) + \",\" + ((colorInt & PConstants.GREEN_MASK) >>> 8) +\n             \",\" + ((colorInt & PConstants.BLUE_MASK)) + \",\" + ((colorInt & PConstants.ALPHA_MASK) >>> 24) / 255 + \")\";\n    };\n\n    // Easy of use function to pack rgba values into a single bit-shifted color int.\n    p.color.toInt = function(r, g, b, a) {\n      return (a << 24) & PConstants.ALPHA_MASK | (r << 16) & PConstants.RED_MASK | (g << 8) & PConstants.GREEN_MASK | b & PConstants.BLUE_MASK;\n    };\n\n    // Creates a simple array in [R, G, B, A] format, [255, 255, 255, 255]\n    p.color.toArray = function(colorInt) {\n      return [(colorInt & PConstants.RED_MASK) >>> 16, (colorInt & PConstants.GREEN_MASK) >>> 8,\n              colorInt & PConstants.BLUE_MASK, (colorInt & PConstants.ALPHA_MASK) >>> 24];\n    };\n\n    // Creates a WebGL color array in [R, G, B, A] format. WebGL wants the color ranges between 0 and 1, [1, 1, 1, 1]\n    p.color.toGLArray = function(colorInt) {\n      return [((colorInt & PConstants.RED_MASK) >>> 16) / 255, ((colorInt & PConstants.GREEN_MASK) >>> 8) / 255,\n              (colorInt & PConstants.BLUE_MASK) / 255, ((colorInt & PConstants.ALPHA_MASK) >>> 24) / 255];\n    };\n\n    // HSB conversion function from Mootools, MIT Licensed\n    p.color.toRGB = function(h, s, b) {\n      // Limit values greater than range\n      h = (h > colorModeX) ? colorModeX : h;\n      s = (s > colorModeY) ? colorModeY : s;\n      b = (b > colorModeZ) ? colorModeZ : b;\n\n      h = (h / colorModeX) * 360;\n      s = (s / colorModeY) * 100;\n      b = (b / colorModeZ) * 100;\n\n      var br = Math.round(b / 100 * 255);\n\n      if (s === 0) { // Grayscale\n        return [br, br, br];\n      }\n      var hue = h % 360;\n      var f = hue % 60;\n      var p = Math.round((b * (100 - s)) / 10000 * 255);\n      var q = Math.round((b * (6000 - s * f)) / 600000 * 255);\n      var t = Math.round((b * (6000 - s * (60 - f))) / 600000 * 255);\n      switch (Math.floor(hue / 60)) {\n      case 0:\n        return [br, t, p];\n      case 1:\n        return [q, br, p];\n      case 2:\n        return [p, br, t];\n      case 3:\n        return [p, q, br];\n      case 4:\n        return [t, p, br];\n      case 5:\n        return [br, p, q];\n      }\n    };\n\n    function colorToHSB(colorInt) {\n      var red, green, blue;\n\n      red   = ((colorInt & PConstants.RED_MASK) >>> 16) / 255;\n      green = ((colorInt & PConstants.GREEN_MASK) >>> 8) / 255;\n      blue  = (colorInt & PConstants.BLUE_MASK) / 255;\n\n      var max = p.max(p.max(red,green), blue),\n          min = p.min(p.min(red,green), blue),\n          hue, saturation;\n\n      if (min === max) {\n        return [0, 0, max*colorModeZ];\n      }\n      saturation = (max - min) / max;\n\n      if (red === max) {\n        hue = (green - blue) / (max - min);\n      } else if (green === max) {\n        hue = 2 + ((blue - red) / (max - min));\n      } else {\n        hue = 4 + ((red - green) / (max - min));\n      }\n\n      hue /= 6;\n\n      if (hue < 0) {\n        hue += 1;\n      } else if (hue > 1) {\n        hue -= 1;\n      }\n      return [hue*colorModeX, saturation*colorModeY, max*colorModeZ];\n    }\n\n    /**\n    * Extracts the brightness value from a color.\n    *\n    * @param {color} colInt any value of the color datatype\n    *\n    * @returns {float} The brightness color value.\n    *\n    * @see red\n    * @see green\n    * @see blue\n    * @see hue\n    * @see saturation\n    */\n    p.brightness = function(colInt){\n      return colorToHSB(colInt)[2];\n    };\n\n    /**\n    * Extracts the saturation value from a color.\n    *\n    * @param {color} colInt any value of the color datatype\n    *\n    * @returns {float} The saturation color value.\n    *\n    * @see red\n    * @see green\n    * @see blue\n    * @see hue\n    * @see brightness\n    */\n    p.saturation = function(colInt){\n      return colorToHSB(colInt)[1];\n    };\n\n    /**\n    * Extracts the hue value from a color.\n    *\n    * @param {color} colInt any value of the color datatype\n    *\n    * @returns {float} The hue color value.\n    *\n    * @see red\n    * @see green\n    * @see blue\n    * @see saturation\n    * @see brightness\n    */\n    p.hue = function(colInt){\n      return colorToHSB(colInt)[0];\n    };\n\n    /**\n    * Extracts the red value from a color, scaled to match current colorMode().\n    * This value is always returned as a float so be careful not to assign it to an int value.\n    *\n    * @param {color} aColor any value of the color datatype\n    *\n    * @returns {float} The red color value.\n    *\n    * @see green\n    * @see blue\n    * @see alpha\n    * @see >> right shift\n    * @see hue\n    * @see saturation\n    * @see brightness\n    */\n    p.red = function(aColor) {\n      return ((aColor & PConstants.RED_MASK) >>> 16) / 255 * colorModeX;\n    };\n\n    /**\n    * Extracts the green value from a color, scaled to match current colorMode().\n    * This value is always returned as a float so be careful not to assign it to an int value.\n    *\n    * @param {color} aColor any value of the color datatype\n    *\n    * @returns {float} The green color value.\n    *\n    * @see red\n    * @see blue\n    * @see alpha\n    * @see >> right shift\n    * @see hue\n    * @see saturation\n    * @see brightness\n    */\n    p.green = function(aColor) {\n      return ((aColor & PConstants.GREEN_MASK) >>> 8) / 255 * colorModeY;\n    };\n\n    /**\n    * Extracts the blue value from a color, scaled to match current colorMode().\n    * This value is always returned as a float so be careful not to assign it to an int value.\n    *\n    * @param {color} aColor any value of the color datatype\n    *\n    * @returns {float} The blue color value.\n    *\n    * @see red\n    * @see green\n    * @see alpha\n    * @see >> right shift\n    * @see hue\n    * @see saturation\n    * @see brightness\n    */\n    p.blue = function(aColor) {\n      return (aColor & PConstants.BLUE_MASK) / 255 * colorModeZ;\n    };\n\n    /**\n    * Extracts the alpha value from a color, scaled to match current colorMode().\n    * This value is always returned as a float so be careful not to assign it to an int value.\n    *\n    * @param {color} aColor any value of the color datatype\n    *\n    * @returns {float} The alpha color value.\n    *\n    * @see red\n    * @see green\n    * @see blue\n    * @see >> right shift\n    * @see hue\n    * @see saturation\n    * @see brightness\n    */\n    p.alpha = function(aColor) {\n      return ((aColor & PConstants.ALPHA_MASK) >>> 24) / 255 * colorModeA;\n    };\n\n    /**\n    * Calculates a color or colors between two colors at a specific increment.\n    * The amt parameter is the amount to interpolate between the two values where 0.0\n    * equal to the first point, 0.1 is very near the first point, 0.5 is half-way in between, etc.\n    *\n    * @param {color} c1     interpolate from this color\n    * @param {color} c2     interpolate to this color\n    * @param {float} amt    between 0.0 and 1.0\n    *\n    * @returns {float} The blended color.\n    *\n    * @see blendColor\n    * @see color\n    */\n    p.lerpColor = function(c1, c2, amt) {\n      var r, g, b, a, r1, g1, b1, a1, r2, g2, b2, a2;\n      var hsb1, hsb2, rgb, h, s;\n      var colorBits1 = p.color(c1);\n      var colorBits2 = p.color(c2);\n\n      if (curColorMode === PConstants.HSB) {\n        // Special processing for HSB mode.\n        // Get HSB and Alpha values for Color 1 and 2\n        hsb1 = colorToHSB(colorBits1);\n        a1 = ((colorBits1 & PConstants.ALPHA_MASK) >>> 24) / colorModeA;\n        hsb2 = colorToHSB(colorBits2);\n        a2 = ((colorBits2 & PConstants.ALPHA_MASK) >>> 24) / colorModeA;\n\n        // Return lerp value for each channel, for HSB components\n        h = p.lerp(hsb1[0], hsb2[0], amt);\n        s = p.lerp(hsb1[1], hsb2[1], amt);\n        b = p.lerp(hsb1[2], hsb2[2], amt);\n        rgb = p.color.toRGB(h, s, b);\n        // ... and for Alpha-range\n        a = (p.lerp(a1, a2, amt) * colorModeA + 0.5) | 0;\n\n        return (a << 24) & PConstants.ALPHA_MASK |\n               (rgb[0] << 16) & PConstants.RED_MASK |\n               (rgb[1] << 8) & PConstants.GREEN_MASK |\n               rgb[2] & PConstants.BLUE_MASK;\n      }\n\n      // Get RGBA values for Color 1 to floats\n      r1 = (colorBits1 & PConstants.RED_MASK) >>> 16;\n      g1 = (colorBits1 & PConstants.GREEN_MASK) >>> 8;\n      b1 = (colorBits1 & PConstants.BLUE_MASK);\n      a1 = ((colorBits1 & PConstants.ALPHA_MASK) >>> 24) / colorModeA;\n\n      // Get RGBA values for Color 2 to floats\n      r2 = (colorBits2 & PConstants.RED_MASK) >>> 16;\n      g2 = (colorBits2 & PConstants.GREEN_MASK) >>> 8;\n      b2 = (colorBits2 & PConstants.BLUE_MASK);\n      a2 = ((colorBits2 & PConstants.ALPHA_MASK) >>> 24) / colorModeA;\n\n      // Return lerp value for each channel, INT for color, Float for Alpha-range\n      r = (p.lerp(r1, r2, amt) + 0.5) | 0;\n      g = (p.lerp(g1, g2, amt) + 0.5) | 0;\n      b = (p.lerp(b1, b2, amt) + 0.5) | 0;\n      a = (p.lerp(a1, a2, amt) * colorModeA + 0.5) | 0;\n\n      return (a << 24) & PConstants.ALPHA_MASK |\n             (r << 16) & PConstants.RED_MASK |\n             (g << 8) & PConstants.GREEN_MASK |\n             b & PConstants.BLUE_MASK;\n    };\n\n    /**\n    * Changes the way Processing interprets color data. By default, fill(), stroke(), and background()\n    * colors are set by values between 0 and 255 using the RGB color model. It is possible to change the\n    * numerical range used for specifying colors and to switch color systems. For example, calling colorMode(RGB, 1.0)\n    * will specify that values are specified between 0 and 1. The limits for defining colors are altered by setting the\n    * parameters range1, range2, range3, and range 4.\n    *\n    * @param {MODE} mode Either RGB or HSB, corresponding to Red/Green/Blue and Hue/Saturation/Brightness\n    * @param {int|float} range              range for all color elements\n    * @param {int|float} range1             range for the red or hue depending on the current color mode\n    * @param {int|float} range2             range for the green or saturation depending on the current color mode\n    * @param {int|float} range3             range for the blue or brightness depending on the current color mode\n    * @param {int|float} range4             range for the alpha\n    *\n    * @returns none\n    *\n    * @see background\n    * @see fill\n    * @see stroke\n    */\n    p.colorMode = function() { // mode, range1, range2, range3, range4\n      curColorMode = arguments[0];\n      if (arguments.length > 1) {\n        colorModeX   = arguments[1];\n        colorModeY   = arguments[2] || arguments[1];\n        colorModeZ   = arguments[3] || arguments[1];\n        colorModeA   = arguments[4] || arguments[1];\n      }\n    };\n\n    /**\n    * Blends two color values together based on the blending mode given as the MODE parameter.\n    * The possible modes are described in the reference for the blend() function.\n    *\n    * @param {color} c1 color: the first color to blend\n    * @param {color} c2 color: the second color to blend\n    * @param {MODE} MODE Either BLEND, ADD, SUBTRACT, DARKEST, LIGHTEST, DIFFERENCE, EXCLUSION, MULTIPLY,\n    * SCREEN, OVERLAY, HARD_LIGHT, SOFT_LIGHT, DODGE, or BURN\n    *\n    * @returns {float} The blended color.\n    *\n    * @see blend\n    * @see color\n    */\n    p.blendColor = function(c1, c2, mode) {\n      if (mode === PConstants.REPLACE) {\n        return p.modes.replace(c1, c2);\n      } else if (mode === PConstants.BLEND) {\n        return p.modes.blend(c1, c2);\n      } else if (mode === PConstants.ADD) {\n        return p.modes.add(c1, c2);\n      } else if (mode === PConstants.SUBTRACT) {\n        return p.modes.subtract(c1, c2);\n      } else if (mode === PConstants.LIGHTEST) {\n        return p.modes.lightest(c1, c2);\n      } else if (mode === PConstants.DARKEST) {\n        return p.modes.darkest(c1, c2);\n      } else if (mode === PConstants.DIFFERENCE) {\n        return p.modes.difference(c1, c2);\n      } else if (mode === PConstants.EXCLUSION) {\n        return p.modes.exclusion(c1, c2);\n      } else if (mode === PConstants.MULTIPLY) {\n        return p.modes.multiply(c1, c2);\n      } else if (mode === PConstants.SCREEN) {\n        return p.modes.screen(c1, c2);\n      } else if (mode === PConstants.HARD_LIGHT) {\n        return p.modes.hard_light(c1, c2);\n      } else if (mode === PConstants.SOFT_LIGHT) {\n        return p.modes.soft_light(c1, c2);\n      } else if (mode === PConstants.OVERLAY) {\n        return p.modes.overlay(c1, c2);\n      } else if (mode === PConstants.DODGE) {\n        return p.modes.dodge(c1, c2);\n      } else if (mode === PConstants.BURN) {\n        return p.modes.burn(c1, c2);\n      }\n    };\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Canvas-Matrix manipulation\n    ////////////////////////////////////////////////////////////////////////////\n\n    function saveContext() {\n      curContext.save();\n    }\n\n    function restoreContext() {\n      curContext.restore();\n      isStrokeDirty = true;\n      isFillDirty = true;\n    }\n\n    /**\n    * Prints the current matrix to the text window.\n    *\n    * @returns none\n    *\n    * @see pushMatrix\n    * @see popMatrix\n    * @see resetMatrix\n    * @see applyMatrix\n    */\n    p.printMatrix = function() {\n      modelView.print();\n    };\n\n    /**\n    * Specifies an amount to displace objects within the display window. The x parameter specifies left/right translation,\n    * the y parameter specifies up/down translation, and the z parameter specifies translations toward/away from the screen.\n    * Using this function with the z  parameter requires using the P3D or OPENGL parameter in combination with size as shown\n    * in the above example. Transformations apply to everything that happens after and subsequent calls to the function\n    * accumulates the effect. For example, calling translate(50, 0) and then translate(20, 0) is the same as translate(70, 0).\n    * If translate() is called within draw(), the transformation is reset when the loop begins again.\n    * This function can be further controlled by the pushMatrix() and popMatrix().\n    *\n    * @param {int|float} x        left/right translation\n    * @param {int|float} y        up/down translation\n    * @param {int|float} z        forward/back translation\n    *\n    * @returns none\n    *\n    * @see pushMatrix\n    * @see popMatrix\n    * @see scale\n    * @see rotate\n    * @see rotateX\n    * @see rotateY\n    * @see rotateZ\n    */\n    Drawing2D.prototype.translate = function(x, y) {\n      modelView.translate(x, y);\n      modelViewInv.invTranslate(x, y);\n      curContext.translate(x, y);\n    };\n\n    Drawing3D.prototype.translate = function(x, y, z) {\n      modelView.translate(x, y, z);\n      modelViewInv.invTranslate(x, y, z);\n    };\n\n    /**\n    * Increases or decreases the size of a shape by expanding and contracting vertices. Objects always scale from their\n    * relative origin to the coordinate system. Scale values are specified as decimal percentages. For example, the\n    * function call scale(2.0) increases the dimension of a shape by 200%. Transformations apply to everything that\n    * happens after and subsequent calls to the function multiply the effect. For example, calling scale(2.0) and\n    * then scale(1.5) is the same as scale(3.0). If scale() is called within draw(), the transformation is reset when\n    * the loop begins again. Using this fuction with the z  parameter requires passing P3D or OPENGL into the size()\n    * parameter as shown in the example above. This function can be further controlled by pushMatrix() and popMatrix().\n    *\n    * @param {int|float} size     percentage to scale the object\n    * @param {int|float} x        percentage to scale the object in the x-axis\n    * @param {int|float} y        percentage to scale the object in the y-axis\n    * @param {int|float} z        percentage to scale the object in the z-axis\n    *\n    * @returns none\n    *\n    * @see pushMatrix\n    * @see popMatrix\n    * @see translate\n    * @see rotate\n    * @see rotateX\n    * @see rotateY\n    * @see rotateZ\n    */\n    Drawing2D.prototype.scale = function(x, y) {\n      modelView.scale(x, y);\n      modelViewInv.invScale(x, y);\n      curContext.scale(x, y || x);\n    };\n\n    Drawing3D.prototype.scale = function(x, y, z) {\n      modelView.scale(x, y, z);\n      modelViewInv.invScale(x, y, z);\n    };\n\n\n    /**\n     * helper function for applying a transfrom matrix to a 2D context.\n     */\n    Drawing2D.prototype.transform = function(pmatrix) {\n      var e = pmatrix.array();\n      curContext.transform(e[0],e[3],e[1],e[4],e[2],e[5]);\n    };\n\n    /**\n     * helper function for applying a transfrom matrix to a 3D context.\n     * not currently implemented.\n     */\n    Drawing3D.prototype.transformm = function(pmatrix3d) {\n      throw(\"p.transform is currently not supported in 3D mode\");\n    };\n\n\n    /**\n    * Pushes the current transformation matrix onto the matrix stack. Understanding pushMatrix() and popMatrix()\n    * requires understanding the concept of a matrix stack. The pushMatrix() function saves the current coordinate\n    * system to the stack and popMatrix() restores the prior coordinate system. pushMatrix() and popMatrix() are\n    * used in conjuction with the other transformation methods and may be embedded to control the scope of\n    * the transformations.\n    *\n    * @returns none\n    *\n    * @see popMatrix\n    * @see translate\n    * @see rotate\n    * @see rotateX\n    * @see rotateY\n    * @see rotateZ\n    */\n    Drawing2D.prototype.pushMatrix = function() {\n      userMatrixStack.load(modelView);\n      userReverseMatrixStack.load(modelViewInv);\n      saveContext();\n    };\n\n    Drawing3D.prototype.pushMatrix = function() {\n      userMatrixStack.load(modelView);\n      userReverseMatrixStack.load(modelViewInv);\n    };\n\n    /**\n    * Pops the current transformation matrix off the matrix stack. Understanding pushing and popping requires\n    * understanding the concept of a matrix stack. The pushMatrix() function saves the current coordinate system to\n    * the stack and popMatrix() restores the prior coordinate system. pushMatrix() and popMatrix() are used in\n    * conjuction with the other transformation methods and may be embedded to control the scope of the transformations.\n    *\n    * @returns none\n    *\n    * @see popMatrix\n    * @see pushMatrix\n    */\n    Drawing2D.prototype.popMatrix = function() {\n      modelView.set(userMatrixStack.pop());\n      modelViewInv.set(userReverseMatrixStack.pop());\n      restoreContext();\n    };\n\n    Drawing3D.prototype.popMatrix = function() {\n      modelView.set(userMatrixStack.pop());\n      modelViewInv.set(userReverseMatrixStack.pop());\n    };\n\n    /**\n    * Replaces the current matrix with the identity matrix. The equivalent function in OpenGL is glLoadIdentity().\n    *\n    * @returns none\n    *\n    * @see popMatrix\n    * @see pushMatrix\n    * @see applyMatrix\n    * @see printMatrix\n    */\n    Drawing2D.prototype.resetMatrix = function() {\n      modelView.reset();\n      modelViewInv.reset();\n      curContext.setTransform(1,0,0,1,0,0);\n    };\n\n    Drawing3D.prototype.resetMatrix = function() {\n      modelView.reset();\n      modelViewInv.reset();\n    };\n\n    /**\n    * Multiplies the current matrix by the one specified through the parameters. This is very slow because it will\n    * try to calculate the inverse of the transform, so avoid it whenever possible. The equivalent function\n    * in OpenGL is glMultMatrix().\n    *\n    * @param {int|float} n00-n15      numbers which define the 4x4 matrix to be multiplied\n    *\n    * @returns none\n    *\n    * @see popMatrix\n    * @see pushMatrix\n    * @see resetMatrix\n    * @see printMatrix\n    */\n    DrawingShared.prototype.applyMatrix = function() {\n      var a = arguments;\n      modelView.apply(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);\n      modelViewInv.invApply(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);\n    };\n\n    Drawing2D.prototype.applyMatrix = function() {\n      var a = arguments;\n      for (var cnt = a.length; cnt < 16; cnt++) {\n        a[cnt] = 0;\n      }\n      a[10] = a[15] = 1;\n      DrawingShared.prototype.applyMatrix.apply(this, a);\n    };\n\n    /**\n    * Rotates a shape around the x-axis the amount specified by the angle parameter. Angles should be\n    * specified in radians (values from 0 to PI*2) or converted to radians with the radians()  function.\n    * Objects are always rotated around their relative position to the origin and positive numbers\n    * rotate objects in a counterclockwise direction. Transformations apply to everything that happens\n    * after and subsequent calls to the function accumulates the effect. For example, calling rotateX(PI/2)\n    * and then rotateX(PI/2) is the same as rotateX(PI). If rotateX() is called within the draw(), the\n    * transformation is reset when the loop begins again. This function requires passing P3D or OPENGL\n    * into the size() parameter as shown in the example above.\n    *\n    * @param {int|float} angleInRadians     angle of rotation specified in radians\n    *\n    * @returns none\n    *\n    * @see rotateY\n    * @see rotateZ\n    * @see rotate\n    * @see translate\n    * @see scale\n    * @see popMatrix\n    * @see pushMatrix\n    */\n    p.rotateX = function(angleInRadians) {\n      modelView.rotateX(angleInRadians);\n      modelViewInv.invRotateX(angleInRadians);\n    };\n\n    /**\n    * Rotates a shape around the z-axis the amount specified by the angle parameter. Angles should be\n    * specified in radians (values from 0 to PI*2) or converted to radians with the radians()  function.\n    * Objects are always rotated around their relative position to the origin and positive numbers\n    * rotate objects in a counterclockwise direction. Transformations apply to everything that happens\n    * after and subsequent calls to the function accumulates the effect. For example, calling rotateZ(PI/2)\n    * and then rotateZ(PI/2) is the same as rotateZ(PI). If rotateZ() is called within the draw(), the\n    * transformation is reset when the loop begins again. This function requires passing P3D or OPENGL\n    * into the size() parameter as shown in the example above.\n    *\n    * @param {int|float} angleInRadians     angle of rotation specified in radians\n    *\n    * @returns none\n    *\n    * @see rotateX\n    * @see rotateY\n    * @see rotate\n    * @see translate\n    * @see scale\n    * @see popMatrix\n    * @see pushMatrix\n    */\n    Drawing2D.prototype.rotateZ = function() {\n      throw \"rotateZ() is not supported in 2D mode. Use rotate(float) instead.\";\n    };\n\n    Drawing3D.prototype.rotateZ = function(angleInRadians) {\n      modelView.rotateZ(angleInRadians);\n      modelViewInv.invRotateZ(angleInRadians);\n    };\n\n    /**\n    * Rotates a shape around the y-axis the amount specified by the angle parameter. Angles should be\n    * specified in radians (values from 0 to PI*2) or converted to radians with the radians()  function.\n    * Objects are always rotated around their relative position to the origin and positive numbers\n    * rotate objects in a counterclockwise direction. Transformations apply to everything that happens\n    * after and subsequent calls to the function accumulates the effect. For example, calling rotateY(PI/2)\n    * and then rotateY(PI/2) is the same as rotateY(PI). If rotateY() is called within the draw(), the\n    * transformation is reset when the loop begins again. This function requires passing P3D or OPENGL\n    * into the size() parameter as shown in the example above.\n    *\n    * @param {int|float} angleInRadians     angle of rotation specified in radians\n    *\n    * @returns none\n    *\n    * @see rotateX\n    * @see rotateZ\n    * @see rotate\n    * @see translate\n    * @see scale\n    * @see popMatrix\n    * @see pushMatrix\n    */\n    p.rotateY = function(angleInRadians) {\n      modelView.rotateY(angleInRadians);\n      modelViewInv.invRotateY(angleInRadians);\n    };\n\n    /**\n    * Rotates a shape the amount specified by the angle parameter. Angles should be specified in radians\n    * (values from 0 to TWO_PI) or converted to radians with the radians() function. Objects are always\n    * rotated around their relative position to the origin and positive numbers rotate objects in a\n    * clockwise direction. Transformations apply to everything that happens after and subsequent calls\n    * to the function accumulates the effect. For example, calling rotate(HALF_PI) and then rotate(HALF_PI)\n    * is the same as rotate(PI). All tranformations are reset when draw() begins again. Technically,\n    * rotate() multiplies the current transformation matrix by a rotation matrix. This function can be\n    * further controlled by the pushMatrix() and popMatrix().\n    *\n    * @param {int|float} angleInRadians     angle of rotation specified in radians\n    *\n    * @returns none\n    *\n    * @see rotateX\n    * @see rotateY\n    * @see rotateZ\n    * @see rotate\n    * @see translate\n    * @see scale\n    * @see popMatrix\n    * @see pushMatrix\n    */\n    Drawing2D.prototype.rotate = function(angleInRadians) {\n      modelView.rotateZ(angleInRadians);\n      modelViewInv.invRotateZ(angleInRadians);\n      curContext.rotate(angleInRadians);\n    };\n\n    Drawing3D.prototype.rotate = function(angleInRadians) {\n      if (arguments.length < 4) {\n        p.rotateZ(angleInRadians);\n      } else {\n        modelView.rotate(angleInRadians, arguments[1], arguments[2], arguments[3]);\n        modelViewInv.rotate((-angleInRadians), arguments[1], arguments[2], arguments[3]);\n      }\n    };\n\n    /**\n    * Shears a shape around the x-axis the amount specified by the angle parameter.\n    * Angles should be specified in radians (values from 0 to PI*2) or converted to radians\n    * with the radians() function. Objects are always sheared around their relative position\n    * to the origin and positive numbers shear objects in a clockwise direction. Transformations\n    * apply to everything that happens after and subsequent calls to the function accumulates the\n    * effect. For example, calling shearX(PI/2) and then shearX(PI/2) is the same as shearX(PI)\n    *\n    * @param {int|float} angleInRadians     angle of rotation specified in radians\n    *\n    * @returns none\n    *\n    * @see rotateX\n    * @see rotateY\n    * @see rotateZ\n    * @see rotate\n    * @see translate\n    * @see scale\n    * @see popMatrix\n    * @see pushMatrix\n    */\n\n    Drawing2D.prototype.shearX = function(angleInRadians) {\n      modelView.shearX(angleInRadians);\n      curContext.transform(1,0,angleInRadians,1,0,0);\n    };\n\n    Drawing3D.prototype.shearX = function(angleInRadians) {\n      modelView.shearX(angleInRadians);\n    };\n\n    /**\n    * Shears a shape around the y-axis the amount specified by the angle parameter.\n    * Angles should be specified in radians (values from 0 to PI*2) or converted to\n    * radians with the radians() function. Objects are always sheared around their\n    * relative position to the origin and positive numbers shear objects in a\n    * clockwise direction. Transformations apply to everything that happens after\n    * and subsequent calls to the function accumulates the effect. For example,\n    * calling shearY(PI/2) and then shearY(PI/2) is the same as shearY(PI).\n    *\n    * @param {int|float} angleInRadians     angle of rotation specified in radians\n    *\n    * @returns none\n    *\n    * @see rotateX\n    * @see rotateY\n    * @see rotateZ\n    * @see rotate\n    * @see translate\n    * @see scale\n    * @see popMatrix\n    * @see pushMatrix\n    * @see shearX\n    */\n\n   Drawing2D.prototype.shearY = function(angleInRadians) {\n      modelView.shearY(angleInRadians);\n      curContext.transform(1,angleInRadians,0,1,0,0);\n    };\n\n    Drawing3D.prototype.shearY = function(angleInRadians) {\n      modelView.shearY(angleInRadians);\n    };\n\n    /**\n    * The pushStyle() function saves the current style settings and popStyle()  restores the prior settings.\n    * Note that these functions are always used together. They allow you to change the style settings and later\n    * return to what you had. When a new style is started with pushStyle(), it builds on the current style information.\n    * The pushStyle() and popStyle() functions can be embedded to provide more control (see the second example\n    * above for a demonstration.)\n    * The style information controlled by the following functions are included in the style: fill(), stroke(), tint(),\n    * strokeWeight(), strokeCap(), strokeJoin(), imageMode(), rectMode(), ellipseMode(), shapeMode(), colorMode(),\n    * textAlign(), textFont(), textMode(), textSize(), textLeading(), emissive(), specular(), shininess(), ambient()\n    *\n    * @returns none\n    *\n    * @see popStyle\n    */\n    p.pushStyle = function() {\n      // Save the canvas state.\n      saveContext();\n\n      p.pushMatrix();\n\n      var newState = {\n        'doFill': doFill,\n        'currentFillColor': currentFillColor,\n        'doStroke': doStroke,\n        'currentStrokeColor': currentStrokeColor,\n        'curTint': curTint,\n        'curRectMode': curRectMode,\n        'curColorMode': curColorMode,\n        'colorModeX': colorModeX,\n        'colorModeZ': colorModeZ,\n        'colorModeY': colorModeY,\n        'colorModeA': colorModeA,\n        'curTextFont': curTextFont,\n        'horizontalTextAlignment': horizontalTextAlignment,\n        'verticalTextAlignment': verticalTextAlignment,\n        'textMode': textMode,\n        'curFontName': curFontName,\n        'curTextSize': curTextSize,\n        'curTextAscent': curTextAscent,\n        'curTextDescent': curTextDescent,\n        'curTextLeading': curTextLeading\n      };\n\n      styleArray.push(newState);\n    };\n\n    /**\n    * The pushStyle() function saves the current style settings and popStyle()  restores the prior settings; these\n    * functions are always used together. They allow you to change the style settings and later return to what you had.\n    * When a new style is started with pushStyle(), it builds on the current style information. The pushStyle() and\n    * popStyle() functions can be embedded to provide more control (see the second example above for a demonstration.)\n    *\n    * @returns none\n    *\n    * @see pushStyle\n    */\n    p.popStyle = function() {\n      var oldState = styleArray.pop();\n\n      if (oldState) {\n        restoreContext();\n\n        p.popMatrix();\n\n        doFill = oldState.doFill;\n        currentFillColor = oldState.currentFillColor;\n        doStroke = oldState.doStroke;\n        currentStrokeColor = oldState.currentStrokeColor;\n        curTint = oldState.curTint;\n        curRectMode = oldState.curRectMode;\n        curColorMode = oldState.curColorMode;\n        colorModeX = oldState.colorModeX;\n        colorModeZ = oldState.colorModeZ;\n        colorModeY = oldState.colorModeY;\n        colorModeA = oldState.colorModeA;\n        curTextFont = oldState.curTextFont;\n        curFontName = oldState.curFontName;\n        curTextSize = oldState.curTextSize;\n        horizontalTextAlignment = oldState.horizontalTextAlignment;\n        verticalTextAlignment = oldState.verticalTextAlignment;\n        textMode = oldState.textMode;\n        curTextAscent = oldState.curTextAscent;\n        curTextDescent = oldState.curTextDescent;\n        curTextLeading = oldState.curTextLeading;\n      } else {\n        throw \"Too many popStyle() without enough pushStyle()\";\n      }\n    };\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Time based functions\n    ////////////////////////////////////////////////////////////////////////////\n\n    /**\n    * Processing communicates with the clock on your computer.\n    * The year() function returns the current year as an integer (2003, 2004, 2005, etc).\n    *\n    * @returns {float} The current year.\n    *\n    * @see millis\n    * @see second\n    * @see minute\n    * @see hour\n    * @see day\n    * @see month\n    */\n    p.year = function() {\n      return new Date().getFullYear();\n    };\n    /**\n    * Processing communicates with the clock on your computer.\n    * The month() function returns the current month as a value from 1 - 12.\n    *\n    * @returns {float} The current month.\n    *\n    * @see millis\n    * @see second\n    * @see minute\n    * @see hour\n    * @see day\n    * @see year\n    */\n    p.month = function() {\n      return new Date().getMonth() + 1;\n    };\n    /**\n    * Processing communicates with the clock on your computer.\n    * The day() function returns the current day as a value from 1 - 31.\n    *\n    * @returns {float} The current day.\n    *\n    * @see millis\n    * @see second\n    * @see minute\n    * @see hour\n    * @see month\n    * @see year\n    */\n    p.day = function() {\n      return new Date().getDate();\n    };\n    /**\n    * Processing communicates with the clock on your computer.\n    * The hour() function returns the current hour as a value from 0 - 23.\n    *\n    * @returns {float} The current hour.\n    *\n    * @see millis\n    * @see second\n    * @see minute\n    * @see month\n    * @see day\n    * @see year\n    */\n    p.hour = function() {\n      return new Date().getHours();\n    };\n    /**\n    * Processing communicates with the clock on your computer.\n    * The minute() function returns the current minute as a value from 0 - 59.\n    *\n    * @returns {float} The current minute.\n    *\n    * @see millis\n    * @see second\n    * @see month\n    * @see hour\n    * @see day\n    * @see year\n    */\n    p.minute = function() {\n      return new Date().getMinutes();\n    };\n    /**\n    * Processing communicates with the clock on your computer.\n    * The second() function returns the current second as a value from 0 - 59.\n    *\n    * @returns {float} The current minute.\n    *\n    * @see millis\n    * @see month\n    * @see minute\n    * @see hour\n    * @see day\n    * @see year\n    */\n    p.second = function() {\n      return new Date().getSeconds();\n    };\n    /**\n    * Returns the number of milliseconds (thousandths of a second) since starting a sketch.\n    * This information is often used for timing animation sequences.\n    *\n    * @returns {long} The number of milliseconds since starting the sketch.\n    *\n    * @see month\n    * @see second\n    * @see minute\n    * @see hour\n    * @see day\n    * @see year\n    */\n    p.millis = function() {\n      return Date.now() - start;\n    };\n\n    /**\n    * Executes the code within draw() one time. This functions allows the program to update\n    * the display window only when necessary, for example when an event registered by\n    * mousePressed() or keyPressed() occurs.\n    * In structuring a program, it only makes sense to call redraw() within events such as\n    * mousePressed(). This is because redraw() does not run draw() immediately (it only sets\n    * a flag that indicates an update is needed).\n    * Calling redraw() within draw() has no effect because draw() is continuously called anyway.\n    *\n    * @returns none\n    *\n    * @see noLoop\n    * @see loop\n    */\n    function redrawHelper() {\n      var sec = (Date.now() - timeSinceLastFPS) / 1000;\n      framesSinceLastFPS++;\n      var fps = framesSinceLastFPS / sec;\n\n      // recalculate FPS every half second for better accuracy.\n      if (sec > 0.5) {\n        timeSinceLastFPS = Date.now();\n        framesSinceLastFPS = 0;\n        p.__frameRate = fps;\n      }\n\n      p.frameCount++;\n    }\n\n    Drawing2D.prototype.redraw = function() {\n      redrawHelper();\n\n      curContext.lineWidth = lineWidth;\n      var pmouseXLastEvent = p.pmouseX,\n          pmouseYLastEvent = p.pmouseY;\n      p.pmouseX = pmouseXLastFrame;\n      p.pmouseY = pmouseYLastFrame;\n\n      saveContext();\n      p.draw();\n      restoreContext();\n\n      pmouseXLastFrame = p.mouseX;\n      pmouseYLastFrame = p.mouseY;\n      p.pmouseX = pmouseXLastEvent;\n      p.pmouseY = pmouseYLastEvent;\n    };\n\n    Drawing3D.prototype.redraw = function() {\n      redrawHelper();\n\n      var pmouseXLastEvent = p.pmouseX,\n          pmouseYLastEvent = p.pmouseY;\n      p.pmouseX = pmouseXLastFrame;\n      p.pmouseY = pmouseYLastFrame;\n      // even if the color buffer isn't cleared with background(),\n      // the depth buffer needs to be cleared regardless.\n      curContext.clear(curContext.DEPTH_BUFFER_BIT);\n      curContextCache = { attributes: {}, locations: {} };\n      // Delete all the lighting states and the materials the\n      // user set in the last draw() call.\n      p.noLights();\n      p.lightFalloff(1, 0, 0);\n      p.shininess(1);\n      p.ambient(255, 255, 255);\n      p.specular(0, 0, 0);\n      p.emissive(0, 0, 0);\n      p.camera();\n      p.draw();\n\n      pmouseXLastFrame = p.mouseX;\n      pmouseYLastFrame = p.mouseY;\n      p.pmouseX = pmouseXLastEvent;\n      p.pmouseY = pmouseYLastEvent;\n    };\n\n    /**\n    * Stops Processing from continuously executing the code within draw(). If loop() is\n    * called, the code in draw() begin to run continuously again. If using noLoop() in\n    * setup(), it should be the last line inside the block.\n    * When noLoop() is used, it's not possible to manipulate or access the screen inside event\n    * handling functions such as mousePressed() or keyPressed(). Instead, use those functions\n    * to call redraw() or loop(), which will run draw(), which can update the screen properly.\n    * This means that when noLoop() has been called, no drawing can happen, and functions like\n    * saveFrame() or loadPixels() may not be used.\n    * Note that if the sketch is resized, redraw() will be called to update the sketch, even\n    * after noLoop() has been specified. Otherwise, the sketch would enter an odd state until\n    * loop() was called.\n    *\n    * @returns none\n    *\n    * @see redraw\n    * @see draw\n    * @see loop\n    */\n    p.noLoop = function() {\n      doLoop = false;\n      loopStarted = false;\n      clearInterval(looping);\n      curSketch.onPause();\n    };\n\n    /**\n    * Causes Processing to continuously execute the code within draw(). If noLoop() is called,\n    * the code in draw() stops executing.\n    *\n    * @returns none\n    *\n    * @see noLoop\n    */\n    p.loop = function() {\n      if (loopStarted) {\n        return;\n      }\n\n      timeSinceLastFPS = Date.now();\n      framesSinceLastFPS = 0;\n\n      looping = window.setInterval(function() {\n        try {\n          curSketch.onFrameStart();\n          p.redraw();\n          curSketch.onFrameEnd();\n        } catch(e_loop) {\n          window.clearInterval(looping);\n          throw e_loop;\n        }\n      }, curMsPerFrame);\n      doLoop = true;\n      loopStarted = true;\n      curSketch.onLoop();\n    };\n\n    /**\n    * Specifies the number of frames to be displayed every second. If the processor is not\n    * fast enough to maintain the specified rate, it will not be achieved. For example, the\n    * function call frameRate(30) will attempt to refresh 30 times a second. It is recommended\n    * to set the frame rate within setup(). The default rate is 60 frames per second.\n    *\n    * @param {int} aRate        number of frames per second.\n    *\n    * @returns none\n    *\n    * @see delay\n    */\n    p.frameRate = function(aRate) {\n      curFrameRate = aRate;\n      curMsPerFrame = 1000 / curFrameRate;\n\n      // clear and reset interval\n      if (doLoop) {\n        p.noLoop();\n        p.loop();\n      }\n    };\n\n    /**\n    * Quits/stops/exits the program.\n    * Rather than terminating immediately, exit() will cause the sketch to exit after draw()\n    * has completed (or after setup() completes if called during the setup() method).\n    *\n    * @returns none\n    */\n    p.exit = function() {\n      // cleanup\n      window.clearInterval(looping);\n      removeInstance(p.externals.canvas.id);\n      delete(curElement.onmousedown);\n\n      // Step through the libraries to detach them\n      for (var lib in Processing.lib) {\n        if (Processing.lib.hasOwnProperty(lib)) {\n          if (Processing.lib[lib].hasOwnProperty(\"detach\")) {\n            Processing.lib[lib].detach(p);\n          }\n        }\n      }\n\n      // clean up all event handling\n      var i = eventHandlers.length;\n      while (i--) {\n        detachEventHandler(eventHandlers[i]);\n      }\n      curSketch.onExit();\n    };\n\n    ////////////////////////////////////////////////////////////////////////////\n    // MISC functions\n    ////////////////////////////////////////////////////////////////////////////\n\n    /**\n    * Sets the cursor to a predefined symbol, an image, or turns it on if already hidden.\n    * If you are trying to set an image as the cursor, it is recommended to make the size\n    * 16x16 or 32x32 pixels. It is not possible to load an image as the cursor if you are\n    * exporting your program for the Web. The values for parameters x and y must be less\n    * than the dimensions of the image.\n    *\n    * @param {MODE} MODE either ARROW, CROSS, HAND, MOVE, TEXT, WAIT\n    * @param {PImage} image       any variable of type PImage\n    * @param {int}    x           the horizonal active spot of the cursor\n    * @param {int}    y           the vertical active spot of the cursor\n    *\n    * @returns none\n    *\n    * @see noCursor\n    */\n    p.cursor = function() {\n      if (arguments.length > 1 || (arguments.length === 1 && arguments[0] instanceof p.PImage)) {\n        var image = arguments[0],\n          x, y;\n        if (arguments.length >= 3) {\n          x = arguments[1];\n          y = arguments[2];\n          if (x < 0 || y < 0 || y >= image.height || x >= image.width) {\n            throw \"x and y must be non-negative and less than the dimensions of the image\";\n          }\n        } else {\n          x = image.width >>> 1;\n          y = image.height >>> 1;\n        }\n\n        // see https://developer.mozilla.org/en/Using_URL_values_for_the_cursor_property\n        var imageDataURL = image.toDataURL();\n        var style = \"url(\\\"\" + imageDataURL + \"\\\") \" + x + \" \" + y + \", default\";\n        curCursor = curElement.style.cursor = style;\n      } else if (arguments.length === 1) {\n        var mode = arguments[0];\n        curCursor = curElement.style.cursor = mode;\n      } else {\n        curCursor = curElement.style.cursor = oldCursor;\n      }\n    };\n\n    /**\n    * Hides the cursor from view.\n    *\n    * @returns none\n    *\n    * @see cursor\n    */\n    p.noCursor = function() {\n      curCursor = curElement.style.cursor = PConstants.NOCURSOR;\n    };\n\n    /**\n    * Links to a webpage either in the same window or in a new window. The complete URL\n    * must be specified.\n    *\n    * @param {String} href      complete url as a String in quotes\n    * @param {String} target    name of the window to load the URL as a string in quotes\n    *\n    * @returns none\n    */\n    p.link = function(href, target) {\n      if (target !== undef) {\n        window.open(href, target);\n      } else {\n        window.location = href;\n      }\n    };\n\n    // PGraphics methods\n    // These functions exist only for compatibility with P5\n    p.beginDraw = noop;\n    p.endDraw = noop;\n\n    /**\n     * This function takes content from a canvas and turns it into an ImageData object to be used with a PImage\n     *\n     * @returns {ImageData}        ImageData object to attach to a PImage (1D array of pixel data)\n     *\n     * @see PImage\n     */\n    Drawing2D.prototype.toImageData = function(x, y, w, h) {\n      x = x !== undef ? x : 0;\n      y = y !== undef ? y : 0;\n      w = w !== undef ? w : p.width;\n      h = h !== undef ? h : p.height;\n      return curContext.getImageData(x, y, w, h);\n    };\n\n    Drawing3D.prototype.toImageData = function(x, y, w, h) {\n      x = x !== undef ? x : 0;\n      y = y !== undef ? y : 0;\n      w = w !== undef ? w : p.width;\n      h = h !== undef ? h : p.height;\n      var c = document.createElement(\"canvas\"),\n          ctx = c.getContext(\"2d\"),\n          obj = ctx.createImageData(w, h),\n          uBuff = new Uint8Array(w * h * 4);\n      curContext.readPixels(x, y, w, h, curContext.RGBA, curContext.UNSIGNED_BYTE, uBuff);\n      for (var i=0, ul=uBuff.length, obj_data=obj.data; i < ul; i++) {\n        obj_data[i] = uBuff[(h - 1 - Math.floor(i / 4 / w)) * w * 4 + (i % (w * 4))];\n      }\n      return obj;\n    };\n\n    /**\n    * Displays message in the browser's status area. This is the text area in the lower\n    * left corner of the browser. The status() function will only work when the\n    * Processing program is running in a web browser.\n    *\n    * @param {String} text      any valid String\n    *\n    * @returns none\n    */\n    p.status = function(text) {\n      window.status = text;\n    };\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Binary Functions\n    ////////////////////////////////////////////////////////////////////////////\n\n    /**\n    * Converts a byte, char, int, or color to a String containing the equivalent binary\n    * notation. For example color(0, 102, 153, 255) will convert to the String\n    * \"11111111000000000110011010011001\". This function can help make your geeky debugging\n    * sessions much happier.\n    *\n    * @param {byte|char|int|color} num          byte, char, int, color: value to convert\n    * @param {int} numBits                      number of digits to return\n    *\n    * @returns {String}\n    *\n    * @see unhex\n    * @see hex\n    * @see unbinary\n    */\n    p.binary = function(num, numBits) {\n      var bit;\n      if (numBits > 0) {\n        bit = numBits;\n      } else if(num instanceof Char) {\n        bit = 16;\n        num |= 0; // making it int\n      } else {\n        // autodetect, skipping zeros\n        bit = 32;\n        while (bit > 1 && !((num >>> (bit - 1)) & 1)) {\n          bit--;\n        }\n      }\n      var result = \"\";\n      while (bit > 0) {\n        result += ((num >>> (--bit)) & 1) ? \"1\" : \"0\";\n      }\n      return result;\n    };\n\n    /**\n    * Converts a String representation of a binary number to its equivalent integer value.\n    * For example, unbinary(\"00001000\") will return 8.\n    *\n    * @param {String} binaryString String\n    *\n    * @returns {Int}\n    *\n    * @see hex\n    * @see binary\n    * @see unbinary\n    */\n    p.unbinary = function(binaryString) {\n      var i = binaryString.length - 1, mask = 1, result = 0;\n      while (i >= 0) {\n        var ch = binaryString[i--];\n        if (ch !== '0' && ch !== '1') {\n          throw \"the value passed into unbinary was not an 8 bit binary number\";\n        }\n        if (ch === '1') {\n          result += mask;\n        }\n        mask <<= 1;\n      }\n      return result;\n    };\n\n    var decimalToHex = function(d, padding) {\n      //if there is no padding value added, default padding to 8 else go into while statement.\n      padding = (padding === undef || padding === null) ? padding = 8 : padding;\n      if (d < 0) {\n        d = 0xFFFFFFFF + d + 1;\n      }\n      var hex = Number(d).toString(16).toUpperCase();\n      while (hex.length < padding) {\n        hex = \"0\" + hex;\n      }\n      if (hex.length >= padding) {\n        hex = hex.substring(hex.length - padding, hex.length);\n      }\n      return hex;\n    };\n\n    // note: since we cannot keep track of byte, int types by default the returned string is 8 chars long\n    // if no 2nd argument is passed.  closest compromise we can use to match java implementation Feb 5 2010\n    // also the char parser has issues with chars that are not digits or letters IE: !@#$%^&*\n    /**\n    * Converts a byte, char, int, or color to a String containing the equivalent hexadecimal notation.\n    * For example color(0, 102, 153, 255) will convert to the String \"FF006699\". This function can help\n    * make your geeky debugging sessions much happier.\n    *\n    * @param {byte|char|int|Color} value   the value to turn into a hex string\n    * @param {int} digits                 the number of digits to return\n    *\n    * @returns {String}\n    *\n    * @see unhex\n    * @see binary\n    * @see unbinary\n    */\n    p.hex = function(value, len) {\n      if (arguments.length === 1) {\n        if (value instanceof Char) {\n          len = 4;\n        } else { // int or byte, indistinguishable at the moment, default to 8\n          len = 8;\n        }\n      }\n      return decimalToHex(value, len);\n    };\n\n    function unhexScalar(hex) {\n      var value = parseInt(\"0x\" + hex, 16);\n\n      // correct for int overflow java expectation\n      if (value > 2147483647) {\n        value -= 4294967296;\n      }\n      return value;\n    }\n\n    /**\n    * Converts a String representation of a hexadecimal number to its equivalent integer value.\n    *\n    * @param {String} hex   the hex string to convert to an int\n    *\n    * @returns {int}\n    *\n    * @see hex\n    * @see binary\n    * @see unbinary\n    */\n    p.unhex = function(hex) {\n      if (hex instanceof Array) {\n        var arr = [];\n        for (var i = 0; i < hex.length; i++) {\n          arr.push(unhexScalar(hex[i]));\n        }\n        return arr;\n      }\n      return unhexScalar(hex);\n    };\n\n    // Load a file or URL into strings\n    /**\n    * Reads the contents of a file or url and creates a String array of its individual lines.\n    * The filename parameter can also be a URL to a file found online.  If the file is not available or an error occurs,\n    * null will be returned and an error message will be printed to the console. The error message does not halt\n    * the program.\n    *\n    * @param {String} filename    name of the file or url to load\n    *\n    * @returns {String[]}\n    *\n    * @see loadBytes\n    * @see saveStrings\n    * @see saveBytes\n    */\n    p.loadStrings = function(filename) {\n      if (localStorage[filename]) {\n        return localStorage[filename].split(\"\\n\");\n      }\n\n      var filecontent = ajax(filename);\n      if(typeof filecontent !== \"string\" || filecontent === \"\") {\n        return [];\n      }\n\n      // deal with the fact that Windows uses \\r\\n, Unix uses \\n,\n      // Mac uses \\r, and we actually expect \\n\n      filecontent = filecontent.replace(/(\\r\\n?)/g,\"\\n\").replace(/\\n$/,\"\");\n\n      return filecontent.split(\"\\n\");\n    };\n\n    // Writes an array of strings to a file, one line per string\n    /**\n    * Writes an array of strings to a file, one line per string. This file is saved to the localStorage.\n    *\n    * @param {String} filename    name of the file to save to localStorage\n    * @param {String[]} strings   string array to be written\n    *\n    * @see loadBytes\n    * @see loadStrings\n    * @see saveBytes\n    */\n    p.saveStrings = function(filename, strings) {\n      localStorage[filename] = strings.join('\\n');\n    };\n\n    /**\n    * Reads the contents of a file or url and places it in a byte array. If a file is specified, it must be located in the localStorage.\n    * The filename parameter can also be a URL to a file found online.\n    *\n    * @param {String} filename   name of a file in the localStorage or a URL.\n    *\n    * @returns {byte[]}\n    *\n    * @see loadStrings\n    * @see saveStrings\n    * @see saveBytes\n    */\n    p.loadBytes = function(url) {\n      var string = ajax(url);\n      var ret = [];\n\n      for (var i = 0; i < string.length; i++) {\n        ret.push(string.charCodeAt(i));\n      }\n\n      return ret;\n    };\n\n    ////////////////////////////////////////////////////////////////////////////\n    // String Functions\n    ////////////////////////////////////////////////////////////////////////////\n    /**\n     * The matchAll() function is identical to match(), except that it returns an array of all matches in\n     * the specified String, rather than just the first.\n     *\n     * @param {String} aString  the String to search inside\n     * @param {String} aRegExp  the regexp to be used for matching\n     *\n     * @return {String[]} returns an array of matches\n     *\n     * @see #match\n     */\n    p.matchAll = function(aString, aRegExp) {\n      var results = [],\n          latest;\n      var regexp = new RegExp(aRegExp, \"g\");\n      while ((latest = regexp.exec(aString)) !== null) {\n        results.push(latest);\n        if (latest[0].length === 0) {\n          ++regexp.lastIndex;\n        }\n      }\n      return results.length > 0 ? results : null;\n    };\n    /**\n     * The match() function matches a string with a regular expression, and returns the match as an\n     * array. The first index is the matching expression, and array elements\n     * [1] and higher represent each of the groups (sequences found in parens).\n     *\n     * @param {String} str      the String to be searched\n     * @param {String} regexp   the regexp to be used for matching\n     *\n     * @return {String[]} an array of matching strings\n     */\n    p.match = function(str, regexp) {\n      return str.match(regexp);\n    };\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Other java specific functions\n    ////////////////////////////////////////////////////////////////////////////\n\n\n    var logBuffer = [];\n\n    /**\n     * The println() function writes to the console area of the Processing environment.\n     * Each call to this function creates a new line of output. Individual elements can be separated with quotes (\"\") and joined with the string concatenation operator (+).\n     *\n     * @param {String} message the string to write to the console\n     *\n     * @see #join\n     * @see #print\n     */\n    p.println = function() {\n      Processing.logger.println.apply(Processing.logger, arguments);\n    };\n    /**\n     * The print() function writes to the console area of the Processing environment.\n     *\n     * @param {String} message the string to write to the console\n     *\n     * @see #join\n     */\n    p.print = function() {\n      Processing.logger.print.apply(Processing.logger, arguments);\n    };\n\n    // Alphanumeric chars arguments automatically converted to numbers when\n    // passed in, and will come out as numbers.\n    p.str = function(val) {\n      if (val instanceof Array) {\n        var arr = [];\n        for (var i = 0; i < val.length; i++) {\n          arr.push(val[i].toString() + \"\");\n        }\n        return arr;\n      }\n      return (val.toString() + \"\");\n    };\n\n\n    // Conversion\n    function booleanScalar(val) {\n      if (typeof val === 'number') {\n        return val !== 0;\n      }\n      if (typeof val === 'boolean') {\n        return val;\n      }\n      if (typeof val === 'string') {\n        return val.toLowerCase() === 'true';\n      }\n      if (val instanceof Char) {\n        // 1, T or t\n        return val.code === 49 || val.code === 84 || val.code === 116;\n      }\n    }\n\n    /**\n     * Converts the passed parameter to the function to its boolean value.\n     * It will return an array of booleans if an array is passed in.\n     *\n     * @param {int, byte, string} val          the parameter to be converted to boolean\n     * @param {int[], byte[], string[]} val    the array to be converted to boolean[]\n     *\n     * @return {boolean|boolean[]} returns a boolean or an array of booleans\n     */\n    p.parseBoolean = function (val) {\n      if (val instanceof Array) {\n        var ret = [];\n        for (var i = 0; i < val.length; i++) {\n          ret.push(booleanScalar(val[i]));\n        }\n        return ret;\n      }\n      return booleanScalar(val);\n    };\n\n    /**\n     * Converts the passed parameter to the function to its byte value.\n     * A byte is a number between -128 and 127.\n     * It will return an array of bytes if an array is passed in.\n     *\n     * @param {int, char} what        the parameter to be conveted to byte\n     * @param {int[], char[]} what    the array to be converted to byte[]\n     *\n     * @return {byte|byte[]} returns a byte or an array of bytes\n     */\n    p.parseByte = function(what) {\n      if (what instanceof Array) {\n        var bytes = [];\n        for (var i = 0; i < what.length; i++) {\n          bytes.push((0 - (what[i] & 0x80)) | (what[i] & 0x7F));\n        }\n        return bytes;\n      }\n      return (0 - (what & 0x80)) | (what & 0x7F);\n    };\n\n    /**\n     * Converts the passed parameter to the function to its char value.\n     * It will return an array of chars if an array is passed in.\n     *\n     * @param {int, byte} key        the parameter to be conveted to char\n     * @param {int[], byte[]} key    the array to be converted to char[]\n     *\n     * @return {char|char[]} returns a char or an array of chars\n     */\n    p.parseChar = function(key) {\n      if (typeof key === \"number\") {\n        return new Char(String.fromCharCode(key & 0xFFFF));\n      }\n      if (key instanceof Array) {\n        var ret = [];\n        for (var i = 0; i < key.length; i++) {\n          ret.push(new Char(String.fromCharCode(key[i] & 0xFFFF)));\n        }\n        return ret;\n      }\n      throw \"char() may receive only one argument of type int, byte, int[], or byte[].\";\n    };\n\n    // Processing doc claims good argument types are: int, char, byte, boolean,\n    // String, int[], char[], byte[], boolean[], String[].\n    // floats should not work. However, floats with only zeroes right of the\n    // decimal will work because JS converts those to int.\n    function floatScalar(val) {\n      if (typeof val === 'number') {\n        return val;\n      }\n      if (typeof val === 'boolean') {\n        return val ? 1 : 0;\n      }\n      if (typeof val === 'string') {\n        return parseFloat(val);\n      }\n      if (val instanceof Char) {\n        return val.code;\n      }\n    }\n\n    /**\n     * Converts the passed parameter to the function to its float value.\n     * It will return an array of floats if an array is passed in.\n     *\n     * @param {int, char, boolean, string} val            the parameter to be conveted to float\n     * @param {int[], char[], boolean[], string[]} val    the array to be converted to float[]\n     *\n     * @return {float|float[]} returns a float or an array of floats\n     */\n    p.parseFloat = function(val) {\n      if (val instanceof Array) {\n        var ret = [];\n        for (var i = 0; i < val.length; i++) {\n          ret.push(floatScalar(val[i]));\n        }\n        return ret;\n      }\n      return floatScalar(val);\n    };\n\n    function intScalar(val, radix) {\n      if (typeof val === 'number') {\n        return val & 0xFFFFFFFF;\n      }\n      if (typeof val === 'boolean') {\n        return val ? 1 : 0;\n      }\n      if (typeof val === 'string') {\n        var number = parseInt(val, radix || 10); // Default to decimal radix.\n        return number & 0xFFFFFFFF;\n      }\n      if (val instanceof Char) {\n        return val.code;\n      }\n    }\n\n    /**\n     * Converts the passed parameter to the function to its int value.\n     * It will return an array of ints if an array is passed in.\n     *\n     * @param {string, char, boolean, float} val            the parameter to be conveted to int\n     * @param {string[], char[], boolean[], float[]} val    the array to be converted to int[]\n     * @param {int} radix                                   optional the radix of the number (for js compatibility)\n     *\n     * @return {int|int[]} returns a int or an array of ints\n     */\n    p.parseInt = function(val, radix) {\n      if (val instanceof Array) {\n        var ret = [];\n        for (var i = 0; i < val.length; i++) {\n          if (typeof val[i] === 'string' && !/^\\s*[+\\-]?\\d+\\s*$/.test(val[i])) {\n            ret.push(0);\n          } else {\n            ret.push(intScalar(val[i], radix));\n          }\n        }\n        return ret;\n      }\n      return intScalar(val, radix);\n    };\n\n    p.__int_cast = function(val) {\n      return 0|val;\n    };\n\n    p.__instanceof = function(obj, type) {\n      if (typeof type !== \"function\") {\n        throw \"Function is expected as type argument for instanceof operator\";\n      }\n\n      if (typeof obj === \"string\") {\n        // special case for strings\n        return type === Object || type === String;\n      }\n\n      if (obj instanceof type) {\n        // fast check if obj is already of type instance\n        return true;\n      }\n\n      if (typeof obj !== \"object\" || obj === null) {\n        return false; // not an object or null\n      }\n\n      var objType = obj.constructor;\n      if (type.$isInterface) {\n        // expecting the interface\n        // queueing interfaces from type and its base classes\n        var interfaces = [];\n        while (objType) {\n          if (objType.$interfaces) {\n            interfaces = interfaces.concat(objType.$interfaces);\n          }\n          objType = objType.$base;\n        }\n        while (interfaces.length > 0) {\n          var i = interfaces.shift();\n          if (i === type) {\n            return true;\n          }\n          // wide search in base interfaces\n          if (i.$interfaces) {\n            interfaces = interfaces.concat(i.$interfaces);\n          }\n        }\n        return false;\n      }\n\n      while (objType.hasOwnProperty(\"$base\")) {\n        objType = objType.$base;\n        if (objType === type) {\n          return true; // object was found\n        }\n      }\n\n      return false;\n    };\n\n    /**\n    * Defines the dimension of the display window in units of pixels. The size() function must\n    * be the first line in setup(). If size() is not called, the default size of the window is\n    * 100x100 pixels. The system variables width and height are set by the parameters passed to\n    * the size() function.\n    *\n    * @param {int} aWidth     width of the display window in units of pixels\n    * @param {int} aHeight    height of the display window in units of pixels\n    * @param {MODE} aMode     Either P2D, P3D, JAVA2D, or OPENGL\n    *\n    * @see createGraphics\n    * @see screen\n    */\n    DrawingShared.prototype.size = function(aWidth, aHeight, aMode) {\n      if (doStroke) {\n        p.stroke(0);\n      }\n\n      if (doFill) {\n        p.fill(255);\n      }\n\n      // The default 2d context has already been created in the p.init() stage if\n      // a 3d context was not specified. This is so that a 2d context will be\n      // available if size() was not called.\n      var savedProperties = {\n        fillStyle: curContext.fillStyle,\n        strokeStyle: curContext.strokeStyle,\n        lineCap: curContext.lineCap,\n        lineJoin: curContext.lineJoin\n      };\n      // remove the style width and height properties to ensure that the canvas gets set to\n      // aWidth and aHeight coming in\n      if (curElement.style.length > 0 ) {\n        curElement.style.removeProperty(\"width\");\n        curElement.style.removeProperty(\"height\");\n      }\n\n      curElement.width = p.width = aWidth || 100;\n      curElement.height = p.height = aHeight || 100;\n\n      for (var prop in savedProperties) {\n        if (savedProperties.hasOwnProperty(prop)) {\n          curContext[prop] = savedProperties[prop];\n        }\n      }\n\n      // make sure to set the default font the first time round.\n      p.textFont(curTextFont);\n\n      // Set the background to whatever it was called last as if background() was called before size()\n      // If background() hasn't been called before, set background() to a light gray\n      p.background();\n\n      // set 5% for pixels to cache (or 1000)\n      maxPixelsCached = Math.max(1000, aWidth * aHeight * 0.05);\n\n      // Externalize the context\n      p.externals.context = curContext;\n\n      for (var i = 0; i < PConstants.SINCOS_LENGTH; i++) {\n        sinLUT[i] = p.sin(i * (PConstants.PI / 180) * 0.5);\n        cosLUT[i] = p.cos(i * (PConstants.PI / 180) * 0.5);\n      }\n    };\n\n    Drawing2D.prototype.size = function(aWidth, aHeight, aMode) {\n      if (curContext === undef) {\n        // size() was called without p.init() default context, i.e. p.createGraphics()\n        curContext = curElement.getContext(\"2d\");\n        userMatrixStack = new PMatrixStack();\n        userReverseMatrixStack = new PMatrixStack();\n        modelView = new PMatrix2D();\n        modelViewInv = new PMatrix2D();\n      }\n\n      DrawingShared.prototype.size.apply(this, arguments);\n    };\n\n    Drawing3D.prototype.size = (function() {\n      var size3DCalled = false;\n\n      return function size(aWidth, aHeight, aMode) {\n        if (size3DCalled) {\n          throw \"Multiple calls to size() for 3D renders are not allowed.\";\n        }\n        size3DCalled = true;\n\n        function getGLContext(canvas) {\n          var ctxNames = ['experimental-webgl', 'webgl', 'webkit-3d'],\n              gl;\n\n          for (var i=0, l=ctxNames.length; i<l; i++) {\n            gl = canvas.getContext(ctxNames[i], {antialias: false, preserveDrawingBuffer: true});\n            if (gl) {\n              break;\n            }\n          }\n\n          return gl;\n        }\n\n        // Get the 3D rendering context.\n        try {\n          // If the HTML <canvas> dimensions differ from the\n          // dimensions specified in the size() call in the sketch, for\n          // 3D sketches, browsers will either not render or render the\n          // scene incorrectly. To fix this, we need to adjust the\n          // width and height attributes of the canvas.\n          curElement.width = p.width = aWidth || 100;\n          curElement.height = p.height = aHeight || 100;\n          curContext = getGLContext(curElement);\n          canTex = curContext.createTexture();\n          textTex = curContext.createTexture();\n        } catch(e_size) {\n          Processing.debug(e_size);\n        }\n\n        if (!curContext) {\n          throw \"WebGL context is not supported on this browser.\";\n        }\n\n        // Set defaults\n        curContext.viewport(0, 0, curElement.width, curElement.height);\n        curContext.enable(curContext.DEPTH_TEST);\n        curContext.enable(curContext.BLEND);\n        curContext.blendFunc(curContext.SRC_ALPHA, curContext.ONE_MINUS_SRC_ALPHA);\n\n        // Create the program objects to render 2D (points, lines) and\n        // 3D (spheres, boxes) shapes. Because 2D shapes are not lit,\n        // lighting calculations are ommitted from this program object.\n        programObject2D = createProgramObject(curContext, vertexShaderSrc2D, fragmentShaderSrc2D);\n\n        programObjectUnlitShape = createProgramObject(curContext, vertexShaderSrcUnlitShape, fragmentShaderSrcUnlitShape);\n\n        // Set the default point and line width for the 2D and unlit shapes.\n        p.strokeWeight(1);\n\n        // Now that the programs have been compiled, we can set the default\n        // states for the lights.\n        programObject3D = createProgramObject(curContext, vertexShaderSrc3D, fragmentShaderSrc3D);\n        curContext.useProgram(programObject3D);\n\n        // Assume we aren't using textures by default.\n        uniformi(\"usingTexture3d\", programObject3D, \"usingTexture\", usingTexture);\n\n        // Set some defaults.\n        p.lightFalloff(1, 0, 0);\n        p.shininess(1);\n        p.ambient(255, 255, 255);\n        p.specular(0, 0, 0);\n        p.emissive(0, 0, 0);\n\n        // Create buffers for 3D primitives\n        boxBuffer = curContext.createBuffer();\n        curContext.bindBuffer(curContext.ARRAY_BUFFER, boxBuffer);\n        curContext.bufferData(curContext.ARRAY_BUFFER, boxVerts, curContext.STATIC_DRAW);\n\n        boxNormBuffer = curContext.createBuffer();\n        curContext.bindBuffer(curContext.ARRAY_BUFFER, boxNormBuffer);\n        curContext.bufferData(curContext.ARRAY_BUFFER, boxNorms, curContext.STATIC_DRAW);\n\n        boxOutlineBuffer = curContext.createBuffer();\n        curContext.bindBuffer(curContext.ARRAY_BUFFER, boxOutlineBuffer);\n        curContext.bufferData(curContext.ARRAY_BUFFER, boxOutlineVerts, curContext.STATIC_DRAW);\n\n        // used to draw the rectangle and the outline\n        rectBuffer = curContext.createBuffer();\n        curContext.bindBuffer(curContext.ARRAY_BUFFER, rectBuffer);\n        curContext.bufferData(curContext.ARRAY_BUFFER, rectVerts, curContext.STATIC_DRAW);\n\n        rectNormBuffer = curContext.createBuffer();\n        curContext.bindBuffer(curContext.ARRAY_BUFFER, rectNormBuffer);\n        curContext.bufferData(curContext.ARRAY_BUFFER, rectNorms, curContext.STATIC_DRAW);\n\n        // The sphere vertices are specified dynamically since the user\n        // can change the level of detail. Everytime the user does that\n        // using sphereDetail(), the new vertices are calculated.\n        sphereBuffer = curContext.createBuffer();\n\n        lineBuffer = curContext.createBuffer();\n\n        // Shape buffers\n        fillBuffer = curContext.createBuffer();\n        fillColorBuffer = curContext.createBuffer();\n        strokeColorBuffer = curContext.createBuffer();\n        shapeTexVBO = curContext.createBuffer();\n\n        pointBuffer = curContext.createBuffer();\n        curContext.bindBuffer(curContext.ARRAY_BUFFER, pointBuffer);\n        curContext.bufferData(curContext.ARRAY_BUFFER, new Float32Array([0, 0, 0]), curContext.STATIC_DRAW);\n\n        textBuffer = curContext.createBuffer();\n        curContext.bindBuffer(curContext.ARRAY_BUFFER, textBuffer );\n        curContext.bufferData(curContext.ARRAY_BUFFER, new Float32Array([1,1,0,-1,1,0,-1,-1,0,1,-1,0]), curContext.STATIC_DRAW);\n\n        textureBuffer = curContext.createBuffer();\n        curContext.bindBuffer(curContext.ARRAY_BUFFER, textureBuffer);\n        curContext.bufferData(curContext.ARRAY_BUFFER, new Float32Array([0,0,1,0,1,1,0,1]), curContext.STATIC_DRAW);\n\n        indexBuffer = curContext.createBuffer();\n        curContext.bindBuffer(curContext.ELEMENT_ARRAY_BUFFER, indexBuffer);\n        curContext.bufferData(curContext.ELEMENT_ARRAY_BUFFER, new Uint16Array([0,1,2,2,3,0]), curContext.STATIC_DRAW);\n\n        cam = new PMatrix3D();\n        cameraInv = new PMatrix3D();\n        modelView = new PMatrix3D();\n        modelViewInv = new PMatrix3D();\n        projection = new PMatrix3D();\n        p.camera();\n        p.perspective();\n\n        userMatrixStack = new PMatrixStack();\n        userReverseMatrixStack = new PMatrixStack();\n        // used by both curve and bezier, so just init here\n        curveBasisMatrix = new PMatrix3D();\n        curveToBezierMatrix = new PMatrix3D();\n        curveDrawMatrix = new PMatrix3D();\n        bezierDrawMatrix = new PMatrix3D();\n        bezierBasisInverse = new PMatrix3D();\n        bezierBasisMatrix = new PMatrix3D();\n        bezierBasisMatrix.set(-1, 3, -3, 1, 3, -6, 3, 0, -3, 3, 0, 0, 1, 0, 0, 0);\n\n        DrawingShared.prototype.size.apply(this, arguments);\n      };\n    }());\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Lights\n    ////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * Adds an ambient light. Ambient light doesn't come from a specific direction,\n     * the rays have light have bounced around so much that objects are evenly lit\n     * from all sides. Ambient lights are almost always used in combination with\n     * other types of lights. Lights need to be included in the <b>draw()</b> to\n     * remain persistent in a looping program. Placing them in the <b>setup()</b>\n     * of a looping program will cause them to only have an effect the first time\n     * through the loop. The effect of the parameters is determined by the current\n     * color mode.\n     *\n     * @param {int | float} r red or hue value\n     * @param {int | float} g green or hue value\n     * @param {int | float} b blue or hue value\n     *\n     * @param {int | float} x x position of light (used for falloff)\n     * @param {int | float} y y position of light (used for falloff)\n     * @param {int | float} z z position of light (used for falloff)\n     *\n     * @returns none\n     *\n     * @see lights\n     * @see directionalLight\n     * @see pointLight\n     * @see spotLight\n    */\n    Drawing2D.prototype.ambientLight = DrawingShared.prototype.a3DOnlyFunction;\n\n    Drawing3D.prototype.ambientLight = function(r, g, b, x, y, z) {\n      if (lightCount === PConstants.MAX_LIGHTS) {\n        throw \"can only create \" + PConstants.MAX_LIGHTS + \" lights\";\n      }\n\n      var pos = new PVector(x, y, z);\n      var view = new PMatrix3D();\n      view.scale(1, -1, 1);\n      view.apply(modelView.array());\n      view.mult(pos, pos);\n\n      // Instead of calling p.color, we do the calculations ourselves to\n      // reduce property lookups.\n      var col = color$4(r, g, b, 0);\n      var normalizedCol = [ ((col & PConstants.RED_MASK) >>> 16) / 255,\n                            ((col & PConstants.GREEN_MASK) >>> 8) / 255,\n                             (col & PConstants.BLUE_MASK) / 255 ];\n\n      curContext.useProgram(programObject3D);\n      uniformf(\"uLights.color.3d.\" + lightCount, programObject3D, \"uLights\" + lightCount + \".color\", normalizedCol);\n      uniformf(\"uLights.position.3d.\" + lightCount, programObject3D, \"uLights\" + lightCount + \".position\", pos.array());\n      uniformi(\"uLights.type.3d.\" + lightCount, programObject3D, \"uLights\" + lightCount + \".type\", 0);\n      uniformi(\"uLightCount3d\", programObject3D, \"uLightCount\", ++lightCount);\n    };\n\n    /**\n     * Adds a directional light. Directional light comes from one direction and\n     * is stronger when hitting a surface squarely and weaker if it hits at a\n     * gentle angle. After hitting a surface, a directional lights scatters in\n     * all directions. Lights need to be included in the <b>draw()</b> to remain\n     * persistent in a looping program. Placing them in the <b>setup()</b> of a\n     * looping program will cause them to only have an effect the first time\n     * through the loop. The affect of the <br>r</b>, <br>g</b>, and <br>b</b>\n     * parameters is determined by the current color mode. The <b>nx</b>,\n     * <b>ny</b>, and <b>nz</b> parameters specify the direction the light is\n     * facing. For example, setting <b>ny</b> to -1 will cause the geometry to be\n     * lit from below (the light is facing directly upward).\n     *\n     * @param {int | float} r red or hue value\n     * @param {int | float} g green or hue value\n     * @param {int | float} b blue or hue value\n     *\n     * @param {int | float} nx direction along the x axis\n     * @param {int | float} ny direction along the y axis\n     * @param {int | float} nz direction along the z axis\n     *\n     * @returns none\n     *\n     * @see lights\n     * @see ambientLight\n     * @see pointLight\n     * @see spotLight\n    */\n    Drawing2D.prototype.directionalLight = DrawingShared.prototype.a3DOnlyFunction;\n\n    Drawing3D.prototype.directionalLight = function(r, g, b, nx, ny, nz) {\n      if (lightCount === PConstants.MAX_LIGHTS) {\n        throw \"can only create \" + PConstants.MAX_LIGHTS + \" lights\";\n      }\n\n      curContext.useProgram(programObject3D);\n\n      var mvm = new PMatrix3D();\n      mvm.scale(1, -1, 1);\n      mvm.apply(modelView.array());\n      mvm = mvm.array();\n\n      // We need to multiply the direction by the model view matrix, but\n      // the mult function checks the w component of the vector, if it isn't\n      // present, it uses 1, so we manually multiply.\n      var dir = [\n        mvm[0] * nx + mvm[4] * ny + mvm[8] * nz,\n        mvm[1] * nx + mvm[5] * ny + mvm[9] * nz,\n        mvm[2] * nx + mvm[6] * ny + mvm[10] * nz\n      ];\n\n      // Instead of calling p.color, we do the calculations ourselves to\n      // reduce property lookups.\n      var col = color$4(r, g, b, 0);\n      var normalizedCol = [ ((col & PConstants.RED_MASK) >>> 16) / 255,\n                            ((col & PConstants.GREEN_MASK) >>> 8) / 255,\n                             (col & PConstants.BLUE_MASK) / 255 ];\n\n      uniformf(\"uLights.color.3d.\" + lightCount, programObject3D, \"uLights\" + lightCount + \".color\", normalizedCol);\n      uniformf(\"uLights.position.3d.\" + lightCount, programObject3D, \"uLights\" + lightCount + \".position\", dir);\n      uniformi(\"uLights.type.3d.\" + lightCount, programObject3D, \"uLights\" + lightCount + \".type\", 1);\n      uniformi(\"uLightCount3d\", programObject3D, \"uLightCount\", ++lightCount);\n    };\n\n    /**\n     * Sets the falloff rates for point lights, spot lights, and ambient lights.\n     * The parameters are used to determine the falloff with the following equation:\n     *\n     * d = distance from light position to vertex position\n     * falloff = 1 / (CONSTANT + d * LINEAR + (d*d) * QUADRATIC)\n     *\n     * Like <b>fill()</b>, it affects only the elements which are created after it in the\n     * code. The default value if <b>LightFalloff(1.0, 0.0, 0.0)</b>. Thinking about an\n     * ambient light with a falloff can be tricky. It is used, for example, if you\n     * wanted a region of your scene to be lit ambiently one color and another region\n     * to be lit ambiently by another color, you would use an ambient light with location\n     * and falloff. You can think of it as a point light that doesn't care which direction\n     * a surface is facing.\n     *\n     * @param {int | float} constant constant value for determining falloff\n     * @param {int | float} linear linear value for determining falloff\n     * @param {int | float} quadratic quadratic value for determining falloff\n     *\n     * @returns none\n     *\n     * @see lights\n     * @see ambientLight\n     * @see pointLight\n     * @see spotLight\n     * @see lightSpecular\n    */\n    Drawing2D.prototype.lightFalloff = DrawingShared.prototype.a3DOnlyFunction;\n\n    Drawing3D.prototype.lightFalloff = function(constant, linear, quadratic) {\n      curContext.useProgram(programObject3D);\n      uniformf(\"uFalloff3d\", programObject3D, \"uFalloff\", [constant, linear, quadratic]);\n    };\n\n    /**\n     * Sets the specular color for lights. Like <b>fill()</b>, it affects only the\n     * elements which are created after it in the code. Specular refers to light\n     * which bounces off a surface in a perferred direction (rather than bouncing\n     * in all directions like a diffuse light) and is used for creating highlights.\n     * The specular quality of a light interacts with the specular material qualities\n     * set through the <b>specular()</b> and <b>shininess()</b> functions.\n     *\n     * @param {int | float} r red or hue value\n     * @param {int | float} g green or hue value\n     * @param {int | float} b blue or hue value\n     *\n     * @returns none\n     *\n     * @see lights\n     * @see ambientLight\n     * @see pointLight\n     * @see spotLight\n    */\n    Drawing2D.prototype.lightSpecular = DrawingShared.prototype.a3DOnlyFunction;\n\n    Drawing3D.prototype.lightSpecular = function(r, g, b) {\n\n      // Instead of calling p.color, we do the calculations ourselves to\n      // reduce property lookups.\n      var col = color$4(r, g, b, 0);\n      var normalizedCol = [ ((col & PConstants.RED_MASK) >>> 16) / 255,\n                            ((col & PConstants.GREEN_MASK) >>> 8) / 255,\n                             (col & PConstants.BLUE_MASK) / 255 ];\n\n      curContext.useProgram(programObject3D);\n      uniformf(\"uSpecular3d\", programObject3D, \"uSpecular\", normalizedCol);\n    };\n\n    /**\n     * Sets the default ambient light, directional light, falloff, and specular\n     * values. The defaults are ambientLight(128, 128, 128) and\n     * directionalLight(128, 128, 128, 0, 0, -1), lightFalloff(1, 0, 0), and\n     * lightSpecular(0, 0, 0). Lights need to be included in the draw() to remain\n     * persistent in a looping program. Placing them in the setup() of a looping\n     * program will cause them to only have an effect the first time through the\n     * loop.\n     *\n     * @returns none\n     *\n     * @see ambientLight\n     * @see directionalLight\n     * @see pointLight\n     * @see spotLight\n     * @see noLights\n     *\n    */\n    p.lights = function() {\n      p.ambientLight(128, 128, 128);\n      p.directionalLight(128, 128, 128, 0, 0, -1);\n      p.lightFalloff(1, 0, 0);\n      p.lightSpecular(0, 0, 0);\n    };\n\n    /**\n     * Adds a point light. Lights need to be included in the <b>draw()</b> to remain\n     * persistent in a looping program. Placing them in the <b>setup()</b> of a\n     * looping program will cause them to only have an effect the first time through\n     * the loop. The affect of the <b>r</b>, <b>g</b>, and <b>b</b> parameters\n     * is determined by the current color mode. The <b>x</b>, <b>y</b>, and <b>z</b>\n     * parameters set the position of the light.\n     *\n     * @param {int | float} r red or hue value\n     * @param {int | float} g green or hue value\n     * @param {int | float} b blue or hue value\n     * @param {int | float} x x coordinate of the light\n     * @param {int | float} y y coordinate of the light\n     * @param {int | float} z z coordinate of the light\n     *\n     * @returns none\n     *\n     * @see lights\n     * @see directionalLight\n     * @see ambientLight\n     * @see spotLight\n    */\n    Drawing2D.prototype.pointLight = DrawingShared.prototype.a3DOnlyFunction;\n\n    Drawing3D.prototype.pointLight = function(r, g, b, x, y, z) {\n      if (lightCount === PConstants.MAX_LIGHTS) {\n        throw \"can only create \" + PConstants.MAX_LIGHTS + \" lights\";\n      }\n\n      // Place the point in view space once instead of once per vertex\n      // in the shader.\n      var pos = new PVector(x, y, z);\n      var view = new PMatrix3D();\n      view.scale(1, -1, 1);\n      view.apply(modelView.array());\n      view.mult(pos, pos);\n\n      // Instead of calling p.color, we do the calculations ourselves to\n      // reduce property lookups.\n      var col = color$4(r, g, b, 0);\n      var normalizedCol = [ ((col & PConstants.RED_MASK) >>> 16) / 255,\n                            ((col & PConstants.GREEN_MASK) >>> 8) / 255,\n                             (col & PConstants.BLUE_MASK) / 255 ];\n\n      curContext.useProgram(programObject3D);\n      uniformf(\"uLights.color.3d.\" + lightCount, programObject3D, \"uLights\" + lightCount + \".color\", normalizedCol);\n      uniformf(\"uLights.position.3d.\" + lightCount, programObject3D, \"uLights\" + lightCount + \".position\", pos.array());\n      uniformi(\"uLights.type.3d.\" + lightCount, programObject3D, \"uLights\" + lightCount + \".type\", 2);\n      uniformi(\"uLightCount3d\", programObject3D, \"uLightCount\", ++lightCount);\n    };\n\n    /**\n     * Disable all lighting. Lighting is turned off by default and enabled with\n     * the lights() method. This function can be used to disable lighting so\n     * that 2D geometry (which does not require lighting) can be drawn after a\n     * set of lighted 3D geometry.\n     *\n     * @returns none\n     *\n     * @see lights\n    */\n    Drawing2D.prototype.noLights = DrawingShared.prototype.a3DOnlyFunction;\n\n    Drawing3D.prototype.noLights = function() {\n      lightCount = 0;\n      curContext.useProgram(programObject3D);\n      uniformi(\"uLightCount3d\", programObject3D, \"uLightCount\", lightCount);\n    };\n\n    /**\n     * Adds a spot light. Lights need to be included in the <b>draw()</b> to\n     * remain persistent in a looping program. Placing them in the <b>setup()</b>\n     * of a looping program will cause them to only have an effect the first time\n     * through the loop. The affect of the <b>r</b>, <b>g</b>, and <b>b</b> parameters\n     * is determined by the current color mode. The <b>x</b>, <b>y</b>, and <b>z</b>\n     * parameters specify the position of the light and <b>nx</b>, <b>ny</b>, <b>nz</b>\n     * specify the direction or light. The angle parameter affects <b>angle</b> of the\n     * spotlight cone.\n     *\n     * @param {int | float} r red or hue value\n     * @param {int | float} g green or hue value\n     * @param {int | float} b blue or hue value\n     * @param {int | float} x coordinate of the light\n     * @param {int | float} y coordinate of the light\n     * @param {int | float} z coordinate of the light\n     * @param {int | float} nx direction along the x axis\n     * @param {int | float} ny direction along the y axis\n     * @param {int | float} nz direction along the z axis\n     * @param {float} angle angle of the spotlight cone\n     * @param {float} concentration exponent determining the center bias of the cone\n     *\n     * @returns none\n     *\n     * @see lights\n     * @see directionalLight\n     * @see ambientLight\n     * @see pointLight\n    */\n    Drawing2D.prototype.spotLight = DrawingShared.prototype.a3DOnlyFunction;\n\n    Drawing3D.prototype.spotLight = function(r, g, b, x, y, z, nx, ny, nz, angle, concentration) {\n      if (lightCount === PConstants.MAX_LIGHTS) {\n        throw \"can only create \" + PConstants.MAX_LIGHTS + \" lights\";\n      }\n\n      curContext.useProgram(programObject3D);\n\n      // multiply the position and direction by the model view matrix\n      // once per object rather than once per vertex.\n      var pos = new PVector(x, y, z);\n      var mvm = new PMatrix3D();\n      mvm.scale(1, -1, 1);\n      mvm.apply(modelView.array());\n      mvm.mult(pos, pos);\n\n      // Convert to array since we need to directly access the elements.\n      mvm = mvm.array();\n\n      // We need to multiply the direction by the model view matrix, but\n      // the mult function checks the w component of the vector, if it isn't\n      // present, it uses 1, so we use a very small value as a work around.\n      var dir = [\n          mvm[0] * nx + mvm[4] * ny + mvm[8] * nz,\n          mvm[1] * nx + mvm[5] * ny + mvm[9] * nz,\n          mvm[2] * nx + mvm[6] * ny + mvm[10] * nz\n      ];\n\n      // Instead of calling p.color, we do the calculations ourselves to\n      // reduce property lookups.\n      var col = color$4(r, g, b, 0);\n      var normalizedCol = [ ((col & PConstants.RED_MASK) >>> 16) / 255,\n                            ((col & PConstants.GREEN_MASK) >>> 8) / 255,\n                             (col & PConstants.BLUE_MASK) / 255 ];\n\n      uniformf(\"uLights.color.3d.\" + lightCount, programObject3D, \"uLights\" + lightCount + \".color\", normalizedCol);\n      uniformf(\"uLights.position.3d.\" + lightCount, programObject3D, \"uLights\" + lightCount + \".position\", pos.array());\n      uniformf(\"uLights.direction.3d.\" + lightCount, programObject3D, \"uLights\" + lightCount + \".direction\", dir);\n      uniformf(\"uLights.concentration.3d.\" + lightCount, programObject3D, \"uLights\" + lightCount + \".concentration\", concentration);\n      uniformf(\"uLights.angle.3d.\" + lightCount, programObject3D, \"uLights\" + lightCount + \".angle\", angle);\n      uniformi(\"uLights.type.3d.\" + lightCount, programObject3D, \"uLights\" + lightCount + \".type\", 3);\n      uniformi(\"uLightCount3d\", programObject3D, \"uLightCount\", ++lightCount);\n    };\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Camera functions\n    ////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * The <b>beginCamera()</b> and <b>endCamera()</b> functions enable advanced customization of the camera space.\n     * The functions are useful if you want to more control over camera movement, however for most users, the <b>camera()</b>\n     * function will be sufficient.<br /><br />The camera functions will replace any transformations (such as <b>rotate()</b>\n     * or <b>translate()</b>) that occur before them in <b>draw()</b>, but they will not automatically replace the camera\n     * transform itself. For this reason, camera functions should be placed at the beginning of <b>draw()</b> (so that\n     * transformations happen afterwards), and the <b>camera()</b> function can be used after <b>beginCamera()</b> if\n     * you want to reset the camera before applying transformations.<br /><br />This function sets the matrix mode to the\n     * camera matrix so calls such as <b>translate()</b>, <b>rotate()</b>, applyMatrix() and resetMatrix() affect the camera.\n     * <b>beginCamera()</b> should always be used with a following <b>endCamera()</b> and pairs of <b>beginCamera()</b> and\n     * <b>endCamera()</b> cannot be nested.\n     *\n     * @see camera\n     * @see endCamera\n     * @see applyMatrix\n     * @see resetMatrix\n     * @see translate\n     * @see rotate\n     * @see scale\n     */\n    Drawing2D.prototype.beginCamera = function() {\n      throw (\"beginCamera() is not available in 2D mode\");\n    };\n\n    Drawing3D.prototype.beginCamera = function() {\n      if (manipulatingCamera) {\n        throw (\"You cannot call beginCamera() again before calling endCamera()\");\n      }\n      manipulatingCamera = true;\n      modelView = cameraInv;\n      modelViewInv = cam;\n    };\n\n    /**\n     * The <b>beginCamera()</b> and <b>endCamera()</b> functions enable advanced customization of the camera space.\n     * Please see the reference for <b>beginCamera()</b> for a description of how the functions are used.\n     *\n     * @see beginCamera\n     */\n    Drawing2D.prototype.endCamera = function() {\n      throw (\"endCamera() is not available in 2D mode\");\n    };\n\n    Drawing3D.prototype.endCamera = function() {\n      if (!manipulatingCamera) {\n        throw (\"You cannot call endCamera() before calling beginCamera()\");\n      }\n      modelView.set(cam);\n      modelViewInv.set(cameraInv);\n      manipulatingCamera = false;\n    };\n\n    /**\n     * Sets the position of the camera through setting the eye position, the center of the scene, and which axis is facing\n     * upward. Moving the eye position and the direction it is pointing (the center of the scene) allows the images to be\n     * seen from different angles. The version without any parameters sets the camera to the default position, pointing to\n     * the center of the display window with the Y axis as up. The default values are camera(width/2.0, height/2.0,\n     * (height/2.0) / tan(PI*60.0 / 360.0), width/2.0, height/2.0, 0, 0, 1, 0). This function is similar to gluLookAt()\n     * in OpenGL, but it first clears the current camera settings.\n     *\n     * @param {float} eyeX    x-coordinate for the eye\n     * @param {float} eyeY    y-coordinate for the eye\n     * @param {float} eyeZ    z-coordinate for the eye\n     * @param {float} centerX x-coordinate for the center of the scene\n     * @param {float} centerY y-coordinate for the center of the scene\n     * @param {float} centerZ z-coordinate for the center of the scene\n     * @param {float} upX     usually 0.0, 1.0, -1.0\n     * @param {float} upY     usually 0.0, 1.0, -1.0\n     * @param {float} upZ     usually 0.0, 1.0, -1.0\n     *\n     * @see beginCamera\n     * @see endCamera\n     * @see frustum\n     */\n    p.camera = function(eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ) {\n      if (eyeX === undef) {\n        // Workaround if createGraphics is used.\n        cameraX = p.width / 2;\n        cameraY = p.height / 2;\n        cameraZ = cameraY / Math.tan(cameraFOV / 2);\n        eyeX = cameraX;\n        eyeY = cameraY;\n        eyeZ = cameraZ;\n        centerX = cameraX;\n        centerY = cameraY;\n        centerZ = 0;\n        upX = 0;\n        upY = 1;\n        upZ = 0;\n      }\n\n      var z = new PVector(eyeX - centerX, eyeY - centerY, eyeZ - centerZ);\n      var y = new PVector(upX, upY, upZ);\n      z.normalize();\n      var x = PVector.cross(y, z);\n      y = PVector.cross(z, x);\n      x.normalize();\n      y.normalize();\n\n      var xX = x.x,\n          xY = x.y,\n          xZ = x.z;\n\n      var yX = y.x,\n          yY = y.y,\n          yZ = y.z;\n\n      var zX = z.x,\n          zY = z.y,\n          zZ = z.z;\n\n      cam.set(xX, xY, xZ, 0, yX, yY, yZ, 0, zX, zY, zZ, 0, 0, 0, 0, 1);\n\n      cam.translate(-eyeX, -eyeY, -eyeZ);\n\n      cameraInv.reset();\n      cameraInv.invApply(xX, xY, xZ, 0, yX, yY, yZ, 0, zX, zY, zZ, 0, 0, 0, 0, 1);\n\n      cameraInv.translate(eyeX, eyeY, eyeZ);\n\n      modelView.set(cam);\n      modelViewInv.set(cameraInv);\n    };\n\n    /**\n     * Sets a perspective projection applying foreshortening, making distant objects appear smaller than closer ones. The\n     * parameters define a viewing volume with the shape of truncated pyramid. Objects near to the front of the volume appear\n     * their actual size, while farther objects appear smaller. This projection simulates the perspective of the world more\n     * accurately than orthographic projection. The version of perspective without parameters sets the default perspective and\n     * the version with four parameters allows the programmer to set the area precisely. The default values are:\n     * perspective(PI/3.0, width/height, cameraZ/10.0, cameraZ*10.0) where cameraZ is ((height/2.0) / tan(PI*60.0/360.0));\n     *\n     * @param {float} fov     field-of-view angle (in radians) for vertical direction\n     * @param {float} aspect  ratio of width to height\n     * @param {float} zNear   z-position of nearest clipping plane\n     * @param {float} zFar    z-positions of farthest clipping plane\n     */\n    p.perspective = function(fov, aspect, near, far) {\n      if (arguments.length === 0) {\n        //in case canvas is resized\n        cameraY = curElement.height / 2;\n        cameraZ = cameraY / Math.tan(cameraFOV / 2);\n        cameraNear = cameraZ / 10;\n        cameraFar = cameraZ * 10;\n        cameraAspect = p.width / p.height;\n        fov = cameraFOV;\n        aspect = cameraAspect;\n        near = cameraNear;\n        far = cameraFar;\n      }\n\n      var yMax, yMin, xMax, xMin;\n      yMax = near * Math.tan(fov / 2);\n      yMin = -yMax;\n      xMax = yMax * aspect;\n      xMin = yMin * aspect;\n      p.frustum(xMin, xMax, yMin, yMax, near, far);\n    };\n\n    /**\n     * Sets a perspective matrix defined through the parameters. Works like glFrustum, except it wipes out the current\n     * perspective matrix rather than muliplying itself with it.\n     *\n     * @param {float} left   left coordinate of the clipping plane\n     * @param {float} right  right coordinate of the clipping plane\n     * @param {float} bottom bottom coordinate of the clipping plane\n     * @param {float} top    top coordinate of the clipping plane\n     * @param {float} near   near coordinate of the clipping plane\n     * @param {float} far    far coordinate of the clipping plane\n     *\n     * @see beginCamera\n     * @see camera\n     * @see endCamera\n     * @see perspective\n     */\n    Drawing2D.prototype.frustum = function() {\n      throw(\"Processing.js: frustum() is not supported in 2D mode\");\n    };\n\n    Drawing3D.prototype.frustum = function(left, right, bottom, top, near, far) {\n      frustumMode = true;\n      projection = new PMatrix3D();\n      projection.set((2 * near) / (right - left), 0, (right + left) / (right - left),\n                     0, 0, (2 * near) / (top - bottom), (top + bottom) / (top - bottom),\n                     0, 0, 0, -(far + near) / (far - near), -(2 * far * near) / (far - near),\n                     0, 0, -1, 0);\n      var proj = new PMatrix3D();\n      proj.set(projection);\n      proj.transpose();\n      curContext.useProgram(programObject2D);\n      uniformMatrix(\"projection2d\", programObject2D, \"uProjection\", false, proj.array());\n      curContext.useProgram(programObject3D);\n      uniformMatrix(\"projection3d\", programObject3D, \"uProjection\", false, proj.array());\n      curContext.useProgram(programObjectUnlitShape);\n      uniformMatrix(\"uProjectionUS\", programObjectUnlitShape, \"uProjection\", false, proj.array());\n    };\n\n    /**\n     * Sets an orthographic projection and defines a parallel clipping volume. All objects with the same dimension appear\n     * the same size, regardless of whether they are near or far from the camera. The parameters to this function specify\n     * the clipping volume where left and right are the minimum and maximum x values, top and bottom are the minimum and\n     * maximum y values, and near and far are the minimum and maximum z values. If no parameters are given, the default\n     * is used: ortho(0, width, 0, height, -10, 10).\n     *\n     * @param {float} left   left plane of the clipping volume\n     * @param {float} right  right plane of the clipping volume\n     * @param {float} bottom bottom plane of the clipping volume\n     * @param {float} top    top plane of the clipping volume\n     * @param {float} near   maximum distance from the origin to the viewer\n     * @param {float} far    maximum distance from the origin away from the viewer\n     */\n    p.ortho = function(left, right, bottom, top, near, far) {\n      if (arguments.length === 0) {\n        left = 0;\n        right = p.width;\n        bottom = 0;\n        top = p.height;\n        near = -10;\n        far = 10;\n      }\n\n      var x = 2 / (right - left);\n      var y = 2 / (top - bottom);\n      var z = -2 / (far - near);\n\n      var tx = -(right + left) / (right - left);\n      var ty = -(top + bottom) / (top - bottom);\n      var tz = -(far + near) / (far - near);\n\n      projection = new PMatrix3D();\n      projection.set(x, 0, 0, tx, 0, y, 0, ty, 0, 0, z, tz, 0, 0, 0, 1);\n\n      var proj = new PMatrix3D();\n      proj.set(projection);\n      proj.transpose();\n      curContext.useProgram(programObject2D);\n      uniformMatrix(\"projection2d\", programObject2D, \"uProjection\", false, proj.array());\n      curContext.useProgram(programObject3D);\n      uniformMatrix(\"projection3d\", programObject3D, \"uProjection\", false, proj.array());\n      curContext.useProgram(programObjectUnlitShape);\n      uniformMatrix(\"uProjectionUS\", programObjectUnlitShape, \"uProjection\", false, proj.array());\n      frustumMode = false;\n    };\n    /**\n     * The printProjection() prints the current projection matrix to the text window.\n     */\n    p.printProjection = function() {\n      projection.print();\n    };\n    /**\n     * The printCamera() function prints the current camera matrix.\n     */\n    p.printCamera = function() {\n      cam.print();\n    };\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Shapes\n    ////////////////////////////////////////////////////////////////////////////\n    /**\n     * The box() function renders a box. A box is an extruded rectangle. A box with equal dimension on all sides is a cube.\n     * Calling this function with only one parameter will create a cube.\n     *\n     * @param {int|float} w  dimension of the box in the x-dimension\n     * @param {int|float} h  dimension of the box in the y-dimension\n     * @param {int|float} d  dimension of the box in the z-dimension\n     */\n    Drawing2D.prototype.box = DrawingShared.prototype.a3DOnlyFunction;\n\n    Drawing3D.prototype.box = function(w, h, d) {\n      // user can uniformly scale the box by\n      // passing in only one argument.\n      if (!h || !d) {\n        h = d = w;\n      }\n\n      // Modeling transformation\n      var model = new PMatrix3D();\n      model.scale(w, h, d);\n\n      // Viewing transformation needs to have Y flipped\n      // becuase that's what Processing does.\n      var view = new PMatrix3D();\n      view.scale(1, -1, 1);\n      view.apply(modelView.array());\n      view.transpose();\n\n      if (doFill) {\n        curContext.useProgram(programObject3D);\n        uniformMatrix(\"model3d\", programObject3D, \"uModel\", false, model.array());\n        uniformMatrix(\"view3d\", programObject3D, \"uView\", false, view.array());\n        // Fix stitching problems. (lines get occluded by triangles\n        // since they share the same depth values). This is not entirely\n        // working, but it's a start for drawing the outline. So\n        // developers can start playing around with styles.\n        curContext.enable(curContext.POLYGON_OFFSET_FILL);\n        curContext.polygonOffset(1, 1);\n        uniformf(\"color3d\", programObject3D, \"uColor\", fillStyle);\n\n        // Calculating the normal matrix can be expensive, so only\n        // do it if it's necessary.\n        if(lightCount > 0){\n          // Create the normal transformation matrix.\n          var v = new PMatrix3D();\n          v.set(view);\n\n          var m = new PMatrix3D();\n          m.set(model);\n\n          v.mult(m);\n\n          var normalMatrix = new PMatrix3D();\n          normalMatrix.set(v);\n          normalMatrix.invert();\n          normalMatrix.transpose();\n\n          uniformMatrix(\"uNormalTransform3d\", programObject3D, \"uNormalTransform\", false, normalMatrix.array());\n          vertexAttribPointer(\"aNormal3d\", programObject3D, \"aNormal\", 3, boxNormBuffer);\n        }\n        else{\n          disableVertexAttribPointer(\"aNormal3d\", programObject3D, \"aNormal\");\n        }\n\n        vertexAttribPointer(\"aVertex3d\", programObject3D, \"aVertex\", 3, boxBuffer);\n\n        // Turn off per vertex colors.\n        disableVertexAttribPointer(\"aColor3d\", programObject3D, \"aColor\");\n        disableVertexAttribPointer(\"aTexture3d\", programObject3D, \"aTexture\");\n\n        curContext.drawArrays(curContext.TRIANGLES, 0, boxVerts.length / 3);\n        curContext.disable(curContext.POLYGON_OFFSET_FILL);\n      }\n\n      // Draw the box outline.\n      if (lineWidth > 0 && doStroke) {\n        curContext.useProgram(programObject2D);\n        uniformMatrix(\"uModel2d\", programObject2D, \"uModel\", false, model.array());\n        uniformMatrix(\"uView2d\", programObject2D, \"uView\", false, view.array());\n        uniformf(\"uColor2d\", programObject2D, \"uColor\", strokeStyle);\n        uniformi(\"uIsDrawingText2d\", programObject2D, \"uIsDrawingText\", false);\n        vertexAttribPointer(\"vertex2d\", programObject2D, \"aVertex\", 3, boxOutlineBuffer);\n        disableVertexAttribPointer(\"aTextureCoord2d\", programObject2D, \"aTextureCoord\");\n        curContext.drawArrays(curContext.LINES, 0, boxOutlineVerts.length / 3);\n      }\n    };\n\n    /**\n     * The initSphere() function is a helper function used by <b>sphereDetail()</b>\n     * This function creates and stores sphere vertices every time the user changes sphere detail.\n     *\n     * @see #sphereDetail\n     */\n    var initSphere = function() {\n      var i;\n      sphereVerts = [];\n\n      for (i = 0; i < sphereDetailU; i++) {\n        sphereVerts.push(0);\n        sphereVerts.push(-1);\n        sphereVerts.push(0);\n        sphereVerts.push(sphereX[i]);\n        sphereVerts.push(sphereY[i]);\n        sphereVerts.push(sphereZ[i]);\n      }\n      sphereVerts.push(0);\n      sphereVerts.push(-1);\n      sphereVerts.push(0);\n      sphereVerts.push(sphereX[0]);\n      sphereVerts.push(sphereY[0]);\n      sphereVerts.push(sphereZ[0]);\n\n      var v1, v11, v2;\n\n      // middle rings\n      var voff = 0;\n      for (i = 2; i < sphereDetailV; i++) {\n        v1 = v11 = voff;\n        voff += sphereDetailU;\n        v2 = voff;\n        for (var j = 0; j < sphereDetailU; j++) {\n          sphereVerts.push(sphereX[v1]);\n          sphereVerts.push(sphereY[v1]);\n          sphereVerts.push(sphereZ[v1++]);\n          sphereVerts.push(sphereX[v2]);\n          sphereVerts.push(sphereY[v2]);\n          sphereVerts.push(sphereZ[v2++]);\n        }\n\n        // close each ring\n        v1 = v11;\n        v2 = voff;\n\n        sphereVerts.push(sphereX[v1]);\n        sphereVerts.push(sphereY[v1]);\n        sphereVerts.push(sphereZ[v1]);\n        sphereVerts.push(sphereX[v2]);\n        sphereVerts.push(sphereY[v2]);\n        sphereVerts.push(sphereZ[v2]);\n      }\n\n      // add the northern cap\n      for (i = 0; i < sphereDetailU; i++) {\n        v2 = voff + i;\n\n        sphereVerts.push(sphereX[v2]);\n        sphereVerts.push(sphereY[v2]);\n        sphereVerts.push(sphereZ[v2]);\n        sphereVerts.push(0);\n        sphereVerts.push(1);\n        sphereVerts.push(0);\n      }\n\n      sphereVerts.push(sphereX[voff]);\n      sphereVerts.push(sphereY[voff]);\n      sphereVerts.push(sphereZ[voff]);\n      sphereVerts.push(0);\n      sphereVerts.push(1);\n      sphereVerts.push(0);\n\n      //set the buffer data\n      curContext.bindBuffer(curContext.ARRAY_BUFFER, sphereBuffer);\n      curContext.bufferData(curContext.ARRAY_BUFFER, new Float32Array(sphereVerts), curContext.STATIC_DRAW);\n    };\n\n    /**\n     * The sphereDetail() function controls the detail used to render a sphere by adjusting the number of\n     * vertices of the sphere mesh. The default resolution is 30, which creates\n     * a fairly detailed sphere definition with vertices every 360/30 = 12\n     * degrees. If you're going to render a great number of spheres per frame,\n     * it is advised to reduce the level of detail using this function.\n     * The setting stays active until <b>sphereDetail()</b> is called again with\n     * a new parameter and so should <i>not</i> be called prior to every\n     * <b>sphere()</b> statement, unless you wish to render spheres with\n     * different settings, e.g. using less detail for smaller spheres or ones\n     * further away from the camera. To control the detail of the horizontal\n     * and vertical resolution independently, use the version of the functions\n     * with two parameters. Calling this function with one parameter sets the number of segments\n     *(minimum of 3) used per full circle revolution. This is equivalent to calling the function with\n     * two identical values.\n     *\n     * @param {int} ures    number of segments used horizontally (longitudinally) per full circle revolution\n     * @param {int} vres    number of segments used vertically (latitudinally) from top to bottom\n     *\n     * @see #sphere()\n     */\n    p.sphereDetail = function(ures, vres) {\n      var i;\n\n      if (arguments.length === 1) {\n        ures = vres = arguments[0];\n      }\n\n      if (ures < 3) {\n        ures = 3;\n      } // force a minimum res\n      if (vres < 2) {\n        vres = 2;\n      } // force a minimum res\n      // if it hasn't changed do nothing\n      if ((ures === sphereDetailU) && (vres === sphereDetailV)) {\n        return;\n      }\n\n      var delta = PConstants.SINCOS_LENGTH / ures;\n      var cx = new Float32Array(ures);\n      var cz = new Float32Array(ures);\n      // calc unit circle in XZ plane\n      for (i = 0; i < ures; i++) {\n        cx[i] = cosLUT[((i * delta) % PConstants.SINCOS_LENGTH) | 0];\n        cz[i] = sinLUT[((i * delta) % PConstants.SINCOS_LENGTH) | 0];\n      }\n\n      // computing vertexlist\n      // vertexlist starts at south pole\n      var vertCount = ures * (vres - 1) + 2;\n      var currVert = 0;\n\n      // re-init arrays to store vertices\n      sphereX = new Float32Array(vertCount);\n      sphereY = new Float32Array(vertCount);\n      sphereZ = new Float32Array(vertCount);\n\n      var angle_step = (PConstants.SINCOS_LENGTH * 0.5) / vres;\n      var angle = angle_step;\n\n      // step along Y axis\n      for (i = 1; i < vres; i++) {\n        var curradius = sinLUT[(angle % PConstants.SINCOS_LENGTH) | 0];\n        var currY = -cosLUT[(angle % PConstants.SINCOS_LENGTH) | 0];\n        for (var j = 0; j < ures; j++) {\n          sphereX[currVert] = cx[j] * curradius;\n          sphereY[currVert] = currY;\n          sphereZ[currVert++] = cz[j] * curradius;\n        }\n        angle += angle_step;\n      }\n      sphereDetailU = ures;\n      sphereDetailV = vres;\n\n      // make the sphere verts and norms\n      initSphere();\n    };\n\n    /**\n     * The sphere() function draws a sphere with radius r centered at coordinate 0, 0, 0.\n     * A sphere is a hollow ball made from tessellated triangles.\n     *\n     * @param {int|float} r the radius of the sphere\n     */\n    Drawing2D.prototype.sphere = DrawingShared.prototype.a3DOnlyFunction;\n\n    Drawing3D.prototype.sphere = function() {\n      var sRad = arguments[0];\n\n      if ((sphereDetailU < 3) || (sphereDetailV < 2)) {\n        p.sphereDetail(30);\n      }\n\n      // Modeling transformation.\n      var model = new PMatrix3D();\n      model.scale(sRad, sRad, sRad);\n\n      // viewing transformation needs to have Y flipped\n      // becuase that's what Processing does.\n      var view = new PMatrix3D();\n      view.scale(1, -1, 1);\n      view.apply(modelView.array());\n      view.transpose();\n\n      if (doFill) {\n        // Calculating the normal matrix can be expensive, so only\n        // do it if it's necessary.\n        if(lightCount > 0){\n          // Create a normal transformation matrix.\n          var v = new PMatrix3D();\n          v.set(view);\n\n          var m = new PMatrix3D();\n          m.set(model);\n\n          v.mult(m);\n\n          var normalMatrix = new PMatrix3D();\n          normalMatrix.set(v);\n          normalMatrix.invert();\n          normalMatrix.transpose();\n\n          uniformMatrix(\"uNormalTransform3d\", programObject3D, \"uNormalTransform\", false, normalMatrix.array());\n          vertexAttribPointer(\"aNormal3d\", programObject3D, \"aNormal\", 3, sphereBuffer);\n        }\n        else{\n          disableVertexAttribPointer(\"aNormal3d\", programObject3D, \"aNormal\");\n        }\n\n        curContext.useProgram(programObject3D);\n        disableVertexAttribPointer(\"aTexture3d\", programObject3D, \"aTexture\");\n\n        uniformMatrix(\"uModel3d\", programObject3D, \"uModel\", false, model.array());\n        uniformMatrix(\"uView3d\", programObject3D, \"uView\", false, view.array());\n        vertexAttribPointer(\"aVertex3d\", programObject3D, \"aVertex\", 3, sphereBuffer);\n\n        // Turn off per vertex colors.\n        disableVertexAttribPointer(\"aColor3d\", programObject3D, \"aColor\");\n\n        // fix stitching problems. (lines get occluded by triangles\n        // since they share the same depth values). This is not entirely\n        // working, but it's a start for drawing the outline. So\n        // developers can start playing around with styles.\n        curContext.enable(curContext.POLYGON_OFFSET_FILL);\n        curContext.polygonOffset(1, 1);\n        uniformf(\"uColor3d\", programObject3D, \"uColor\", fillStyle);\n        curContext.drawArrays(curContext.TRIANGLE_STRIP, 0, sphereVerts.length / 3);\n        curContext.disable(curContext.POLYGON_OFFSET_FILL);\n      }\n\n      // Draw the sphere outline.\n      if (lineWidth > 0 && doStroke) {\n        curContext.useProgram(programObject2D);\n        uniformMatrix(\"uModel2d\", programObject2D, \"uModel\", false, model.array());\n        uniformMatrix(\"uView2d\", programObject2D, \"uView\", false, view.array());\n        vertexAttribPointer(\"aVertex2d\", programObject2D, \"aVertex\", 3, sphereBuffer);\n        disableVertexAttribPointer(\"aTextureCoord2d\", programObject2D, \"aTextureCoord\");\n        uniformf(\"uColor2d\", programObject2D, \"uColor\", strokeStyle);\n        uniformi(\"uIsDrawingText\", programObject2D, \"uIsDrawingText\", false);\n        curContext.drawArrays(curContext.LINE_STRIP, 0, sphereVerts.length / 3);\n      }\n    };\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Coordinates\n    ////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * Returns the three-dimensional X, Y, Z position in model space. This returns\n     * the X value for a given coordinate based on the current set of transformations\n     * (scale, rotate, translate, etc.) The X value can be used to place an object\n     * in space relative to the location of the original point once the transformations\n     * are no longer in use.<br />\n     * <br />\n     *\n     * @param {int | float} x 3D x coordinate to be mapped\n     * @param {int | float} y 3D y coordinate to be mapped\n     * @param {int | float} z 3D z coordinate to be mapped\n     *\n     * @returns {float}\n     *\n     * @see modelY\n     * @see modelZ\n    */\n    p.modelX = function(x, y, z) {\n      var mv = modelView.array();\n      var ci = cameraInv.array();\n\n      var ax = mv[0] * x + mv[1] * y + mv[2] * z + mv[3];\n      var ay = mv[4] * x + mv[5] * y + mv[6] * z + mv[7];\n      var az = mv[8] * x + mv[9] * y + mv[10] * z + mv[11];\n      var aw = mv[12] * x + mv[13] * y + mv[14] * z + mv[15];\n\n      var ox = ci[0] * ax + ci[1] * ay + ci[2] * az + ci[3] * aw;\n      var ow = ci[12] * ax + ci[13] * ay + ci[14] * az + ci[15] * aw;\n\n      return (ow !== 0) ? ox / ow : ox;\n    };\n\n    /**\n     * Returns the three-dimensional X, Y, Z position in model space. This returns\n     * the Y value for a given coordinate based on the current set of transformations\n     * (scale, rotate, translate, etc.) The Y value can be used to place an object in\n     * space relative to the location of the original point once the transformations\n     * are no longer in use.<br />\n     * <br />\n     *\n     * @param {int | float} x 3D x coordinate to be mapped\n     * @param {int | float} y 3D y coordinate to be mapped\n     * @param {int | float} z 3D z coordinate to be mapped\n     *\n     * @returns {float}\n     *\n     * @see modelX\n     * @see modelZ\n    */\n    p.modelY = function(x, y, z) {\n      var mv = modelView.array();\n      var ci = cameraInv.array();\n\n      var ax = mv[0] * x + mv[1] * y + mv[2] * z + mv[3];\n      var ay = mv[4] * x + mv[5] * y + mv[6] * z + mv[7];\n      var az = mv[8] * x + mv[9] * y + mv[10] * z + mv[11];\n      var aw = mv[12] * x + mv[13] * y + mv[14] * z + mv[15];\n\n      var oy = ci[4] * ax + ci[5] * ay + ci[6] * az + ci[7] * aw;\n      var ow = ci[12] * ax + ci[13] * ay + ci[14] * az + ci[15] * aw;\n\n      return (ow !== 0) ? oy / ow : oy;\n    };\n\n    /**\n     * Returns the three-dimensional X, Y, Z position in model space. This returns\n     * the Z value for a given coordinate based on the current set of transformations\n     * (scale, rotate, translate, etc.) The Z value can be used to place an object in\n     * space relative to the location of the original point once the transformations\n     * are no longer in use.\n     *\n     * @param {int | float} x 3D x coordinate to be mapped\n     * @param {int | float} y 3D y coordinate to be mapped\n     * @param {int | float} z 3D z coordinate to be mapped\n     *\n     * @returns {float}\n     *\n     * @see modelX\n     * @see modelY\n    */\n    p.modelZ = function(x, y, z) {\n      var mv = modelView.array();\n      var ci = cameraInv.array();\n\n      var ax = mv[0] * x + mv[1] * y + mv[2] * z + mv[3];\n      var ay = mv[4] * x + mv[5] * y + mv[6] * z + mv[7];\n      var az = mv[8] * x + mv[9] * y + mv[10] * z + mv[11];\n      var aw = mv[12] * x + mv[13] * y + mv[14] * z + mv[15];\n\n      var oz = ci[8] * ax + ci[9] * ay + ci[10] * az + ci[11] * aw;\n      var ow = ci[12] * ax + ci[13] * ay + ci[14] * az + ci[15] * aw;\n\n      return (ow !== 0) ? oz / ow : oz;\n    };\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Material Properties\n    ////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * Sets the ambient reflectance for shapes drawn to the screen. This is\n     * combined with the ambient light component of environment. The color\n     * components set through the parameters define the reflectance. For example in\n     * the default color mode, setting v1=255, v2=126, v3=0, would cause all the\n     * red light to reflect and half of the green light to reflect. Used in combination\n     * with <b>emissive()</b>, <b>specular()</b>, and <b>shininess()</b> in setting\n     * the materal properties of shapes.\n     *\n     * @param {int | float} gray\n     *\n     * @returns none\n     *\n     * @see emissive\n     * @see specular\n     * @see shininess\n    */\n    Drawing2D.prototype.ambient = DrawingShared.prototype.a3DOnlyFunction;\n\n    Drawing3D.prototype.ambient = function(v1, v2, v3) {\n      curContext.useProgram(programObject3D);\n      uniformi(\"uUsingMat3d\", programObject3D, \"uUsingMat\", true);\n      var col = p.color(v1, v2, v3);\n      uniformf(\"uMaterialAmbient3d\", programObject3D, \"uMaterialAmbient\", p.color.toGLArray(col).slice(0, 3));\n    };\n\n    /**\n     * Sets the emissive color of the material used for drawing shapes\n     * drawn to the screen. Used in combination with ambient(), specular(),\n     * and shininess() in setting the material properties of shapes.\n     *\n     * Can be called in the following ways:\n     *\n     * emissive(gray)\n     * @param {int | float} gray number specifying value between white and black\n     *\n     * emissive(color)\n     * @param {color} color any value of the color datatype\n     *\n     * emissive(v1, v2, v3)\n     * @param {int | float} v1 red or hue value\n     * @param {int | float} v2 green or saturation value\n     * @param {int | float} v3 blue or brightness value\n     *\n     * @returns none\n     *\n     * @see ambient\n     * @see specular\n     * @see shininess\n    */\n    Drawing2D.prototype.emissive = DrawingShared.prototype.a3DOnlyFunction;\n\n    Drawing3D.prototype.emissive = function(v1, v2, v3) {\n      curContext.useProgram(programObject3D);\n      uniformi(\"uUsingMat3d\", programObject3D, \"uUsingMat\", true);\n      var col = p.color(v1, v2, v3);\n      uniformf(\"uMaterialEmissive3d\", programObject3D, \"uMaterialEmissive\", p.color.toGLArray(col).slice(0, 3));\n    };\n\n    /**\n     * Sets the amount of gloss in the surface of shapes. Used in combination with\n     * <b>ambient()</b>, <b>specular()</b>, and <b>emissive()</b> in setting the\n     * material properties of shapes.\n     *\n     * @param {float} shine degree of shininess\n     *\n     * @returns none\n    */\n    Drawing2D.prototype.shininess = DrawingShared.prototype.a3DOnlyFunction;\n\n    Drawing3D.prototype.shininess = function(shine) {\n      curContext.useProgram(programObject3D);\n      uniformi(\"uUsingMat3d\", programObject3D, \"uUsingMat\", true);\n      uniformf(\"uShininess3d\", programObject3D, \"uShininess\", shine);\n    };\n\n    /**\n     * Sets the specular color of the materials used for shapes drawn to the screen,\n     * which sets the color of hightlights. Specular refers to light which bounces\n     * off a surface in a perferred direction (rather than bouncing in all directions\n     * like a diffuse light). Used in combination with emissive(), ambient(), and\n     * shininess() in setting the material properties of shapes.\n     *\n     * Can be called in the following ways:\n     *\n     * specular(gray)\n     * @param {int | float} gray number specifying value between white and black\n     *\n     * specular(gray, alpha)\n     * @param {int | float} gray number specifying value between white and black\n     * @param {int | float} alpha opacity\n     *\n     * specular(color)\n     * @param {color} color any value of the color datatype\n     *\n     * specular(v1, v2, v3)\n     * @param {int | float} v1 red or hue value\n     * @param {int | float} v2 green or saturation value\n     * @param {int | float} v3 blue or brightness value\n     *\n     * specular(v1, v2, v3, alpha)\n     * @param {int | float} v1 red or hue value\n     * @param {int | float} v2 green or saturation value\n     * @param {int | float} v3 blue or brightness value\n     * @param {int | float} alpha opacity\n     *\n     * @returns none\n     *\n     * @see ambient\n     * @see emissive\n     * @see shininess\n    */\n    Drawing2D.prototype.specular = DrawingShared.prototype.a3DOnlyFunction;\n\n    Drawing3D.prototype.specular = function(v1, v2, v3) {\n      curContext.useProgram(programObject3D);\n      uniformi(\"uUsingMat3d\", programObject3D, \"uUsingMat\", true);\n      var col = p.color(v1, v2, v3);\n      uniformf(\"uMaterialSpecular3d\", programObject3D, \"uMaterialSpecular\", p.color.toGLArray(col).slice(0, 3));\n    };\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Coordinates\n    ////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * Takes a three-dimensional X, Y, Z position and returns the X value for\n     * where it will appear on a (two-dimensional) screen.\n     *\n     * @param {int | float} x 3D x coordinate to be mapped\n     * @param {int | float} y 3D y coordinate to be mapped\n     * @param {int | float} z 3D z optional coordinate to be mapped\n     *\n     * @returns {float}\n     *\n     * @see screenY\n     * @see screenZ\n    */\n    p.screenX = function( x, y, z ) {\n      var mv = modelView.array();\n      if( mv.length === 16 )\n      {\n        var ax = mv[ 0]*x + mv[ 1]*y + mv[ 2]*z + mv[ 3];\n        var ay = mv[ 4]*x + mv[ 5]*y + mv[ 6]*z + mv[ 7];\n        var az = mv[ 8]*x + mv[ 9]*y + mv[10]*z + mv[11];\n        var aw = mv[12]*x + mv[13]*y + mv[14]*z + mv[15];\n\n        var pj = projection.array();\n\n        var ox = pj[ 0]*ax + pj[ 1]*ay + pj[ 2]*az + pj[ 3]*aw;\n        var ow = pj[12]*ax + pj[13]*ay + pj[14]*az + pj[15]*aw;\n\n        if ( ow !== 0 ){\n          ox /= ow;\n        }\n        return p.width * ( 1 + ox ) / 2.0;\n      }\n      // We assume that we're in 2D\n      return modelView.multX(x, y);\n    };\n\n    /**\n     * Takes a three-dimensional X, Y, Z position and returns the Y value for\n     * where it will appear on a (two-dimensional) screen.\n     *\n     * @param {int | float} x 3D x coordinate to be mapped\n     * @param {int | float} y 3D y coordinate to be mapped\n     * @param {int | float} z 3D z optional coordinate to be mapped\n     *\n     * @returns {float}\n     *\n     * @see screenX\n     * @see screenZ\n    */\n    p.screenY = function screenY( x, y, z ) {\n      var mv = modelView.array();\n      if( mv.length === 16 ) {\n        var ax = mv[ 0]*x + mv[ 1]*y + mv[ 2]*z + mv[ 3];\n        var ay = mv[ 4]*x + mv[ 5]*y + mv[ 6]*z + mv[ 7];\n        var az = mv[ 8]*x + mv[ 9]*y + mv[10]*z + mv[11];\n        var aw = mv[12]*x + mv[13]*y + mv[14]*z + mv[15];\n\n        var pj = projection.array();\n\n        var oy = pj[ 4]*ax + pj[ 5]*ay + pj[ 6]*az + pj[ 7]*aw;\n        var ow = pj[12]*ax + pj[13]*ay + pj[14]*az + pj[15]*aw;\n\n        if ( ow !== 0 ){\n          oy /= ow;\n        }\n        return p.height * ( 1 + oy ) / 2.0;\n      }\n      // We assume that we're in 2D\n      return modelView.multY(x, y);\n    };\n\n    /**\n     * Takes a three-dimensional X, Y, Z position and returns the Z value for\n     * where it will appear on a (two-dimensional) screen.\n     *\n     * @param {int | float} x 3D x coordinate to be mapped\n     * @param {int | float} y 3D y coordinate to be mapped\n     * @param {int | float} z 3D z coordinate to be mapped\n     *\n     * @returns {float}\n     *\n     * @see screenX\n     * @see screenY\n    */\n    p.screenZ = function screenZ( x, y, z ) {\n      var mv = modelView.array();\n      if( mv.length !== 16 ) {\n        return 0;\n      }\n\n      var pj = projection.array();\n\n      var ax = mv[ 0]*x + mv[ 1]*y + mv[ 2]*z + mv[ 3];\n      var ay = mv[ 4]*x + mv[ 5]*y + mv[ 6]*z + mv[ 7];\n      var az = mv[ 8]*x + mv[ 9]*y + mv[10]*z + mv[11];\n      var aw = mv[12]*x + mv[13]*y + mv[14]*z + mv[15];\n\n      var oz = pj[ 8]*ax + pj[ 9]*ay + pj[10]*az + pj[11]*aw;\n      var ow = pj[12]*ax + pj[13]*ay + pj[14]*az + pj[15]*aw;\n\n      if ( ow !== 0 ) {\n        oz /= ow;\n      }\n      return ( oz + 1 ) / 2.0;\n    };\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Style functions\n    ////////////////////////////////////////////////////////////////////////////\n    /**\n     * The fill() function sets the color used to fill shapes. For example, if you run <b>fill(204, 102, 0)</b>, all subsequent shapes will be filled with orange.\n     * This color is either specified in terms of the RGB or HSB color depending on the current <b>colorMode()</b>\n     *(the default color space is RGB, with each value in the range from 0 to 255).\n     * <br><br>When using hexadecimal notation to specify a color, use \"#\" or \"0x\" before the values (e.g. #CCFFAA, 0xFFCCFFAA).\n     * The # syntax uses six digits to specify a color (the way colors are specified in HTML and CSS). When using the hexadecimal notation starting with \"0x\",\n     * the hexadecimal value must be specified with eight characters; the first two characters define the alpha component and the remainder the red, green, and blue components.\n     * <br><br>The value for the parameter \"gray\" must be less than or equal to the current maximum value as specified by <b>colorMode()</b>. The default maximum value is 255.\n     * <br><br>To change the color of an image (or a texture), use tint().\n     *\n     * @param {int|float} gray    number specifying value between white and black\n     * @param {int|float} value1  red or hue value\n     * @param {int|float} value2  green or saturation value\n     * @param {int|float} value3  blue or brightness value\n     * @param {int|float} alpha   opacity of the fill\n     * @param {Color} color       any value of the color datatype\n     * @param {int} hex           color value in hexadecimal notation (i.e. #FFCC00 or 0xFFFFCC00)\n     *\n     * @see #noFill()\n     * @see #stroke()\n     * @see #tint()\n     * @see #background()\n     * @see #colorMode()\n     */\n    DrawingShared.prototype.fill = function() {\n      var color = p.color.apply(this, arguments);\n      if(color === currentFillColor && doFill) {\n        return;\n      }\n      doFill = true;\n      currentFillColor = color;\n    };\n\n    Drawing2D.prototype.fill = function() {\n      DrawingShared.prototype.fill.apply(this, arguments);\n      isFillDirty = true;\n    };\n\n    Drawing3D.prototype.fill = function() {\n      DrawingShared.prototype.fill.apply(this, arguments);\n      fillStyle = p.color.toGLArray(currentFillColor);\n    };\n\n    function executeContextFill() {\n      if(doFill) {\n        if(isFillDirty) {\n          curContext.fillStyle = p.color.toString(currentFillColor);\n          isFillDirty = false;\n        }\n        curContext.fill();\n      }\n    }\n\n    /**\n     * The noFill() function disables filling geometry. If both <b>noStroke()</b> and <b>noFill()</b>\n     * are called, no shapes will be drawn to the screen.\n     *\n     * @see #fill()\n     *\n     */\n    p.noFill = function() {\n      doFill = false;\n    };\n\n    /**\n     * The stroke() function sets the color used to draw lines and borders around shapes. This color\n     * is either specified in terms of the RGB or HSB color depending on the\n     * current <b>colorMode()</b> (the default color space is RGB, with each\n     * value in the range from 0 to 255).\n     * <br><br>When using hexadecimal notation to specify a color, use \"#\" or\n     * \"0x\" before the values (e.g. #CCFFAA, 0xFFCCFFAA). The # syntax uses six\n     * digits to specify a color (the way colors are specified in HTML and CSS).\n     * When using the hexadecimal notation starting with \"0x\", the hexadecimal\n     * value must be specified with eight characters; the first two characters\n     * define the alpha component and the remainder the red, green, and blue\n     * components.\n     * <br><br>The value for the parameter \"gray\" must be less than or equal\n     * to the current maximum value as specified by <b>colorMode()</b>.\n     * The default maximum value is 255.\n     *\n     * @param {int|float} gray    number specifying value between white and black\n     * @param {int|float} value1  red or hue value\n     * @param {int|float} value2  green or saturation value\n     * @param {int|float} value3  blue or brightness value\n     * @param {int|float} alpha   opacity of the stroke\n     * @param {Color} color       any value of the color datatype\n     * @param {int} hex           color value in hexadecimal notation (i.e. #FFCC00 or 0xFFFFCC00)\n     *\n     * @see #fill()\n     * @see #noStroke()\n     * @see #tint()\n     * @see #background()\n     * @see #colorMode()\n     */\n    DrawingShared.prototype.stroke = function() {\n      var color = p.color.apply(this, arguments);\n      if(color === currentStrokeColor && doStroke) {\n        return;\n      }\n      doStroke = true;\n      currentStrokeColor = color;\n    };\n\n    Drawing2D.prototype.stroke = function() {\n      DrawingShared.prototype.stroke.apply(this, arguments);\n      isStrokeDirty = true;\n    };\n\n    Drawing3D.prototype.stroke = function() {\n      DrawingShared.prototype.stroke.apply(this, arguments);\n      strokeStyle = p.color.toGLArray(currentStrokeColor);\n    };\n\n    function executeContextStroke() {\n      if(doStroke) {\n        if(isStrokeDirty) {\n          curContext.strokeStyle = p.color.toString(currentStrokeColor);\n          isStrokeDirty = false;\n        }\n        curContext.stroke();\n      }\n    }\n\n    /**\n     * The noStroke() function disables drawing the stroke (outline). If both <b>noStroke()</b> and\n     * <b>noFill()</b> are called, no shapes will be drawn to the screen.\n     *\n     * @see #stroke()\n     */\n    p.noStroke = function() {\n      doStroke = false;\n    };\n\n    /**\n     * The strokeWeight() function sets the width of the stroke used for lines, points, and the border around shapes.\n     * All widths are set in units of pixels.\n     *\n     * @param {int|float} w the weight (in pixels) of the stroke\n     */\n    DrawingShared.prototype.strokeWeight = function(w) {\n      lineWidth = w;\n    };\n\n    Drawing2D.prototype.strokeWeight = function(w) {\n      DrawingShared.prototype.strokeWeight.apply(this, arguments);\n      curContext.lineWidth = w;\n    };\n\n    Drawing3D.prototype.strokeWeight = function(w) {\n      DrawingShared.prototype.strokeWeight.apply(this, arguments);\n\n      // Processing groups the weight of points and lines under this one function,\n      // but for WebGL, we need to set a uniform for points and call a function for line.\n\n      curContext.useProgram(programObject2D);\n      uniformf(\"pointSize2d\", programObject2D, \"uPointSize\", w);\n\n      curContext.useProgram(programObjectUnlitShape);\n      uniformf(\"pointSizeUnlitShape\", programObjectUnlitShape, \"uPointSize\", w);\n\n      curContext.lineWidth(w);\n    };\n\n    /**\n     * The strokeCap() function sets the style for rendering line endings. These ends are either squared, extended, or rounded and\n     * specified with the corresponding parameters SQUARE, PROJECT, and ROUND. The default cap is ROUND.\n     * This function is not available with the P2D, P3D, or OPENGL renderers\n     *\n     * @param {int} value Either SQUARE, PROJECT, or ROUND\n     */\n    p.strokeCap = function(value) {\n      drawing.$ensureContext().lineCap = value;\n    };\n\n    /**\n     * The strokeJoin() function sets the style of the joints which connect line segments.\n     * These joints are either mitered, beveled, or rounded and specified with the corresponding parameters MITER, BEVEL, and ROUND. The default joint is MITER.\n     * This function is not available with the P2D, P3D, or OPENGL renderers\n     *\n     * @param {int} value Either SQUARE, PROJECT, or ROUND\n     */\n    p.strokeJoin = function(value) {\n      drawing.$ensureContext().lineJoin = value;\n    };\n\n    /**\n     * The smooth() function draws all geometry with smooth (anti-aliased) edges. This will slow down the frame rate of the application,\n     * but will enhance the visual refinement. <br/><br/>\n     * Note that smooth() will also improve image quality of resized images, and noSmooth() will disable image (and font) smoothing altogether.\n     * When working with a 3D sketch, smooth will draw points as circles rather than squares.\n     *\n     * @see #noSmooth()\n     * @see #hint()\n     * @see #size()\n     */\n\n    Drawing2D.prototype.smooth = function() {\n      renderSmooth = true;\n      var style = curElement.style;\n      style.setProperty(\"image-rendering\", \"optimizeQuality\", \"important\");\n      style.setProperty(\"-ms-interpolation-mode\", \"bicubic\", \"important\");\n      if (curContext.hasOwnProperty(\"mozImageSmoothingEnabled\")) {\n        curContext.mozImageSmoothingEnabled = true;\n      }\n    };\n\n    Drawing3D.prototype.smooth = function(){\n      renderSmooth = true;\n    };\n\n    /**\n     * The noSmooth() function draws all geometry with jagged (aliased) edges.\n     *\n     * @see #smooth()\n     */\n\n    Drawing2D.prototype.noSmooth = function() {\n      renderSmooth = false;\n      var style = curElement.style;\n      style.setProperty(\"image-rendering\", \"optimizeSpeed\", \"important\");\n      style.setProperty(\"image-rendering\", \"-moz-crisp-edges\", \"important\");\n      style.setProperty(\"image-rendering\", \"-webkit-optimize-contrast\", \"important\");\n      style.setProperty(\"image-rendering\", \"optimize-contrast\", \"important\");\n      style.setProperty(\"-ms-interpolation-mode\", \"nearest-neighbor\", \"important\");\n      if (curContext.hasOwnProperty(\"mozImageSmoothingEnabled\")) {\n        curContext.mozImageSmoothingEnabled = false;\n      }\n    };\n\n    Drawing3D.prototype.noSmooth = function(){\n      renderSmooth = false;\n    };\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Vector drawing functions\n    ////////////////////////////////////////////////////////////////////////////\n    /**\n     * The point() function draws a point, a coordinate in space at the dimension of one pixel.\n     * The first parameter is the horizontal value for the point, the second\n     * value is the vertical value for the point, and the optional third value\n     * is the depth value. Drawing this shape in 3D using the <b>z</b>\n     * parameter requires the P3D or OPENGL parameter in combination with\n     * size as shown in the above example.\n     *\n     * @param {int|float} x x-coordinate of the point\n     * @param {int|float} y y-coordinate of the point\n     * @param {int|float} z z-coordinate of the point\n     *\n     * @see #beginShape()\n     */\n    Drawing2D.prototype.point = function(x, y) {\n      if (!doStroke) {\n        return;\n      }\n      if (!renderSmooth) {\n        x = Math.round(x);\n        y = Math.round(y);\n      }\n      curContext.fillStyle = p.color.toString(currentStrokeColor);\n      isFillDirty = true;\n      // Draw a circle for any point larger than 1px\n      if (lineWidth > 1) {\n        curContext.beginPath();\n        curContext.arc(x, y, lineWidth / 2, 0, PConstants.TWO_PI, false);\n        curContext.fill();\n      } else {\n        curContext.fillRect(x, y, 1, 1);\n      }\n    };\n\n    Drawing3D.prototype.point = function(x, y, z) {\n      var model = new PMatrix3D();\n\n      // move point to position\n      model.translate(x, y, z || 0);\n      model.transpose();\n\n      var view = new PMatrix3D();\n      view.scale(1, -1, 1);\n      view.apply(modelView.array());\n      view.transpose();\n\n      curContext.useProgram(programObject2D);\n      uniformMatrix(\"uModel2d\", programObject2D, \"uModel\", false, model.array());\n      uniformMatrix(\"uView2d\", programObject2D, \"uView\", false, view.array());\n\n      if (lineWidth > 0 && doStroke) {\n        // this will be replaced with the new bit shifting color code\n        uniformf(\"uColor2d\", programObject2D, \"uColor\", strokeStyle);\n        uniformi(\"uIsDrawingText2d\", programObject2D, \"uIsDrawingText\", false);\n        uniformi(\"uSmooth2d\", programObject2D, \"uSmooth\", renderSmooth);\n        vertexAttribPointer(\"aVertex2d\", programObject2D, \"aVertex\", 3, pointBuffer);\n        disableVertexAttribPointer(\"aTextureCoord2d\", programObject2D, \"aTextureCoord\");\n        curContext.drawArrays(curContext.POINTS, 0, 1);\n      }\n    };\n\n    /**\n     * Using the <b>beginShape()</b> and <b>endShape()</b> functions allow creating more complex forms.\n     * <b>beginShape()</b> begins recording vertices for a shape and <b>endShape()</b> stops recording.\n     * The value of the <b>MODE</b> parameter tells it which types of shapes to create from the provided vertices.\n     * With no mode specified, the shape can be any irregular polygon. After calling the <b>beginShape()</b> function,\n     * a series of <b>vertex()</b> commands must follow. To stop drawing the shape, call <b>endShape()</b>.\n     * The <b>vertex()</b> function with two parameters specifies a position in 2D and the <b>vertex()</b>\n     * function with three parameters specifies a position in 3D. Each shape will be outlined with the current\n     * stroke color and filled with the fill color.\n     *\n     * @param {int} MODE either POINTS, LINES, TRIANGLES, TRIANGLE_FAN, TRIANGLE_STRIP, QUADS, and QUAD_STRIP.\n     *\n     * @see endShape\n     * @see vertex\n     * @see curveVertex\n     * @see bezierVertex\n     */\n    p.beginShape = function(type) {\n      curShape = type;\n      curvePoints = [];\n      vertArray = [];\n    };\n\n    /**\n     * All shapes are constructed by connecting a series of vertices. <b>vertex()</b> is used to specify the vertex\n     * coordinates for points, lines, triangles, quads, and polygons and is used exclusively within the <b>beginShape()</b>\n     * and <b>endShape()</b> function. <br /><br />Drawing a vertex in 3D using the <b>z</b> parameter requires the P3D or\n     * OPENGL parameter in combination with size as shown in the above example.<br /><br />This function is also used to map a\n     * texture onto the geometry. The <b>texture()</b> function declares the texture to apply to the geometry and the <b>u</b>\n     * and <b>v</b> coordinates set define the mapping of this texture to the form. By default, the coordinates used for\n     * <b>u</b> and <b>v</b> are specified in relation to the image's size in pixels, but this relation can be changed with\n     * <b>textureMode()</b>.\n     *\n     * @param {int | float} x x-coordinate of the vertex\n     * @param {int | float} y y-coordinate of the vertex\n     * @param {boolean} moveto flag to indicate whether this is a new subpath\n     *\n     * @see beginShape\n     * @see endShape\n     * @see bezierVertex\n     * @see curveVertex\n     * @see texture\n     */\n\n    Drawing2D.prototype.vertex = function(x, y, moveTo) {\n      var vert = [];\n\n      if (firstVert) { firstVert = false; }\n      vert.isVert = true;\n\n      vert[0] = x;\n      vert[1] = y;\n      vert[2] = 0;\n      vert[3] = 0;\n      vert[4] = 0;\n\n      // fill and stroke color\n      vert[5] = currentFillColor;\n      vert[6] = currentStrokeColor;\n\n      vertArray.push(vert);\n      if (moveTo) {\n        vertArray[vertArray.length-1].moveTo = moveTo;\n      }\n    };\n\n    Drawing3D.prototype.vertex = function(x, y, z, u, v) {\n      var vert = [];\n\n      if (firstVert) { firstVert = false; }\n      vert.isVert = true;\n\n      if (v === undef && usingTexture) {\n        v = u;\n        u = z;\n        z = 0;\n      }\n\n      // Convert u and v to normalized coordinates\n      if (u !== undef && v !== undef) {\n        if (curTextureMode === PConstants.IMAGE) {\n          u /= curTexture.width;\n          v /= curTexture.height;\n        }\n        u = u > 1 ? 1 : u;\n        u = u < 0 ? 0 : u;\n        v = v > 1 ? 1 : v;\n        v = v < 0 ? 0 : v;\n      }\n\n      vert[0] = x;\n      vert[1] = y;\n      vert[2] = z || 0;\n      vert[3] = u || 0;\n      vert[4] = v || 0;\n\n      // fill rgba\n      vert[5] = fillStyle[0];\n      vert[6] = fillStyle[1];\n      vert[7] = fillStyle[2];\n      vert[8] = fillStyle[3];\n      // stroke rgba\n      vert[9] = strokeStyle[0];\n      vert[10] = strokeStyle[1];\n      vert[11] = strokeStyle[2];\n      vert[12] = strokeStyle[3];\n      //normals\n      vert[13] = normalX;\n      vert[14] = normalY;\n      vert[15] = normalZ;\n\n      vertArray.push(vert);\n    };\n\n    /**\n     * @private\n     * Renders 3D points created from calls to vertex and beginShape/endShape\n     *\n     * @param {Array} vArray an array of vertex coordinate\n     * @param {Array} cArray an array of colours used for the vertices\n     *\n     * @see beginShape\n     * @see endShape\n     * @see vertex\n     */\n    var point3D = function(vArray, cArray){\n      var view = new PMatrix3D();\n      view.scale(1, -1, 1);\n      view.apply(modelView.array());\n      view.transpose();\n\n      curContext.useProgram(programObjectUnlitShape);\n\n      uniformMatrix(\"uViewUS\", programObjectUnlitShape, \"uView\", false, view.array());\n      uniformi(\"uSmoothUS\", programObjectUnlitShape, \"uSmooth\", renderSmooth);\n\n      vertexAttribPointer(\"aVertexUS\", programObjectUnlitShape, \"aVertex\", 3, pointBuffer);\n      curContext.bufferData(curContext.ARRAY_BUFFER, new Float32Array(vArray), curContext.STREAM_DRAW);\n\n      vertexAttribPointer(\"aColorUS\", programObjectUnlitShape, \"aColor\", 4, fillColorBuffer);\n      curContext.bufferData(curContext.ARRAY_BUFFER, new Float32Array(cArray), curContext.STREAM_DRAW);\n\n      curContext.drawArrays(curContext.POINTS, 0, vArray.length/3);\n    };\n\n    /**\n     * @private\n     * Renders 3D lines created from calls to beginShape/vertex/endShape - based on the mode specified LINES, LINE_LOOP, etc.\n     *\n     * @param {Array} vArray an array of vertex coordinate\n     * @param {String} mode  either LINES, LINE_LOOP, or LINE_STRIP\n     * @param {Array} cArray an array of colours used for the vertices\n     *\n     * @see beginShape\n     * @see endShape\n     * @see vertex\n     */\n    var line3D = function(vArray, mode, cArray){\n      var ctxMode;\n      if (mode === \"LINES\"){\n        ctxMode = curContext.LINES;\n      }\n      else if(mode === \"LINE_LOOP\"){\n        ctxMode = curContext.LINE_LOOP;\n      }\n      else{\n        ctxMode = curContext.LINE_STRIP;\n      }\n\n      var view = new PMatrix3D();\n      view.scale(1, -1, 1);\n      view.apply(modelView.array());\n      view.transpose();\n\n      curContext.useProgram(programObjectUnlitShape);\n      uniformMatrix(\"uViewUS\", programObjectUnlitShape, \"uView\", false, view.array());\n      vertexAttribPointer(\"aVertexUS\", programObjectUnlitShape, \"aVertex\", 3, lineBuffer);\n      curContext.bufferData(curContext.ARRAY_BUFFER, new Float32Array(vArray), curContext.STREAM_DRAW);\n      vertexAttribPointer(\"aColorUS\", programObjectUnlitShape, \"aColor\", 4, strokeColorBuffer);\n      curContext.bufferData(curContext.ARRAY_BUFFER, new Float32Array(cArray), curContext.STREAM_DRAW);\n      curContext.drawArrays(ctxMode, 0, vArray.length/3);\n    };\n\n    /**\n     * @private\n     * Render filled shapes created from calls to beginShape/vertex/endShape - based on the mode specified TRIANGLES, etc.\n     *\n     * @param {Array} vArray an array of vertex coordinate\n     * @param {String} mode  either LINES, LINE_LOOP, or LINE_STRIP\n     * @param {Array} cArray an array of colours used for the vertices\n     * @param {Array} tArray an array of u,v coordinates for textures\n     *\n     * @see beginShape\n     * @see endShape\n     * @see vertex\n     */\n    var fill3D = function(vArray, mode, cArray, tArray){\n      var ctxMode;\n      if (mode === \"TRIANGLES\") {\n        ctxMode = curContext.TRIANGLES;\n      } else if(mode === \"TRIANGLE_FAN\") {\n        ctxMode = curContext.TRIANGLE_FAN;\n      } else {\n        ctxMode = curContext.TRIANGLE_STRIP;\n      }\n\n      var view = new PMatrix3D();\n      view.scale( 1, -1, 1 );\n      view.apply( modelView.array() );\n      view.transpose();\n\n      curContext.useProgram( programObject3D );\n      uniformMatrix( \"model3d\", programObject3D, \"uModel\", false,  [1,0,0,0,  0,1,0,0,   0,0,1,0,   0,0,0,1] );\n      uniformMatrix( \"view3d\", programObject3D, \"uView\", false, view.array() );\n      curContext.enable( curContext.POLYGON_OFFSET_FILL );\n      curContext.polygonOffset( 1, 1 );\n      uniformf( \"color3d\", programObject3D, \"uColor\", [-1,0,0,0] );\n      vertexAttribPointer( \"vertex3d\", programObject3D, \"aVertex\", 3, fillBuffer );\n      curContext.bufferData( curContext.ARRAY_BUFFER, new Float32Array(vArray), curContext.STREAM_DRAW );\n\n      // if we are using a texture and a tint, then overwrite the\n      // contents of the color buffer with the current tint\n      if ( usingTexture && curTint !== null ){\n        curTint3d( cArray );\n      }\n\n      vertexAttribPointer( \"aColor3d\", programObject3D, \"aColor\", 4, fillColorBuffer );\n      curContext.bufferData( curContext.ARRAY_BUFFER, new Float32Array(cArray), curContext.STREAM_DRAW );\n\n      // No support for lights....yet\n      disableVertexAttribPointer( \"aNormal3d\", programObject3D, \"aNormal\" );\n\n      if ( usingTexture ) {\n        uniformi( \"uUsingTexture3d\", programObject3D, \"uUsingTexture\", usingTexture );\n        vertexAttribPointer( \"aTexture3d\", programObject3D, \"aTexture\", 2, shapeTexVBO );\n        curContext.bufferData( curContext.ARRAY_BUFFER, new Float32Array(tArray), curContext.STREAM_DRAW );\n      }\n\n      curContext.drawArrays( ctxMode, 0, vArray.length/3 );\n      curContext.disable( curContext.POLYGON_OFFSET_FILL );\n    };\n\n    /**\n     * this series of three operations is used a lot in Drawing2D.prototype.endShape\n     * and has been split off as its own function, to tighten the code and allow for\n     * fewer bugs.\n     */\n    function fillStrokeClose() {\n      executeContextFill();\n      executeContextStroke();\n      curContext.closePath();\n    }\n\n    /**\n     * The endShape() function is the companion to beginShape() and may only be called after beginShape().\n     * When endshape() is called, all of image data defined since the previous call to beginShape() is written\n     * into the image buffer.\n     *\n     * @param {int} MODE Use CLOSE to close the shape\n     *\n     * @see beginShape\n     */\n    Drawing2D.prototype.endShape = function(mode) {\n      // Duplicated in Drawing3D; too many variables used\n      if (vertArray.length === 0) { return; }\n\n      var closeShape = mode === PConstants.CLOSE;\n\n      // if the shape is closed, the first element is also the last element\n      if (closeShape) {\n        vertArray.push(vertArray[0]);\n      }\n\n      var lineVertArray = [];\n      var fillVertArray = [];\n      var colorVertArray = [];\n      var strokeVertArray = [];\n      var texVertArray = [];\n      var cachedVertArray;\n\n      firstVert = true;\n      var i, j, k;\n      var vertArrayLength = vertArray.length;\n\n      for (i = 0; i < vertArrayLength; i++) {\n        cachedVertArray = vertArray[i];\n        for (j = 0; j < 3; j++) {\n          fillVertArray.push(cachedVertArray[j]);\n        }\n      }\n\n      // 5,6,7,8\n      // R,G,B,A - fill colour\n      for (i = 0; i < vertArrayLength; i++) {\n        cachedVertArray = vertArray[i];\n        for (j = 5; j < 9; j++) {\n          colorVertArray.push(cachedVertArray[j]);\n        }\n      }\n\n      // 9,10,11,12\n      // R, G, B, A - stroke colour\n      for (i = 0; i < vertArrayLength; i++) {\n        cachedVertArray = vertArray[i];\n        for (j = 9; j < 13; j++) {\n          strokeVertArray.push(cachedVertArray[j]);\n        }\n      }\n\n      // texture u,v\n      for (i = 0; i < vertArrayLength; i++) {\n        cachedVertArray = vertArray[i];\n        texVertArray.push(cachedVertArray[3]);\n        texVertArray.push(cachedVertArray[4]);\n      }\n\n      // curveVertex\n      if ( isCurve && (curShape === PConstants.POLYGON || curShape === undef) ) {\n        if (vertArrayLength > 3) {\n          var b = [],\n              s = 1 - curTightness;\n          curContext.beginPath();\n          curContext.moveTo(vertArray[1][0], vertArray[1][1]);\n            /*\n            * Matrix to convert from Catmull-Rom to cubic Bezier\n            * where t = curTightness\n            * |0         1          0         0       |\n            * |(t-1)/6   1          (1-t)/6   0       |\n            * |0         (1-t)/6    1         (t-1)/6 |\n            * |0         0          0         0       |\n            */\n          for (i = 1; (i+2) < vertArrayLength; i++) {\n            cachedVertArray = vertArray[i];\n            b[0] = [cachedVertArray[0], cachedVertArray[1]];\n            b[1] = [cachedVertArray[0] + (s * vertArray[i+1][0] - s * vertArray[i-1][0]) / 6,\n                   cachedVertArray[1] + (s * vertArray[i+1][1] - s * vertArray[i-1][1]) / 6];\n            b[2] = [vertArray[i+1][0] + (s * vertArray[i][0] - s * vertArray[i+2][0]) / 6,\n                   vertArray[i+1][1] + (s * vertArray[i][1] - s * vertArray[i+2][1]) / 6];\n            b[3] = [vertArray[i+1][0], vertArray[i+1][1]];\n            curContext.bezierCurveTo(b[1][0], b[1][1], b[2][0], b[2][1], b[3][0], b[3][1]);\n          }\n          fillStrokeClose();\n        }\n      }\n\n      // bezierVertex\n      else if ( isBezier && (curShape === PConstants.POLYGON || curShape === undef) ) {\n        curContext.beginPath();\n        for (i = 0; i < vertArrayLength; i++) {\n          cachedVertArray = vertArray[i];\n          if (vertArray[i].isVert) { //if it is a vertex move to the position\n            if (vertArray[i].moveTo) {\n              curContext.moveTo(cachedVertArray[0], cachedVertArray[1]);\n            } else {\n              curContext.lineTo(cachedVertArray[0], cachedVertArray[1]);\n            }\n          } else { //otherwise continue drawing bezier\n            curContext.bezierCurveTo(vertArray[i][0], vertArray[i][1], vertArray[i][2], vertArray[i][3], vertArray[i][4], vertArray[i][5]);\n          }\n        }\n        fillStrokeClose();\n      }\n\n      // render the vertices provided\n      else {\n        if (curShape === PConstants.POINTS) {\n          for (i = 0; i < vertArrayLength; i++) {\n            cachedVertArray = vertArray[i];\n            if (doStroke) {\n              p.stroke(cachedVertArray[6]);\n            }\n            p.point(cachedVertArray[0], cachedVertArray[1]);\n          }\n        } else if (curShape === PConstants.LINES) {\n          for (i = 0; (i + 1) < vertArrayLength; i+=2) {\n            cachedVertArray = vertArray[i];\n            if (doStroke) {\n              p.stroke(vertArray[i+1][6]);\n            }\n            p.line(cachedVertArray[0], cachedVertArray[1], vertArray[i+1][0], vertArray[i+1][1]);\n          }\n        } else if (curShape === PConstants.TRIANGLES) {\n          for (i = 0; (i + 2) < vertArrayLength; i+=3) {\n            cachedVertArray = vertArray[i];\n            curContext.beginPath();\n            curContext.moveTo(cachedVertArray[0], cachedVertArray[1]);\n            curContext.lineTo(vertArray[i+1][0], vertArray[i+1][1]);\n            curContext.lineTo(vertArray[i+2][0], vertArray[i+2][1]);\n            curContext.lineTo(cachedVertArray[0], cachedVertArray[1]);\n\n            if (doFill) {\n              p.fill(vertArray[i+2][5]);\n              executeContextFill();\n            }\n            if (doStroke) {\n              p.stroke(vertArray[i+2][6]);\n              executeContextStroke();\n            }\n\n            curContext.closePath();\n          }\n        } else if (curShape === PConstants.TRIANGLE_STRIP) {\n          for (i = 0; (i+1) < vertArrayLength; i++) {\n            cachedVertArray = vertArray[i];\n            curContext.beginPath();\n            curContext.moveTo(vertArray[i+1][0], vertArray[i+1][1]);\n            curContext.lineTo(cachedVertArray[0], cachedVertArray[1]);\n\n            if (doStroke) {\n              p.stroke(vertArray[i+1][6]);\n            }\n            if (doFill) {\n              p.fill(vertArray[i+1][5]);\n            }\n\n            if (i + 2 < vertArrayLength) {\n              curContext.lineTo(vertArray[i+2][0], vertArray[i+2][1]);\n              if (doStroke) {\n                p.stroke(vertArray[i+2][6]);\n              }\n              if (doFill) {\n                p.fill(vertArray[i+2][5]);\n              }\n            }\n            fillStrokeClose();\n          }\n        } else if (curShape === PConstants.TRIANGLE_FAN) {\n          if (vertArrayLength > 2) {\n            curContext.beginPath();\n            curContext.moveTo(vertArray[0][0], vertArray[0][1]);\n            curContext.lineTo(vertArray[1][0], vertArray[1][1]);\n            curContext.lineTo(vertArray[2][0], vertArray[2][1]);\n\n            if (doFill) {\n              p.fill(vertArray[2][5]);\n              executeContextFill();\n            }\n            if (doStroke) {\n              p.stroke(vertArray[2][6]);\n              executeContextStroke();\n            }\n\n            curContext.closePath();\n            for (i = 3; i < vertArrayLength; i++) {\n              cachedVertArray = vertArray[i];\n              curContext.beginPath();\n              curContext.moveTo(vertArray[0][0], vertArray[0][1]);\n              curContext.lineTo(vertArray[i-1][0], vertArray[i-1][1]);\n              curContext.lineTo(cachedVertArray[0], cachedVertArray[1]);\n\n              if (doFill) {\n                p.fill(cachedVertArray[5]);\n                executeContextFill();\n              }\n              if (doStroke) {\n                p.stroke(cachedVertArray[6]);\n                executeContextStroke();\n              }\n\n              curContext.closePath();\n            }\n          }\n        } else if (curShape === PConstants.QUADS) {\n          for (i = 0; (i + 3) < vertArrayLength; i+=4) {\n            cachedVertArray = vertArray[i];\n            curContext.beginPath();\n            curContext.moveTo(cachedVertArray[0], cachedVertArray[1]);\n            for (j = 1; j < 4; j++) {\n              curContext.lineTo(vertArray[i+j][0], vertArray[i+j][1]);\n            }\n            curContext.lineTo(cachedVertArray[0], cachedVertArray[1]);\n\n            if (doFill) {\n              p.fill(vertArray[i+3][5]);\n              executeContextFill();\n            }\n            if (doStroke) {\n              p.stroke(vertArray[i+3][6]);\n              executeContextStroke();\n            }\n\n            curContext.closePath();\n          }\n        } else if (curShape === PConstants.QUAD_STRIP) {\n          if (vertArrayLength > 3) {\n            for (i = 0; (i+1) < vertArrayLength; i+=2) {\n              cachedVertArray = vertArray[i];\n              curContext.beginPath();\n              if (i+3 < vertArrayLength) {\n                curContext.moveTo(vertArray[i+2][0], vertArray[i+2][1]);\n                curContext.lineTo(cachedVertArray[0], cachedVertArray[1]);\n                curContext.lineTo(vertArray[i+1][0], vertArray[i+1][1]);\n                curContext.lineTo(vertArray[i+3][0], vertArray[i+3][1]);\n\n                if (doFill) {\n                  p.fill(vertArray[i+3][5]);\n                }\n                if (doStroke) {\n                  p.stroke(vertArray[i+3][6]);\n                }\n              } else {\n                curContext.moveTo(cachedVertArray[0], cachedVertArray[1]);\n                curContext.lineTo(vertArray[i+1][0], vertArray[i+1][1]);\n              }\n              fillStrokeClose();\n            }\n          }\n        } else {\n          curContext.beginPath();\n          curContext.moveTo(vertArray[0][0], vertArray[0][1]);\n          for (i = 1; i < vertArrayLength; i++) {\n            cachedVertArray = vertArray[i];\n            if (cachedVertArray.isVert) { //if it is a vertex move to the position\n              if (cachedVertArray.moveTo) {\n                curContext.moveTo(cachedVertArray[0], cachedVertArray[1]);\n              } else {\n                curContext.lineTo(cachedVertArray[0], cachedVertArray[1]);\n              }\n            }\n          }\n          fillStrokeClose();\n        }\n      }\n\n      // Reset some settings\n      isCurve = false;\n      isBezier = false;\n      curveVertArray = [];\n      curveVertCount = 0;\n\n      // If the shape is closed, the first element was added as last element.\n      // We must remove it again to prevent the list of vertices from growing\n      // over successive calls to endShape(CLOSE)\n      if (closeShape) {\n        vertArray.pop();\n      }\n    };\n\n    Drawing3D.prototype.endShape = function(mode) {\n      // Duplicated in Drawing3D; too many variables used\n      if (vertArray.length === 0) { return; }\n\n      var closeShape = mode === PConstants.CLOSE;\n      var lineVertArray = [];\n      var fillVertArray = [];\n      var colorVertArray = [];\n      var strokeVertArray = [];\n      var texVertArray = [];\n      var cachedVertArray;\n\n      firstVert = true;\n      var i, j, k;\n      var vertArrayLength = vertArray.length;\n\n      for (i = 0; i < vertArrayLength; i++) {\n        cachedVertArray = vertArray[i];\n        for (j = 0; j < 3; j++) {\n          fillVertArray.push(cachedVertArray[j]);\n        }\n      }\n\n      // 5,6,7,8\n      // R,G,B,A - fill colour\n      for (i = 0; i < vertArrayLength; i++) {\n        cachedVertArray = vertArray[i];\n        for (j = 5; j < 9; j++) {\n          colorVertArray.push(cachedVertArray[j]);\n        }\n      }\n\n      // 9,10,11,12\n      // R, G, B, A - stroke colour\n      for (i = 0; i < vertArrayLength; i++) {\n        cachedVertArray = vertArray[i];\n        for (j = 9; j < 13; j++) {\n          strokeVertArray.push(cachedVertArray[j]);\n        }\n      }\n\n      // texture u,v\n      for (i = 0; i < vertArrayLength; i++) {\n        cachedVertArray = vertArray[i];\n        texVertArray.push(cachedVertArray[3]);\n        texVertArray.push(cachedVertArray[4]);\n      }\n\n      // if shape is closed, push the first point into the last point (including colours)\n      if (closeShape) {\n        fillVertArray.push(vertArray[0][0]);\n        fillVertArray.push(vertArray[0][1]);\n        fillVertArray.push(vertArray[0][2]);\n\n        for (i = 5; i < 9; i++) {\n          colorVertArray.push(vertArray[0][i]);\n        }\n\n        for (i = 9; i < 13; i++) {\n          strokeVertArray.push(vertArray[0][i]);\n        }\n\n        texVertArray.push(vertArray[0][3]);\n        texVertArray.push(vertArray[0][4]);\n      }\n      // End duplication\n\n      // curveVertex\n      if ( isCurve && (curShape === PConstants.POLYGON || curShape === undef) ) {\n        lineVertArray = fillVertArray;\n        if (doStroke) {\n          line3D(lineVertArray, null, strokeVertArray);\n        }\n        if (doFill) {\n          fill3D(fillVertArray, null, colorVertArray);\n        }\n      }\n      // bezierVertex\n      else if ( isBezier && (curShape === PConstants.POLYGON || curShape === undef) ) {\n        lineVertArray = fillVertArray;\n        lineVertArray.splice(lineVertArray.length - 3);\n        strokeVertArray.splice(strokeVertArray.length - 4);\n        if (doStroke) {\n          line3D(lineVertArray, null, strokeVertArray);\n        }\n        if (doFill) {\n          fill3D(fillVertArray, \"TRIANGLES\", colorVertArray);\n        }\n      }\n\n      // render the vertices provided\n      else {\n        if (curShape === PConstants.POINTS) {       // if POINTS was the specified parameter in beginShape\n          for (i = 0; i < vertArrayLength; i++) {  // loop through and push the point location information to the array\n            cachedVertArray = vertArray[i];\n            for (j = 0; j < 3; j++) {\n              lineVertArray.push(cachedVertArray[j]);\n            }\n          }\n          point3D(lineVertArray, strokeVertArray);  // render function for points\n        } else if (curShape === PConstants.LINES) { // if LINES was the specified parameter in beginShape\n          for (i = 0; i < vertArrayLength; i++) {  // loop through and push the point location information to the array\n            cachedVertArray = vertArray[i];\n            for (j = 0; j < 3; j++) {\n              lineVertArray.push(cachedVertArray[j]);\n            }\n          }\n          for (i = 0; i < vertArrayLength; i++) {  // loop through and push the color information to the array\n            cachedVertArray = vertArray[i];\n            for (j = 5; j < 9; j++) {\n              colorVertArray.push(cachedVertArray[j]);\n            }\n          }\n          line3D(lineVertArray, \"LINES\", strokeVertArray);  // render function for lines\n        } else if (curShape === PConstants.TRIANGLES) {     // if TRIANGLES was the specified parameter in beginShape\n          if (vertArrayLength > 2) {\n            for (i = 0; (i+2) < vertArrayLength; i+=3) {   // loop through the array per triangle\n              fillVertArray = [];\n              texVertArray = [];\n              lineVertArray = [];\n              colorVertArray = [];\n              strokeVertArray = [];\n              for (j = 0; j < 3; j++) {\n                for (k = 0; k < 3; k++) {                   // loop through and push\n                  lineVertArray.push(vertArray[i+j][k]);    // the line point location information\n                  fillVertArray.push(vertArray[i+j][k]);    // and fill point location information\n                }\n              }\n              for (j = 0; j < 3; j++) {                     // loop through and push the texture information\n                for (k = 3; k < 5; k++) {\n                  texVertArray.push(vertArray[i+j][k]);\n                }\n              }\n              for (j = 0; j < 3; j++) {\n                for (k = 5; k < 9; k++) {                   // loop through and push\n                  colorVertArray.push(vertArray[i+j][k]);   // the colour information\n                  strokeVertArray.push(vertArray[i+j][k+4]);// and the stroke information\n                }\n              }\n              if (doStroke) {\n                line3D(lineVertArray, \"LINE_LOOP\", strokeVertArray );               // line render function\n              }\n              if (doFill || usingTexture) {\n                fill3D(fillVertArray, \"TRIANGLES\", colorVertArray, texVertArray);   // fill shape render function\n              }\n            }\n          }\n        } else if (curShape === PConstants.TRIANGLE_STRIP) {    // if TRIANGLE_STRIP was the specified parameter in beginShape\n          if (vertArrayLength > 2) {\n            for (i = 0; (i+2) < vertArrayLength; i++) {\n              lineVertArray = [];\n              fillVertArray = [];\n              strokeVertArray = [];\n              colorVertArray = [];\n              texVertArray = [];\n              for (j = 0; j < 3; j++) {\n                for (k = 0; k < 3; k++) {\n                  lineVertArray.push(vertArray[i+j][k]);\n                  fillVertArray.push(vertArray[i+j][k]);\n                }\n              }\n              for (j = 0; j < 3; j++) {\n                for (k = 3; k < 5; k++) {\n                  texVertArray.push(vertArray[i+j][k]);\n                }\n              }\n              for (j = 0; j < 3; j++) {\n                for (k = 5; k < 9; k++) {\n                  strokeVertArray.push(vertArray[i+j][k+4]);\n                  colorVertArray.push(vertArray[i+j][k]);\n                }\n              }\n\n              if (doFill || usingTexture) {\n                fill3D(fillVertArray, \"TRIANGLE_STRIP\", colorVertArray, texVertArray);\n              }\n              if (doStroke) {\n                line3D(lineVertArray, \"LINE_LOOP\", strokeVertArray);\n              }\n            }\n          }\n        } else if (curShape === PConstants.TRIANGLE_FAN) {\n          if (vertArrayLength > 2) {\n            for (i = 0; i < 3; i++) {\n              cachedVertArray = vertArray[i];\n              for (j = 0; j < 3; j++) {\n                lineVertArray.push(cachedVertArray[j]);\n              }\n            }\n            for (i = 0; i < 3; i++) {\n              cachedVertArray = vertArray[i];\n              for (j = 9; j < 13; j++) {\n                strokeVertArray.push(cachedVertArray[j]);\n              }\n            }\n            if (doStroke) {\n              line3D(lineVertArray, \"LINE_LOOP\", strokeVertArray);\n            }\n\n            for (i = 2; (i+1) < vertArrayLength; i++) {\n              lineVertArray = [];\n              strokeVertArray = [];\n              lineVertArray.push(vertArray[0][0]);\n              lineVertArray.push(vertArray[0][1]);\n              lineVertArray.push(vertArray[0][2]);\n\n              strokeVertArray.push(vertArray[0][9]);\n              strokeVertArray.push(vertArray[0][10]);\n              strokeVertArray.push(vertArray[0][11]);\n              strokeVertArray.push(vertArray[0][12]);\n\n              for (j = 0; j < 2; j++) {\n                for (k = 0; k < 3; k++) {\n                  lineVertArray.push(vertArray[i+j][k]);\n                }\n              }\n              for (j = 0; j < 2; j++) {\n                for (k = 9; k < 13; k++) {\n                  strokeVertArray.push(vertArray[i+j][k]);\n                }\n              }\n              if (doStroke) {\n                line3D(lineVertArray, \"LINE_STRIP\",strokeVertArray);\n              }\n            }\n            if (doFill || usingTexture) {\n              fill3D(fillVertArray, \"TRIANGLE_FAN\", colorVertArray, texVertArray);\n            }\n          }\n        } else if (curShape === PConstants.QUADS) {\n          for (i = 0; (i + 3) < vertArrayLength; i+=4) {\n            lineVertArray = [];\n            for (j = 0; j < 4; j++) {\n              cachedVertArray = vertArray[i+j];\n              for (k = 0; k < 3; k++) {\n                lineVertArray.push(cachedVertArray[k]);\n              }\n            }\n            if (doStroke) {\n              line3D(lineVertArray, \"LINE_LOOP\",strokeVertArray);\n            }\n\n            if (doFill) {\n              fillVertArray = [];\n              colorVertArray = [];\n              texVertArray = [];\n              for (j = 0; j < 3; j++) {\n                fillVertArray.push(vertArray[i][j]);\n              }\n              for (j = 5; j < 9; j++) {\n                colorVertArray.push(vertArray[i][j]);\n              }\n\n              for (j = 0; j < 3; j++) {\n                fillVertArray.push(vertArray[i+1][j]);\n              }\n              for (j = 5; j < 9; j++) {\n                colorVertArray.push(vertArray[i+1][j]);\n              }\n\n              for (j = 0; j < 3; j++) {\n                fillVertArray.push(vertArray[i+3][j]);\n              }\n              for (j = 5; j < 9; j++) {\n                colorVertArray.push(vertArray[i+3][j]);\n              }\n\n              for (j = 0; j < 3; j++) {\n                fillVertArray.push(vertArray[i+2][j]);\n              }\n              for (j = 5; j < 9; j++) {\n                colorVertArray.push(vertArray[i+2][j]);\n              }\n\n              if (usingTexture) {\n                texVertArray.push(vertArray[i+0][3]);\n                texVertArray.push(vertArray[i+0][4]);\n                texVertArray.push(vertArray[i+1][3]);\n                texVertArray.push(vertArray[i+1][4]);\n                texVertArray.push(vertArray[i+3][3]);\n                texVertArray.push(vertArray[i+3][4]);\n                texVertArray.push(vertArray[i+2][3]);\n                texVertArray.push(vertArray[i+2][4]);\n              }\n\n              fill3D(fillVertArray, \"TRIANGLE_STRIP\", colorVertArray, texVertArray);\n            }\n          }\n        } else if (curShape === PConstants.QUAD_STRIP) {\n          var tempArray = [];\n          if (vertArrayLength > 3) {\n            for (i = 0; i < 2; i++) {\n              cachedVertArray = vertArray[i];\n              for (j = 0; j < 3; j++) {\n                lineVertArray.push(cachedVertArray[j]);\n              }\n            }\n\n            for (i = 0; i < 2; i++) {\n              cachedVertArray = vertArray[i];\n              for (j = 9; j < 13; j++) {\n                strokeVertArray.push(cachedVertArray[j]);\n              }\n            }\n\n            line3D(lineVertArray, \"LINE_STRIP\", strokeVertArray);\n            if (vertArrayLength > 4 && vertArrayLength % 2 > 0) {\n              tempArray = fillVertArray.splice(fillVertArray.length - 3);\n              vertArray.pop();\n            }\n            for (i = 0; (i+3) < vertArrayLength; i+=2) {\n              lineVertArray = [];\n              strokeVertArray = [];\n              for (j = 0; j < 3; j++) {\n                lineVertArray.push(vertArray[i+1][j]);\n              }\n              for (j = 0; j < 3; j++) {\n                lineVertArray.push(vertArray[i+3][j]);\n              }\n              for (j = 0; j < 3; j++) {\n                lineVertArray.push(vertArray[i+2][j]);\n              }\n              for (j = 0; j < 3; j++) {\n                lineVertArray.push(vertArray[i+0][j]);\n              }\n              for (j = 9; j < 13; j++) {\n                strokeVertArray.push(vertArray[i+1][j]);\n              }\n              for (j = 9; j < 13; j++) {\n                strokeVertArray.push(vertArray[i+3][j]);\n              }\n              for (j = 9; j < 13; j++) {\n                strokeVertArray.push(vertArray[i+2][j]);\n              }\n              for (j = 9; j < 13; j++) {\n                strokeVertArray.push(vertArray[i+0][j]);\n              }\n              if (doStroke) {\n                line3D(lineVertArray, \"LINE_STRIP\", strokeVertArray);\n              }\n            }\n\n            if (doFill || usingTexture) {\n              fill3D(fillVertArray, \"TRIANGLE_LIST\", colorVertArray, texVertArray);\n            }\n          }\n        }\n        // If the user didn't specify a type (LINES, TRIANGLES, etc)\n        else {\n          // If only one vertex was specified, it must be a point\n          if (vertArrayLength === 1) {\n            for (j = 0; j < 3; j++) {\n              lineVertArray.push(vertArray[0][j]);\n            }\n            for (j = 9; j < 13; j++) {\n              strokeVertArray.push(vertArray[0][j]);\n            }\n            point3D(lineVertArray,strokeVertArray);\n          } else {\n            for (i = 0; i < vertArrayLength; i++) {\n              cachedVertArray = vertArray[i];\n              for (j = 0; j < 3; j++) {\n                lineVertArray.push(cachedVertArray[j]);\n              }\n              for (j = 5; j < 9; j++) {\n                strokeVertArray.push(cachedVertArray[j]);\n              }\n            }\n            if (doStroke && closeShape) {\n              line3D(lineVertArray, \"LINE_LOOP\", strokeVertArray);\n            } else if (doStroke && !closeShape) {\n              line3D(lineVertArray, \"LINE_STRIP\", strokeVertArray);\n            }\n\n            // fill is ignored if textures are used\n            if (doFill || usingTexture) {\n              fill3D(fillVertArray, \"TRIANGLE_FAN\", colorVertArray, texVertArray);\n            }\n          }\n        }\n        // everytime beginShape is followed by a call to\n        // texture(), texturing it turned back on. We do this to\n        // figure out if the shape should be textured or filled\n        // with a color.\n        usingTexture = false;\n        curContext.useProgram(programObject3D);\n        uniformi(\"usingTexture3d\", programObject3D, \"uUsingTexture\", usingTexture);\n      }\n\n      // Reset some settings\n      isCurve = false;\n      isBezier = false;\n      curveVertArray = [];\n      curveVertCount = 0;\n    };\n\n    /**\n     * The function splineForward() setup forward-differencing matrix to be used for speedy\n     * curve rendering. It's based on using a specific number\n     * of curve segments and just doing incremental adds for each\n     * vertex of the segment, rather than running the mathematically\n     * expensive cubic equation. This function is used by both curveDetail and bezierDetail.\n     *\n     * @param {int} segments      number of curve segments to use when drawing\n     * @param {PMatrix3D} matrix  target object for the new matrix\n     */\n    var splineForward = function(segments, matrix) {\n      var f = 1.0 / segments;\n      var ff = f * f;\n      var fff = ff * f;\n\n      matrix.set(0, 0, 0, 1, fff, ff, f, 0, 6 * fff, 2 * ff, 0, 0, 6 * fff, 0, 0, 0);\n    };\n\n    /**\n     * The curveInit() function set the number of segments to use when drawing a Catmull-Rom\n     * curve, and setting the s parameter, which defines how tightly\n     * the curve fits to each vertex. Catmull-Rom curves are actually\n     * a subset of this curve type where the s is set to zero.\n     * This in an internal function used by curveDetail() and curveTightness().\n     */\n    var curveInit = function() {\n      // allocate only if/when used to save startup time\n      if (!curveDrawMatrix) {\n        curveBasisMatrix = new PMatrix3D();\n        curveDrawMatrix = new PMatrix3D();\n        curveInited = true;\n      }\n\n      var s = curTightness;\n      curveBasisMatrix.set((s - 1) / 2, (s + 3) / 2, (-3 - s) / 2, (1 - s) / 2,\n                           (1 - s), (-5 - s) / 2, (s + 2), (s - 1) / 2,\n                           (s - 1) / 2, 0, (1 - s) / 2, 0, 0, 1, 0, 0);\n\n      splineForward(curveDet, curveDrawMatrix);\n\n      if (!bezierBasisInverse) {\n        //bezierBasisInverse = bezierBasisMatrix.get();\n        //bezierBasisInverse.invert();\n        curveToBezierMatrix = new PMatrix3D();\n      }\n\n      // TODO only needed for PGraphicsJava2D? if so, move it there\n      // actually, it's generally useful for other renderers, so keep it\n      // or hide the implementation elsewhere.\n      curveToBezierMatrix.set(curveBasisMatrix);\n      curveToBezierMatrix.preApply(bezierBasisInverse);\n\n      // multiply the basis and forward diff matrices together\n      // saves much time since this needn't be done for each curve\n      curveDrawMatrix.apply(curveBasisMatrix);\n    };\n\n    /**\n     * Specifies vertex coordinates for Bezier curves. Each call to <b>bezierVertex()</b> defines the position of two control\n     * points and one anchor point of a Bezier curve, adding a new segment to a line or shape. The first time\n     * <b>bezierVertex()</b> is used within a <b>beginShape()</b> call, it must be prefaced with a call to <b>vertex()</b>\n     * to set the first anchor point. This function must be used between <b>beginShape()</b> and <b>endShape()</b> and only\n     * when there is no MODE parameter specified to <b>beginShape()</b>. Using the 3D version of requires rendering with P3D\n     * or OPENGL (see the Environment reference for more information). <br /> <br /> <b>NOTE: </b> Fill does not work properly yet.\n     *\n     * @param {float | int} cx1 The x-coordinate of 1st control point\n     * @param {float | int} cy1 The y-coordinate of 1st control point\n     * @param {float | int} cz1 The z-coordinate of 1st control point\n     * @param {float | int} cx2 The x-coordinate of 2nd control point\n     * @param {float | int} cy2 The y-coordinate of 2nd control point\n     * @param {float | int} cz2 The z-coordinate of 2nd control point\n     * @param {float | int} x   The x-coordinate of the anchor point\n     * @param {float | int} y   The y-coordinate of the anchor point\n     * @param {float | int} z   The z-coordinate of the anchor point\n     *\n     * @see curveVertex\n     * @see vertex\n     * @see bezier\n     */\n    Drawing2D.prototype.bezierVertex = function() {\n      isBezier = true;\n      var vert = [];\n      if (firstVert) {\n        throw (\"vertex() must be used at least once before calling bezierVertex()\");\n      }\n\n      for (var i = 0; i < arguments.length; i++) {\n        vert[i] = arguments[i];\n      }\n      vertArray.push(vert);\n      vertArray[vertArray.length -1].isVert = false;\n    };\n\n    Drawing3D.prototype.bezierVertex = function() {\n      isBezier = true;\n      var vert = [];\n      if (firstVert) {\n        throw (\"vertex() must be used at least once before calling bezierVertex()\");\n      }\n\n      if (arguments.length === 9) {\n        if (bezierDrawMatrix === undef) {\n          bezierDrawMatrix = new PMatrix3D();\n        }\n        // setup matrix for forward differencing to speed up drawing\n        var lastPoint = vertArray.length - 1;\n        splineForward( bezDetail, bezierDrawMatrix );\n        bezierDrawMatrix.apply( bezierBasisMatrix );\n        var draw = bezierDrawMatrix.array();\n        var x1 = vertArray[lastPoint][0],\n            y1 = vertArray[lastPoint][1],\n            z1 = vertArray[lastPoint][2];\n        var xplot1 = draw[4] * x1 + draw[5] * arguments[0] + draw[6] * arguments[3] + draw[7] * arguments[6];\n        var xplot2 = draw[8] * x1 + draw[9] * arguments[0] + draw[10]* arguments[3] + draw[11]* arguments[6];\n        var xplot3 = draw[12]* x1 + draw[13]* arguments[0] + draw[14]* arguments[3] + draw[15]* arguments[6];\n\n        var yplot1 = draw[4] * y1 + draw[5] * arguments[1] + draw[6] * arguments[4] + draw[7] * arguments[7];\n        var yplot2 = draw[8] * y1 + draw[9] * arguments[1] + draw[10]* arguments[4] + draw[11]* arguments[7];\n        var yplot3 = draw[12]* y1 + draw[13]* arguments[1] + draw[14]* arguments[4] + draw[15]* arguments[7];\n\n        var zplot1 = draw[4] * z1 + draw[5] * arguments[2] + draw[6] * arguments[5] + draw[7] * arguments[8];\n        var zplot2 = draw[8] * z1 + draw[9] * arguments[2] + draw[10]* arguments[5] + draw[11]* arguments[8];\n        var zplot3 = draw[12]* z1 + draw[13]* arguments[2] + draw[14]* arguments[5] + draw[15]* arguments[8];\n        for (var j = 0; j < bezDetail; j++) {\n          x1 += xplot1; xplot1 += xplot2; xplot2 += xplot3;\n          y1 += yplot1; yplot1 += yplot2; yplot2 += yplot3;\n          z1 += zplot1; zplot1 += zplot2; zplot2 += zplot3;\n          p.vertex(x1, y1, z1);\n        }\n        p.vertex(arguments[6], arguments[7], arguments[8]);\n      }\n    };\n\n    /**\n     * Sets a texture to be applied to vertex points. The <b>texture()</b> function\n     * must be called between <b>beginShape()</b> and <b>endShape()</b> and before\n     * any calls to vertex().\n     *\n     * When textures are in use, the fill color is ignored. Instead, use tint() to\n     * specify the color of the texture as it is applied to the shape.\n     *\n     * @param {PImage} pimage the texture to apply\n     *\n     * @returns none\n     *\n     * @see textureMode\n     * @see beginShape\n     * @see endShape\n     * @see vertex\n    */\n    p.texture = function(pimage) {\n      var curContext = drawing.$ensureContext();\n\n      if (pimage.__texture) {\n        curContext.bindTexture(curContext.TEXTURE_2D, pimage.__texture);\n      } else if (pimage.localName === \"canvas\") {\n        curContext.bindTexture(curContext.TEXTURE_2D, canTex);\n        curContext.texImage2D(curContext.TEXTURE_2D, 0, curContext.RGBA, curContext.RGBA, curContext.UNSIGNED_BYTE, pimage);\n        curContext.texParameteri(curContext.TEXTURE_2D, curContext.TEXTURE_MAG_FILTER, curContext.LINEAR);\n        curContext.texParameteri(curContext.TEXTURE_2D, curContext.TEXTURE_MIN_FILTER, curContext.LINEAR);\n        curContext.generateMipmap(curContext.TEXTURE_2D);\n        curTexture.width = pimage.width;\n        curTexture.height = pimage.height;\n      } else {\n        var texture = curContext.createTexture(),\n            cvs = document.createElement('canvas'),\n            cvsTextureCtx = cvs.getContext('2d'),\n            pot;\n\n        // WebGL requires power of two textures\n        if (pimage.width & (pimage.width-1) === 0) {\n          cvs.width = pimage.width;\n        } else {\n          pot = 1;\n          while (pot < pimage.width) {\n            pot *= 2;\n          }\n          cvs.width = pot;\n        }\n\n        if (pimage.height & (pimage.height-1) === 0) {\n          cvs.height = pimage.height;\n        } else {\n          pot = 1;\n          while (pot < pimage.height) {\n            pot *= 2;\n          }\n          cvs.height = pot;\n        }\n\n        cvsTextureCtx.drawImage(pimage.sourceImg, 0, 0, pimage.width, pimage.height, 0, 0, cvs.width, cvs.height);\n\n        curContext.bindTexture(curContext.TEXTURE_2D, texture);\n        curContext.texParameteri(curContext.TEXTURE_2D, curContext.TEXTURE_MIN_FILTER, curContext.LINEAR_MIPMAP_LINEAR);\n        curContext.texParameteri(curContext.TEXTURE_2D, curContext.TEXTURE_MAG_FILTER, curContext.LINEAR);\n        curContext.texParameteri(curContext.TEXTURE_2D, curContext.TEXTURE_WRAP_T, curContext.CLAMP_TO_EDGE);\n        curContext.texParameteri(curContext.TEXTURE_2D, curContext.TEXTURE_WRAP_S, curContext.CLAMP_TO_EDGE);\n        curContext.texImage2D(curContext.TEXTURE_2D, 0, curContext.RGBA, curContext.RGBA, curContext.UNSIGNED_BYTE, cvs);\n        curContext.generateMipmap(curContext.TEXTURE_2D);\n\n        pimage.__texture = texture;\n        curTexture.width = pimage.width;\n        curTexture.height = pimage.height;\n      }\n\n      usingTexture = true;\n      curContext.useProgram(programObject3D);\n      uniformi(\"usingTexture3d\", programObject3D, \"uUsingTexture\", usingTexture);\n    };\n\n    /**\n     * Sets the coordinate space for texture mapping. There are two options, IMAGE,\n     * which refers to the actual coordinates of the image, and NORMALIZED, which\n     * refers to a normalized space of values ranging from 0 to 1. The default mode\n     * is IMAGE. In IMAGE, if an image is 100 x 200 pixels, mapping the image onto\n     * the entire size of a quad would require the points (0,0) (0,100) (100,200) (0,200).\n     * The same mapping in NORMAL_SPACE is (0,0) (0,1) (1,1) (0,1).\n     *\n     * @param MODE either IMAGE or NORMALIZED\n     *\n     * @returns none\n     *\n     * @see texture\n    */\n    p.textureMode = function(mode){\n      curTextureMode = mode;\n    };\n    /**\n     * The curveVertexSegment() function handle emitting a specific segment of Catmull-Rom curve. Internal helper function used by <b>curveVertex()</b>.\n     */\n    var curveVertexSegment = function(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4) {\n      var x0 = x2;\n      var y0 = y2;\n      var z0 = z2;\n\n      var draw = curveDrawMatrix.array();\n\n      var xplot1 = draw[4] * x1 + draw[5] * x2 + draw[6] * x3 + draw[7] * x4;\n      var xplot2 = draw[8] * x1 + draw[9] * x2 + draw[10] * x3 + draw[11] * x4;\n      var xplot3 = draw[12] * x1 + draw[13] * x2 + draw[14] * x3 + draw[15] * x4;\n\n      var yplot1 = draw[4] * y1 + draw[5] * y2 + draw[6] * y3 + draw[7] * y4;\n      var yplot2 = draw[8] * y1 + draw[9] * y2 + draw[10] * y3 + draw[11] * y4;\n      var yplot3 = draw[12] * y1 + draw[13] * y2 + draw[14] * y3 + draw[15] * y4;\n\n      var zplot1 = draw[4] * z1 + draw[5] * z2 + draw[6] * z3 + draw[7] * z4;\n      var zplot2 = draw[8] * z1 + draw[9] * z2 + draw[10] * z3 + draw[11] * z4;\n      var zplot3 = draw[12] * z1 + draw[13] * z2 + draw[14] * z3 + draw[15] * z4;\n\n      p.vertex(x0, y0, z0);\n      for (var j = 0; j < curveDet; j++) {\n        x0 += xplot1; xplot1 += xplot2; xplot2 += xplot3;\n        y0 += yplot1; yplot1 += yplot2; yplot2 += yplot3;\n        z0 += zplot1; zplot1 += zplot2; zplot2 += zplot3;\n        p.vertex(x0, y0, z0);\n      }\n    };\n\n    /**\n     * Specifies vertex coordinates for curves. This function may only be used between <b>beginShape()</b> and\n     * <b>endShape()</b> and only when there is no MODE parameter specified to <b>beginShape()</b>. The first and last points\n     * in a series of <b>curveVertex()</b> lines will be used to guide the beginning and end of a the curve. A minimum of four\n     * points is required to draw a tiny curve between the second and third points. Adding a fifth point with\n     * <b>curveVertex()</b> will draw the curve between the second, third, and fourth points. The <b>curveVertex()</b> function\n     * is an implementation of Catmull-Rom splines. Using the 3D version of requires rendering with P3D or OPENGL (see the\n     * Environment reference for more information). <br /> <br /><b>NOTE: </b> Fill does not work properly yet.\n     *\n     * @param {float | int} x The x-coordinate of the vertex\n     * @param {float | int} y The y-coordinate of the vertex\n     * @param {float | int} z The z-coordinate of the vertex\n     *\n     * @see curve\n     * @see beginShape\n     * @see endShape\n     * @see vertex\n     * @see bezierVertex\n     */\n    Drawing2D.prototype.curveVertex = function(x, y) {\n      isCurve = true;\n\n      p.vertex(x, y);\n    };\n\n    Drawing3D.prototype.curveVertex = function(x, y, z) {\n      isCurve = true;\n\n      if (!curveInited) {\n        curveInit();\n      }\n      var vert = [];\n      vert[0] = x;\n      vert[1] = y;\n      vert[2] = z;\n      curveVertArray.push(vert);\n      curveVertCount++;\n\n      if (curveVertCount > 3) {\n        curveVertexSegment( curveVertArray[curveVertCount-4][0],\n                            curveVertArray[curveVertCount-4][1],\n                            curveVertArray[curveVertCount-4][2],\n                            curveVertArray[curveVertCount-3][0],\n                            curveVertArray[curveVertCount-3][1],\n                            curveVertArray[curveVertCount-3][2],\n                            curveVertArray[curveVertCount-2][0],\n                            curveVertArray[curveVertCount-2][1],\n                            curveVertArray[curveVertCount-2][2],\n                            curveVertArray[curveVertCount-1][0],\n                            curveVertArray[curveVertCount-1][1],\n                            curveVertArray[curveVertCount-1][2] );\n      }\n    };\n\n    /**\n     * The curve() function draws a curved line on the screen. The first and second parameters\n     * specify the beginning control point and the last two parameters specify\n     * the ending control point. The middle parameters specify the start and\n     * stop of the curve. Longer curves can be created by putting a series of\n     * <b>curve()</b> functions together or using <b>curveVertex()</b>.\n     * An additional function called <b>curveTightness()</b> provides control\n     * for the visual quality of the curve. The <b>curve()</b> function is an\n     * implementation of Catmull-Rom splines. Using the 3D version of requires\n     * rendering with P3D or OPENGL (see the Environment reference for more\n     * information).\n     *\n     * @param {int|float} x1 coordinates for the beginning control point\n     * @param {int|float} y1 coordinates for the beginning control point\n     * @param {int|float} z1 coordinates for the beginning control point\n     * @param {int|float} x2 coordinates for the first point\n     * @param {int|float} y2 coordinates for the first point\n     * @param {int|float} z2 coordinates for the first point\n     * @param {int|float} x3 coordinates for the second point\n     * @param {int|float} y3 coordinates for the second point\n     * @param {int|float} z3 coordinates for the second point\n     * @param {int|float} x4 coordinates for the ending control point\n     * @param {int|float} y4 coordinates for the ending control point\n     * @param {int|float} z4 coordinates for the ending control point\n     *\n     * @see #curveVertex()\n     * @see #curveTightness()\n     * @see #bezier()\n     */\n    Drawing2D.prototype.curve = function(x1, y1, x2, y2, x3, y3, x4, y4) {\n      p.beginShape();\n      p.curveVertex(x1, y1);\n      p.curveVertex(x2, y2);\n      p.curveVertex(x3, y3);\n      p.curveVertex(x4, y4);\n      p.endShape();\n    };\n\n    Drawing3D.prototype.curve = function(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4) {\n      if (z4 !== undef) {\n        p.beginShape();\n        p.curveVertex(x1, y1, z1);\n        p.curveVertex(x2, y2, z2);\n        p.curveVertex(x3, y3, z3);\n        p.curveVertex(x4, y4, z4);\n        p.endShape();\n        return;\n      }\n      p.beginShape();\n      p.curveVertex(x1, y1);\n      p.curveVertex(z1, x2);\n      p.curveVertex(y2, z2);\n      p.curveVertex(x3, y3);\n      p.endShape();\n    };\n\n    /**\n     * The curveTightness() function modifies the quality of forms created with <b>curve()</b> and\n     * <b>curveVertex()</b>. The parameter <b>squishy</b> determines how the\n     * curve fits to the vertex points. The value 0.0 is the default value for\n     * <b>squishy</b> (this value defines the curves to be Catmull-Rom splines)\n     * and the value 1.0 connects all the points with straight lines.\n     * Values within the range -5.0 and 5.0 will deform the curves but\n     * will leave them recognizable and as values increase in magnitude,\n     * they will continue to deform.\n     *\n     * @param {float} tightness amount of deformation from the original vertices\n     *\n     * @see #curve()\n     * @see #curveVertex()\n     *\n     */\n    p.curveTightness = function(tightness) {\n      curTightness = tightness;\n    };\n\n    /**\n     * The curveDetail() function sets the resolution at which curves display. The default value is 20.\n     * This function is only useful when using the P3D or OPENGL renderer.\n     *\n     * @param {int} detail resolution of the curves\n     *\n     * @see curve()\n     * @see curveVertex()\n     * @see curveTightness()\n     */\n    p.curveDetail = function(detail) {\n      curveDet = detail;\n      curveInit();\n    };\n\n    /**\n    * Modifies the location from which rectangles draw. The default mode is rectMode(CORNER), which\n    * specifies the location to be the upper left corner of the shape and uses the third and fourth\n    * parameters of rect() to specify the width and height. The syntax rectMode(CORNERS) uses the\n    * first and second parameters of rect() to set the location of one corner and uses the third and\n    * fourth parameters to set the opposite corner. The syntax rectMode(CENTER) draws the image from\n    * its center point and uses the third and forth parameters of rect() to specify the image's width\n    * and height. The syntax rectMode(RADIUS) draws the image from its center point and uses the third\n    * and forth parameters of rect()  to specify half of the image's width and height. The parameter must\n    * be written in ALL CAPS because Processing is a case sensitive language. Note: In version 125, the\n    * mode named CENTER_RADIUS was shortened to RADIUS.\n    *\n    * @param {MODE} MODE      Either CORNER, CORNERS, CENTER, or RADIUS\n    *\n    * @see rect\n    */\n    p.rectMode = function(aRectMode) {\n      curRectMode = aRectMode;\n    };\n\n    /**\n    * Modifies the location from which images draw. The default mode is imageMode(CORNER), which specifies\n    * the location to be the upper left corner and uses the fourth and fifth parameters of image() to set\n    * the image's width and height. The syntax imageMode(CORNERS) uses the second and third parameters of\n    * image() to set the location of one corner of the image and uses the fourth and fifth parameters to\n    * set the opposite corner. Use imageMode(CENTER) to draw images centered at the given x and y position.\n    * The parameter to imageMode() must be written in ALL CAPS because Processing is a case sensitive language.\n    *\n    * @param {MODE} MODE      Either CORNER, CORNERS, or CENTER\n    *\n    * @see loadImage\n    * @see PImage\n    * @see image\n    * @see background\n    */\n    p.imageMode = function(mode) {\n      switch (mode) {\n      case PConstants.CORNER:\n        imageModeConvert = imageModeCorner;\n        break;\n      case PConstants.CORNERS:\n        imageModeConvert = imageModeCorners;\n        break;\n      case PConstants.CENTER:\n        imageModeConvert = imageModeCenter;\n        break;\n      default:\n        throw \"Invalid imageMode\";\n      }\n    };\n\n    /**\n    * The origin of the ellipse is modified by the ellipseMode() function. The default configuration is\n    * ellipseMode(CENTER), which specifies the location of the ellipse as the center of the shape. The RADIUS\n    * mode is the same, but the width and height parameters to ellipse()  specify the radius of the ellipse,\n    * rather than the diameter. The CORNER mode draws the shape from the upper-left corner of its bounding box.\n    * The CORNERS mode uses the four parameters to ellipse() to set two opposing corners of the ellipse's bounding\n    * box. The parameter must be written in \"ALL CAPS\" because Processing is a case sensitive language.\n    *\n    * @param {MODE} MODE      Either CENTER, RADIUS, CORNER, or CORNERS.\n    *\n    * @see ellipse\n    */\n    p.ellipseMode = function(aEllipseMode) {\n      curEllipseMode = aEllipseMode;\n    };\n\n    /**\n     * The arc() function draws an arc in the display window.\n     * Arcs are drawn along the outer edge of an ellipse defined by the\n     * <b>x</b>, <b>y</b>, <b>width</b> and <b>height</b> parameters.\n     * The origin or the arc's ellipse may be changed with the\n     * <b>ellipseMode()</b> function.\n     * The <b>start</b> and <b>stop</b> parameters specify the angles\n     * at which to draw the arc.\n     *\n     * @param {float} a       x-coordinate of the arc's ellipse\n     * @param {float} b       y-coordinate of the arc's ellipse\n     * @param {float} c       width of the arc's ellipse\n     * @param {float} d       height of the arc's ellipse\n     * @param {float} start   angle to start the arc, specified in radians\n     * @param {float} stop    angle to stop the arc, specified in radians\n     * @param {enum}  mode    drawing mode (OPEN, CHORD, PIE)\n     *\n     * @see #ellipseMode()\n     * @see #ellipse()\n     */\n    p.arc = function(x, y, width, height, start, stop, mode) {\n      if (width <= 0 || stop < start) { return; }\n\n      if (curEllipseMode === PConstants.CORNERS) {\n        width = width - x;\n        height = height - y;\n      } else if (curEllipseMode === PConstants.RADIUS) {\n        x = x - width;\n        y = y - height;\n        width = width * 2;\n        height = height * 2;\n      } else if (curEllipseMode === PConstants.CENTER) {\n        x = x - width/2;\n        y = y - height/2;\n      }\n      // make sure that we're starting at a useful point\n      while (start < 0) {\n        start += PConstants.TWO_PI;\n        stop += PConstants.TWO_PI;\n      }\n      if (stop - start > PConstants.TWO_PI) {\n        // don't change start, it is visible in PIE mode\n        stop = start + PConstants.TWO_PI;\n      }\n      var hr = width / 2,\n          vr = height / 2,\n          centerX = x + hr,\n          centerY = y + vr,\n          step = 1/(hr+vr);\n\n      var drawSlice = (function(x, y, start, step, stop) {\n        return function(p, closed, i, a, e) {\n          i = 0;\n          a = start;\n          e = stop + step;\n          p.beginShape();\n          if(closed) { p.vertex(x-0.5, y-0.5); }\n          for (; a < e; i++, a = i*step + start) {\n            p.vertex(\n              (x + Math.cos(a) * hr)|0,\n              (y + Math.sin(a) * vr)|0\n            );\n          }\n\n          if (mode === PConstants.OPEN && doFill) {\n            p.vertex(centerX + Math.cos(start) * hr, centerY + Math.sin(start) * vr);\n          } else if (mode === PConstants.CHORD) {\n            p.vertex(centerX + Math.cos(start) * hr, centerY + Math.sin(start) * vr);\n          } else if (mode === PConstants.PIE) {\n            p.line(centerX + Math.cos(start) * hr, centerY + Math.sin(start) * vr, centerX, centerY);\n            p.line(centerX, centerY, centerX + Math.cos(stop) * hr, centerY + Math.sin(stop) * vr);\n          } \n\n          p.endShape(closed ? PConstants.CLOSE : undefined);\n        };\n      }(centerX+0.5, centerY+0.5, start, step, stop));\n\n      if (doFill) {\n        var savedStroke = doStroke;\n        doStroke = false;\n        drawSlice(p, true);\n        doStroke = savedStroke;\n      }\n\n      if (doStroke) {\n        var savedFill = doFill;\n        doFill = false;\n        drawSlice(p);\n        doFill = savedFill;\n      }\n    };\n\n    /**\n    * Draws a line (a direct path between two points) to the screen. The version of line() with four parameters\n    * draws the line in 2D. To color a line, use the stroke() function. A line cannot be filled, therefore the\n    * fill()  method will not affect the color of a line. 2D lines are drawn with a width of one pixel by default,\n    * but this can be changed with the strokeWeight()  function. The version with six parameters allows the line\n    * to be placed anywhere within XYZ space. Drawing this shape in 3D using the z parameter requires the P3D or\n    * OPENGL parameter in combination with size.\n    *\n    * @param {int|float} x1       x-coordinate of the first point\n    * @param {int|float} y1       y-coordinate of the first point\n    * @param {int|float} z1       z-coordinate of the first point\n    * @param {int|float} x2       x-coordinate of the second point\n    * @param {int|float} y2       y-coordinate of the second point\n    * @param {int|float} z2       z-coordinate of the second point\n    *\n    * @see strokeWeight\n    * @see strokeJoin\n    * @see strokeCap\n    * @see beginShape\n    */\n    Drawing2D.prototype.line = function(x1, y1, x2, y2) {\n      if (!doStroke) {\n        return;\n      }\n      if (!renderSmooth) {\n        x1 = Math.round(x1);\n        x2 = Math.round(x2);\n        y1 = Math.round(y1);\n        y2 = Math.round(y2);\n      }\n\n      // A line is only defined if it has different start and end coordinates.\n      // If they are the same, we call point instead.\n      if (x1 === x2 && y1 === y2) {\n        p.point(x1, y1);\n        return;\n      }\n\n      var swap = undef,\n          lineCap = undef,\n          drawCrisp = true,\n          currentModelView = modelView.array(),\n          identityMatrix = [1, 0, 0, 0, 1, 0];\n      // Test if any transformations have been applied to the sketch\n      for (var i = 0; i < 6 && drawCrisp; i++) {\n        drawCrisp = currentModelView[i] === identityMatrix[i];\n      }\n      /* Draw crisp lines if the line is vertical or horizontal with the following method\n       * If any transformations have been applied to the sketch, don't make the line crisp\n       * If the line is directed up or to the left, reverse it by swapping x1/x2 or y1/y2\n       * Make the line 1 pixel longer to work around cross-platform canvas implementations\n       * If the lineWidth is odd, translate the line by 0.5 in the perpendicular direction\n       * Even lineWidths do not need to be translated because the canvas will draw them on pixel boundaries\n       * Change the cap to butt-end to work around cross-platform canvas implementations\n       * Reverse the translate and lineCap canvas state changes after drawing the line\n       */\n      if (drawCrisp) {\n        if (x1 === x2) {\n          if (y1 > y2) {\n            swap = y1;\n            y1 = y2;\n            y2 = swap;\n          }\n          y2++;\n          if (lineWidth % 2 === 1) {\n            curContext.translate(0.5, 0.0);\n          }\n        } else if (y1 === y2) {\n          if (x1 > x2) {\n            swap = x1;\n            x1 = x2;\n            x2 = swap;\n          }\n          x2++;\n          if (lineWidth % 2 === 1) {\n            curContext.translate(0.0, 0.5);\n          }\n        }\n        if (lineWidth === 1) {\n          lineCap = curContext.lineCap;\n          curContext.lineCap = 'butt';\n        }\n      }\n      curContext.beginPath();\n      curContext.moveTo(x1 || 0, y1 || 0);\n      curContext.lineTo(x2 || 0, y2 || 0);\n      executeContextStroke();\n      if (drawCrisp) {\n        if (x1 === x2 && lineWidth % 2 === 1) {\n          curContext.translate(-0.5, 0.0);\n        } else if (y1 === y2 && lineWidth % 2 === 1) {\n          curContext.translate(0.0, -0.5);\n        }\n        if (lineWidth === 1) {\n          curContext.lineCap = lineCap;\n        }\n      }\n    };\n\n    Drawing3D.prototype.line = function(x1, y1, z1, x2, y2, z2) {\n      if (y2 === undef || z2 === undef) { // 2D line called in 3D context\n        z2 = 0;\n        y2 = x2;\n        x2 = z1;\n        z1 = 0;\n      }\n\n      // a line is only defined if it has different start and end coordinates.\n      // If they are the same, we call point instead.\n      if (x1===x2 && y1===y2 && z1===z2) {\n        p.point(x1,y1,z1);\n        return;\n      }\n\n      var lineVerts = [x1, y1, z1, x2, y2, z2];\n\n      var view = new PMatrix3D();\n      view.scale(1, -1, 1);\n      view.apply(modelView.array());\n      view.transpose();\n\n      if (lineWidth > 0 && doStroke) {\n        curContext.useProgram(programObject2D);\n\n        uniformMatrix(\"uModel2d\", programObject2D, \"uModel\", false, [1,0,0,0,  0,1,0,0,  0,0,1,0,  0,0,0,1]);\n        uniformMatrix(\"uView2d\", programObject2D, \"uView\", false, view.array());\n\n        uniformf(\"uColor2d\", programObject2D, \"uColor\", strokeStyle);\n        uniformi(\"uIsDrawingText\", programObject2D, \"uIsDrawingText\", false);\n\n        vertexAttribPointer(\"aVertex2d\", programObject2D, \"aVertex\", 3, lineBuffer);\n        disableVertexAttribPointer(\"aTextureCoord2d\", programObject2D, \"aTextureCoord\");\n\n        curContext.bufferData(curContext.ARRAY_BUFFER, new Float32Array(lineVerts), curContext.STREAM_DRAW);\n        curContext.drawArrays(curContext.LINES, 0, 2);\n      }\n    };\n\n    /**\n     * Draws a Bezier curve on the screen. These curves are defined by a series of anchor and control points. The first\n     * two parameters specify the first anchor point and the last two parameters specify the other anchor point. The\n     * middle parameters specify the control points which define the shape of the curve. Bezier curves were developed\n     * by French engineer Pierre Bezier. Using the 3D version of requires rendering with P3D or OPENGL (see the\n     * Environment reference for more information).\n     *\n     * @param {int | float} x1,y1,z1    coordinates for the first anchor point\n     * @param {int | float} cx1,cy1,cz1 coordinates for the first control point\n     * @param {int | float} cx2,cy2,cz2 coordinates for the second control point\n     * @param {int | float} x2,y2,z2    coordinates for the second anchor point\n     *\n     * @see bezierVertex\n     * @see curve\n     */\n    Drawing2D.prototype.bezier = function() {\n      if (arguments.length !== 8) {\n        throw(\"You must use 8 parameters for bezier() in 2D mode\");\n      }\n\n      p.beginShape();\n      p.vertex( arguments[0], arguments[1] );\n      p.bezierVertex( arguments[2], arguments[3],\n                      arguments[4], arguments[5],\n                      arguments[6], arguments[7] );\n      p.endShape();\n    };\n\n    Drawing3D.prototype.bezier = function() {\n      if (arguments.length !== 12) {\n        throw(\"You must use 12 parameters for bezier() in 3D mode\");\n      }\n\n      p.beginShape();\n      p.vertex( arguments[0], arguments[1], arguments[2] );\n      p.bezierVertex( arguments[3], arguments[4], arguments[5],\n                      arguments[6], arguments[7], arguments[8],\n                      arguments[9], arguments[10], arguments[11] );\n      p.endShape();\n    };\n\n    /**\n     * Sets the resolution at which Beziers display. The default value is 20. This function is only useful when using the P3D\n     * or OPENGL renderer as the default (JAVA2D) renderer does not use this information.\n     *\n     * @param {int} detail resolution of the curves\n     *\n     * @see curve\n     * @see curveVertex\n     * @see curveTightness\n     */\n    p.bezierDetail = function( detail ){\n      bezDetail = detail;\n    };\n\n    /**\n     * The bezierPoint() function evalutes quadratic bezier at point t for points a, b, c, d.\n     * The parameter t varies between 0 and 1. The a and d parameters are the\n     * on-curve points, b and c are the control points. To make a two-dimensional\n     * curve, call this function once with the x coordinates and a second time\n     * with the y coordinates to get the location of a bezier curve at t.\n     *\n     * @param {float} a   coordinate of first point on the curve\n     * @param {float} b   coordinate of first control point\n     * @param {float} c   coordinate of second control point\n     * @param {float} d   coordinate of second point on the curve\n     * @param {float} t   value between 0 and 1\n     *\n     * @see #bezier()\n     * @see #bezierVertex()\n     * @see #curvePoint()\n     */\n    p.bezierPoint = function(a, b, c, d, t) {\n      return (1 - t) * (1 - t) * (1 - t) * a + 3 * (1 - t) * (1 - t) * t * b + 3 * (1 - t) * t * t * c + t * t * t * d;\n    };\n\n    /**\n     * The bezierTangent() function calculates the tangent of a point on a Bezier curve. There is a good\n     * definition of \"tangent\" at Wikipedia: <a href=\"http://en.wikipedia.org/wiki/Tangent\" target=\"new\">http://en.wikipedia.org/wiki/Tangent</a>\n     *\n     * @param {float} a   coordinate of first point on the curve\n     * @param {float} b   coordinate of first control point\n     * @param {float} c   coordinate of second control point\n     * @param {float} d   coordinate of second point on the curve\n     * @param {float} t   value between 0 and 1\n     *\n     * @see #bezier()\n     * @see #bezierVertex()\n     * @see #curvePoint()\n     */\n    p.bezierTangent = function(a, b, c, d, t) {\n      return (3 * t * t * (-a + 3 * b - 3 * c + d) + 6 * t * (a - 2 * b + c) + 3 * (-a + b));\n    };\n\n    /**\n     * The curvePoint() function evalutes the Catmull-Rom curve at point t for points a, b, c, d. The\n     * parameter t varies between 0 and 1, a and d are points on the curve,\n     * and b and c are the control points. This can be done once with the x\n     * coordinates and a second time with the y coordinates to get the\n     * location of a curve at t.\n     *\n     * @param {int|float} a   coordinate of first point on the curve\n     * @param {int|float} b   coordinate of second point on the curve\n     * @param {int|float} c   coordinate of third point on the curve\n     * @param {int|float} d   coordinate of fourth point on the curve\n     * @param {float} t       value between 0 and 1\n     *\n     * @see #curve()\n     * @see #curveVertex()\n     * @see #bezierPoint()\n     */\n    p.curvePoint = function(a, b, c, d, t) {\n      return 0.5 * ((2 * b) + (-a + c) * t + (2 * a - 5 * b + 4 * c - d) * t * t + (-a + 3 * b - 3 * c + d) * t * t * t);\n    };\n\n    /**\n     * The curveTangent() function calculates the tangent of a point on a Catmull-Rom curve.\n     * There is a good definition of \"tangent\" at Wikipedia: <a href=\"http://en.wikipedia.org/wiki/Tangent\" target=\"new\">http://en.wikipedia.org/wiki/Tangent</a>.\n     *\n     * @param {int|float} a   coordinate of first point on the curve\n     * @param {int|float} b   coordinate of first control point\n     * @param {int|float} c   coordinate of second control point\n     * @param {int|float} d   coordinate of second point on the curve\n     * @param {float} t       value between 0 and 1\n     *\n     * @see #curve()\n     * @see #curveVertex()\n     * @see #curvePoint()\n     * @see #bezierTangent()\n     */\n    p.curveTangent = function(a, b, c, d, t) {\n      return 0.5 * ((-a + c) + 2 * (2 * a - 5 * b + 4 * c - d) * t + 3 * (-a + 3 * b - 3 * c + d) * t * t);\n    };\n\n    /**\n     * A triangle is a plane created by connecting three points. The first two arguments specify the first point,\n     * the middle two arguments specify the second point, and the last two arguments specify the third point.\n     *\n     * @param {int | float} x1 x-coordinate of the first point\n     * @param {int | float} y1 y-coordinate of the first point\n     * @param {int | float} x2 x-coordinate of the second point\n     * @param {int | float} y2 y-coordinate of the second point\n     * @param {int | float} x3 x-coordinate of the third point\n     * @param {int | float} y3 y-coordinate of the third point\n     */\n    p.triangle = function(x1, y1, x2, y2, x3, y3) {\n      p.beginShape(PConstants.TRIANGLES);\n      p.vertex(x1, y1, 0);\n      p.vertex(x2, y2, 0);\n      p.vertex(x3, y3, 0);\n      p.endShape();\n    };\n\n    /**\n     * A quad is a quadrilateral, a four sided polygon. It is similar to a rectangle, but the angles between its\n     * edges are not constrained to ninety degrees. The first pair of parameters (x1,y1) sets the first vertex\n     * and the subsequent pairs should proceed clockwise or counter-clockwise around the defined shape.\n     *\n     * @param {float | int} x1 x-coordinate of the first corner\n     * @param {float | int} y1 y-coordinate of the first corner\n     * @param {float | int} x2 x-coordinate of the second corner\n     * @param {float | int} y2 y-coordinate of the second corner\n     * @param {float | int} x3 x-coordinate of the third corner\n     * @param {float | int} y3 y-coordinate of the third corner\n     * @param {float | int} x4 x-coordinate of the fourth corner\n     * @param {float | int} y4 y-coordinate of the fourth corner\n     */\n    p.quad = function(x1, y1, x2, y2, x3, y3, x4, y4) {\n      p.beginShape(PConstants.QUADS);\n      p.vertex(x1, y1, 0);\n      p.vertex(x2, y2, 0);\n      p.vertex(x3, y3, 0);\n      p.vertex(x4, y4, 0);\n      p.endShape();\n    };\n\n    var roundedRect$2d = function(x, y, width, height, tl, tr, br, bl) {\n      if (bl === undef) {\n        tr = tl;\n        br = tl;\n        bl = tl;\n      }\n      var halfWidth = width / 2,\n          halfHeight = height / 2;\n      if (tl > halfWidth || tl > halfHeight) {\n        tl = Math.min(halfWidth, halfHeight);\n      }\n      if (tr > halfWidth || tr > halfHeight) {\n        tr = Math.min(halfWidth, halfHeight);\n      }\n      if (br > halfWidth || br > halfHeight) {\n        br = Math.min(halfWidth, halfHeight);\n      }\n      if (bl > halfWidth || bl > halfHeight) {\n        bl = Math.min(halfWidth, halfHeight);\n      }\n      // Translate the stroke by (0.5, 0.5) to draw a crisp border\n      if (!doFill || doStroke) {\n        curContext.translate(0.5, 0.5);\n      }\n      curContext.beginPath();\n      curContext.moveTo(x + tl, y);\n      curContext.lineTo(x + width - tr, y);\n      curContext.quadraticCurveTo(x + width, y, x + width, y + tr);\n      curContext.lineTo(x + width, y + height - br);\n      curContext.quadraticCurveTo(x + width, y + height, x + width - br, y + height);\n      curContext.lineTo(x + bl, y + height);\n      curContext.quadraticCurveTo(x, y + height, x, y + height - bl);\n      curContext.lineTo(x, y + tl);\n      curContext.quadraticCurveTo(x, y, x + tl, y);\n      if (!doFill || doStroke) {\n        curContext.translate(-0.5, -0.5);\n      }\n      executeContextFill();\n      executeContextStroke();\n    };\n\n    /**\n    * Draws a rectangle to the screen. A rectangle is a four-sided shape with every angle at ninety\n    * degrees. The first two parameters set the location, the third sets the width, and the fourth\n    * sets the height. The origin is changed with the rectMode() function.\n    *\n    * @param {int|float} x        x-coordinate of the rectangle\n    * @param {int|float} y        y-coordinate of the rectangle\n    * @param {int|float} width    width of the rectangle\n    * @param {int|float} height   height of the rectangle\n    *\n    * @see rectMode\n    * @see quad\n    */\n    Drawing2D.prototype.rect = function(x, y, width, height, tl, tr, br, bl) {\n      // width and height need to be defined, numerical values\n      if (width!=''+width && height!=''+height) {\n        return;\n      }\n\n      if (curRectMode === PConstants.CORNERS) {\n        width -= x;\n        height -= y;\n      } else if (curRectMode === PConstants.RADIUS) {\n        width *= 2;\n        height *= 2;\n        x -= width / 2;\n        y -= height / 2;\n      } else if (curRectMode === PConstants.CENTER) {\n        x -= width / 2;\n        y -= height / 2;\n      }\n\n      if (!renderSmooth) {\n        x = Math.round(x);\n        y = Math.round(y);\n        width = Math.round(width);\n        height = Math.round(height);\n      }\n      if (tl !== undef) {\n        roundedRect$2d(x, y, width, height, tl, tr, br, bl);\n        return;\n      }\n\n//      if (width < 0) { x += width; width = -width; }\n//      if (height < 0) { y += height; height = -height; }\n\n      console.log(x,y,width,height);\n\n      // Translate the line by (0.5, 0.5) to draw a crisp rectangle border\n      if (doStroke && lineWidth % 2 === 1) {\n        curContext.translate(0.5, 0.5);\n      }\n      curContext.beginPath();\n      curContext.rect(x, y, width, height);\n      executeContextFill();\n      executeContextStroke();\n      if (doStroke && lineWidth % 2 === 1) {\n        curContext.translate(-0.5, -0.5);\n      }\n    };\n\n    Drawing3D.prototype.rect = function(x, y, width, height, tl, tr, br, bl) {\n      if (tl !== undef) {\n        throw \"rect() with rounded corners is not supported in 3D mode\";\n      }\n\n      if (curRectMode === PConstants.CORNERS) {\n        width -= x;\n        height -= y;\n      } else if (curRectMode === PConstants.RADIUS) {\n        width *= 2;\n        height *= 2;\n        x -= width / 2;\n        y -= height / 2;\n      } else if (curRectMode === PConstants.CENTER) {\n        x -= width / 2;\n        y -= height / 2;\n      }\n\n      // Modeling transformation\n      var model = new PMatrix3D();\n      model.translate(x, y, 0);\n      model.scale(width, height, 1);\n      model.transpose();\n\n      // viewing transformation needs to have Y flipped\n      // becuase that's what Processing does.\n      var view = new PMatrix3D();\n      view.scale(1, -1, 1);\n      view.apply(modelView.array());\n      view.transpose();\n\n      if (lineWidth > 0 && doStroke) {\n        curContext.useProgram(programObject2D);\n        uniformMatrix(\"uModel2d\", programObject2D, \"uModel\", false, model.array());\n        uniformMatrix(\"uView2d\", programObject2D, \"uView\", false, view.array());\n        uniformf(\"uColor2d\", programObject2D, \"uColor\", strokeStyle);\n        uniformi(\"uIsDrawingText2d\", programObject2D, \"uIsDrawingText\", false);\n        vertexAttribPointer(\"aVertex2d\", programObject2D, \"aVertex\", 3, rectBuffer);\n        disableVertexAttribPointer(\"aTextureCoord2d\", programObject2D, \"aTextureCoord\");\n        curContext.drawArrays(curContext.LINE_LOOP, 0, rectVerts.length / 3);\n      }\n\n      if (doFill) {\n        curContext.useProgram(programObject3D);\n        uniformMatrix(\"uModel3d\", programObject3D, \"uModel\", false, model.array());\n        uniformMatrix(\"uView3d\", programObject3D, \"uView\", false, view.array());\n\n        // fix stitching problems. (lines get occluded by triangles\n        // since they share the same depth values). This is not entirely\n        // working, but it's a start for drawing the outline. So\n        // developers can start playing around with styles.\n        curContext.enable(curContext.POLYGON_OFFSET_FILL);\n        curContext.polygonOffset(1, 1);\n\n        uniformf(\"color3d\", programObject3D, \"uColor\", fillStyle);\n\n        if(lightCount > 0){\n          var v = new PMatrix3D();\n          v.set(view);\n\n          var m = new PMatrix3D();\n          m.set(model);\n\n          v.mult(m);\n\n          var normalMatrix = new PMatrix3D();\n          normalMatrix.set(v);\n          normalMatrix.invert();\n          normalMatrix.transpose();\n\n          uniformMatrix(\"uNormalTransform3d\", programObject3D, \"uNormalTransform\", false, normalMatrix.array());\n          vertexAttribPointer(\"aNormal3d\", programObject3D, \"aNormal\", 3, rectNormBuffer);\n        }\n        else{\n          disableVertexAttribPointer(\"normal3d\", programObject3D, \"aNormal\");\n        }\n\n        vertexAttribPointer(\"vertex3d\", programObject3D, \"aVertex\", 3, rectBuffer);\n\n        curContext.drawArrays(curContext.TRIANGLE_FAN, 0, rectVerts.length / 3);\n        curContext.disable(curContext.POLYGON_OFFSET_FILL);\n      }\n    };\n\n    /**\n     * Draws an ellipse (oval) in the display window. An ellipse with an equal <b>width</b> and <b>height</b> is a circle.\n     * The first two parameters set the location, the third sets the width, and the fourth sets the height. The origin may be\n     * changed with the <b>ellipseMode()</b> function.\n     *\n     * @param {float|int} x      x-coordinate of the ellipse\n     * @param {float|int} y      y-coordinate of the ellipse\n     * @param {float|int} width  width of the ellipse\n     * @param {float|int} height height of the ellipse\n     *\n     * @see ellipseMode\n     */\n    Drawing2D.prototype.ellipse = function(x, y, width, height) {\n      x = x || 0;\n      y = y || 0;\n\n      if (width <= 0 && height <= 0) {\n        return;\n      }\n\n      if (curEllipseMode === PConstants.RADIUS) {\n        width *= 2;\n        height *= 2;\n      } else if (curEllipseMode === PConstants.CORNERS) {\n        width = width - x;\n        height = height - y;\n        x += width / 2;\n        y += height / 2;\n      } else if (curEllipseMode === PConstants.CORNER) {\n        x += width / 2;\n        y += height / 2;\n      }\n\n      // Shortcut for drawing a 2D circle\n      if (width === height) {\n        curContext.beginPath();\n        curContext.arc(x, y, width / 2, 0, PConstants.TWO_PI, false);\n        executeContextFill();\n        executeContextStroke();\n      } else {\n        var w = width / 2,\n            h = height / 2,\n            C = 0.5522847498307933,\n            c_x = C * w,\n            c_y = C * h;\n\n        p.beginShape();\n        p.vertex(x + w, y);\n        p.bezierVertex(x + w, y - c_y, x + c_x, y - h, x, y - h);\n        p.bezierVertex(x - c_x, y - h, x - w, y - c_y, x - w, y);\n        p.bezierVertex(x - w, y + c_y, x - c_x, y + h, x, y + h);\n        p.bezierVertex(x + c_x, y + h, x + w, y + c_y, x + w, y);\n        p.endShape();\n      }\n    };\n\n    Drawing3D.prototype.ellipse = function(x, y, width, height) {\n      x = x || 0;\n      y = y || 0;\n\n      if (width <= 0 && height <= 0) {\n        return;\n      }\n\n      if (curEllipseMode === PConstants.RADIUS) {\n        width *= 2;\n        height *= 2;\n      } else if (curEllipseMode === PConstants.CORNERS) {\n        width = width - x;\n        height = height - y;\n        x += width / 2;\n        y += height / 2;\n      } else if (curEllipseMode === PConstants.CORNER) {\n        x += width / 2;\n        y += height / 2;\n      }\n\n      var w = width / 2,\n          h = height / 2,\n          C = 0.5522847498307933,\n          c_x = C * w,\n          c_y = C * h;\n\n      p.beginShape();\n      p.vertex(x + w, y);\n      p.bezierVertex(x + w, y - c_y, 0, x + c_x, y - h, 0, x, y - h, 0);\n      p.bezierVertex(x - c_x, y - h, 0, x - w, y - c_y, 0, x - w, y, 0);\n      p.bezierVertex(x - w, y + c_y, 0, x - c_x, y + h, 0, x, y + h, 0);\n      p.bezierVertex(x + c_x, y + h, 0, x + w, y + c_y, 0, x + w, y, 0);\n      p.endShape();\n\n      if (doFill) {\n        //temporary workaround to not working fills for bezier -- will fix later\n        var xAv = 0, yAv = 0, i, j;\n        for (i = 0; i < vertArray.length; i++) {\n          xAv += vertArray[i][0];\n          yAv += vertArray[i][1];\n        }\n        xAv /= vertArray.length;\n        yAv /= vertArray.length;\n        var vert = [],\n            fillVertArray = [],\n            colorVertArray = [];\n        vert[0] = xAv;\n        vert[1] = yAv;\n        vert[2] = 0;\n        vert[3] = 0;\n        vert[4] = 0;\n        vert[5] = fillStyle[0];\n        vert[6] = fillStyle[1];\n        vert[7] = fillStyle[2];\n        vert[8] = fillStyle[3];\n        vert[9] = strokeStyle[0];\n        vert[10] = strokeStyle[1];\n        vert[11] = strokeStyle[2];\n        vert[12] = strokeStyle[3];\n        vert[13] = normalX;\n        vert[14] = normalY;\n        vert[15] = normalZ;\n        vertArray.unshift(vert);\n        for (i = 0; i < vertArray.length; i++) {\n          for (j = 0; j < 3; j++) {\n            fillVertArray.push(vertArray[i][j]);\n          }\n          for (j = 5; j < 9; j++) {\n            colorVertArray.push(vertArray[i][j]);\n          }\n        }\n        fill3D(fillVertArray, \"TRIANGLE_FAN\", colorVertArray);\n      }\n    };\n\n    /**\n    * Sets the current normal vector. This is for drawing three dimensional shapes and surfaces and\n    * specifies a vector perpendicular to the surface of the shape which determines how lighting affects\n    * it. Processing attempts to automatically assign normals to shapes, but since that's imperfect,\n    * this is a better option when you want more control. This function is identical to glNormal3f() in OpenGL.\n    *\n    * @param {float} nx       x direction\n    * @param {float} ny       y direction\n    * @param {float} nz       z direction\n    *\n    * @see beginShape\n    * @see endShape\n    * @see lights\n    */\n    p.normal = function(nx, ny, nz) {\n      if (arguments.length !== 3 || !(typeof nx === \"number\" && typeof ny === \"number\" && typeof nz === \"number\")) {\n        throw \"normal() requires three numeric arguments.\";\n      }\n\n      normalX = nx;\n      normalY = ny;\n      normalZ = nz;\n\n      if (curShape !== 0) {\n        if (normalMode === PConstants.NORMAL_MODE_AUTO) {\n          normalMode = PConstants.NORMAL_MODE_SHAPE;\n        } else if (normalMode === PConstants.NORMAL_MODE_SHAPE) {\n          normalMode = PConstants.NORMAL_MODE_VERTEX;\n        }\n      }\n    };\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Raster drawing functions\n    ////////////////////////////////////////////////////////////////////////////\n\n    /**\n    * Saves an image from the display window. Images are saved in TIFF, TARGA, JPEG, and PNG format\n    * depending on the extension within the filename  parameter. For example, \"image.tif\" will have\n    * a TIFF image and \"image.png\" will save a PNG image. If no extension is included in the filename,\n    * the image will save in TIFF format and .tif will be added to the name. These files are saved to\n    * the sketch's folder, which may be opened by selecting \"Show sketch folder\" from the \"Sketch\" menu.\n    * It is not possible to use save() while running the program in a web browser.  All images saved\n    * from the main drawing window will be opaque. To save images without a background, use createGraphics().\n    *\n    * @param {String} filename      any sequence of letters and numbers\n    *\n    * @see saveFrame\n    * @see createGraphics\n    */\n    p.save = function(file, img) {\n      // file is unused at the moment\n      // may implement this differently in later release\n      if (img !== undef) {\n        return window.open(img.toDataURL(),\"_blank\");\n      }\n      return window.open(p.externals.canvas.toDataURL(),\"_blank\");\n    };\n\n    var saveNumber = 0;\n\n    p.saveFrame = function(file) {\n      if(file === undef) {\n        // use default name template if parameter is not specified\n        file = \"screen-####.png\";\n      }\n      // Increment changeable part: screen-0000.png, screen-0001.png, ...\n      var frameFilename = file.replace(/#+/, function(all) {\n        var s = \"\" + (saveNumber++);\n        while(s.length < all.length) {\n          s = \"0\" + s;\n        }\n        return s;\n      });\n      p.save(frameFilename);\n    };\n\n    var utilityContext2d = document.createElement(\"canvas\").getContext(\"2d\");\n\n    var canvasDataCache = [undef, undef, undef]; // we need three for now\n\n    function getCanvasData(obj, w, h) {\n      var canvasData = canvasDataCache.shift();\n\n      if (canvasData === undef) {\n        canvasData = {};\n        canvasData.canvas = document.createElement(\"canvas\");\n        canvasData.context = canvasData.canvas.getContext('2d');\n      }\n\n      canvasDataCache.push(canvasData);\n\n      var canvas = canvasData.canvas, context = canvasData.context,\n          width = w || obj.width, height = h || obj.height;\n\n      canvas.width = width;\n      canvas.height = height;\n\n      if (!obj) {\n        context.clearRect(0, 0, width, height);\n      } else if (\"data\" in obj) { // ImageData\n        context.putImageData(obj, 0, 0);\n      } else {\n        context.clearRect(0, 0, width, height);\n        context.drawImage(obj, 0, 0, width, height);\n      }\n      return canvasData;\n    }\n\n    /**\n     * Handle the sketch code for pixels[] and pixels.length\n     * parser code converts pixels[] to getPixels()\n     * or setPixels(), .length becomes getLength()\n     */\n    function buildPixelsObject(pImage) {\n      return {\n\n        getLength: (function(aImg) {\n          return function() {\n            if (aImg.isRemote) {\n              throw \"Image is loaded remotely. Cannot get length.\";\n            } else {\n              return aImg.imageData.data.length ? aImg.imageData.data.length/4 : 0;\n            }\n          };\n        }(pImage)),\n\n        getPixel: (function(aImg) {\n          return function(i) {\n            var offset = i*4,\n              data = aImg.imageData.data;\n\n            if (aImg.isRemote) {\n              throw \"Image is loaded remotely. Cannot get pixels.\";\n            }\n\n            return (data[offset+3] << 24) & PConstants.ALPHA_MASK |\n                   (data[offset] << 16) & PConstants.RED_MASK |\n                   (data[offset+1] << 8) & PConstants.GREEN_MASK |\n                   data[offset+2] & PConstants.BLUE_MASK;\n          };\n        }(pImage)),\n\n        setPixel: (function(aImg) {\n          return function(i, c) {\n            var offset = i*4,\n              data = aImg.imageData.data;\n\n            if (aImg.isRemote) {\n              throw \"Image is loaded remotely. Cannot set pixel.\";\n            }\n\n            data[offset+0] = (c & PConstants.RED_MASK) >>> 16;\n            data[offset+1] = (c & PConstants.GREEN_MASK) >>> 8;\n            data[offset+2] = (c & PConstants.BLUE_MASK);\n            data[offset+3] = (c & PConstants.ALPHA_MASK) >>> 24;\n            aImg.__isDirty = true;\n          };\n        }(pImage)),\n\n        toArray: (function(aImg) {\n          return function() {\n            var arr = [],\n              data = aImg.imageData.data,\n              length = aImg.width * aImg.height;\n\n            if (aImg.isRemote) {\n              throw \"Image is loaded remotely. Cannot get pixels.\";\n            }\n\n            for (var i = 0, offset = 0; i < length; i++, offset += 4) {\n              arr.push( (data[offset+3] << 24) & PConstants.ALPHA_MASK |\n                        (data[offset] << 16) & PConstants.RED_MASK |\n                        (data[offset+1] << 8) & PConstants.GREEN_MASK |\n                        data[offset+2] & PConstants.BLUE_MASK );\n            }\n            return arr;\n          };\n        }(pImage)),\n\n        set: (function(aImg) {\n          return function(arr) {\n            var offset,\n              data,\n              c;\n            if (this.isRemote) {\n              throw \"Image is loaded remotely. Cannot set pixels.\";\n            }\n\n            data = aImg.imageData.data;\n            for (var i = 0, aL = arr.length; i < aL; i++) {\n              c = arr[i];\n              offset = i*4;\n\n              data[offset+0] = (c & PConstants.RED_MASK) >>> 16;\n              data[offset+1] = (c & PConstants.GREEN_MASK) >>> 8;\n              data[offset+2] = (c & PConstants.BLUE_MASK);\n              data[offset+3] = (c & PConstants.ALPHA_MASK) >>> 24;\n            }\n            aImg.__isDirty = true;\n          };\n        }(pImage))\n\n      };\n    }\n\n    /**\n    * Datatype for storing images. Processing can display .gif, .jpg, .tga, and .png images. Images may be\n    * displayed in 2D and 3D space. Before an image is used, it must be loaded with the loadImage() function.\n    * The PImage object contains fields for the width and height of the image, as well as an array called\n    * pixels[]  which contains the values for every pixel in the image. A group of methods, described below,\n    * allow easy access to the image's pixels and alpha channel and simplify the process of compositing.\n    * Before using the pixels[] array, be sure to use the loadPixels() method on the image to make sure that the\n    * pixel data is properly loaded. To create a new image, use the createImage() function (do not use new PImage()).\n    *\n    * @param {int} width                image width\n    * @param {int} height               image height\n    * @param {MODE} format              Either RGB, ARGB, ALPHA (grayscale alpha channel)\n    *\n    * @returns {PImage}\n    *\n    * @see loadImage\n    * @see imageMode\n    * @see createImage\n    */\n    var PImage = function(aWidth, aHeight, aFormat) {\n\n      // Keep track of whether or not the cached imageData has been touched.\n      this.__isDirty = false;\n\n      if (aWidth instanceof HTMLImageElement) {\n        // convert an <img> to a PImage\n        this.fromHTMLImageData(aWidth);\n      } else if (aHeight || aFormat) {\n        this.width = aWidth || 1;\n        this.height = aHeight || 1;\n\n        // Stuff a canvas into sourceImg so image() calls can use drawImage like an <img>\n        var canvas = this.sourceImg = document.createElement(\"canvas\");\n        canvas.width = this.width;\n        canvas.height = this.height;\n\n        var imageData = this.imageData = canvas.getContext('2d').createImageData(this.width, this.height);\n        this.format = (aFormat === PConstants.ARGB || aFormat === PConstants.ALPHA) ? aFormat : PConstants.RGB;\n        if (this.format === PConstants.RGB) {\n          // Set the alpha channel of an RGB image to opaque.\n          for (var i = 3, data = this.imageData.data, len = data.length; i < len; i += 4) {\n            data[i] = 255;\n          }\n        }\n\n        this.__isDirty = true;\n        this.updatePixels();\n      } else {\n        this.width = 0;\n        this.height = 0;\n        this.imageData = utilityContext2d.createImageData(1, 1);\n        this.format = PConstants.ARGB;\n      }\n\n      this.pixels = buildPixelsObject(this);\n    };\n    PImage.prototype = {\n\n      /**\n       * Temporary hack to deal with cross-Processing-instance created PImage.  See\n       * tickets #1623 and #1644.\n       */\n      __isPImage: true,\n\n      /**\n      * @member PImage\n      * Updates the image with the data in its pixels[] array. Use in conjunction with loadPixels(). If\n      * you're only reading pixels from the array, there's no need to call updatePixels().\n      * Certain renderers may or may not seem to require loadPixels() or updatePixels(). However, the rule\n      * is that any time you want to manipulate the pixels[] array, you must first call loadPixels(), and\n      * after changes have been made, call updatePixels(). Even if the renderer may not seem to use this\n      * function in the current Processing release, this will always be subject to change.\n      * Currently, none of the renderers use the additional parameters to updatePixels().\n      */\n      updatePixels: function() {\n        var canvas = this.sourceImg;\n        if (canvas && canvas instanceof HTMLCanvasElement && this.__isDirty) {\n          canvas.getContext('2d').putImageData(this.imageData, 0, 0);\n        }\n        this.__isDirty = false;\n      },\n\n      fromHTMLImageData: function(htmlImg) {\n        // convert an <img> to a PImage\n        var canvasData = getCanvasData(htmlImg);\n        try {\n          var imageData = canvasData.context.getImageData(0, 0, htmlImg.width, htmlImg.height);\n          this.fromImageData(imageData);\n        } catch(e) {\n          if (htmlImg.width && htmlImg.height) {\n            this.isRemote = true;\n            this.width = htmlImg.width;\n            this.height = htmlImg.height;\n          }\n        }\n        this.sourceImg = htmlImg;\n      },\n\n      'get': function(x, y, w, h) {\n        if (!arguments.length) {\n          return p.get(this);\n        }\n        if (arguments.length === 2) {\n          return p.get(x, y, this);\n        }\n        if (arguments.length === 4) {\n          return p.get(x, y, w, h, this);\n        }\n      },\n\n      /**\n      * @member PImage\n      * Changes the color of any pixel or writes an image directly into the image. The x and y parameter\n      * specify the pixel or the upper-left corner of the image. The color parameter specifies the color value.\n      * Setting the color of a single pixel with set(x, y) is easy, but not as fast as putting the data\n      * directly into pixels[]. The equivalent statement to \"set(x, y, #000000)\" using pixels[] is\n      * \"pixels[y*width+x] = #000000\". Processing requires calling loadPixels() to load the display window\n      * data into the pixels[] array before getting the values and calling updatePixels() to update the window.\n      *\n      * @param {int} x        x-coordinate of the pixel or upper-left corner of the image\n      * @param {int} y        y-coordinate of the pixel or upper-left corner of the image\n      * @param {color} color  any value of the color datatype\n      *\n      * @see get\n      * @see pixels[]\n      * @see copy\n      */\n      'set': function(x, y, c) {\n        p.set(x, y, c, this);\n        this.__isDirty = true;\n      },\n\n      /**\n      * @member PImage\n      * Blends a region of pixels into the image specified by the img parameter. These copies utilize full\n      * alpha channel support and a choice of the following modes to blend the colors of source pixels (A)\n      * with the ones of pixels in the destination image (B):\n      * BLEND - linear interpolation of colours: C = A*factor + B\n      * ADD - additive blending with white clip: C = min(A*factor + B, 255)\n      * SUBTRACT - subtractive blending with black clip: C = max(B - A*factor, 0)\n      * DARKEST - only the darkest colour succeeds: C = min(A*factor, B)\n      * LIGHTEST - only the lightest colour succeeds: C = max(A*factor, B)\n      * DIFFERENCE - subtract colors from underlying image.\n      * EXCLUSION - similar to DIFFERENCE, but less extreme.\n      * MULTIPLY - Multiply the colors, result will always be darker.\n      * SCREEN - Opposite multiply, uses inverse values of the colors.\n      * OVERLAY - A mix of MULTIPLY and SCREEN. Multiplies dark values, and screens light values.\n      * HARD_LIGHT - SCREEN when greater than 50% gray, MULTIPLY when lower.\n      * SOFT_LIGHT - Mix of DARKEST and LIGHTEST. Works like OVERLAY, but not as harsh.\n      * DODGE - Lightens light tones and increases contrast, ignores darks. Called \"Color Dodge\" in Illustrator and Photoshop.\n      * BURN - Darker areas are applied, increasing contrast, ignores lights. Called \"Color Burn\" in Illustrator and Photoshop.\n      * All modes use the alpha information (highest byte) of source image pixels as the blending factor.\n      * If the source and destination regions are different sizes, the image will be automatically resized to\n      * match the destination size. If the srcImg parameter is not used, the display window is used as the source image.\n      * This function ignores imageMode().\n      *\n      * @param {int} x              X coordinate of the source's upper left corner\n      * @param {int} y              Y coordinate of the source's upper left corner\n      * @param {int} width          source image width\n      * @param {int} height         source image height\n      * @param {int} dx             X coordinate of the destinations's upper left corner\n      * @param {int} dy             Y coordinate of the destinations's upper left corner\n      * @param {int} dwidth         destination image width\n      * @param {int} dheight        destination image height\n      * @param {PImage} srcImg      an image variable referring to the source image\n      * @param {MODE} MODE          Either BLEND, ADD, SUBTRACT, LIGHTEST, DARKEST, DIFFERENCE, EXCLUSION,\n      * MULTIPLY, SCREEN, OVERLAY, HARD_LIGHT, SOFT_LIGHT, DODGE, BURN\n      *\n      * @see alpha\n      * @see copy\n      */\n      blend: function(srcImg, x, y, width, height, dx, dy, dwidth, dheight, MODE) {\n        if (arguments.length === 9) {\n          p.blend(this, srcImg, x, y, width, height, dx, dy, dwidth, dheight, this);\n        } else if (arguments.length === 10) {\n          p.blend(srcImg, x, y, width, height, dx, dy, dwidth, dheight, MODE, this);\n        }\n        delete this.sourceImg;\n      },\n\n      /**\n      * @member PImage\n      * Copies a region of pixels from one image into another. If the source and destination regions\n      * aren't the same size, it will automatically resize source pixels to fit the specified target region.\n      * No alpha information is used in the process, however if the source image has an alpha channel set,\n      * it will be copied as well. This function ignores imageMode().\n      *\n      * @param {int} sx             X coordinate of the source's upper left corner\n      * @param {int} sy             Y coordinate of the source's upper left corner\n      * @param {int} swidth         source image width\n      * @param {int} sheight        source image height\n      * @param {int} dx             X coordinate of the destinations's upper left corner\n      * @param {int} dy             Y coordinate of the destinations's upper left corner\n      * @param {int} dwidth         destination image width\n      * @param {int} dheight        destination image height\n      * @param {PImage} srcImg      an image variable referring to the source image\n      *\n      * @see alpha\n      * @see blend\n      */\n      copy: function(srcImg, sx, sy, swidth, sheight, dx, dy, dwidth, dheight) {\n        if (arguments.length === 8) {\n          p.blend(this, srcImg, sx, sy, swidth, sheight, dx, dy, dwidth, PConstants.REPLACE, this);\n        } else if (arguments.length === 9) {\n          p.blend(srcImg, sx, sy, swidth, sheight, dx, dy, dwidth, dheight, PConstants.REPLACE, this);\n        }\n        delete this.sourceImg;\n      },\n\n      /**\n      * @member PImage\n      * Filters an image as defined by one of the following modes:\n      * THRESHOLD - converts the image to black and white pixels depending if they are above or below\n      * the threshold defined by the level parameter. The level must be between 0.0 (black) and 1.0(white).\n      * If no level is specified, 0.5 is used.\n      * GRAY - converts any colors in the image to grayscale equivalents\n      * INVERT - sets each pixel to its inverse value\n      * POSTERIZE - limits each channel of the image to the number of colors specified as the level parameter\n      * BLUR - executes a Guassian blur with the level parameter specifying the extent of the blurring.\n      * If no level parameter is used, the blur is equivalent to Guassian blur of radius 1.\n      * OPAQUE - sets the alpha channel to entirely opaque.\n      * ERODE - reduces the light areas with the amount defined by the level parameter.\n      * DILATE - increases the light areas with the amount defined by the level parameter\n      *\n      * @param {MODE} MODE        Either THRESHOLD, GRAY, INVERT, POSTERIZE, BLUR, OPAQUE, ERODE, or DILATE\n      * @param {int|float} param  in the range from 0 to 1\n      */\n      filter: function(mode, param) {\n        if (arguments.length === 2) {\n          p.filter(mode, param, this);\n        } else if (arguments.length === 1) {\n          // no param specified, send null to show its invalid\n          p.filter(mode, null, this);\n        }\n        delete this.sourceImg;\n      },\n\n      /**\n      * @member PImage\n      * Saves the image into a file. Images are saved in TIFF, TARGA, JPEG, and PNG format depending on\n      * the extension within the filename  parameter. For example, \"image.tif\" will have a TIFF image and\n      * \"image.png\" will save a PNG image. If no extension is included in the filename, the image will save\n      * in TIFF format and .tif will be added to the name. These files are saved to the sketch's folder,\n      * which may be opened by selecting \"Show sketch folder\" from the \"Sketch\" menu. It is not possible to\n      * use save() while running the program in a web browser.\n      * To save an image created within the code, rather than through loading, it's necessary to make the\n      * image with the createImage() function so it is aware of the location of the program and can therefore\n      * save the file to the right place. See the createImage() reference for more information.\n      *\n      * @param {String} filename        a sequence of letters and numbers\n      */\n      save: function(file){\n        p.save(file,this);\n      },\n\n      /**\n      * @member PImage\n      * Resize the image to a new width and height. To make the image scale proportionally, use 0 as the\n      * value for the wide or high parameter.\n      *\n      * @param {int} wide         the resized image width\n      * @param {int} high         the resized image height\n      *\n      * @see get\n      */\n      resize: function(w, h) {\n        if (this.isRemote) { // Remote images cannot access imageData\n          throw \"Image is loaded remotely. Cannot resize.\";\n        }\n        if (this.width !== 0 || this.height !== 0) {\n          // make aspect ratio if w or h is 0\n          if (w === 0 && h !== 0) {\n            w = Math.floor(this.width / this.height * h);\n          } else if (h === 0 && w !== 0) {\n            h = Math.floor(this.height / this.width * w);\n          }\n          // put 'this.imageData' into a new canvas\n          var canvas = getCanvasData(this.imageData).canvas;\n          // pull imageData object out of canvas into ImageData object\n          var imageData = getCanvasData(canvas, w, h).context.getImageData(0, 0, w, h);\n          // set this as new pimage\n          this.fromImageData(imageData);\n        }\n      },\n\n      /**\n      * @member PImage\n      * Masks part of an image from displaying by loading another image and using it as an alpha channel.\n      * This mask image should only contain grayscale data, but only the blue color channel is used. The\n      * mask image needs to be the same size as the image to which it is applied.\n      * In addition to using a mask image, an integer array containing the alpha channel data can be\n      * specified directly. This method is useful for creating dynamically generated alpha masks. This\n      * array must be of the same length as the target image's pixels array and should contain only grayscale\n      * data of values between 0-255.\n      *\n      * @param {PImage} maskImg         any PImage object used as the alpha channel for \"img\", needs to be same\n      *                                 size as \"img\"\n      * @param {int[]} maskArray        any array of Integer numbers used as the alpha channel, needs to be same\n      *                                 length as the image's pixel array\n      */\n      mask: function(mask) {\n        var obj = this.toImageData(),\n            i,\n            size;\n\n        if (mask instanceof PImage || mask.__isPImage) {\n          if (mask.width === this.width && mask.height === this.height) {\n            mask = mask.toImageData();\n\n            for (i = 2, size = this.width * this.height * 4; i < size; i += 4) {\n              // using it as an alpha channel\n              obj.data[i + 1] = mask.data[i];\n              // but only the blue color channel\n            }\n          } else {\n            throw \"mask must have the same dimensions as PImage.\";\n          }\n        } else if (mask instanceof Array) {\n          if (this.width * this.height === mask.length) {\n            for (i = 0, size = mask.length; i < size; ++i) {\n              obj.data[i * 4 + 3] = mask[i];\n            }\n          } else {\n            throw \"mask array must be the same length as PImage pixels array.\";\n          }\n        }\n\n        this.fromImageData(obj);\n      },\n\n      // These are intentionally left blank for PImages, we work live with pixels and draw as necessary\n      /**\n      * @member PImage\n      * Loads the pixel data for the image into its pixels[] array. This function must always be called\n      * before reading from or writing to pixels[].\n      * Certain renderers may or may not seem to require loadPixels() or updatePixels(). However, the\n      * rule is that any time you want to manipulate the pixels[] array, you must first call loadPixels(),\n      * and after changes have been made, call updatePixels(). Even if the renderer may not seem to use\n      * this function in the current Processing release, this will always be subject to change.\n      */\n      loadPixels: noop,\n\n      toImageData: function() {\n        if (this.isRemote) {\n          return this.sourceImg;\n        }\n\n        if (!this.__isDirty) {\n          return this.imageData;\n        }\n\n        var canvasData = getCanvasData(this.sourceImg);\n        return canvasData.context.getImageData(0, 0, this.width, this.height);\n      },\n\n      toDataURL: function() {\n        if (this.isRemote) { // Remote images cannot access imageData\n          throw \"Image is loaded remotely. Cannot create dataURI.\";\n        }\n        var canvasData = getCanvasData(this.imageData);\n        return canvasData.canvas.toDataURL();\n      },\n\n      fromImageData: function(canvasImg) {\n        var w = canvasImg.width,\n          h = canvasImg.height,\n          canvas = document.createElement('canvas'),\n          ctx = canvas.getContext('2d');\n\n        this.width = canvas.width = w;\n        this.height = canvas.height = h;\n\n        ctx.putImageData(canvasImg, 0, 0);\n\n        // changed for 0.9\n        this.format = PConstants.ARGB;\n\n        this.imageData = canvasImg;\n        this.sourceImg = canvas;\n      }\n    };\n\n    p.PImage = PImage;\n\n    /**\n    * Creates a new PImage (the datatype for storing images). This provides a fresh buffer of pixels to play\n    * with. Set the size of the buffer with the width and height parameters. The format parameter defines how\n    * the pixels are stored. See the PImage reference for more information.\n    * Be sure to include all three parameters, specifying only the width and height (but no format) will\n    * produce a strange error.\n    * Advanced users please note that createImage() should be used instead of the syntax new PImage().\n    *\n    * @param {int} width                image width\n    * @param {int} height               image height\n    * @param {MODE} format              Either RGB, ARGB, ALPHA (grayscale alpha channel)\n    *\n    * @returns {PImage}\n    *\n    * @see PImage\n    * @see PGraphics\n    */\n    p.createImage = function(w, h, mode) {\n      return new PImage(w,h,mode);\n    };\n\n    // Loads an image for display. Type is an extension. Callback is fired on load.\n    /**\n    * Loads an image into a variable of type PImage. Four types of images ( .gif, .jpg, .tga, .png) images may\n    * be loaded. To load correctly, images must be located in the data directory of the current sketch. In most\n    * cases, load all images in setup() to preload them at the start of the program. Loading images inside draw()\n    * will reduce the speed of a program.\n    * The filename parameter can also be a URL to a file found online. For security reasons, a Processing sketch\n    * found online can only download files from the same server from which it came. Getting around this restriction\n    * requires a signed applet.\n    * The extension parameter is used to determine the image type in cases where the image filename does not end\n    * with a proper extension. Specify the extension as the second parameter to loadImage(), as shown in the\n    * third example on this page.\n    * If an image is not loaded successfully, the null value is returned and an error message will be printed to\n    * the console. The error message does not halt the program, however the null value may cause a NullPointerException\n    * if your code does not check whether the value returned from loadImage() is null.\n    * Depending on the type of error, a PImage object may still be returned, but the width and height of the image\n    * will be set to -1. This happens if bad image data is returned or cannot be decoded properly. Sometimes this happens\n    * with image URLs that produce a 403 error or that redirect to a password prompt, because loadImage() will attempt\n    * to interpret the HTML as image data.\n    *\n    * @param {String} filename        name of file to load, can be .gif, .jpg, .tga, or a handful of other image\n    *                                 types depending on your platform.\n    * @param {String} extension       the type of image to load, for example \"png\", \"gif\", \"jpg\"\n    *\n    * @returns {PImage}\n    *\n    * @see PImage\n    * @see image\n    * @see imageMode\n    * @see background\n    */\n    p.loadImage = function(file, type, callback) {\n      // if type is specified, we just ignore it\n\n      var pimg;\n      // if image is in the preloader cache return a new PImage\n      if (curSketch.imageCache.images[file]) {\n        pimg = new PImage(curSketch.imageCache.images[file]);\n        pimg.loaded = true;\n        return pimg;\n      }\n      // else async load it\n      pimg = new PImage();\n      var img = document.createElement('img');\n\n      pimg.sourceImg = img;\n\n      img.onload = (function(aImage, aPImage, aCallback) {\n        var image = aImage;\n        var pimg = aPImage;\n        var callback = aCallback;\n        return function() {\n          // change the <img> object into a PImage now that its loaded\n          pimg.fromHTMLImageData(image);\n          pimg.loaded = true;\n          if (callback) {\n            callback();\n          }\n        };\n      }(img, pimg, callback));\n\n      img.src = file; // needs to be called after the img.onload function is declared or it wont work in opera\n      return pimg;\n    };\n\n    // async loading of large images, same functionality as loadImage above\n    /**\n    * This function load images on a separate thread so that your sketch does not freeze while images load during\n    * setup(). While the image is loading, its width and height will be 0. If an error occurs while loading the image,\n    * its width and height will be set to -1. You'll know when the image has loaded properly because its width and\n    * height will be greater than 0. Asynchronous image loading (particularly when downloading from a server) can\n    * dramatically improve performance.\n    * The extension parameter is used to determine the image type in cases where the image filename does not end\n    * with a proper extension. Specify the extension as the second parameter to requestImage().\n    *\n    * @param {String} filename        name of file to load, can be .gif, .jpg, .tga, or a handful of other image\n    *                                 types depending on your platform.\n    * @param {String} extension       the type of image to load, for example \"png\", \"gif\", \"jpg\"\n    *\n    * @returns {PImage}\n    *\n    * @see PImage\n    * @see loadImage\n    */\n    p.requestImage = p.loadImage;\n\n    function get$2(x,y) {\n      var data;\n      // return the color at x,y (int) of curContext\n      if (x >= p.width || x < 0 || y < 0 || y >= p.height) {\n        // x,y is outside image return transparent black\n        return 0;\n      }\n\n      // loadPixels() has been called\n      if (isContextReplaced) {\n        var offset = ((0|x) + p.width * (0|y)) * 4;\n        data = p.imageData.data;\n        return (data[offset + 3] << 24) & PConstants.ALPHA_MASK |\n               (data[offset] << 16) & PConstants.RED_MASK |\n               (data[offset + 1] << 8) & PConstants.GREEN_MASK |\n               data[offset + 2] & PConstants.BLUE_MASK;\n      }\n\n      // x,y is inside canvas space\n      data = p.toImageData(0|x, 0|y, 1, 1).data;\n      return (data[3] << 24) & PConstants.ALPHA_MASK |\n             (data[0] << 16) & PConstants.RED_MASK |\n             (data[1] << 8) & PConstants.GREEN_MASK |\n             data[2] & PConstants.BLUE_MASK;\n    }\n    function get$3(x,y,img) {\n      if (img.isRemote) { // Remote images cannot access imageData\n        throw \"Image is loaded remotely. Cannot get x,y.\";\n      }\n      // PImage.get(x,y) was called, return the color (int) at x,y of img\n      var offset = y * img.width * 4 + (x * 4),\n          data = img.imageData.data;\n      return (data[offset + 3] << 24) & PConstants.ALPHA_MASK |\n             (data[offset] << 16) & PConstants.RED_MASK |\n             (data[offset + 1] << 8) & PConstants.GREEN_MASK |\n             data[offset + 2] & PConstants.BLUE_MASK;\n    }\n    function get$4(x, y, w, h) {\n      // return a PImage of w and h from cood x,y of curContext\n      var c = new PImage(w, h, PConstants.ARGB);\n      c.fromImageData(p.toImageData(x, y, w, h));\n      return c;\n    }\n    function get$5(x, y, w, h, img) {\n      if (img.isRemote) { // Remote images cannot access imageData\n        throw \"Image is loaded remotely. Cannot get x,y,w,h.\";\n      }\n      // PImage.get(x,y,w,h) was called, return x,y,w,h PImage of img\n      // offset start point needs to be *4\n      var c = new PImage(w, h, PConstants.ARGB), cData = c.imageData.data,\n        imgWidth = img.width, imgHeight = img.height, imgData = img.imageData.data;\n      // Don't need to copy pixels from the image outside ranges.\n      var startRow = Math.max(0, -y), startColumn = Math.max(0, -x),\n        stopRow = Math.min(h, imgHeight - y), stopColumn = Math.min(w, imgWidth - x);\n      for (var i = startRow; i < stopRow; ++i) {\n        var sourceOffset = ((y + i) * imgWidth + (x + startColumn)) * 4;\n        var targetOffset = (i * w + startColumn) * 4;\n        for (var j = startColumn; j < stopColumn; ++j) {\n          cData[targetOffset++] = imgData[sourceOffset++];\n          cData[targetOffset++] = imgData[sourceOffset++];\n          cData[targetOffset++] = imgData[sourceOffset++];\n          cData[targetOffset++] = imgData[sourceOffset++];\n        }\n      }\n      c.__isDirty = true;\n      return c;\n    }\n\n    // Gets a single pixel or block of pixels from the current Canvas Context or a PImage\n    /**\n    * Reads the color of any pixel or grabs a section of an image. If no parameters are specified, the entire\n    * image is returned. Get the value of one pixel by specifying an x,y coordinate. Get a section of the display\n    * window by specifying an additional width and height parameter. If the pixel requested is outside of the image\n    * window, black is returned. The numbers returned are scaled according to the current color ranges, but only RGB\n    * values are returned by this function. For example, even though you may have drawn a shape with colorMode(HSB),\n    * the numbers returned will be in RGB.\n    * Getting the color of a single pixel with get(x, y) is easy, but not as fast as grabbing the data directly\n    * from pixels[]. The equivalent statement to \"get(x, y)\" using pixels[] is \"pixels[y*width+x]\". Processing\n    * requires calling loadPixels() to load the display window data into the pixels[] array before getting the values.\n    * This function ignores imageMode().\n    *\n    * @param {int} x            x-coordinate of the pixel\n    * @param {int} y            y-coordinate of the pixel\n    * @param {int} width        width of pixel rectangle to get\n    * @param {int} height       height of pixel rectangle to get\n    *\n    * @returns {Color|PImage}\n    *\n    * @see set\n    * @see pixels[]\n    * @see imageMode\n    */\n    p.get = function(x, y, w, h, img) {\n      // for 0 2 and 4 arguments use curContext, otherwise PImage.get was called\n      if (img !== undefined) {\n        return get$5(x, y, w, h, img);\n      }\n      if (h !== undefined) {\n        return get$4(x, y, w, h);\n      }\n      if (w !== undefined) {\n        return get$3(x, y, w);\n      }\n      if (y !== undefined) {\n        return get$2(x, y);\n      }\n      if (x !== undefined) {\n        // PImage.get() was called, return a new PImage\n        return get$5(0, 0, x.width, x.height, x);\n      }\n\n      return get$4(0, 0, p.width, p.height);\n    };\n\n    /**\n     * Creates and returns a new <b>PGraphics</b> object of the types P2D, P3D, and JAVA2D. Use this class if you need to draw\n     * into an off-screen graphics buffer. It's not possible to use <b>createGraphics()</b> with OPENGL, because it doesn't\n     * allow offscreen use. The DXF and PDF renderers require the filename parameter. <br /><br /> It's important to call\n     * any drawing commands between beginDraw() and endDraw() statements. This is also true for any commands that affect\n     * drawing, such as smooth() or colorMode().<br /><br /> Unlike the main drawing surface which is completely opaque,\n     * surfaces created with createGraphics() can have transparency. This makes it possible to draw into a graphics and\n     * maintain the alpha channel.\n     *\n     * @param {int} width       width in pixels\n     * @param {int} height      height in pixels\n     * @param {int} renderer    Either P2D, P3D, JAVA2D, PDF, DXF\n     * @param {String} filename the name of the file (not supported yet)\n     */\n    p.createGraphics = function(w, h, render) {\n      var pg = new Processing();\n      pg.size(w, h, render);\n      pg.background(0,0);\n      return pg;\n    };\n\n    // pixels caching\n    function resetContext() {\n      if(isContextReplaced) {\n        curContext = originalContext;\n        isContextReplaced = false;\n\n        p.updatePixels();\n      }\n    }\n    function SetPixelContextWrapper() {\n      function wrapFunction(newContext, name) {\n        function wrapper() {\n          resetContext();\n          curContext[name].apply(curContext, arguments);\n        }\n        newContext[name] = wrapper;\n      }\n      function wrapProperty(newContext, name) {\n        function getter() {\n          resetContext();\n          return curContext[name];\n        }\n        function setter(value) {\n          resetContext();\n          curContext[name] = value;\n        }\n        p.defineProperty(newContext, name, { get: getter, set: setter });\n      }\n      for(var n in curContext) {\n        if(typeof curContext[n] === 'function') {\n          wrapFunction(this, n);\n        } else {\n          wrapProperty(this, n);\n        }\n      }\n    }\n    function replaceContext() {\n      if(isContextReplaced) {\n        return;\n      }\n      p.loadPixels();\n      if(proxyContext === null) {\n        originalContext = curContext;\n        proxyContext = new SetPixelContextWrapper();\n      }\n      isContextReplaced = true;\n      curContext = proxyContext;\n      setPixelsCached = 0;\n    }\n\n    function set$3(x, y, c) {\n      if (x < p.width && x >= 0 && y >= 0 && y < p.height) {\n        replaceContext();\n        p.pixels.setPixel((0|x)+p.width*(0|y), c);\n        if(++setPixelsCached > maxPixelsCached) {\n          resetContext();\n        }\n      }\n    }\n    function set$4(x, y, obj, img) {\n      if (img.isRemote) { // Remote images cannot access imageData\n        throw \"Image is loaded remotely. Cannot set x,y.\";\n      }\n      var c = p.color.toArray(obj);\n      var offset = y * img.width * 4 + (x*4);\n      var data = img.imageData.data;\n      data[offset] = c[0];\n      data[offset+1] = c[1];\n      data[offset+2] = c[2];\n      data[offset+3] = c[3];\n    }\n\n    // Paints a pixel array into the canvas\n    /**\n    * Changes the color of any pixel or writes an image directly into the display window. The x and y parameters\n    * specify the pixel to change and the color  parameter specifies the color value. The color parameter is affected\n    * by the current color mode (the default is RGB values from 0 to 255). When setting an image, the x and y\n    * parameters define the coordinates for the upper-left corner of the image.\n    * Setting the color of a single pixel with set(x, y) is easy, but not as fast as putting the data directly\n    * into pixels[]. The equivalent statement to \"set(x, y, #000000)\" using pixels[] is \"pixels[y*width+x] = #000000\".\n    * You must call loadPixels() to load the display window data into the pixels[] array before setting the values\n    * and calling updatePixels() to update the window with any changes. This function ignores imageMode().\n    *\n    * @param {int} x            x-coordinate of the pixel\n    * @param {int} y            y-coordinate of the pixel\n    * @param {Color} obj        any value of the color datatype\n    * @param {PImage} img       any valid variable of type PImage\n    *\n    * @see get\n    * @see pixels[]\n    * @see imageMode\n    */\n    p.set = function(x, y, obj, img) {\n      var color, oldFill;\n      if (arguments.length === 3) {\n        // called p.set(), was it with a color or a img ?\n        if (typeof obj === \"number\") {\n          set$3(x, y, obj);\n        } else if (obj instanceof PImage || obj.__isPImage) {\n          p.image(obj, x, y);\n        }\n      } else if (arguments.length === 4) {\n        // PImage.set(x,y,c) was called, set coordinate x,y color to c of img\n        set$4(x, y, obj, img);\n      }\n    };\n    p.imageData = {};\n\n    // handle the sketch code for pixels[]\n    // parser code converts pixels[] to getPixels() or setPixels(),\n    // .length becomes getLength()\n    /**\n    * Array containing the values for all the pixels in the display window. These values are of the color datatype.\n    * This array is the size of the display window. For example, if the image is 100x100 pixels, there will be 10000\n    * values and if the window is 200x300 pixels, there will be 60000 values. The index value defines the position\n    * of a value within the array. For example, the statment color b = pixels[230] will set the variable b to be\n    * equal to the value at that location in the array.\n    * Before accessing this array, the data must loaded with the loadPixels() function. After the array data has\n    * been modified, the updatePixels() function must be run to update the changes.\n    *\n    * @param {int} index      must not exceed the size of the array\n    *\n    * @see loadPixels\n    * @see updatePixels\n    * @see get\n    * @see set\n    * @see PImage\n    */\n    p.pixels = {\n      getLength: function() { return p.imageData.data.length ? p.imageData.data.length/4 : 0; },\n      getPixel: function(i) {\n        var offset = i*4, data = p.imageData.data;\n        return (data[offset+3] << 24) & 0xff000000 |\n               (data[offset+0] << 16) & 0x00ff0000 |\n               (data[offset+1] << 8) & 0x0000ff00 |\n               data[offset+2] & 0x000000ff;\n      },\n      setPixel: function(i,c) {\n        var offset = i*4, data = p.imageData.data;\n        data[offset+0] = (c & 0x00ff0000) >>> 16; // RED_MASK\n        data[offset+1] = (c & 0x0000ff00) >>> 8;  // GREEN_MASK\n        data[offset+2] = (c & 0x000000ff);        // BLUE_MASK\n        data[offset+3] = (c & 0xff000000) >>> 24; // ALPHA_MASK\n      },\n      toArray: function() {\n        var arr = [], length = p.imageData.width * p.imageData.height, data = p.imageData.data;\n        for (var i = 0, offset = 0; i < length; i++, offset += 4) {\n          arr.push((data[offset+3] << 24) & 0xff000000 |\n                   (data[offset+0] << 16) & 0x00ff0000 |\n                   (data[offset+1] << 8) & 0x0000ff00 |\n                   data[offset+2] & 0x000000ff);\n        }\n        return arr;\n      },\n      set: function(arr) {\n        for (var i = 0, aL = arr.length; i < aL; i++) {\n          this.setPixel(i, arr[i]);\n        }\n      }\n    };\n\n    // Gets a 1-Dimensional pixel array from Canvas\n    /**\n    * Loads the pixel data for the display window into the pixels[] array. This function must always be called\n    * before reading from or writing to pixels[].\n    * Certain renderers may or may not seem to require loadPixels() or updatePixels(). However, the rule is that\n    * any time you want to manipulate the pixels[] array, you must first call loadPixels(), and after changes\n    * have been made, call updatePixels(). Even if the renderer may not seem to use this function in the current\n    * Processing release, this will always be subject to change.\n    *\n    * @see pixels[]\n    * @see updatePixels\n    */\n    p.loadPixels = function() {\n      p.imageData = drawing.$ensureContext().getImageData(0, 0, p.width, p.height);\n    };\n\n    // Draws a 1-Dimensional pixel array to Canvas\n    /**\n    * Updates the display window with the data in the pixels[] array. Use in conjunction with loadPixels(). If\n    * you're only reading pixels from the array, there's no need to call updatePixels() unless there are changes.\n    * Certain renderers may or may not seem to require loadPixels() or updatePixels(). However, the rule is that\n    * any time you want to manipulate the pixels[] array, you must first call loadPixels(), and after changes\n    * have been made, call updatePixels(). Even if the renderer may not seem to use this function in the current\n    * Processing release, this will always be subject to change.\n    * Currently, none of the renderers use the additional parameters to updatePixels(), however this may be\n    * implemented in the future.\n    *\n    * @see loadPixels\n    * @see pixels[]\n    */\n    p.updatePixels = function() {\n      if (p.imageData) {\n        drawing.$ensureContext().putImageData(p.imageData, 0, 0);\n      }\n    };\n\n    /**\n    * Set various hints and hacks for the renderer. This is used to handle obscure rendering features that cannot be\n    * implemented in a consistent manner across renderers. Many options will often graduate to standard features\n    * instead of hints over time.\n    * hint(ENABLE_OPENGL_4X_SMOOTH) - Enable 4x anti-aliasing for OpenGL. This can help force anti-aliasing if\n    * it has not been enabled by the user. On some graphics cards, this can also be set by the graphics driver's\n    * control panel, however not all cards make this available. This hint must be called immediately after the\n    * size() command because it resets the renderer, obliterating any settings and anything drawn (and like size(),\n    * re-running the code that came before it again).\n    * hint(DISABLE_OPENGL_2X_SMOOTH) - In Processing 1.0, Processing always enables 2x smoothing when the OpenGL\n    * renderer is used. This hint disables the default 2x smoothing and returns the smoothing behavior found in\n    * earlier releases, where smooth() and noSmooth() could be used to enable and disable smoothing, though the\n    * quality was inferior.\n    * hint(ENABLE_NATIVE_FONTS) - Use the native version fonts when they are installed, rather than the bitmapped\n    * version from a .vlw file. This is useful with the JAVA2D renderer setting, as it will improve font rendering\n    * speed. This is not enabled by default, because it can be misleading while testing because the type will look\n    * great on your machine (because you have the font installed) but lousy on others' machines if the identical\n    * font is unavailable. This option can only be set per-sketch, and must be called before any use of textFont().\n    * hint(DISABLE_DEPTH_TEST) - Disable the zbuffer, allowing you to draw on top of everything at will. When depth\n    * testing is disabled, items will be drawn to the screen sequentially, like a painting. This hint is most often\n    * used to draw in 3D, then draw in 2D on top of it (for instance, to draw GUI controls in 2D on top of a 3D\n    * interface). Starting in release 0149, this will also clear the depth buffer. Restore the default with\n    * hint(ENABLE_DEPTH_TEST), but note that with the depth buffer cleared, any 3D drawing that happens later in\n    * draw() will ignore existing shapes on the screen.\n    * hint(ENABLE_DEPTH_SORT) - Enable primitive z-sorting of triangles and lines in P3D and OPENGL. This can slow\n    * performance considerably, and the algorithm is not yet perfect. Restore the default with hint(DISABLE_DEPTH_SORT).\n    * hint(DISABLE_OPENGL_ERROR_REPORT) - Speeds up the OPENGL renderer setting by not checking for errors while\n    * running. Undo with hint(ENABLE_OPENGL_ERROR_REPORT).\n    * As of release 0149, unhint() has been removed in favor of adding additional ENABLE/DISABLE constants to reset\n    * the default behavior. This prevents the double negatives, and also reinforces which hints can be enabled or disabled.\n    *\n    * @param {MODE} item          constant: name of the hint to be enabled or disabled\n    *\n    * @see PGraphics\n    * @see createGraphics\n    * @see size\n    */\n    p.hint = function(which) {\n      var curContext = drawing.$ensureContext();\n      if (which === PConstants.DISABLE_DEPTH_TEST) {\n         curContext.disable(curContext.DEPTH_TEST);\n         curContext.depthMask(false);\n         curContext.clear(curContext.DEPTH_BUFFER_BIT);\n      }\n      else if (which === PConstants.ENABLE_DEPTH_TEST) {\n         curContext.enable(curContext.DEPTH_TEST);\n         curContext.depthMask(true);\n      }\n      else if (which === PConstants.ENABLE_OPENGL_2X_SMOOTH ||\n               which === PConstants.ENABLE_OPENGL_4X_SMOOTH){\n        renderSmooth = true;\n      }\n      else if (which === PConstants.DISABLE_OPENGL_2X_SMOOTH){\n        renderSmooth = false;\n      }\n    };\n\n    /**\n     * The background() function sets the color used for the background of the Processing window.\n     * The default background is light gray. In the <b>draw()</b> function, the background color is used to clear the display window at the beginning of each frame.\n     * An image can also be used as the background for a sketch, however its width and height must be the same size as the sketch window.\n     * To resize an image 'b' to the size of the sketch window, use b.resize(width, height).\n     * Images used as background will ignore the current <b>tint()</b> setting.\n     * For the main drawing surface, the alpha value will be ignored. However,\n     * alpha can be used on PGraphics objects from <b>createGraphics()</b>. This is\n     * the only way to set all the pixels partially transparent, for instance.\n     * If the 'gray' parameter is passed in the function sets the background to a grayscale value, based on the\n     * current colorMode.\n     * <p>\n     * Note that background() should be called before any transformations occur,\n     * because some implementations may require the current transformation matrix\n     * to be identity before drawing.\n     *\n     * @param {int|float} gray    specifies a value between white and black\n     * @param {int|float} value1  red or hue value (depending on the current color mode)\n     * @param {int|float} value2  green or saturation value (depending on the current color mode)\n     * @param {int|float} value3  blue or brightness value (depending on the current color mode)\n     * @param {int|float} alpha   opacity of the background\n     * @param {Color} color       any value of the color datatype\n     * @param {int} hex           color value in hexadecimal notation (i.e. #FFCC00 or 0xFFFFCC00)\n     * @param {PImage} image      an instance of a PImage to use as a background\n     *\n     * @see #stroke()\n     * @see #fill()\n     * @see #tint()\n     * @see #colorMode()\n     */\n    var backgroundHelper = function(arg1, arg2, arg3, arg4) {\n      var obj;\n\n      if (arg1 instanceof PImage || arg1.__isPImage) {\n        obj = arg1;\n\n        if (!obj.loaded) {\n          throw \"Error using image in background(): PImage not loaded.\";\n        }\n        if(obj.width !== p.width || obj.height !== p.height){\n          throw \"Background image must be the same dimensions as the canvas.\";\n        }\n      } else {\n        obj = p.color(arg1, arg2, arg3, arg4);\n      }\n\n      backgroundObj = obj;\n    };\n\n    Drawing2D.prototype.background = function(arg1, arg2, arg3, arg4) {\n      if (arg1 !== undef) {\n        backgroundHelper(arg1, arg2, arg3, arg4);\n      }\n\n      if (backgroundObj instanceof PImage || backgroundObj.__isPImage) {\n        saveContext();\n        curContext.setTransform(1, 0, 0, 1, 0, 0);\n        p.image(backgroundObj, 0, 0);\n        restoreContext();\n      } else {\n        saveContext();\n        curContext.setTransform(1, 0, 0, 1, 0, 0);\n\n        // If the background is transparent\n        if (p.alpha(backgroundObj) !== colorModeA) {\n          curContext.clearRect(0,0, p.width, p.height);\n        }\n        curContext.fillStyle = p.color.toString(backgroundObj);\n        curContext.fillRect(0, 0, p.width, p.height);\n        isFillDirty = true;\n        restoreContext();\n      }\n    };\n\n    Drawing3D.prototype.background = function(arg1, arg2, arg3, arg4) {\n      if (arguments.length > 0) {\n        backgroundHelper(arg1, arg2, arg3, arg4);\n      }\n\n      var c = p.color.toGLArray(backgroundObj);\n      curContext.clearColor(c[0], c[1], c[2], c[3]);\n      curContext.clear(curContext.COLOR_BUFFER_BIT | curContext.DEPTH_BUFFER_BIT);\n\n      // An image as a background in 3D is not implemented yet\n    };\n\n    // Draws an image to the Canvas\n    /**\n    * Displays images to the screen. The images must be in the sketch's \"data\" directory to load correctly. Select \"Add\n    * file...\" from the \"Sketch\" menu to add the image. Processing currently works with GIF, JPEG, and Targa images. The\n    * color of an image may be modified with the tint() function and if a GIF has transparency, it will maintain its\n    * transparency. The img parameter specifies the image to display and the x and y parameters define the location of\n    * the image from its upper-left corner. The image is displayed at its original size unless the width and height\n    * parameters specify a different size. The imageMode() function changes the way the parameters work. A call to\n    * imageMode(CORNERS) will change the width and height parameters to define the x and y values of the opposite\n    * corner of the image.\n    *\n    * @param {PImage} img            the image to display\n    * @param {int|float} x           x-coordinate of the image\n    * @param {int|float} y           y-coordinate of the image\n    * @param {int|float} width       width to display the image\n    * @param {int|float} height      height to display the image\n    *\n    * @see loadImage\n    * @see PImage\n    * @see imageMode\n    * @see tint\n    * @see background\n    * @see alpha\n    */\n    Drawing2D.prototype.image = function(img, x, y, w, h) {\n      // Fix fractional positions\n      x = Math.round(x);\n      y = Math.round(y);\n\n      if (img.width > 0) {\n        var wid = w || img.width;\n        var hgt = h || img.height;\n\n        var bounds = imageModeConvert(x || 0, y || 0, w || img.width, h || img.height, arguments.length < 4);\n        var fastImage = !!img.sourceImg && curTint === null;\n        if (fastImage) {\n          var htmlElement = img.sourceImg;\n          if (img.__isDirty) {\n            img.updatePixels();\n          }\n          // Using HTML element's width and height in case if the image was resized.\n          curContext.drawImage(htmlElement, 0, 0,\n            htmlElement.width, htmlElement.height, bounds.x, bounds.y, bounds.w, bounds.h);\n        } else {\n          var obj = img.toImageData();\n\n          // Tint the image\n          if (curTint !== null) {\n            curTint(obj);\n            img.__isDirty = true;\n          }\n\n          curContext.drawImage(getCanvasData(obj).canvas, 0, 0,\n            img.width, img.height, bounds.x, bounds.y, bounds.w, bounds.h);\n        }\n      }\n    };\n\n    Drawing3D.prototype.image = function(img, x, y, w, h) {\n      if (img.width > 0) {\n        // Fix fractional positions\n        x = Math.round(x);\n        y = Math.round(y);\n        w = w || img.width;\n        h = h || img.height;\n\n        p.beginShape(p.QUADS);\n        p.texture(img);\n        p.vertex(x, y, 0, 0, 0);\n        p.vertex(x, y+h, 0, 0, h);\n        p.vertex(x+w, y+h, 0, w, h);\n        p.vertex(x+w, y, 0, w, 0);\n        p.endShape();\n      }\n    };\n\n    /**\n     * The tint() function sets the fill value for displaying images. Images can be tinted to\n     * specified colors or made transparent by setting the alpha.\n     * <br><br>To make an image transparent, but not change it's color,\n     * use white as the tint color and specify an alpha value. For instance,\n     * tint(255, 128) will make an image 50% transparent (unless\n     * <b>colorMode()</b> has been used).\n     *\n     * <br><br>When using hexadecimal notation to specify a color, use \"#\" or\n     * \"0x\" before the values (e.g. #CCFFAA, 0xFFCCFFAA). The # syntax uses six\n     * digits to specify a color (the way colors are specified in HTML and CSS).\n     * When using the hexadecimal notation starting with \"0x\", the hexadecimal\n     * value must be specified with eight characters; the first two characters\n     * define the alpha component and the remainder the red, green, and blue\n     * components.\n     * <br><br>The value for the parameter \"gray\" must be less than or equal\n     * to the current maximum value as specified by <b>colorMode()</b>.\n     * The default maximum value is 255.\n     * <br><br>The tint() method is also used to control the coloring of\n     * textures in 3D.\n     *\n     * @param {int|float} gray    any valid number\n     * @param {int|float} alpha    opacity of the image\n     * @param {int|float} value1  red or hue value\n     * @param {int|float} value2  green or saturation value\n     * @param {int|float} value3  blue or brightness value\n     * @param {int|float} color    any value of the color datatype\n     * @param {int} hex            color value in hexadecimal notation (i.e. #FFCC00 or 0xFFFFCC00)\n     *\n     * @see #noTint()\n     * @see #image()\n     */\n    p.tint = function(a1, a2, a3, a4) {\n      var tintColor = p.color(a1, a2, a3, a4);\n      var r = p.red(tintColor) / colorModeX;\n      var g = p.green(tintColor) / colorModeY;\n      var b = p.blue(tintColor) / colorModeZ;\n      var a = p.alpha(tintColor) / colorModeA;\n      curTint = function(obj) {\n        var data = obj.data,\n            length = 4 * obj.width * obj.height;\n        for (var i = 0; i < length;) {\n          data[i++] *= r;\n          data[i++] *= g;\n          data[i++] *= b;\n          data[i++] *= a;\n        }\n      };\n      // for overriding the color buffer when 3d rendering\n      curTint3d = function(data){\n        for (var i = 0; i < data.length;) {\n          data[i++] = r;\n          data[i++] = g;\n          data[i++] = b;\n          data[i++] = a;\n        }\n      };\n    };\n\n    /**\n     * The noTint() function removes the current fill value for displaying images and reverts to displaying images with their original hues.\n     *\n     * @see #tint()\n     * @see #image()\n     */\n    p.noTint = function() {\n      curTint = null;\n      curTint3d = null;\n    };\n\n    /**\n    * Copies a region of pixels from the display window to another area of the display window and copies a region of pixels from an\n    * image used as the srcImg  parameter into the display window. If the source and destination regions aren't the same size, it will\n    * automatically resize the source pixels to fit the specified target region. No alpha information is used in the process, however\n    * if the source image has an alpha channel set, it will be copied as well. This function ignores imageMode().\n    *\n    * @param {int} x            X coordinate of the source's upper left corner\n    * @param {int} y            Y coordinate of the source's upper left corner\n    * @param {int} width        source image width\n    * @param {int} height       source image height\n    * @param {int} dx           X coordinate of the destination's upper left corner\n    * @param {int} dy           Y coordinate of the destination's upper left corner\n    * @param {int} dwidth       destination image width\n    * @param {int} dheight      destination image height\n    * @param {PImage} srcImg    image variable referring to the source image\n    *\n    * @see blend\n    * @see get\n    */\n    p.copy = function(src, sx, sy, sw, sh, dx, dy, dw, dh) {\n      if (dh === undef) {\n        // shift everything, and introduce p\n        dh = dw;\n        dw = dy;\n        dy = dx;\n        dx = sh;\n        sh = sw;\n        sw = sy;\n        sy = sx;\n        sx = src;\n        src = p;\n      }\n      p.blend(src, sx, sy, sw, sh, dx, dy, dw, dh, PConstants.REPLACE);\n    };\n\n    /**\n    * Blends a region of pixels from one image into another (or in itself again) with full alpha channel support. There\n    * is a choice of the following modes to blend the source pixels (A) with the ones of pixels in the destination image (B):\n    * BLEND - linear interpolation of colours: C = A*factor + B\n    * ADD - additive blending with white clip: C = min(A*factor + B, 255)\n    * SUBTRACT - subtractive blending with black clip: C = max(B - A*factor, 0)\n    * DARKEST - only the darkest colour succeeds: C = min(A*factor, B)\n    * LIGHTEST - only the lightest colour succeeds: C = max(A*factor, B)\n    * DIFFERENCE - subtract colors from underlying image.\n    * EXCLUSION - similar to DIFFERENCE, but less extreme.\n    * MULTIPLY - Multiply the colors, result will always be darker.\n    * SCREEN - Opposite multiply, uses inverse values of the colors.\n    * OVERLAY - A mix of MULTIPLY and SCREEN. Multiplies dark values, and screens light values.\n    * HARD_LIGHT - SCREEN when greater than 50% gray, MULTIPLY when lower.\n    * SOFT_LIGHT - Mix of DARKEST and LIGHTEST. Works like OVERLAY, but not as harsh.\n    * DODGE - Lightens light tones and increases contrast, ignores darks. Called \"Color Dodge\" in Illustrator and Photoshop.\n    * BURN - Darker areas are applied, increasing contrast, ignores lights. Called \"Color Burn\" in Illustrator and Photoshop.\n    * All modes use the alpha information (highest byte) of source image pixels as the blending factor. If the source and\n    * destination regions are different sizes, the image will be automatically resized to match the destination size. If the\n    * srcImg parameter is not used, the display window is used as the source image.  This function ignores imageMode().\n    *\n    * @param {int} x            X coordinate of the source's upper left corner\n    * @param {int} y            Y coordinate of the source's upper left corner\n    * @param {int} width        source image width\n    * @param {int} height       source image height\n    * @param {int} dx           X coordinate of the destination's upper left corner\n    * @param {int} dy           Y coordinate of the destination's upper left corner\n    * @param {int} dwidth       destination image width\n    * @param {int} dheight      destination image height\n    * @param {PImage} srcImg    image variable referring to the source image\n    * @param {PImage} MODE      Either BLEND, ADD, SUBTRACT, LIGHTEST, DARKEST, DIFFERENCE, EXCLUSION, MULTIPLY, SCREEN,\n    *                           OVERLAY, HARD_LIGHT, SOFT_LIGHT, DODGE, BURN\n    * @see filter\n    */\n    p.blend = function(src, sx, sy, sw, sh, dx, dy, dw, dh, mode, pimgdest) {\n      if (src.isRemote) {\n        throw \"Image is loaded remotely. Cannot blend image.\";\n      }\n\n      if (mode === undef) {\n        // shift everything, and introduce p\n        mode = dh;\n        dh = dw;\n        dw = dy;\n        dy = dx;\n        dx = sh;\n        sh = sw;\n        sw = sy;\n        sy = sx;\n        sx = src;\n        src = p;\n      }\n\n      var sx2 = sx + sw,\n        sy2 = sy + sh,\n        dx2 = dx + dw,\n        dy2 = dy + dh,\n        dest = pimgdest || p;\n\n      // check if pimgdest is there and pixels, if so this was a call from pimg.blend\n      if (pimgdest === undef || mode === undef) {\n        p.loadPixels();\n      }\n\n      src.loadPixels();\n\n      if (src === p && p.intersect(sx, sy, sx2, sy2, dx, dy, dx2, dy2)) {\n        p.blit_resize(p.get(sx, sy, sx2 - sx, sy2 - sy), 0, 0, sx2 - sx - 1, sy2 - sy - 1,\n                      dest.imageData.data, dest.width, dest.height, dx, dy, dx2, dy2, mode);\n      } else {\n        p.blit_resize(src, sx, sy, sx2, sy2, dest.imageData.data, dest.width, dest.height, dx, dy, dx2, dy2, mode);\n      }\n\n      if (pimgdest === undef) {\n        p.updatePixels();\n      }\n    };\n\n    // helper function for filter()\n    var buildBlurKernel = function(r) {\n      var radius = p.floor(r * 3.5), i;\n      radius = (radius < 1) ? 1 : ((radius < 248) ? radius : 248);\n      if (p.shared.blurRadius !== radius) {\n        p.shared.blurRadius = radius;\n        p.shared.blurKernelSize = 1 + (p.shared.blurRadius<<1);\n        p.shared.blurKernel = new Float32Array(p.shared.blurKernelSize);\n        var sharedBlurKernal = p.shared.blurKernel;\n        var sharedBlurKernelSize = p.shared.blurKernelSize;\n        var sharedBlurRadius = p.shared.blurRadius;\n        // init blurKernel\n        for (i = 0; i < sharedBlurKernelSize; i++) {\n          sharedBlurKernal[i] = 0;\n        }\n        var radiusiSquared = (radius - 1) * (radius - 1);\n        for (i = 1; i < radius; i++) {\n          sharedBlurKernal[radius + i] = sharedBlurKernal[radius-i] = radiusiSquared;\n        }\n        sharedBlurKernal[radius] = radius * radius;\n      }\n    };\n\n    var blurARGB = function(r, aImg) {\n      var sum, cr, cg, cb, ca, c, m;\n      var read, ri, ym, ymi, bk0;\n      var wh = aImg.pixels.getLength();\n      var r2 = new Float32Array(wh);\n      var g2 = new Float32Array(wh);\n      var b2 = new Float32Array(wh);\n      var a2 = new Float32Array(wh);\n      var yi = 0;\n      var x, y, i, offset;\n\n      buildBlurKernel(r);\n\n      var aImgHeight = aImg.height;\n      var aImgWidth = aImg.width;\n      var sharedBlurKernelSize = p.shared.blurKernelSize;\n      var sharedBlurRadius = p.shared.blurRadius;\n      var sharedBlurKernal = p.shared.blurKernel;\n      var pix = aImg.imageData.data;\n\n      for (y = 0; y < aImgHeight; y++) {\n        for (x = 0; x < aImgWidth; x++) {\n          cb = cg = cr = ca = sum = 0;\n          read = x - sharedBlurRadius;\n          if (read<0) {\n            bk0 = -read;\n            read = 0;\n          } else {\n            if (read >= aImgWidth) {\n              break;\n            }\n            bk0=0;\n          }\n          for (i = bk0; i < sharedBlurKernelSize; i++) {\n            if (read >= aImgWidth) {\n              break;\n            }\n            offset = (read + yi) *4;\n            m = sharedBlurKernal[i];\n            ca += m * pix[offset + 3];\n            cr += m * pix[offset];\n            cg += m * pix[offset + 1];\n            cb += m * pix[offset + 2];\n            sum += m;\n            read++;\n          }\n          ri = yi + x;\n          a2[ri] = ca / sum;\n          r2[ri] = cr / sum;\n          g2[ri] = cg / sum;\n          b2[ri] = cb / sum;\n        }\n        yi += aImgWidth;\n      }\n\n      yi = 0;\n      ym = -sharedBlurRadius;\n      ymi = ym*aImgWidth;\n\n      for (y = 0; y < aImgHeight; y++) {\n        for (x = 0; x < aImgWidth; x++) {\n          cb = cg = cr = ca = sum = 0;\n          if (ym<0) {\n            bk0 = ri = -ym;\n            read = x;\n          } else {\n            if (ym >= aImgHeight) {\n              break;\n            }\n            bk0 = 0;\n            ri = ym;\n            read = x + ymi;\n          }\n          for (i = bk0; i < sharedBlurKernelSize; i++) {\n            if (ri >= aImgHeight) {\n              break;\n            }\n            m = sharedBlurKernal[i];\n            ca += m * a2[read];\n            cr += m * r2[read];\n            cg += m * g2[read];\n            cb += m * b2[read];\n            sum += m;\n            ri++;\n            read += aImgWidth;\n          }\n          offset = (x + yi) *4;\n          pix[offset] = cr / sum;\n          pix[offset + 1] = cg / sum;\n          pix[offset + 2] = cb / sum;\n          pix[offset + 3] = ca / sum;\n        }\n        yi += aImgWidth;\n        ymi += aImgWidth;\n        ym++;\n      }\n    };\n\n    // helper funtion for ERODE and DILATE modes of filter()\n    var dilate = function(isInverted, aImg) {\n      var currIdx = 0;\n      var maxIdx = aImg.pixels.getLength();\n      var out = new Int32Array(maxIdx);\n      var currRowIdx, maxRowIdx, colOrig, colOut, currLum;\n      var idxRight, idxLeft, idxUp, idxDown,\n          colRight, colLeft, colUp, colDown,\n          lumRight, lumLeft, lumUp, lumDown;\n\n      if (!isInverted) {\n        // erosion (grow light areas)\n        while (currIdx<maxIdx) {\n          currRowIdx = currIdx;\n          maxRowIdx = currIdx + aImg.width;\n          while (currIdx < maxRowIdx) {\n            colOrig = colOut = aImg.pixels.getPixel(currIdx);\n            idxLeft = currIdx - 1;\n            idxRight = currIdx + 1;\n            idxUp = currIdx - aImg.width;\n            idxDown = currIdx + aImg.width;\n            if (idxLeft < currRowIdx) {\n              idxLeft = currIdx;\n            }\n            if (idxRight >= maxRowIdx) {\n              idxRight = currIdx;\n            }\n            if (idxUp < 0) {\n              idxUp = 0;\n            }\n            if (idxDown >= maxIdx) {\n              idxDown = currIdx;\n            }\n            colUp = aImg.pixels.getPixel(idxUp);\n            colLeft = aImg.pixels.getPixel(idxLeft);\n            colDown = aImg.pixels.getPixel(idxDown);\n            colRight = aImg.pixels.getPixel(idxRight);\n\n            // compute luminance\n            currLum = 77*(colOrig>>16&0xff) + 151*(colOrig>>8&0xff) + 28*(colOrig&0xff);\n            lumLeft = 77*(colLeft>>16&0xff) + 151*(colLeft>>8&0xff) + 28*(colLeft&0xff);\n            lumRight = 77*(colRight>>16&0xff) + 151*(colRight>>8&0xff) + 28*(colRight&0xff);\n            lumUp = 77*(colUp>>16&0xff) + 151*(colUp>>8&0xff) + 28*(colUp&0xff);\n            lumDown = 77*(colDown>>16&0xff) + 151*(colDown>>8&0xff) + 28*(colDown&0xff);\n\n            if (lumLeft > currLum) {\n              colOut = colLeft;\n              currLum = lumLeft;\n            }\n            if (lumRight > currLum) {\n              colOut = colRight;\n              currLum = lumRight;\n            }\n            if (lumUp > currLum) {\n              colOut = colUp;\n              currLum = lumUp;\n            }\n            if (lumDown > currLum) {\n              colOut = colDown;\n              currLum = lumDown;\n            }\n            out[currIdx++] = colOut;\n          }\n        }\n      } else {\n        // dilate (grow dark areas)\n        while (currIdx < maxIdx) {\n          currRowIdx = currIdx;\n          maxRowIdx = currIdx + aImg.width;\n          while (currIdx < maxRowIdx) {\n            colOrig = colOut = aImg.pixels.getPixel(currIdx);\n            idxLeft = currIdx - 1;\n            idxRight = currIdx + 1;\n            idxUp = currIdx - aImg.width;\n            idxDown = currIdx + aImg.width;\n            if (idxLeft < currRowIdx) {\n              idxLeft = currIdx;\n            }\n            if (idxRight >= maxRowIdx) {\n              idxRight = currIdx;\n            }\n            if (idxUp < 0) {\n              idxUp = 0;\n            }\n            if (idxDown >= maxIdx) {\n              idxDown = currIdx;\n            }\n            colUp = aImg.pixels.getPixel(idxUp);\n            colLeft = aImg.pixels.getPixel(idxLeft);\n            colDown = aImg.pixels.getPixel(idxDown);\n            colRight = aImg.pixels.getPixel(idxRight);\n\n            // compute luminance\n            currLum = 77*(colOrig>>16&0xff) + 151*(colOrig>>8&0xff) + 28*(colOrig&0xff);\n            lumLeft = 77*(colLeft>>16&0xff) + 151*(colLeft>>8&0xff) + 28*(colLeft&0xff);\n            lumRight = 77*(colRight>>16&0xff) + 151*(colRight>>8&0xff) + 28*(colRight&0xff);\n            lumUp = 77*(colUp>>16&0xff) + 151*(colUp>>8&0xff) + 28*(colUp&0xff);\n            lumDown = 77*(colDown>>16&0xff) + 151*(colDown>>8&0xff) + 28*(colDown&0xff);\n\n            if (lumLeft < currLum) {\n              colOut = colLeft;\n              currLum = lumLeft;\n            }\n            if (lumRight < currLum) {\n              colOut = colRight;\n              currLum = lumRight;\n            }\n            if (lumUp < currLum) {\n              colOut = colUp;\n              currLum = lumUp;\n            }\n            if (lumDown < currLum) {\n              colOut = colDown;\n              currLum = lumDown;\n            }\n            out[currIdx++]=colOut;\n          }\n        }\n      }\n      aImg.pixels.set(out);\n      //p.arraycopy(out,0,pixels,0,maxIdx);\n    };\n\n    /**\n    * Filters the display window as defined by one of the following modes:\n    * THRESHOLD - converts the image to black and white pixels depending if they are above or below the threshold\n    * defined by the level parameter. The level must be between 0.0 (black) and 1.0(white). If no level is specified, 0.5 is used.\n    * GRAY - converts any colors in the image to grayscale equivalents\n    * INVERT - sets each pixel to its inverse value\n    * POSTERIZE - limits each channel of the image to the number of colors specified as the level parameter\n    * BLUR - executes a Guassian blur with the level parameter specifying the extent of the blurring. If no level parameter is\n    * used, the blur is equivalent to Guassian blur of radius 1.\n    * OPAQUE - sets the alpha channel to entirely opaque.\n    * ERODE - reduces the light areas with the amount defined by the level parameter.\n    * DILATE - increases the light areas with the amount defined by the level parameter.\n    *\n    * @param {MODE} MODE          Either THRESHOLD, GRAY, INVERT, POSTERIZE, BLUR, OPAQUE, ERODE, or DILATE\n    * @param {int|float} level    defines the quality of the filter\n    *\n    * @see blend\n    */\n    p.filter = function(kind, param, aImg){\n      var img, col, lum, i;\n\n      if (arguments.length === 3) {\n        aImg.loadPixels();\n        img = aImg;\n      } else {\n        p.loadPixels();\n        img = p;\n      }\n\n      if (param === undef) {\n        param = null;\n      }\n      if (img.isRemote) { // Remote images cannot access imageData\n        throw \"Image is loaded remotely. Cannot filter image.\";\n      }\n      // begin filter process\n      var imglen = img.pixels.getLength();\n      switch (kind) {\n        case PConstants.BLUR:\n          var radius = param || 1; // if no param specified, use 1 (default for p5)\n          blurARGB(radius, img);\n          break;\n\n        case PConstants.GRAY:\n          if (img.format === PConstants.ALPHA) { //trouble\n            // for an alpha image, convert it to an opaque grayscale\n            for (i = 0; i < imglen; i++) {\n              col = 255 - img.pixels.getPixel(i);\n              img.pixels.setPixel(i,(0xff000000 | (col << 16) | (col << 8) | col));\n            }\n            img.format = PConstants.RGB; //trouble\n          } else {\n            for (i = 0; i < imglen; i++) {\n              col = img.pixels.getPixel(i);\n              lum = (77*(col>>16&0xff) + 151*(col>>8&0xff) + 28*(col&0xff))>>8;\n              img.pixels.setPixel(i,((col & PConstants.ALPHA_MASK) | lum<<16 | lum<<8 | lum));\n            }\n          }\n          break;\n\n        case PConstants.INVERT:\n          for (i = 0; i < imglen; i++) {\n            img.pixels.setPixel(i, (img.pixels.getPixel(i) ^ 0xffffff));\n          }\n          break;\n\n        case PConstants.POSTERIZE:\n          if (param === null) {\n            throw \"Use filter(POSTERIZE, int levels) instead of filter(POSTERIZE)\";\n          }\n          var levels = p.floor(param);\n          if ((levels < 2) || (levels > 255)) {\n            throw \"Levels must be between 2 and 255 for filter(POSTERIZE, levels)\";\n          }\n          var levels1 = levels - 1;\n          for (i = 0; i < imglen; i++) {\n            var rlevel = (img.pixels.getPixel(i) >> 16) & 0xff;\n            var glevel = (img.pixels.getPixel(i) >> 8) & 0xff;\n            var blevel = img.pixels.getPixel(i) & 0xff;\n            rlevel = (((rlevel * levels) >> 8) * 255) / levels1;\n            glevel = (((glevel * levels) >> 8) * 255) / levels1;\n            blevel = (((blevel * levels) >> 8) * 255) / levels1;\n            img.pixels.setPixel(i, ((0xff000000 & img.pixels.getPixel(i)) | (rlevel << 16) | (glevel << 8) | blevel));\n          }\n          break;\n\n        case PConstants.OPAQUE:\n          for (i = 0; i < imglen; i++) {\n            img.pixels.setPixel(i, (img.pixels.getPixel(i) | 0xff000000));\n          }\n          img.format = PConstants.RGB; //trouble\n          break;\n\n        case PConstants.THRESHOLD:\n          if (param === null) {\n            param = 0.5;\n          }\n          if ((param < 0) || (param > 1)) {\n            throw \"Level must be between 0 and 1 for filter(THRESHOLD, level)\";\n          }\n          var thresh = p.floor(param * 255);\n          for (i = 0; i < imglen; i++) {\n            var max = p.max((img.pixels.getPixel(i) & PConstants.RED_MASK) >> 16, p.max((img.pixels.getPixel(i) & PConstants.GREEN_MASK) >> 8, (img.pixels.getPixel(i) & PConstants.BLUE_MASK)));\n            img.pixels.setPixel(i, ((img.pixels.getPixel(i) & PConstants.ALPHA_MASK) | ((max < thresh) ? 0x000000 : 0xffffff)));\n          }\n          break;\n\n        case PConstants.ERODE:\n          dilate(true, img);\n          break;\n\n        case PConstants.DILATE:\n          dilate(false, img);\n          break;\n      }\n      img.updatePixels();\n    };\n\n\n    // shared variables for blit_resize(), filter_new_scanline(), filter_bilinear(), filter()\n    // change this in the future to not be exposed to p\n    p.shared = {\n      fracU: 0,\n      ifU: 0,\n      fracV: 0,\n      ifV: 0,\n      u1: 0,\n      u2: 0,\n      v1: 0,\n      v2: 0,\n      sX: 0,\n      sY: 0,\n      iw: 0,\n      iw1: 0,\n      ih1: 0,\n      ul: 0,\n      ll: 0,\n      ur: 0,\n      lr: 0,\n      cUL: 0,\n      cLL: 0,\n      cUR: 0,\n      cLR: 0,\n      srcXOffset: 0,\n      srcYOffset: 0,\n      r: 0,\n      g: 0,\n      b: 0,\n      a: 0,\n      srcBuffer: null,\n      blurRadius: 0,\n      blurKernelSize: 0,\n      blurKernel: null\n    };\n\n    p.intersect = function(sx1, sy1, sx2, sy2, dx1, dy1, dx2, dy2) {\n      var sw = sx2 - sx1 + 1;\n      var sh = sy2 - sy1 + 1;\n      var dw = dx2 - dx1 + 1;\n      var dh = dy2 - dy1 + 1;\n      if (dx1 < sx1) {\n        dw += dx1 - sx1;\n        if (dw > sw) {\n          dw = sw;\n        }\n      } else {\n        var w = sw + sx1 - dx1;\n        if (dw > w) {\n          dw = w;\n        }\n      }\n      if (dy1 < sy1) {\n        dh += dy1 - sy1;\n        if (dh > sh) {\n          dh = sh;\n        }\n      } else {\n        var h = sh + sy1 - dy1;\n        if (dh > h) {\n          dh = h;\n        }\n      }\n      return ! (dw <= 0 || dh <= 0);\n    };\n\n    var blendFuncs = {};\n    blendFuncs[PConstants.BLEND] = p.modes.blend;\n    blendFuncs[PConstants.ADD] = p.modes.add;\n    blendFuncs[PConstants.SUBTRACT] = p.modes.subtract;\n    blendFuncs[PConstants.LIGHTEST] = p.modes.lightest;\n    blendFuncs[PConstants.DARKEST] = p.modes.darkest;\n    blendFuncs[PConstants.REPLACE] = p.modes.replace;\n    blendFuncs[PConstants.DIFFERENCE] = p.modes.difference;\n    blendFuncs[PConstants.EXCLUSION] = p.modes.exclusion;\n    blendFuncs[PConstants.MULTIPLY] = p.modes.multiply;\n    blendFuncs[PConstants.SCREEN] = p.modes.screen;\n    blendFuncs[PConstants.OVERLAY] = p.modes.overlay;\n    blendFuncs[PConstants.HARD_LIGHT] = p.modes.hard_light;\n    blendFuncs[PConstants.SOFT_LIGHT] = p.modes.soft_light;\n    blendFuncs[PConstants.DODGE] = p.modes.dodge;\n    blendFuncs[PConstants.BURN] = p.modes.burn;\n\n    p.blit_resize = function(img, srcX1, srcY1, srcX2, srcY2, destPixels,\n                             screenW, screenH, destX1, destY1, destX2, destY2, mode) {\n      var x, y;\n      if (srcX1 < 0) {\n        srcX1 = 0;\n      }\n      if (srcY1 < 0) {\n        srcY1 = 0;\n      }\n      if (srcX2 >= img.width) {\n        srcX2 = img.width - 1;\n      }\n      if (srcY2 >= img.height) {\n        srcY2 = img.height - 1;\n      }\n      var srcW = srcX2 - srcX1;\n      var srcH = srcY2 - srcY1;\n      var destW = destX2 - destX1;\n      var destH = destY2 - destY1;\n\n      if (destW <= 0 || destH <= 0 || srcW <= 0 || srcH <= 0 || destX1 >= screenW ||\n          destY1 >= screenH || srcX1 >= img.width || srcY1 >= img.height) {\n        return;\n      }\n\n      var dx = Math.floor(srcW / destW * PConstants.PRECISIONF);\n      var dy = Math.floor(srcH / destH * PConstants.PRECISIONF);\n\n      var pshared = p.shared;\n\n      pshared.srcXOffset = Math.floor(destX1 < 0 ? -destX1 * dx : srcX1 * PConstants.PRECISIONF);\n      pshared.srcYOffset = Math.floor(destY1 < 0 ? -destY1 * dy : srcY1 * PConstants.PRECISIONF);\n      if (destX1 < 0) {\n        destW += destX1;\n        destX1 = 0;\n      }\n      if (destY1 < 0) {\n        destH += destY1;\n        destY1 = 0;\n      }\n      destW = Math.min(destW, screenW - destX1);\n      destH = Math.min(destH, screenH - destY1);\n\n      var destOffset = destY1 * screenW + destX1;\n      var destColor;\n\n      pshared.srcBuffer = img.imageData.data;\n      pshared.iw = img.width;\n      pshared.iw1 = img.width - 1;\n      pshared.ih1 = img.height - 1;\n\n      // cache for speed\n      var filterBilinear = p.filter_bilinear,\n        filterNewScanline = p.filter_new_scanline,\n        blendFunc = blendFuncs[mode],\n        blendedColor,\n        idx,\n        cULoffset,\n        cURoffset,\n        cLLoffset,\n        cLRoffset,\n        ALPHA_MASK = PConstants.ALPHA_MASK,\n        RED_MASK = PConstants.RED_MASK,\n        GREEN_MASK = PConstants.GREEN_MASK,\n        BLUE_MASK = PConstants.BLUE_MASK,\n        PREC_MAXVAL = PConstants.PREC_MAXVAL,\n        PRECISIONB = PConstants.PRECISIONB,\n        PREC_RED_SHIFT = PConstants.PREC_RED_SHIFT,\n        PREC_ALPHA_SHIFT = PConstants.PREC_ALPHA_SHIFT,\n        srcBuffer = pshared.srcBuffer,\n        min = Math.min;\n\n      for (y = 0; y < destH; y++) {\n\n        pshared.sX = pshared.srcXOffset;\n        pshared.fracV = pshared.srcYOffset & PREC_MAXVAL;\n        pshared.ifV = PREC_MAXVAL - pshared.fracV;\n        pshared.v1 = (pshared.srcYOffset >> PRECISIONB) * pshared.iw;\n        pshared.v2 = min((pshared.srcYOffset >> PRECISIONB) + 1, pshared.ih1) * pshared.iw;\n\n        for (x = 0; x < destW; x++) {\n          idx = (destOffset + x) * 4;\n\n          destColor = (destPixels[idx + 3] << 24) &\n                      ALPHA_MASK | (destPixels[idx] << 16) &\n                      RED_MASK   | (destPixels[idx + 1] << 8) &\n                      GREEN_MASK |  destPixels[idx + 2] & BLUE_MASK;\n\n          pshared.fracU = pshared.sX & PREC_MAXVAL;\n          pshared.ifU = PREC_MAXVAL - pshared.fracU;\n          pshared.ul = (pshared.ifU * pshared.ifV) >> PRECISIONB;\n          pshared.ll = (pshared.ifU * pshared.fracV) >> PRECISIONB;\n          pshared.ur = (pshared.fracU * pshared.ifV) >> PRECISIONB;\n          pshared.lr = (pshared.fracU * pshared.fracV) >> PRECISIONB;\n          pshared.u1 = (pshared.sX >> PRECISIONB);\n          pshared.u2 = min(pshared.u1 + 1, pshared.iw1);\n\n          cULoffset = (pshared.v1 + pshared.u1) * 4;\n          cURoffset = (pshared.v1 + pshared.u2) * 4;\n          cLLoffset = (pshared.v2 + pshared.u1) * 4;\n          cLRoffset = (pshared.v2 + pshared.u2) * 4;\n\n          pshared.cUL = (srcBuffer[cULoffset + 3] << 24) &\n                        ALPHA_MASK | (srcBuffer[cULoffset] << 16) &\n                        RED_MASK   | (srcBuffer[cULoffset + 1] << 8) &\n                        GREEN_MASK |  srcBuffer[cULoffset + 2] & BLUE_MASK;\n\n          pshared.cUR = (srcBuffer[cURoffset + 3] << 24) &\n                        ALPHA_MASK | (srcBuffer[cURoffset] << 16) &\n                        RED_MASK   | (srcBuffer[cURoffset + 1] << 8) &\n                        GREEN_MASK |  srcBuffer[cURoffset + 2] & BLUE_MASK;\n\n          pshared.cLL = (srcBuffer[cLLoffset + 3] << 24) &\n                        ALPHA_MASK | (srcBuffer[cLLoffset] << 16) &\n                        RED_MASK   | (srcBuffer[cLLoffset + 1] << 8) &\n                        GREEN_MASK |  srcBuffer[cLLoffset + 2] & BLUE_MASK;\n\n          pshared.cLR = (srcBuffer[cLRoffset + 3] << 24) &\n                        ALPHA_MASK | (srcBuffer[cLRoffset] << 16) &\n                        RED_MASK   | (srcBuffer[cLRoffset + 1] << 8) &\n                        GREEN_MASK |  srcBuffer[cLRoffset + 2] & BLUE_MASK;\n\n          pshared.r = ((pshared.ul * ((pshared.cUL & RED_MASK) >> 16) +\n                       pshared.ll * ((pshared.cLL & RED_MASK) >> 16) +\n                       pshared.ur * ((pshared.cUR & RED_MASK) >> 16) +\n                       pshared.lr * ((pshared.cLR & RED_MASK) >> 16)) << PREC_RED_SHIFT) & RED_MASK;\n          pshared.g = ((pshared.ul * (pshared.cUL & GREEN_MASK) +\n                       pshared.ll * (pshared.cLL & GREEN_MASK) +\n                       pshared.ur * (pshared.cUR & GREEN_MASK) +\n                       pshared.lr * (pshared.cLR & GREEN_MASK)) >>> PRECISIONB) & GREEN_MASK;\n          pshared.b = (pshared.ul * (pshared.cUL & BLUE_MASK) +\n                       pshared.ll * (pshared.cLL & BLUE_MASK) +\n                       pshared.ur * (pshared.cUR & BLUE_MASK) +\n                       pshared.lr * (pshared.cLR & BLUE_MASK)) >>> PRECISIONB;\n          pshared.a = ((pshared.ul * ((pshared.cUL & ALPHA_MASK) >>> 24) +\n                       pshared.ll * ((pshared.cLL & ALPHA_MASK) >>> 24) +\n                       pshared.ur * ((pshared.cUR & ALPHA_MASK) >>> 24) +\n                       pshared.lr * ((pshared.cLR & ALPHA_MASK) >>> 24)) << PREC_ALPHA_SHIFT) & ALPHA_MASK;\n\n          blendedColor = blendFunc(destColor, (pshared.a | pshared.r | pshared.g | pshared.b));\n\n          destPixels[idx]     = (blendedColor & RED_MASK) >>> 16;\n          destPixels[idx + 1] = (blendedColor & GREEN_MASK) >>> 8;\n          destPixels[idx + 2] = (blendedColor & BLUE_MASK);\n          destPixels[idx + 3] = (blendedColor & ALPHA_MASK) >>> 24;\n\n          pshared.sX += dx;\n        }\n        destOffset += screenW;\n        pshared.srcYOffset += dy;\n      }\n    };\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Font handling\n    ////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * loadFont() Loads a font into a variable of type PFont.\n     *\n     * @param {String} name filename of the font to load\n     * @param {int|float} size option font size (used internally)\n     *\n     * @returns {PFont} new PFont object\n     *\n     * @see #PFont\n     * @see #textFont\n     * @see #text\n     * @see #createFont\n     */\n    p.loadFont = function(name, size) {\n      if (name === undef) {\n        throw(\"font name required in loadFont.\");\n      }\n      if (name.indexOf(\".svg\") === -1) {\n        if (size === undef) {\n          size = curTextFont.size;\n        }\n        return PFont.get(name, size);\n      }\n      // If the font is a glyph, calculate by SVG table\n      var font = p.loadGlyphs(name);\n\n      return {\n        name: name,\n        css: '12px sans-serif',\n        glyph: true,\n        units_per_em: font.units_per_em,\n        horiz_adv_x: 1 / font.units_per_em * font.horiz_adv_x,\n        ascent: font.ascent,\n        descent: font.descent,\n        width: function(str) {\n          var width = 0;\n          var len = str.length;\n          for (var i = 0; i < len; i++) {\n            try {\n              width += parseFloat(p.glyphLook(p.glyphTable[name], str[i]).horiz_adv_x);\n            }\n            catch(e) {\n              Processing.debug(e);\n            }\n          }\n          return width / p.glyphTable[name].units_per_em;\n        }\n      };\n    };\n\n    /**\n     * createFont() Loads a font into a variable of type PFont.\n     * Smooth and charset are ignored in Processing.js.\n     *\n     * @param {String}    name    filename of the font to load\n     * @param {int|float} size    font size in pixels\n     * @param {boolean}   smooth  not used in Processing.js\n     * @param {char[]}    charset not used in Processing.js\n     *\n     * @returns {PFont} new PFont object\n     *\n     * @see #PFont\n     * @see #textFont\n     * @see #text\n     * @see #loadFont\n     */\n    p.createFont = function(name, size) {\n      // because Processing.js only deals with real fonts,\n      // createFont is simply a wrapper for loadFont/2\n      return p.loadFont(name, size);\n    };\n\n    /**\n     * textFont() Sets the current font.\n     *\n     * @param {PFont}     pfont the PFont to load as current text font\n     * @param {int|float} size optional font size in pixels\n     *\n     * @see #createFont\n     * @see #loadFont\n     * @see #PFont\n     * @see #text\n     */\n    p.textFont = function(pfont, size) {\n      if (size !== undef) {\n        // If we're using an SVG glyph font, don't load from cache\n        if (!pfont.glyph) {\n          pfont = PFont.get(pfont.name, size);\n        }\n        curTextSize = size;\n      }\n      curTextFont = pfont;\n      curFontName = curTextFont.name;\n      curTextAscent = curTextFont.ascent;\n      curTextDescent = curTextFont.descent;\n      curTextLeading = curTextFont.leading;\n      var curContext = drawing.$ensureContext();\n      curContext.font = curTextFont.css;\n    };\n\n    /**\n     * textSize() Sets the current font size in pixels.\n     *\n     * @param {int|float} size font size in pixels\n     *\n     * @see #textFont\n     * @see #loadFont\n     * @see #PFont\n     * @see #text\n     */\n    p.textSize = function(size) {\n      curTextFont = PFont.get(curFontName, size);\n      curTextSize = size;\n      // recache metrics\n      curTextAscent = curTextFont.ascent;\n      curTextDescent = curTextFont.descent;\n      curTextLeading = curTextFont.leading;\n      var curContext = drawing.$ensureContext();\n      curContext.font = curTextFont.css;\n    };\n\n    /**\n     * textAscent() returns the maximum height a character extends above the baseline of the\n     * current font at its current size, in pixels.\n     *\n     * @returns {float} height of the current font above the baseline, at its current size, in pixels\n     *\n     * @see #textDescent\n     */\n    p.textAscent = function() {\n      return curTextAscent;\n    };\n\n    /**\n     * textDescent() returns the maximum depth a character will protrude below the baseline of\n     * the current font at its current size, in pixels.\n     *\n     * @returns {float} depth of the current font below the baseline, at its current size, in pixels\n     *\n     * @see #textAscent\n     */\n    p.textDescent = function() {\n      return curTextDescent;\n    };\n\n    /**\n     * textLeading() Sets the current font's leading, which is the distance\n     * from baseline to baseline over consecutive lines, with additional vertical\n     * spacing taking into account. Usually this value is 1.2 or 1.25 times the\n     * textsize, but this value can be changed to effect vertically compressed\n     * or stretched text.\n     *\n     * @param {int|float} the desired baseline-to-baseline size in pixels\n     */\n    p.textLeading = function(leading) {\n      curTextLeading = leading;\n    };\n\n    /**\n     * textAlign() Sets the current alignment for drawing text.\n     *\n     * @param {int} ALIGN  Horizontal alignment, either LEFT, CENTER, or RIGHT\n     * @param {int} YALIGN optional vertical alignment, either TOP, BOTTOM, CENTER, or BASELINE\n     *\n     * @see #loadFont\n     * @see #PFont\n     * @see #text\n     */\n    p.textAlign = function(xalign, yalign) {\n      horizontalTextAlignment = xalign;\n      verticalTextAlignment = yalign || PConstants.BASELINE;\n    };\n\n    /**\n     * toP5String converts things with arbitrary data type into\n     * string values, for text rendering.\n     *\n     * @param {any} any object that can be converted into a string\n     *\n     * @return {String} the string representation of the input\n     */\n    function toP5String(obj) {\n      if(obj instanceof String) {\n        return obj;\n      }\n      if(typeof obj === 'number') {\n        // check if an int\n        if(obj === (0 | obj)) {\n          return obj.toString();\n        }\n        return p.nf(obj, 0, 3);\n      }\n      if(obj === null || obj === undef) {\n        return \"\";\n      }\n      return obj.toString();\n    }\n\n    /**\n     * textWidth() Calculates and returns the width of any character or text string in pixels.\n     *\n     * @param {char|String} str char or String to be measured\n     *\n     * @return {float} width of char or String in pixels\n     *\n     * @see #loadFont\n     * @see #PFont\n     * @see #text\n     * @see #textFont\n     */\n    Drawing2D.prototype.textWidth = function(str) {\n      var lines = toP5String(str).split(/\\r?\\n/g), width = 0;\n      var i, linesCount = lines.length;\n\n      curContext.font = curTextFont.css;\n      for (i = 0; i < linesCount; ++i) {\n        width = Math.max(width, curTextFont.measureTextWidth(lines[i]));\n      }\n      return width | 0;\n    };\n\n    Drawing3D.prototype.textWidth = function(str) {\n      var lines = toP5String(str).split(/\\r?\\n/g), width = 0;\n      var i, linesCount = lines.length;\n      if (textcanvas === undef) {\n        textcanvas = document.createElement(\"canvas\");\n      }\n\n      var textContext = textcanvas.getContext(\"2d\");\n      textContext.font = curTextFont.css;\n\n      for (i = 0; i < linesCount; ++i) {\n        width = Math.max(width, textContext.measureText(lines[i]).width);\n      }\n      return width | 0;\n    };\n\n    // A lookup table for characters that can not be referenced by Object\n    p.glyphLook = function(font, chr) {\n      try {\n        switch (chr) {\n        case \"1\":\n          return font.one;\n        case \"2\":\n          return font.two;\n        case \"3\":\n          return font.three;\n        case \"4\":\n          return font.four;\n        case \"5\":\n          return font.five;\n        case \"6\":\n          return font.six;\n        case \"7\":\n          return font.seven;\n        case \"8\":\n          return font.eight;\n        case \"9\":\n          return font.nine;\n        case \"0\":\n          return font.zero;\n        case \" \":\n          return font.space;\n        case \"$\":\n          return font.dollar;\n        case \"!\":\n          return font.exclam;\n        case '\"':\n          return font.quotedbl;\n        case \"#\":\n          return font.numbersign;\n        case \"%\":\n          return font.percent;\n        case \"&\":\n          return font.ampersand;\n        case \"'\":\n          return font.quotesingle;\n        case \"(\":\n          return font.parenleft;\n        case \")\":\n          return font.parenright;\n        case \"*\":\n          return font.asterisk;\n        case \"+\":\n          return font.plus;\n        case \",\":\n          return font.comma;\n        case \"-\":\n          return font.hyphen;\n        case \".\":\n          return font.period;\n        case \"/\":\n          return font.slash;\n        case \"_\":\n          return font.underscore;\n        case \":\":\n          return font.colon;\n        case \";\":\n          return font.semicolon;\n        case \"<\":\n          return font.less;\n        case \"=\":\n          return font.equal;\n        case \">\":\n          return font.greater;\n        case \"?\":\n          return font.question;\n        case \"@\":\n          return font.at;\n        case \"[\":\n          return font.bracketleft;\n        case \"\\\\\":\n          return font.backslash;\n        case \"]\":\n          return font.bracketright;\n        case \"^\":\n          return font.asciicircum;\n        case \"`\":\n          return font.grave;\n        case \"{\":\n          return font.braceleft;\n        case \"|\":\n          return font.bar;\n        case \"}\":\n          return font.braceright;\n        case \"~\":\n          return font.asciitilde;\n          // If the character is not 'special', access it by object reference\n        default:\n          return font[chr];\n        }\n      } catch(e) {\n        Processing.debug(e);\n      }\n    };\n\n    // Print some text to the Canvas\n    Drawing2D.prototype.text$line = function(str, x, y, z, align) {\n      var textWidth = 0, xOffset = 0;\n      // If the font is a standard Canvas font...\n      if (!curTextFont.glyph) {\n        if (str && (\"fillText\" in curContext)) {\n          if (isFillDirty) {\n            curContext.fillStyle = p.color.toString(currentFillColor);\n            isFillDirty = false;\n          }\n\n          // horizontal offset/alignment\n          if(align === PConstants.RIGHT || align === PConstants.CENTER) {\n            textWidth = curTextFont.measureTextWidth(str);\n\n            if(align === PConstants.RIGHT) {\n              xOffset = -textWidth;\n            } else { // if(align === PConstants.CENTER)\n              xOffset = -textWidth/2;\n            }\n          }\n\n          curContext.fillText(str, x+xOffset, y);\n        }\n      } else {\n        // If the font is a Batik SVG font...\n        var font = p.glyphTable[curFontName];\n        saveContext();\n        curContext.translate(x, y + curTextSize);\n\n        // horizontal offset/alignment\n        if(align === PConstants.RIGHT || align === PConstants.CENTER) {\n          textWidth = font.width(str);\n\n          if(align === PConstants.RIGHT) {\n            xOffset = -textWidth;\n          } else { // if(align === PConstants.CENTER)\n            xOffset = -textWidth/2;\n          }\n        }\n\n        var upem   = font.units_per_em,\n          newScale = 1 / upem * curTextSize;\n\n        curContext.scale(newScale, newScale);\n\n        for (var i=0, len=str.length; i < len; i++) {\n          // Test character against glyph table\n          try {\n            p.glyphLook(font, str[i]).draw();\n          } catch(e) {\n            Processing.debug(e);\n          }\n        }\n        restoreContext();\n      }\n    };\n\n    Drawing3D.prototype.text$line = function(str, x, y, z, align) {\n      // handle case for 3d text\n      if (textcanvas === undef) {\n        textcanvas = document.createElement(\"canvas\");\n      }\n      var oldContext = curContext;\n      curContext = textcanvas.getContext(\"2d\");\n      curContext.font = curTextFont.css;\n      var textWidth = curTextFont.measureTextWidth(str);\n      textcanvas.width = textWidth;\n      textcanvas.height = curTextSize;\n      curContext = textcanvas.getContext(\"2d\"); // refreshes curContext\n      curContext.font = curTextFont.css;\n      curContext.textBaseline=\"top\";\n\n      // paint on 2D canvas\n      Drawing2D.prototype.text$line(str,0,0,0,PConstants.LEFT);\n\n      // use it as a texture\n      var aspect = textcanvas.width/textcanvas.height;\n      curContext = oldContext;\n\n      curContext.bindTexture(curContext.TEXTURE_2D, textTex);\n      curContext.texImage2D(curContext.TEXTURE_2D, 0, curContext.RGBA, curContext.RGBA, curContext.UNSIGNED_BYTE, textcanvas);\n      curContext.texParameteri(curContext.TEXTURE_2D, curContext.TEXTURE_MAG_FILTER, curContext.LINEAR);\n      curContext.texParameteri(curContext.TEXTURE_2D, curContext.TEXTURE_MIN_FILTER, curContext.LINEAR);\n      curContext.texParameteri(curContext.TEXTURE_2D, curContext.TEXTURE_WRAP_T, curContext.CLAMP_TO_EDGE);\n      curContext.texParameteri(curContext.TEXTURE_2D, curContext.TEXTURE_WRAP_S, curContext.CLAMP_TO_EDGE);\n      // If we don't have a power of two texture, we can't mipmap it.\n      // curContext.generateMipmap(curContext.TEXTURE_2D);\n\n      // horizontal offset/alignment\n      var xOffset = 0;\n      if (align === PConstants.RIGHT) {\n        xOffset = -textWidth;\n      } else if(align === PConstants.CENTER) {\n        xOffset = -textWidth/2;\n      }\n      var model = new PMatrix3D();\n      var scalefactor = curTextSize * 0.5;\n      model.translate(x+xOffset-scalefactor/2, y-scalefactor, z);\n      model.scale(-aspect*scalefactor, -scalefactor, scalefactor);\n      model.translate(-1, -1, -1);\n      model.transpose();\n\n      var view = new PMatrix3D();\n      view.scale(1, -1, 1);\n      view.apply(modelView.array());\n      view.transpose();\n\n      curContext.useProgram(programObject2D);\n      vertexAttribPointer(\"aVertex2d\", programObject2D, \"aVertex\", 3, textBuffer);\n      vertexAttribPointer(\"aTextureCoord2d\", programObject2D, \"aTextureCoord\", 2, textureBuffer);\n      uniformi(\"uSampler2d\", programObject2D, \"uSampler\", [0]);\n\n      uniformi(\"uIsDrawingText2d\", programObject2D, \"uIsDrawingText\", true);\n\n      uniformMatrix(\"uModel2d\", programObject2D, \"uModel\", false,  model.array());\n      uniformMatrix(\"uView2d\", programObject2D, \"uView\", false, view.array());\n      uniformf(\"uColor2d\", programObject2D, \"uColor\", fillStyle);\n      curContext.bindBuffer(curContext.ELEMENT_ARRAY_BUFFER, indexBuffer);\n      curContext.drawElements(curContext.TRIANGLES, 6, curContext.UNSIGNED_SHORT, 0);\n    };\n\n\n    /**\n    * unbounded text function (z is an optional argument)\n    */\n    function text$4(str, x, y, z) {\n      var lines, linesCount;\n      if(str.indexOf('\\n') < 0) {\n        lines = [str];\n        linesCount = 1;\n      } else {\n        lines = str.split(/\\r?\\n/g);\n        linesCount = lines.length;\n      }\n      // handle text line-by-line\n\n      var yOffset = 0;\n      if(verticalTextAlignment === PConstants.TOP) {\n        yOffset = curTextAscent + curTextDescent;\n      } else if(verticalTextAlignment === PConstants.CENTER) {\n        yOffset = curTextAscent/2 - (linesCount-1)*curTextLeading/2;\n      } else if(verticalTextAlignment === PConstants.BOTTOM) {\n        yOffset = -(curTextDescent + (linesCount-1)*curTextLeading);\n      }\n\n      for(var i=0;i<linesCount;++i) {\n        var line = lines[i];\n        drawing.text$line(line, x, y + yOffset, z, horizontalTextAlignment);\n        yOffset += curTextLeading;\n      }\n    }\n\n\n    /**\n    * box-bounded text function (z is an optional argument)\n    */\n    function text$6(str, x, y, width, height, z) {\n      // 'fail' on 0-valued dimensions\n      if (str.length === 0 || width === 0 || height === 0) {\n        return;\n      }\n      // also 'fail' if the text height is larger than the bounding height\n      if(curTextSize > height) {\n        return;\n      }\n\n      var spaceMark = -1;\n      var start = 0;\n      var lineWidth = 0;\n      var drawCommands = [];\n\n      // run through text, character-by-character\n      for (var charPos=0, len=str.length; charPos < len; charPos++)\n      {\n        var currentChar = str[charPos];\n        var spaceChar = (currentChar === \" \");\n        var letterWidth = curTextFont.measureTextWidth(currentChar);\n\n        // if we aren't looking at a newline, and the text still fits, keep processing\n        if (currentChar !== \"\\n\" && (lineWidth + letterWidth <= width)) {\n          if (spaceChar) { spaceMark = charPos; }\n          lineWidth += letterWidth;\n        }\n\n        // if we're looking at a newline, or the text no longer fits, push the section that fit into the drawcommand list\n        else\n        {\n          if (spaceMark + 1 === start) {\n            if(charPos>0) {\n              // Whole line without spaces so far.\n              spaceMark = charPos;\n            } else {\n              // 'fail', because the line can't even fit the first character\n              return;\n            }\n          }\n\n          if (currentChar === \"\\n\") {\n            drawCommands.push({text:str.substring(start, charPos), width: lineWidth});\n            start = charPos + 1;\n          } else {\n            // current is not a newline, which means the line doesn't fit in box. push text.\n            // In Processing 1.5.1, the space is also pushed, so we push up to spaceMark+1,\n            // rather than up to spaceMark, as was the case for Processing 1.5 and earlier.\n            drawCommands.push({text:str.substring(start, spaceMark+1), width: lineWidth});\n            start = spaceMark + 1;\n          }\n\n          // newline + return\n          lineWidth = 0;\n          charPos = start - 1;\n        }\n      }\n\n      // push the remaining text\n      if (start < len) {\n        drawCommands.push({text:str.substring(start), width: lineWidth});\n      }\n\n      // resolve horizontal alignment\n      var xOffset = 1,\n          yOffset = curTextAscent;\n      if (horizontalTextAlignment === PConstants.CENTER) {\n        xOffset = width/2;\n      } else if (horizontalTextAlignment === PConstants.RIGHT) {\n        xOffset = width;\n      }\n\n      // resolve vertical alignment\n      var linesCount = drawCommands.length,\n          visibleLines = Math.min(linesCount, Math.floor(height/curTextLeading));\n      if(verticalTextAlignment === PConstants.TOP) {\n        yOffset = curTextAscent + curTextDescent;\n      } else if(verticalTextAlignment === PConstants.CENTER) {\n        yOffset = (height/2) - curTextLeading * (visibleLines/2 - 1);\n      } else if(verticalTextAlignment === PConstants.BOTTOM) {\n        yOffset = curTextDescent + curTextLeading;\n      }\n\n      var command,\n          drawCommand,\n          leading;\n      for (command = 0; command < linesCount; command++) {\n        leading = command * curTextLeading;\n        // stop if not enough space for one more line draw\n        if (yOffset + leading > height - curTextDescent) {\n          break;\n        }\n        drawCommand = drawCommands[command];\n        drawing.text$line(drawCommand.text, x + xOffset, y + yOffset + leading, z, horizontalTextAlignment);\n      }\n    }\n\n    /**\n     * text() Draws text to the screen.\n     *\n     * @param {String|char|int|float} data       the alphanumeric symbols to be displayed\n     * @param {int|float}             x          x-coordinate of text\n     * @param {int|float}             y          y-coordinate of text\n     * @param {int|float}             z          optional z-coordinate of text\n     * @param {String}                stringdata optional letters to be displayed\n     * @param {int|float}             width      optional width of text box\n     * @param {int|float}             height     optional height of text box\n     *\n     * @see #textAlign\n     * @see #textMode\n     * @see #loadFont\n     * @see #PFont\n     * @see #textFont\n     */\n    p.text = function() {\n      if (textMode === PConstants.SHAPE) {\n        // TODO: requires beginRaw function\n        return;\n      }\n      if (arguments.length === 3) { // for text( str, x, y)\n        text$4(toP5String(arguments[0]), arguments[1], arguments[2], 0);\n      } else if (arguments.length === 4) { // for text( str, x, y, z)\n        text$4(toP5String(arguments[0]), arguments[1], arguments[2], arguments[3]);\n      } else if (arguments.length === 5) { // for text( str, x, y , width, height)\n        text$6(toP5String(arguments[0]), arguments[1], arguments[2], arguments[3], arguments[4], 0);\n      } else if (arguments.length === 6) { // for text( stringdata, x, y , width, height, z)\n        text$6(toP5String(arguments[0]), arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);\n      }\n    };\n\n    /**\n     * Sets the way text draws to the screen. In the default configuration (the MODEL mode), it's possible to rotate,\n     * scale, and place letters in two and three dimensional space. <br /><br /> Changing to SCREEN mode draws letters\n     * directly to the front of the window and greatly increases rendering quality and speed when used with the P2D and\n     * P3D renderers. textMode(SCREEN) with OPENGL and JAVA2D (the default) renderers will generally be slower, though\n     * pixel accurate with P2D and P3D. With textMode(SCREEN), the letters draw at the actual size of the font (in pixels)\n     * and therefore calls to <b>textSize()</b> will not affect the size of the letters. To create a font at the size you\n     * desire, use the \"Create font...\" option in the Tools menu, or use the createFont() function. When using textMode(SCREEN),\n     * any z-coordinate passed to a text() command will be ignored, because your computer screen is...flat!\n     *\n     * @param {int} MODE Either MODEL, SCREEN or SHAPE (not yet supported)\n     *\n     * @see loadFont\n     * @see PFont\n     * @see text\n     * @see textFont\n     * @see createFont\n     */\n    p.textMode = function(mode){\n      textMode = mode;\n    };\n\n    // Load Batik SVG Fonts and parse to pre-def objects for quick rendering\n    p.loadGlyphs = function(url) {\n      var x, y, cx, cy, nx, ny, d, a, lastCom, lenC, horiz_adv_x, getXY = '[0-9\\\\-]+', path;\n\n      // Return arrays of SVG commands and coords\n      // get this to use p.matchAll() - will need to work around the lack of null return\n      var regex = function(needle, hay) {\n        var i = 0,\n          results = [],\n          latest, regexp = new RegExp(needle, \"g\");\n        latest = results[i] = regexp.exec(hay);\n        while (latest) {\n          i++;\n          latest = results[i] = regexp.exec(hay);\n        }\n        return results;\n      };\n\n      var buildPath = function(d) {\n        var c = regex(\"[A-Za-z][0-9\\\\- ]+|Z\", d);\n        var beforePathDraw = function() {\n          saveContext();\n          return drawing.$ensureContext();\n        };\n        var afterPathDraw = function() {\n          executeContextFill();\n          executeContextStroke();\n          restoreContext();\n        };\n\n        // Begin storing path object\n        path = \"return {draw:function(){var curContext=beforePathDraw();curContext.beginPath();\";\n\n        x = 0;\n        y = 0;\n        cx = 0;\n        cy = 0;\n        nx = 0;\n        ny = 0;\n        d = 0;\n        a = 0;\n        lastCom = \"\";\n        lenC = c.length - 1;\n\n        // Loop through SVG commands translating to canvas eqivs functions in path object\n        for (var j = 0; j < lenC; j++) {\n          var com = c[j][0], xy = regex(getXY, com);\n\n          switch (com[0]) {\n            case \"M\":\n              //curContext.moveTo(x,-y);\n              x = parseFloat(xy[0][0]);\n              y = parseFloat(xy[1][0]);\n              path += \"curContext.moveTo(\" + x + \",\" + (-y) + \");\";\n              break;\n\n            case \"L\":\n              //curContext.lineTo(x,-y);\n              x = parseFloat(xy[0][0]);\n              y = parseFloat(xy[1][0]);\n              path += \"curContext.lineTo(\" + x + \",\" + (-y) + \");\";\n              break;\n\n            case \"H\":\n              //curContext.lineTo(x,-y)\n              x = parseFloat(xy[0][0]);\n              path += \"curContext.lineTo(\" + x + \",\" + (-y) + \");\";\n              break;\n\n            case \"V\":\n              //curContext.lineTo(x,-y);\n              y = parseFloat(xy[0][0]);\n              path += \"curContext.lineTo(\" + x + \",\" + (-y) + \");\";\n              break;\n\n            case \"T\":\n              //curContext.quadraticCurveTo(cx,-cy,nx,-ny);\n              nx = parseFloat(xy[0][0]);\n              ny = parseFloat(xy[1][0]);\n\n              if (lastCom === \"Q\" || lastCom === \"T\") {\n                d = Math.sqrt(Math.pow(x - cx, 2) + Math.pow(cy - y, 2));\n                a = Math.PI + Math.atan2(cx - x, cy - y);\n                cx = x + (Math.sin(a) * (d));\n                cy = y + (Math.cos(a) * (d));\n              } else {\n                cx = x;\n                cy = y;\n              }\n\n              path += \"curContext.quadraticCurveTo(\" + cx + \",\" + (-cy) + \",\" + nx + \",\" + (-ny) + \");\";\n              x = nx;\n              y = ny;\n              break;\n\n            case \"Q\":\n              //curContext.quadraticCurveTo(cx,-cy,nx,-ny);\n              cx = parseFloat(xy[0][0]);\n              cy = parseFloat(xy[1][0]);\n              nx = parseFloat(xy[2][0]);\n              ny = parseFloat(xy[3][0]);\n              path += \"curContext.quadraticCurveTo(\" + cx + \",\" + (-cy) + \",\" + nx + \",\" + (-ny) + \");\";\n              x = nx;\n              y = ny;\n              break;\n\n            case \"Z\":\n              //curContext.closePath();\n              path += \"curContext.closePath();\";\n              break;\n          }\n          lastCom = com[0];\n        }\n\n        path += \"afterPathDraw();\";\n        path += \"curContext.translate(\" + horiz_adv_x + \",0);\";\n        path += \"}}\";\n\n        return ((new Function(\"beforePathDraw\", \"afterPathDraw\", path))(beforePathDraw, afterPathDraw));\n      };\n\n      // Parse SVG font-file into block of Canvas commands\n      var parseSVGFont = function(svg) {\n        // Store font attributes\n        var font = svg.getElementsByTagName(\"font\");\n        p.glyphTable[url].horiz_adv_x = font[0].getAttribute(\"horiz-adv-x\");\n\n        var font_face = svg.getElementsByTagName(\"font-face\")[0];\n        p.glyphTable[url].units_per_em = parseFloat(font_face.getAttribute(\"units-per-em\"));\n        p.glyphTable[url].ascent = parseFloat(font_face.getAttribute(\"ascent\"));\n        p.glyphTable[url].descent = parseFloat(font_face.getAttribute(\"descent\"));\n\n        var glyph = svg.getElementsByTagName(\"glyph\"),\n          len = glyph.length;\n\n        // Loop through each glyph in the SVG\n        for (var i = 0; i < len; i++) {\n          // Store attributes for this glyph\n          var unicode = glyph[i].getAttribute(\"unicode\");\n          var name = glyph[i].getAttribute(\"glyph-name\");\n          horiz_adv_x = glyph[i].getAttribute(\"horiz-adv-x\");\n          if (horiz_adv_x === null) {\n            horiz_adv_x = p.glyphTable[url].horiz_adv_x;\n          }\n          d = glyph[i].getAttribute(\"d\");\n          // Split path commands in glpyh\n          if (d !== undef) {\n            path = buildPath(d);\n            // Store glyph data to table object\n            p.glyphTable[url][name] = {\n              name: name,\n              unicode: unicode,\n              horiz_adv_x: horiz_adv_x,\n              draw: path.draw\n            };\n          }\n        } // finished adding glyphs to table\n      };\n\n      // Load and parse Batik SVG font as XML into a Processing Glyph object\n      var loadXML = function() {\n        var xmlDoc;\n\n        try {\n          xmlDoc = document.implementation.createDocument(\"\", \"\", null);\n        }\n        catch(e_fx_op) {\n          Processing.debug(e_fx_op.message);\n          return;\n        }\n\n        try {\n          xmlDoc.async = false;\n          xmlDoc.load(url);\n          parseSVGFont(xmlDoc.getElementsByTagName(\"svg\")[0]);\n        }\n        catch(e_sf_ch) {\n          // Google Chrome, Safari etc.\n          Processing.debug(e_sf_ch);\n          try {\n            var xmlhttp = new window.XMLHttpRequest();\n            xmlhttp.open(\"GET\", url, false);\n            xmlhttp.send(null);\n            parseSVGFont(xmlhttp.responseXML.documentElement);\n          }\n          catch(e) {\n            Processing.debug(e_sf_ch);\n          }\n        }\n      };\n\n      // Create a new object in glyphTable to store this font\n      p.glyphTable[url] = {};\n\n      // Begin loading the Batik SVG font...\n      loadXML(url);\n\n      // Return the loaded font for attribute grabbing\n      return p.glyphTable[url];\n    };\n\n    /**\n     * Gets the sketch parameter value. The parameter can be defined as the canvas attribute with\n     * the \"data-processing-\" prefix or provided in the pjs directive (e.g. param-test=\"52\").\n     * The function tries the canvas attributes, then the pjs directive content.\n     *\n     * @param   {String}    name          The name of the param to read.\n     *\n     * @returns {String}    The parameter value, or null if parameter is not defined.\n     */\n    p.param = function(name) {\n      // trying attribute that was specified in CANVAS\n      var attributeName = \"data-processing-\" + name;\n      if (curElement.hasAttribute(attributeName)) {\n        return curElement.getAttribute(attributeName);\n      }\n      // trying child PARAM elements of the CANVAS\n      for (var i = 0, len = curElement.childNodes.length; i < len; ++i) {\n        var item = curElement.childNodes.item(i);\n        if (item.nodeType !== 1 || item.tagName.toLowerCase() !== \"param\") {\n          continue;\n        }\n        if (item.getAttribute(\"name\") === name) {\n          return item.getAttribute(\"value\");\n        }\n      }\n      // fallback to default params\n      if (curSketch.params.hasOwnProperty(name)) {\n        return curSketch.params[name];\n      }\n      return null;\n    };\n\n    ////////////////////////////////////////////////////////////////////////////\n    // 2D/3D methods wiring utils\n    ////////////////////////////////////////////////////////////////////////////\n    function wireDimensionalFunctions(mode) {\n      // Drawing2D/Drawing3D\n      if (mode === '3D') {\n        drawing = new Drawing3D();\n      } else if (mode === '2D') {\n        drawing = new Drawing2D();\n      } else {\n        drawing = new DrawingPre();\n      }\n\n      // Wire up functions (Use DrawingPre properties names)\n      for (var i in DrawingPre.prototype) {\n        if (DrawingPre.prototype.hasOwnProperty(i) && i.indexOf(\"$\") < 0) {\n          p[i] = drawing[i];\n        }\n      }\n\n      // Run initialization\n      drawing.$init();\n    }\n\n    function createDrawingPreFunction(name) {\n      return function() {\n        wireDimensionalFunctions(\"2D\");\n        return drawing[name].apply(this, arguments);\n      };\n    }\n    DrawingPre.prototype.translate = createDrawingPreFunction(\"translate\");\n    DrawingPre.prototype.transform = createDrawingPreFunction(\"transform\");\n    DrawingPre.prototype.scale = createDrawingPreFunction(\"scale\");\n    DrawingPre.prototype.pushMatrix = createDrawingPreFunction(\"pushMatrix\");\n    DrawingPre.prototype.popMatrix = createDrawingPreFunction(\"popMatrix\");\n    DrawingPre.prototype.resetMatrix = createDrawingPreFunction(\"resetMatrix\");\n    DrawingPre.prototype.applyMatrix = createDrawingPreFunction(\"applyMatrix\");\n    DrawingPre.prototype.rotate = createDrawingPreFunction(\"rotate\");\n    DrawingPre.prototype.rotateZ = createDrawingPreFunction(\"rotateZ\");\n    DrawingPre.prototype.shearX = createDrawingPreFunction(\"shearX\");\n    DrawingPre.prototype.shearY = createDrawingPreFunction(\"shearY\");\n    DrawingPre.prototype.redraw = createDrawingPreFunction(\"redraw\");\n    DrawingPre.prototype.toImageData = createDrawingPreFunction(\"toImageData\");\n    DrawingPre.prototype.ambientLight = createDrawingPreFunction(\"ambientLight\");\n    DrawingPre.prototype.directionalLight = createDrawingPreFunction(\"directionalLight\");\n    DrawingPre.prototype.lightFalloff = createDrawingPreFunction(\"lightFalloff\");\n    DrawingPre.prototype.lightSpecular = createDrawingPreFunction(\"lightSpecular\");\n    DrawingPre.prototype.pointLight = createDrawingPreFunction(\"pointLight\");\n    DrawingPre.prototype.noLights = createDrawingPreFunction(\"noLights\");\n    DrawingPre.prototype.spotLight = createDrawingPreFunction(\"spotLight\");\n    DrawingPre.prototype.beginCamera = createDrawingPreFunction(\"beginCamera\");\n    DrawingPre.prototype.endCamera = createDrawingPreFunction(\"endCamera\");\n    DrawingPre.prototype.frustum = createDrawingPreFunction(\"frustum\");\n    DrawingPre.prototype.box = createDrawingPreFunction(\"box\");\n    DrawingPre.prototype.sphere = createDrawingPreFunction(\"sphere\");\n    DrawingPre.prototype.ambient = createDrawingPreFunction(\"ambient\");\n    DrawingPre.prototype.emissive = createDrawingPreFunction(\"emissive\");\n    DrawingPre.prototype.shininess = createDrawingPreFunction(\"shininess\");\n    DrawingPre.prototype.specular = createDrawingPreFunction(\"specular\");\n    DrawingPre.prototype.fill = createDrawingPreFunction(\"fill\");\n    DrawingPre.prototype.stroke = createDrawingPreFunction(\"stroke\");\n    DrawingPre.prototype.strokeWeight = createDrawingPreFunction(\"strokeWeight\");\n    DrawingPre.prototype.smooth = createDrawingPreFunction(\"smooth\");\n    DrawingPre.prototype.noSmooth = createDrawingPreFunction(\"noSmooth\");\n    DrawingPre.prototype.point = createDrawingPreFunction(\"point\");\n    DrawingPre.prototype.vertex = createDrawingPreFunction(\"vertex\");\n    DrawingPre.prototype.endShape = createDrawingPreFunction(\"endShape\");\n    DrawingPre.prototype.bezierVertex = createDrawingPreFunction(\"bezierVertex\");\n    DrawingPre.prototype.curveVertex = createDrawingPreFunction(\"curveVertex\");\n    DrawingPre.prototype.curve = createDrawingPreFunction(\"curve\");\n    DrawingPre.prototype.line = createDrawingPreFunction(\"line\");\n    DrawingPre.prototype.bezier = createDrawingPreFunction(\"bezier\");\n    DrawingPre.prototype.rect = createDrawingPreFunction(\"rect\");\n    DrawingPre.prototype.ellipse = createDrawingPreFunction(\"ellipse\");\n    DrawingPre.prototype.background = createDrawingPreFunction(\"background\");\n    DrawingPre.prototype.image = createDrawingPreFunction(\"image\");\n    DrawingPre.prototype.textWidth = createDrawingPreFunction(\"textWidth\");\n    DrawingPre.prototype.text$line = createDrawingPreFunction(\"text$line\");\n    DrawingPre.prototype.$ensureContext = createDrawingPreFunction(\"$ensureContext\");\n    DrawingPre.prototype.$newPMatrix = createDrawingPreFunction(\"$newPMatrix\");\n\n    DrawingPre.prototype.size = function(aWidth, aHeight, aMode) {\n      wireDimensionalFunctions(aMode === PConstants.WEBGL ? \"3D\" : \"2D\");\n      p.size(aWidth, aHeight, aMode);\n    };\n\n    DrawingPre.prototype.$init = noop;\n\n    Drawing2D.prototype.$init = function() {\n      // Setup default 2d canvas context.\n      // Moving this here removes the number of times we need to check the 3D variable\n      p.size(p.width, p.height);\n\n      curContext.lineCap = 'round';\n\n      // Set default stroke and fill color\n      p.noSmooth();\n      p.disableContextMenu();\n    };\n    Drawing3D.prototype.$init = function() {\n      // For ref/perf test compatibility until those are fixed\n      p.use3DContext = true;\n      p.disableContextMenu();\n    };\n\n    DrawingShared.prototype.$ensureContext = function() {\n      return curContext;\n    };\n\n    //////////////////////////////////////////////////////////////////////////\n    // Keyboard Events\n    //////////////////////////////////////////////////////////////////////////\n\n    // In order to catch key events in a canvas, it needs to be \"specially focusable\",\n    // by assigning it a tabindex. If no tabindex is specified on-page, set this to 0.\n    if (!curElement.getAttribute(\"tabindex\")) {\n      curElement.setAttribute(\"tabindex\", 0);\n    }\n\n    function getKeyCode(e) {\n      var code = e.which || e.keyCode;\n      switch (code) {\n        case 13: // ENTER\n          return 10;\n        case 91: // META L (Saf/Mac)\n        case 93: // META R (Saf/Mac)\n        case 224: // META (FF/Mac)\n          return 157;\n        case 57392: // CONTROL (Op/Mac)\n          return 17;\n        case 46: // DELETE\n          return 127;\n        case 45: // INSERT\n          return 155;\n      }\n      return code;\n    }\n\n    function getKeyChar(e) {\n      var c = e.which || e.keyCode;\n      var anyShiftPressed = e.shiftKey || e.ctrlKey || e.altKey || e.metaKey;\n      switch (c) {\n        case 13:\n          c = anyShiftPressed ? 13 : 10; // RETURN vs ENTER (Mac)\n          break;\n        case 8:\n          c = anyShiftPressed ? 127 : 8; // DELETE vs BACKSPACE (Mac)\n          break;\n      }\n      return new Char(c);\n    }\n\n    function suppressKeyEvent(e) {\n      if (typeof e.preventDefault === \"function\") {\n        e.preventDefault();\n      } else if (typeof e.stopPropagation === \"function\") {\n        e.stopPropagation();\n      }\n      return false;\n    }\n\n    function updateKeyPressed() {\n      var ch;\n      for (ch in pressedKeysMap) {\n        if (pressedKeysMap.hasOwnProperty(ch)) {\n          p.__keyPressed = true;\n          return;\n        }\n      }\n      p.__keyPressed = false;\n    }\n\n    function resetKeyPressed() {\n      p.__keyPressed = false;\n      pressedKeysMap = [];\n      lastPressedKeyCode = null;\n    }\n\n    function simulateKeyTyped(code, c) {\n      pressedKeysMap[code] = c;\n      lastPressedKeyCode = null;\n      p.key = c;\n      p.keyCode = code;\n      p.keyPressed();\n      p.keyCode = 0;\n      p.keyTyped();\n      updateKeyPressed();\n    }\n\n    function handleKeydown(e) {\n      var code = getKeyCode(e);\n      if (code === PConstants.DELETE) {\n        simulateKeyTyped(code, new Char(127));\n        return;\n      }\n      if (codedKeys.indexOf(code) < 0) {\n        lastPressedKeyCode = code;\n        return;\n      }\n      var c = new Char(PConstants.CODED);\n      p.key = c;\n      p.keyCode = code;\n      pressedKeysMap[code] = c;\n      p.keyPressed();\n      lastPressedKeyCode = null;\n      updateKeyPressed();\n      return suppressKeyEvent(e);\n    }\n\n    function handleKeypress(e) {\n      if (lastPressedKeyCode === null) {\n        return; // processed in handleKeydown\n      }\n      var code = lastPressedKeyCode, c = getKeyChar(e);\n      simulateKeyTyped(code, c);\n      return suppressKeyEvent(e);\n    }\n\n    function handleKeyup(e) {\n      var code = getKeyCode(e), c = pressedKeysMap[code];\n      if (c === undef) {\n        return; // no keyPressed event was generated.\n      }\n      p.key = c;\n      p.keyCode = code;\n      p.keyReleased();\n      delete pressedKeysMap[code];\n      updateKeyPressed();\n    }\n\n    // Send aCode Processing syntax to be converted to JavaScript\n    if (!pgraphicsMode) {\n      if (aCode instanceof Processing.Sketch) {\n        // Use sketch as is\n        curSketch = aCode;\n      } else if (typeof aCode === \"function\") {\n        // Wrap function with default sketch parameters\n        curSketch = new Processing.Sketch(aCode);\n      } else if (!aCode) {\n        // Empty sketch\n        curSketch = new Processing.Sketch(function (){});\n      } else {\n  //#if PARSER\n        // Compile the code\n        curSketch = Processing.compile(aCode);\n  //#else\n  //      throw \"PJS compile is not supported\";\n  //#endif\n      }\n\n      // Expose internal field for diagnostics and testing\n      p.externals.sketch = curSketch;\n\n      wireDimensionalFunctions();\n\n      // the onfocus and onblur events are handled in two parts.\n      // 1) the p.focused property is handled per sketch\n      curElement.onfocus = function() {\n        p.focused = true;\n      };\n\n      curElement.onblur = function() {\n        p.focused = false;\n        if (!curSketch.options.globalKeyEvents) {\n          resetKeyPressed();\n        }\n      };\n\n      // 2) looping status is handled per page, based on the pauseOnBlur @pjs directive\n      if (curSketch.options.pauseOnBlur) {\n        attachEventHandler(window, 'focus', function() {\n          if (doLoop) {\n            p.loop();\n          }\n        });\n\n        attachEventHandler(window, 'blur', function() {\n          if (doLoop && loopStarted) {\n            p.noLoop();\n            doLoop = true; // make sure to keep this true after the noLoop call\n          }\n          resetKeyPressed();\n        });\n      }\n\n      // if keyboard events should be handled globally, the listeners should\n      // be bound to the document window, rather than to the current canvas\n      var keyTrigger = curSketch.options.globalKeyEvents ? window : curElement;\n      attachEventHandler(keyTrigger, \"keydown\", handleKeydown);\n      attachEventHandler(keyTrigger, \"keypress\", handleKeypress);\n      attachEventHandler(keyTrigger, \"keyup\", handleKeyup);\n\n      // Step through the libraries that were attached at doc load...\n      for (var i in Processing.lib) {\n        if (Processing.lib.hasOwnProperty(i)) {\n          if(Processing.lib[i].hasOwnProperty(\"attach\")) {\n            // use attach function if present\n            Processing.lib[i].attach(p);\n          } else if(Processing.lib[i] instanceof Function)  {\n            // Init the libraries in the context of this p_instance (legacy)\n            Processing.lib[i].call(this);\n          }\n        }\n      }\n\n      // sketch execute test interval, used to reschedule\n      // an execute when preloads have not yet finished.\n      var retryInterval = 100;\n\n      var executeSketch = function(processing) {\n        // Don't start until all specified images and fonts in the cache are preloaded\n        if (!(curSketch.imageCache.pending || PFont.preloading.pending(retryInterval))) {\n          // the opera preload cache can only be cleared once we start\n          if (window.opera) {\n            var link,\n                element,\n                operaCache=curSketch.imageCache.operaCache;\n            for (link in operaCache) {\n              if(operaCache.hasOwnProperty(link)) {\n                element = operaCache[link];\n                if (element !== null) {\n                  document.body.removeChild(element);\n                }\n                delete(operaCache[link]);\n              }\n            }\n          }\n\n          curSketch.attach(processing, defaultScope);\n\n          // pass a reference to the p instance for this sketch.\n          curSketch.onLoad(processing);\n\n          // Run void setup()\n          if (processing.setup) {\n            processing.setup();\n            // if any transforms were performed in setup reset to identity matrix\n            // so draw loop is unpolluted\n            processing.resetMatrix();\n            curSketch.onSetup();\n          }\n\n          // some pixels can be cached, flushing\n          resetContext();\n\n          if (processing.draw) {\n            if (!doLoop) {\n              processing.redraw();\n            } else {\n              processing.loop();\n            }\n          }\n        } else {\n          window.setTimeout(function() { executeSketch(processing); }, retryInterval);\n        }\n      };\n\n      // Only store an instance of non-createGraphics instances.\n      addInstance(this);\n\n      // The parser adds custom methods to the processing context\n      // this renames p to processing so these methods will run\n      executeSketch(p);\n    } else {\n      // No executable sketch was specified\n      // or called via createGraphics\n      curSketch = new Processing.Sketch();\n\n      wireDimensionalFunctions();\n\n      // Hack to make PGraphics work again after splitting size()\n      p.size = function(w, h, render) {\n        if (render && render === PConstants.WEBGL) {\n          wireDimensionalFunctions('3D');\n        } else {\n          wireDimensionalFunctions('2D');\n        }\n\n        p.size(w, h, render);\n      };\n    }\n  };\n\n  // Place-holder for overridable debugging function\n  Processing.debug = (function() {\n    if (\"console\" in window) {\n      return function(msg) {\n        window.console.log('Processing.js: ' + msg);\n      };\n    }\n    return noop;\n  }());\n\n  // bind prototype\n  Processing.prototype = defaultScope;\n\n  /**\n   * instance store and lookup\n   */\n  Processing.instances = processingInstances;\n  Processing.getInstanceById = function(name) {\n    return processingInstances[processingInstanceIds[name]];\n  };\n\n  // Unsupported Processing File and I/O operations.\n  (function(Processing) {\n    var unsupportedP5 = (\"open() createOutput() createInput() BufferedReader selectFolder() \" +\n                         \"dataPath() createWriter() selectOutput() beginRecord() \" +\n                         \"saveStream() endRecord() selectInput() saveBytes() createReader() \" +\n                         \"beginRaw() endRaw() PrintWriter delay()\").split(\" \"),\n        count = unsupportedP5.length,\n        prettyName,\n        p5Name;\n\n    function createUnsupportedFunc(n) {\n      return function() {\n        throw \"Processing.js does not support \" + n + \".\";\n      };\n    }\n\n    while (count--) {\n      prettyName = unsupportedP5[count];\n      p5Name = prettyName.replace(\"()\", \"\");\n      Processing[p5Name] = createUnsupportedFunc(prettyName);\n    }\n  }(defaultScope));\n\n  // we're done. Return our object.\n  return Processing;\n};\n\n},{}],27:[function(require,module,exports){\n// Base source files\nvar source = {\n  virtEquals: require(\"./Helpers/virtEquals\"),\n  virtHashCode: require(\"./Helpers/virtHashCode\"),\n  ObjectIterator: require(\"./Helpers/ObjectIterator\"),\n  PConstants: require(\"./Helpers/PConstants\"),\n  ArrayList: require(\"./Objects/ArrayList\"),\n  HashMap: require(\"./Objects/HashMap\"),\n  PVector: require(\"./Objects/PVector\"),\n  PFont: require(\"./Objects/PFont\"),\n  Char: require(\"./Objects/Char\"),\n  XMLAttribute: require(\"./Objects/XMLAttribute\"),\n  XMLElement: require(\"./Objects/XMLElement\"),\n  PMatrix2D: require(\"./Objects/PMatrix2D\"),\n  PMatrix3D: require(\"./Objects/PMatrix3D\"),\n  PShape: require(\"./Objects/PShape\"),\n  colors: require(\"./Objects/webcolors\"),\n  PShapeSVG:  require(\"./Objects/PShapeSVG\"),\n  CommonFunctions: require(\"./P5Functions/commonFunctions\"),\n  defaultScope: require(\"./Helpers/defaultScope\"),\n  Processing: require(\"./Processing\"),\n  setupParser: require(\"./Parser/Parser\"),\n  finalize: require(\"./Helpers/finalizeProcessing\")\n};\n\n// Additional code that gets tacked onto \"p\" during\n// instantiation of a Processing sketch.\nsource.extend = {\n  withMath: require(\"./P5Functions/Math.js\"),\n  withProxyFunctions: require(\"./P5Functions/JavaProxyFunctions\")(source.virtHashCode, source.virtEquals),\n  withTouch: require(\"./P5Functions/touchmouse\"),\n  withCommonFunctions: source.CommonFunctions.withCommonFunctions\n};\n\n/**\n * Processing.js building function\n */\nmodule.exports = function buildProcessingJS(Browser, testHarness) {\n  var noop = function(){},\n      virtEquals = source.virtEquals,\n      virtHashCode = source.virtHashCode,\n      PConstants = source.PConstants,\n      CommonFunctions = source.CommonFunctions,\n      ObjectIterator = source.ObjectIterator,\n      Char = source.Char,\n      XMLAttribute = source.XMLAttribute(),\n\n      ArrayList = source.ArrayList({\n        virtHashCode: virtHashCode,\n        virtEquals: virtEquals\n      }),\n\n      HashMap = source.HashMap({\n        virtHashCode: virtHashCode,\n        virtEquals: virtEquals\n      }),\n\n      PVector = source.PVector({\n        PConstants: PConstants\n      }),\n\n      PFont = source.PFont({\n        Browser: Browser,\n        noop: noop\n      }),\n\n      XMLElement = source.XMLElement({\n        Browser: Browser,\n        XMLAttribute: XMLAttribute\n      }),\n\n      PMatrix2D = source.PMatrix2D({\n        p:CommonFunctions\n      }),\n\n      PMatrix3D = source.PMatrix3D({\n        p:CommonFunctions\n      }),\n\n      PShape = source.PShape({\n        PConstants: PConstants,\n        PMatrix2D: PMatrix2D,\n        PMatrix3D: PMatrix3D\n      }),\n\n      PShapeSVG = source.PShapeSVG({\n        CommonFunctions: CommonFunctions,\n        PConstants: PConstants,\n        PShape: PShape,\n        XMLElement: XMLElement,\n        colors: source.colors\n      }),\n\n      defaultScope = source.defaultScope({\n        ArrayList: ArrayList,\n        HashMap: HashMap,\n        PVector: PVector,\n        PFont: PFont,\n        PShapeSVG: PShapeSVG,\n        ObjectIterator: ObjectIterator,\n        PConstants: PConstants,\n        Char: Char,\n        XMLElement: XMLElement,\n        XML: XMLElement\n      }),\n\n      Processing = source.Processing({\n        defaultScope: defaultScope,\n        Browser: Browser,\n        extend: source.extend,\n        noop: noop\n      });\n\n  // set up the Processing syntax parser\n  Processing = source.setupParser(Processing, {\n    Browser: Browser,\n    aFunctions: testHarness,\n    defaultScope: defaultScope\n  });\n\n  // finalise the Processing object\n  Processing = source.finalize(Processing, {\n    version: require('../package.json').version,\n    isDomPresent: false || Browser.isDomPresent,\n    window: Browser.window,\n    document: Browser.document,\n    noop: noop\n  });\n\n  // done.\n  return Processing;\n};\n\n},{\"../package.json\":1,\"./Helpers/ObjectIterator\":2,\"./Helpers/PConstants\":3,\"./Helpers/defaultScope\":5,\"./Helpers/finalizeProcessing\":6,\"./Helpers/virtEquals\":7,\"./Helpers/virtHashCode\":8,\"./Objects/ArrayList\":9,\"./Objects/Char\":10,\"./Objects/HashMap\":11,\"./Objects/PFont\":12,\"./Objects/PMatrix2D\":13,\"./Objects/PMatrix3D\":14,\"./Objects/PShape\":15,\"./Objects/PShapeSVG\":16,\"./Objects/PVector\":17,\"./Objects/XMLAttribute\":18,\"./Objects/XMLElement\":19,\"./Objects/webcolors\":20,\"./P5Functions/JavaProxyFunctions\":21,\"./P5Functions/Math.js\":22,\"./P5Functions/commonFunctions\":23,\"./P5Functions/touchmouse\":24,\"./Parser/Parser\":25,\"./Processing\":26}],28:[function(require,module,exports){\n// build script for generating processing.js\n\nvar Browser = {\n  isDomPresent: true,\n  navigator: navigator,\n  window: window,\n  document: document,\n  ajax: function(url) {\n    var xhr = new XMLHttpRequest();\n    xhr.open(\"GET\", url, false);\n    if (xhr.overrideMimeType) {\n      xhr.overrideMimeType(\"text/plain\");\n    }\n    xhr.setRequestHeader(\"If-Modified-Since\", \"Fri, 01 Jan 1960 00:00:00 GMT\");\n    xhr.send(null);\n    // failed request?\n    if (xhr.status !== 200 && xhr.status !== 0) { throw (\"XMLHttpRequest failed, status code \" + xhr.status); }\n    return xhr.responseText;\n  }\n};\n\nwindow.Processing = require('./src/')(Browser);\n\n},{\"./src/\":27}]},{},[28]);\n"}